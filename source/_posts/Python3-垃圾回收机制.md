---
title: Python3 垃圾回收机制
date: 2018-03-05 21:38:25
tags:
  - Python3
categories:
  - Python3 进阶
---
Python中的垃圾回收GC(Garbage collection)是以引用计数为主，分代收集为辅。引用计数的缺陷是循环引用的问题。
分代收集在一定程度上解决了循环引用的问题（可能描述不准确）。

<!-- more -->
## 引用计数

Python语言默认采用的垃圾收集机制是『引用计数法 Reference Counting』，该算法最早George E. Collins在1960的时候首次提出，50年后的今天，该算法依然被很多编程语言使用，『引用计数法』的原理是：每个对象维护一个`ob_ref`字段，用来记录该对象当前被引用的次数，每当新的引用指向该对象时，它的引用计数ob_ref加1，每当该对象的引用失效时计数ob_ref减1，一旦对象的引用计数为0，该对象立即被回收，对象占用的内存空间将被释放。它的缺点是需要额外的空间维护引用计数，这个问题是其次的，不过最主要的问题是它不能解决对象的“循环引用”，因此，有很多语言比如Java并没有采用该算法做来垃圾的收集机制。

导致引用计数+1的情况
  1. 对象被创建，例如`a=23`
  2. 对象被引用，例如`b=a`
  3. 对象被作为参数，传入到一个函数中，例如`func(a)`
  4. 对象作为一个元素，存储在容器中，例如`list1=[a,a]`
导致引用计数-1的情况
  1. 对象的别名被显式销毁，例如`del a`
  2. 对象的别名被赋予新的对象，例如`a=24`
  3. 一个对象离开它的作用域，例如f函数执行完毕时，func函数中的局部变量（全局变量不会）
  4. 对象所在的容器被销毁，或从容器中删除对象

## 标记清除

『标记清除（Mark—Sweep）』算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。它分为两个阶段：第一阶段是标记阶段，GC会把所有的『活动对象』打上标记，第二阶段是把那些没有标记的对象『非活动对象』进行回收。那么GC又是如何判断哪些是活动对象哪些是非活动对象的呢？

对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。

![mark-sweepg](https://foofish.net/images/mark-sweep.svg)

在上图中，我们把小黑圈视为全局变量，也就是把它作为root object，从小黑圈出发，对象1可直达，那么它将被标记，对象2、3可间接到达也会被标记，而4和5不可达，那么1、2、3就是活动对象，4和5是非活动对象会被GC回收。

标记清除算法作为Python的辅助垃圾收集技术主要处理的是一些容器对象，比如list、dict、tuple，instance等，因为对于字符串、数值对象是不可能造成循环引用问题。Python使用一个双向链表将这些容器对象组织起来。不过，这种简单粗暴的标记清除算法也有明显的缺点：清除非活动的对象前它必须顺序扫描整个堆内存，哪怕只剩下小部分活动对象也要扫描所有对象。


## 分代回收

分代回收是一种以空间换时间的操作方式，Python将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代），他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发，把那些可以被回收的对象回收掉(包括循环引用的对象)，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。同时，`分代回收是建立在标记清除技术基础之上`。分代回收同样作为Python的辅助垃圾收集技术处理那些容器对象

## Python中的GC阈值

随着你的程序运行，Python解释器保持对新创建的对象，以及因为引用计数为零而被释放掉的对象的追踪。从理论上说，这两个值应该保持一致，因为程序新建的每个对象都应该最终被释放掉。

当然，事实并非如此。因为循环引用的原因，并且因为你的程序使用了一些比其他对象存在时间更长的对象，从而被分配对象的计数值与被释放对象的计数值之间的差异在逐渐增长。一旦这个差异累计超过某个阈值，则Python的收集机制就启动了，并且触发上边所说到的零代算法，释放“浮动的垃圾”，并且将剩下的对象移动到一代列表。

随着时间的推移，程序所使用的对象逐渐从零代列表移动到一代列表。而Python对于一代列表中对象的处理遵循同样的方法，一旦被分配计数值与被释放计数值累计到达一定阈值，Python会将剩下的活跃对象移动到二代列表。

通过这种方法，你的代码所长期使用的对象，那些你的代码持续访问的活跃对象，会从零代链表转移到一代再转移到二代。通过不同的阈值设置，Python可以在不同的时间间隔处理这些对象。Python处理零代最为频繁，其次是一代然后才是二代。


## gc模块
[Garbage Collector interface](https://docs.python.org/2/library/gc.html)  
gc模块提供一个接口给开发者设置垃圾回收的选项。上面说到，采用引用计数的方法管理内存的一个缺陷是循环引用，而gc模块的一个主要功能就是解决循环引用的问题。

### 常用函数：

  1. gc.set_debug(flags)  
设置gc的debug日志，一般设置为gc.DEBUG_LEAK
  2. gc.collect([generation])  
显式进行垃圾回收，可以输入参数，0代表只检查第一代的对象，1代表检查一，二代的对象，2代表检查一，二，三代的对象，如果不传参数，执行一个full collection，也就是等于传2。  
返回不可达（unreachable objects）对象的数目
  3. gc.set_threshold(threshold0[, threshold1[, threshold2])  
设置自动执行垃圾回收的频率。
  4. gc.get_count()  
获取当前自动执行垃圾回收的计数器，返回一个长度为3的列表

### gc模块的自动垃圾回收机制

必须要import gc模块，并且is_enable()=True才会启动自动垃圾回收。  
这个机制的主要作用就是发现并处理不可达的垃圾对象。

`垃圾回收=垃圾检查+垃圾回收`  

在Python中，采用分代收集的方法。把对象分为三代，一开始，对象在创建的时候，放在一代中，如果在一次一代的垃圾检查中，该对象存活下来，就会被放到二代中，同理在一次二代的垃圾检查中，该对象存活下来，就会被放到三代中。

gc模块里面会有一个长度为3的列表的计数器，可以通过`gc.get_count()`获取。  
例如`(488,3,0)`，其中`488`是指距离上一次0代垃圾检查，Python分配内存的数目减去释放内存的数目，**注意是内存分配，而不是引用计数的增加**。例如：
```Python
print gc.get_count()  # (590, 8, 0)
a = ClassA()
print gc.get_count()  # (591, 8, 0)
del a
print gc.get_count()  # (590, 8, 0)
```
`3`是指距离上一次1代垃圾检查，0代垃圾检查的次数，同理，`0`是指距离上一次2代垃圾检查，1代垃圾检查的次数。

gc模快有一个自动垃圾回收的阀值，即通过`gc.get_threshold`函数获取到的长度为3的元组，例如`(700,10,10)`  
每一次计数器的增加，gc模块就会检查增加后的计数是否达到阀值的数目，如果是，就会执行对应的代数的垃圾检查，然后重置计数器  
例如，假设阀值是`(700,10,10)`：

  * 当计数器从`(699,3,0)`增加到`(700,3,0)`，gc模块就会执行`gc.collect(0)`,即检查0代对象的垃圾，并重置计数器为`(0,4,0)`
  * 当计数器从`(699,9,0)`增加到`(700,9,0)`，gc模块就会执行`gc.collect(1)`,即检查1、2代对象的垃圾，并重置计数器为`(0,0,1)`
  * 当计数器从`(699,9,9)`增加到`(700,9,9)`，gc模块就会执行`gc.collect(2)`,即检查0、1、2代对象的垃圾，并重置计数器为`(0,0,0)`


## 应用

1. 项目中避免循环引用
2. 引入gc模块，启动gc模块的自动清理循环引用的对象机制
3. 由于分代收集，所以把需要长期使用的变量集中管理，并尽快移到二代以后，减少GC检查时的消耗
4. gc模块唯一处理不了的是循环引用的类都有`__del__`方法，所以项目中要避免定义_`_del__`方法，如果一定要使用该方法，同时导致了循环引用，需要代码显式调用`gc.garbage`里面的对象的`__del__`来打破僵局


## 参考
1. http://python.jobbole.com/87843/
2. https://www.cnblogs.com/pinganzi/p/6646742.html
3. http://python.jobbole.com/87064/?utm_source=blog.jobbole.com&utm_medium=relatedPosts
