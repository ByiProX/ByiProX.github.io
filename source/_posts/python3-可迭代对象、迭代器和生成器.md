---
title: python3 可迭代对象、迭代器和生成器
date: 2018-03-01 20:17:53
tags:
  - Python3
categories:
  - Python3 进阶
  - Python3 迭代器和生成器
---

## 前言
迭代是数据处理的基石。扫描内存中放不下数据集时，我们要找到一种惰性获取数据项的方式，即按需一次获取一个数据项，这就是迭代器模式（iterator pattern）。所有的`生成器`都是`迭代器`，因为生成器完全实现了迭代器接口。在python社区中，大多数时候都把`迭代器`和`生成器`视作同一概念。

所有python程序员都知道，序列可迭代，下面说明具体原因。
<!-- more -->
## 序列可迭代的原因：iter函数
解释器需要迭代对象x时，会自动调用`iter(x)`。
内置的iter函数有以下作用。

1. 检查对象是否实现了`__iter__`方法，如果实现了就调用它，获得一个迭代器。
2. 如果没有实现`__iter__`方法，但是实现了`__getitem__`方法，python会创建一个迭代器，尝试按顺序（从索引0开始）获取元素。
3. 如果尝试失败，python会抛出`TypeError`异常，通常会提示"C object is not iterable",其中C是目标对象所属的类。

任何Python序列都可迭代的原因是它们实现了`__getitem__`方法。其实标准的序列也都实现了`__iter__`方法。之所以对`__getitem__`方法做特殊处理是为了向后兼容。

从Python3.4开始，检查x能否迭代，最准确的方法是调用iter(x)函数，如果不可迭代，再处理TypeError异常。这比使用isinstance(x, abc.Iterable)更准确，因为iter(x)函数会考虑到遗留的`__getitem__`方法，而abc.Iterable类则不考虑。

## 可迭代的对象与迭代器的对比

### 可迭代对象

**使用iter内置函数可以获取迭代器的对象。** 如果实现了能返回迭代器的`__iter__`方法，那么对象就是可迭代的。序列都可以迭代；实现了`__getitem__`方法，而且七参数是从零开始的索引，这种对象也是可迭代的。

我们要明确可迭代对象和迭代器之间的关系：**Python从可迭代的对象中获取迭代器**

标准的迭代器接口有两个方法，即：
1. `__next__`:返回下一个可用元素，如果没有元素，抛出`StopIteration`异常
2. `__iter__`:返回self,以便在应该使用可迭代对象的地方使用迭代器，比如for循环中。

因为`迭代器`只需`__next__`和`__iter__`两个方法，所以除了调用next()方法，以及捕获`StopIteration`异常之外，没有办法检查是否还有遗留的元素。此外，也没有办法还原迭代器。如果想再次迭代，那就要调用iter(...)，传入之前构建迭代器的可迭代对象。

### 迭代器

迭代器是这样的对象：实现了无参数的`__next__`方法，返回序列中的下一个元素；如果没有元素了，那么抛出`StopIteration`异常。Python迭代器还实现了`__iter__`方法，因此迭代器也可以迭代。

构建`可迭代对象`和`迭代器`时经常会出现错误，原因是混淆了两者。要知道，`可迭代的对象`有个`__iter__`方法，每次都实例化一个新的迭代器；而`迭代器`要实现`__next__`方法，返回单个元素，此外还要实现`__iter__`方法，返回迭代器本身。因此，`迭代器`可以迭代，但是`可迭代的对象`不是迭代器。

可迭代的对象一定不是自身的迭代器。也就是说，可迭代的对象必须实现`__iter__`方法，但不能实现`__next__`方法。另一方面，迭代器应该一直可以迭代，迭代器的`__iter__`方法应该返回自身。

```python
a = [1,2,3]
'__iter__' in dir(a)            # True
'__iter__' in dir(iter(a))      # True

```

## 生成器函数

只要Python函数的定义体中有yield关键字，该函数就是生成器函数。调用生成器函数时，会返回一个生成器对象。也就是说，生成器函数是生成器工厂。

普通的函数与生成器函数在句法上的唯一区别是，在后者的定义体中有`yield`关键字。有些人认为定义生成器函数应该使用一个新的关键字，例如gen，而不是def，但是Guido不同意。
### 生成器函数工作原理

```python
def gen_123():  # 只要Python代码中包含yield，该函数就是生成器函数
    yield 1    #生成器函数的定义体中通常都有循环，不过这不是必要条件；此处重复使用了3次yield
    yield 2
    yield 3

if __name__ == '__main__':
    print(gen_123)    # 可以看出gen_123是函数对象
    # <function gen_123 at 0x10be199d8>
    print(gen_123())  # 函数调用时返回的是一个生成器对象
    # <generator object gen_123 at 0x10be31ca8>

    for i in gen_123(): # 生成器是迭代器，会生成传给yield关键字的表达式的值
        print(i)    
        # 1
        # 2
        # 3

    g = gen_123() # 为了仔细检查，把生成器对象赋值给g
    print(next(g))  # 1
    print(next(g))  # 2
    print(next(g))  # 3
    print(next(g))   # 生成器函数的定义体执行完毕后，生成器对象会抛出异常。
# Traceback (most recent call last):
#   File "test.py", line 17, in <module>
#     print(next(g))
# StopIteration

```

如上述代码所示：
1. 只要Python代码中包含yield，该函数就是生成器函数
2. 生成器函数的定义体中通常都有循环，不过这不是必要条件；此处重复使用了3次yield
3. 可以看出gen_123是函数对象
4. 函数调用时返回的是一个生成器对象
5. 生成器是迭代器，会`生成`传给yield关键字的表达式的值
6. 为了仔细检查，把生成器对象赋值给g
7. 因为g是迭代器，所以调用nest(g)会获取yield`生成`的下一个元素
8. 生成器函数的定义体执行完毕后，生成器对象会抛出异常。


使用准确的词语描述从生成器中获取结果的过程有助于理解生成器。注意，此处说的是`产出`或`生成`值。如果说生成器`返回`值，就会让人难以理解。
>函数返回值; 调用生成器函数返回生成器; 生成器`产出`或`生成`值。生成器不会以常规方式`返回`值;



```python

In [66]: def gen_AB():
    ...:     print('start')
    ...:     yield 'A'
    ...:     print('continue')
    ...:     yield 'B'
    ...:     print('end.')
    ...:

In [67]: for c in gen_AB():
    ...:     print('-->', c)
    ...:
start
--> A
continue
--> B
end.

```







### 未完待续
