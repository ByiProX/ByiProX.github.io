---
title: python3 可迭代对象、迭代器和生成器
date: 2018-03-01 20:17:53
tags:
  - Python3
categories:
  - Python3 进阶
  - Python3 迭代器和生成器
---

## 前言
迭代是数据处理的基石。扫描内存中放不下数据集时，我们要找到一种惰性获取数据项的方式，即按需一次获取一个数据项，这就是迭代器模式（iterator pattern）。所有的`生成器`都是`迭代器`，因为生成器完全实现了迭代器接口。在python社区中，大多数时候都把`迭代器`和`生成器`视作同一概念。

所有python程序员都知道，序列可迭代，下面说明具体原因。
<!-- more -->
## 序列可迭代的原因：iter函数
解释器需要迭代对象x时，会自动调用`iter(x)`。
内置的iter函数有以下作用。

1. 检查对象是否实现了`__iter__`方法，如果实现了就调用它，获得一个迭代器。
2. 如果没有实现`__iter__`方法，但是实现了`__getitem__`方法，python会创建一个迭代器，尝试按顺序（从索引0开始）获取元素。
3. 如果尝试失败，python会抛出`TypeError`异常，通常会提示"C object is not iterable",其中C是目标对象所属的类。

任何Python序列都可迭代的原因是它们实现了`__getitem__`方法。其实标准的序列也都实现了`__iter__`方法。之所以对`__getitem__`方法做特殊处理是为了向后兼容。

从Python3.4开始，检查x能否迭代，最准确的方法是调用iter(x)函数，如果不可迭代，再处理TypeError异常。这比使用isinstance(x, abc.Iterable)更准确，因为iter(x)函数会考虑到遗留的`__getitem__`方法，而abc.Iterable类则不考虑。

## 可迭代的对象与迭代器的对比

### 可迭代对象

**使用iter内置函数可以获取迭代器的对象。** 如果实现了能返回迭代器的`__iter__`方法，那么对象就是可迭代的。序列都可以迭代；实现了`__getitem__`方法，而且七参数是从零开始的索引，这种对象也是可迭代的。

我们要明确可迭代对象和迭代器之间的关系：**Python从可迭代的对象中获取迭代器**

标准的迭代器接口有两个方法，即：
1. `__next__`:返回下一个可用元素，如果没有元素，抛出`StopIteration`异常
2. `__iter__`:返回self,以便在应该使用可迭代对象的地方使用迭代器，比如for循环中。

因为`迭代器`只需`__next__`和`__iter__`两个方法，所以除了调用next()方法，以及捕获`StopIteration`异常之外，没有办法检查是否还有遗留的元素。此外，也没有办法还原迭代器。如果想再次迭代，那就要调用iter(...)，传入之前构建迭代器的可迭代对象。

### 迭代器

迭代器是这样的对象：实现了无参数的`__next__`方法，返回序列中的下一个元素；如果没有元素了，那么抛出`StopIteration`异常。Python迭代器还实现了`__iter__`方法，因此迭代器也可以迭代。

构建`可迭代对象`和`迭代器`时经常会出现错误，原因是混淆了两者。要知道，`可迭代的对象`有个`__iter__`方法，每次都实例化一个新的迭代器；而`迭代器`要实现`__next__`方法，返回单个元素，此外还要实现`__iter__`方法，返回迭代器本身。因此，`迭代器`可以迭代，但是`可迭代的对象`不是迭代器。

可迭代的对象一定不是自身的迭代器。也就是说，可迭代的对象必须实现`__iter__`方法，但不能实现`__next__`方法。另一方面，迭代器应该一直可以迭代，迭代器的`__iter__`方法应该返回自身。

```python
a = [1,2,3]
'__iter__' in dir(a)            # True
'__iter__' in dir(iter(a))      # True

```

## 生成器函数

只要Python函数的定义体中有yield关键字，该函数就是生成器函数。调用生成器函数时，会返回一个生成器对象。也就是说，生成器函数是生成器工厂。

普通的函数与生成器函数在句法上的唯一区别是，在后者的定义体中有`yield`关键字。有些人认为定义生成器函数应该使用一个新的关键字，例如gen，而不是def，但是Guido不同意。
### 生成器函数工作原理

```python
def gen_123():  # 只要Python代码中包含yield，该函数就是生成器函数
    yield 1    #生成器函数的定义体中通常都有循环，不过这不是必要条件；此处重复使用了3次yield
    yield 2
    yield 3

if __name__ == '__main__':
    print(gen_123)    # 可以看出gen_123是函数对象
    # <function gen_123 at 0x10be199d8>
    print(gen_123())  # 函数调用时返回的是一个生成器对象
    # <generator object gen_123 at 0x10be31ca8>

    for i in gen_123(): # 生成器是迭代器，会生成传给yield关键字的表达式的值
        print(i)    
        # 1
        # 2
        # 3

    g = gen_123() # 为了仔细检查，把生成器对象赋值给g
    print(next(g))  # 1
    print(next(g))  # 2
    print(next(g))  # 3
    print(next(g))   # 生成器函数的定义体执行完毕后，生成器对象会抛出异常。
# Traceback (most recent call last):
#   File "test.py", line 17, in <module>
#     print(next(g))
# StopIteration

```

如上述代码所示：
1. 只要Python代码中包含yield，该函数就是生成器函数
2. 生成器函数的定义体中通常都有循环，不过这不是必要条件；此处重复使用了3次yield
3. 可以看出gen_123是函数对象
4. 函数调用时返回的是一个生成器对象
5. 生成器是迭代器，会`生成`传给yield关键字的表达式的值
6. 为了仔细检查，把生成器对象赋值给g
7. 因为g是迭代器，所以调用nest(g)会获取yield`生成`的下一个元素
8. 生成器函数的定义体执行完毕后，生成器对象会抛出异常。


使用准确的词语描述从生成器中获取结果的过程有助于理解生成器。注意，此处说的是`产出`或`生成`值。如果说生成器`返回`值，就会让人难以理解。
>函数返回值; 调用生成器函数返回生成器; 生成器`产出`或`生成`值。生成器不会以常规方式`返回`值;


```python

In [66]: def gen_AB():            # 1
    ...:     print('start')       
    ...:     yield 'A'            # 2
    ...:     print('continue')
    ...:     yield 'B'            # 3
    ...:     print('end.')        # 4
    ...:

In [67]: for c in gen_AB():       # 5
    ...:     print('-->', c)      # 6
    ...:
start       # 7
--> A       # 8
continue    # 9
--> B       # 10
end.        # 11

```
1. 定义生成的器函数的方式与普通函数无异，只不过要使用yield关键字
2. 在for循环中第一次隐式调用next()函数时（序号5），会打印'start'，然后停在第一个yield语句，生成值 'A'
3. 在for循环第二次隐式调用next()函数时，会打印'continue'，然后停在第二个yield语句，生成值'B'
4. 第三次调用 next()函数时，会打印'end.'，然后到达函数定义体末尾。导致生成器对象抛出StopIteration异常
5. 迭代时, for 机制的作用与g = iter(gen_AB())一样，用于获取生成器对象，然后每次迭代时调用next(g)
6. 循环打印 --> 与 next(g)返回的值。但是，生成器函数中的print函数输出结果之后才会看到这个输出
7. 'start'是生成器函数定义体中print('start')输出的记过
8. 生成器函数定义体中的yield 'A' 语句会生成值 A，提供给for循环使用，而A会赋值给变量c，最终输出--> A
9. 第二次调用next(g)，继续迭代，生成器函数定义体中的代码由yield 'A'前进到 yield 'B'。文本continue是由生成器函数定义体中的第二个print函数输出的
10. 生成器函数定义体中的yield 'B' 语句会生成值 B，提供给for循环使用，而B会赋值给变量c，最终输出--> B
11. 第三次调用next(g)，继续迭代，前进到生成器函数的结尾。文本 end. 是由生成器函数定义体中第三个print函数输出的。
12. 到达生成器函数定义体结尾时，生成器对象抛出StopIteration异常。for 机制会捕捉异常，因此循环终止没有报错。

## 生成器表达式

简单的生成器函数，可以替换成生成器表达式。生成器表达式可以理解为列表推导的惰性版本：不会迫切的构建列表，而是返回一个生成器，按需惰性生成元素。也就是说，如果列表推导是制造工厂的列表，那么生成器表达式就是制造生成器的工厂。如下演示了一个简单的生成器表达式，并且与列表推导做了对比。

```python

In [66]: def gen_AB():            # 1
    ...:     print('start')       
    ...:     yield 'A'            
    ...:     print('continue')
    ...:     yield 'B'            
    ...:     print('end.')        
    ...:

In [67]: res1 = [x*3 for x in gen_AB()]  # 2
start
continue
end.

In [68]: for i in res1():       # 3
    ...:     print('-->', i)      
    ...:
AAA
BBB

In [69]: res2 = (x*3 for x in gen_AB())  # 4

In [70]: res2  # 5
<generator object <genexpr> at 0x106a07620>

In [71]: for i in res2():       # 6
    ...:     print('-->', i)
    ...:
start   
--> A   
continue
--> B       
end.

```
1. 创建gen_AB函数
2. 列表推到迫切的迭代gen_AB()函数生成的生成器对象产出的元素：'A'和'B'。注意。下面输出的是start、continue、end.。
3. for循环迭代列表推导生成的res1列表
4. 把生成器表达式返回的值赋值给res2。只需调用gen_AB()函数，虽然调用时会返回一个生成器，但是这里并不使用。
5. 可以看出res2是一个生成器对象。
6. 只有for循环迭代res2时，gen_AB函数的定义体才会真正执行。for循环每次迭代时会隐式调用next(res2)，前进到gen_AB函数中的下一个yield语句。注意，gen_AB函数的输出与for循环中print函数的输出夹杂在一起。

生成器表达式会产出生成器，因此可以使用生成器表达式进一步减少代码量。生成器表达式是一种语法糖，完全可以替换成生成器函数，不过有时候使用生成器表达式更便利。


## 何时使用生成器表达式

生成器表达式是创建生成器的简洁句法，这样无需定义函数再调用。不过，生成器函数灵活的多，可以使用多个语句实现复杂的逻辑，也可以作为`协程`使用。遇到简单的情况时，可以使用生成器表达式，因为这样扫一眼就知道代码的作用。其实选择那种句法很容易判断：如果生成器表达式需要分行写，倾向于定义成生成器函数，以便提高可读性。此外生成器函数有名称，因此可以重用。
