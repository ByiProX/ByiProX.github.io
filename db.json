{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/README.md","path":"README.md","modified":0,"renderable":0},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/uploads/avatar.jpg","path":"uploads/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"29ee9addacd83cf155a59e05be540b2ffc50874b","modified":1530242139450},{"_id":"source/CNAME","hash":"5db3e3c11d5692cb4315e39fb27af311a14cb878","modified":1527665563497},{"_id":"source/README.md","hash":"3535b5914786d3308f3b3d0b16d5de9d19fa9424","modified":1520359701887},{"_id":"themes/next/.DS_Store","hash":"f09a86bb4ce7d04901ec1bb4cb55bee99909840c","modified":1519703664064},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1519624147209},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1519624147209},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1519624147209},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1519624147210},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1519624147210},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1519624147211},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1519624147211},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1519624147211},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1519624147211},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1519624147211},{"_id":"themes/next/README.cn.md","hash":"5d8af3d8de8d3926126a738519e97c8442b0effe","modified":1519624147212},{"_id":"themes/next/README.md","hash":"44b28d995681a7c48bfe3d0577d6203812d07e59","modified":1519624147212},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1519624147214},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1519624147214},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1519624147243},{"_id":"themes/next/_config.yml","hash":"78f536c85d5ba6e4cf236d487dffc74ffe989c1d","modified":1523035212160},{"_id":"source/about/index.md","hash":"9c0170da2b5b7b2334874df8a6346542044cebc7","modified":1525583188585},{"_id":"source/categories/index.md","hash":"e675535fc5444a91757d1878ea74869cfba250dc","modified":1519728606227},{"_id":"source/_posts/Apache和Nginx的对比.md","hash":"1202d780fc2f252c2a5452472b3091b8f3fa4bab","modified":1520447510268},{"_id":"source/_posts/Differences-between-and-is-in-Python3---(Reprint).md","hash":"71c7965f60f91cc9db7a0111a649b800a2f9a18c","modified":1522265146867},{"_id":"source/_posts/Django2-0-1搭建电影网站.md","hash":"9ccb572e15d1f52614d6ca6dfb07f4dc390ffb0e","modified":1519713719694},{"_id":"source/_posts/Django运行方式以及处理流程简介-转载.md","hash":"62d6b017aff72482c703f52a74adee2f6f04ad99","modified":1520424584924},{"_id":"source/_posts/Github多分支管理Hexo-Blog项目.md","hash":"005d4f3688fd9edb4a3712f675f81d44c1c24dcc","modified":1519713656801},{"_id":"source/_posts/HTML里引入CSS的四种方式.md","hash":"13410cb2d7ad21ff8662c37d684015cff757e805","modified":1524281683171},{"_id":"source/_posts/Hexo博客Next主题添加Fork-me-on-GitHub标签.md","hash":"165fac5df8b750ddd0b4ec9a7fe1c94dcb2f1677","modified":1519814115748},{"_id":"source/_posts/Hexo部署的网站项目-deploy-git-中添加README-md.md","hash":"2b664378eee7ddaace2b2a47b57c6a3794f7b56e","modified":1519799364312},{"_id":"source/_posts/IO密集型任务、计算密集型任务，以及多线程、多进程.md","hash":"0535c19510cd22b19892dfa4e6ce7971635a42d2","modified":1520265257211},{"_id":"source/_posts/Linux之crontab命令.md","hash":"bce2cc4145b27c64eb986af6f479f157f0eed5a5","modified":1525774450479},{"_id":"source/_posts/Mac-OS-命令之文件-夹-删除.md","hash":"3185e748f81945750c3c7a1c99a2c197988f9506","modified":1525534260225},{"_id":"source/_posts/Mac下profile文件.md","hash":"5392ed1cd275a1c85afb94f6143f01e4f1ad4bf3","modified":1526019107289},{"_id":"source/_posts/Mac下打开swf文件.md","hash":"393abe1ca4fdf85e001d16cdd9cdf2633a87c615","modified":1526016619985},{"_id":"source/_posts/Markdown小技巧之空格输入.md","hash":"1ff677079c2129c379663b06bc8950dfcc486d84","modified":1520053674804},{"_id":"source/_posts/Python2-7-x与Python3-x差异.md","hash":"49a55d4cbf469913510f0fc99a99aa15770e107b","modified":1520356806242},{"_id":"source/_posts/Python3-for-else-陷阱.md","hash":"0adf0211d83da433568d75c95b077b5d38a75ff7","modified":1522317617633},{"_id":"source/_posts/Python3-is和-的区别.md","hash":"92661516643e096d7632768f6e23f037cb1c3be6","modified":1524281694494},{"_id":"source/_posts/Python3-nonlocal声明.md","hash":"e5045c6c39dd03e00e5b2ef77de33c533b7eba7b","modified":1520321018494},{"_id":"source/_posts/Python3-os和sys模块的作用，以及常用的模块方法.md","hash":"21d7072558a89cb0d9d54e39283562da675d2399","modified":1520844543868},{"_id":"source/_posts/Python3-staticmethod和-classmethod.md","hash":"f360bdbf1b118b696a7a30a4726c8d20fd7c1426","modified":1519886180315},{"_id":"source/_posts/Python3-作用域.md","hash":"8daa35ac6f77dadb18dd65d5ad134118bec8ac00","modified":1520049390508},{"_id":"source/_posts/Python3-使用Selenium-PhantomJS爬火影忍者漫画.md","hash":"75b5bad4d74ee4c557fff100159c6061e0f19efd","modified":1520015145955},{"_id":"source/_posts/Python3-使用virtualenv搭建虚拟环境.md","hash":"a58749c6683d391b6d5bf7ed2136ff10ac9dc764","modified":1520055163613},{"_id":"source/_posts/Python3-函数重载.md","hash":"b703ad58e952ce0c740093f29cf8b00eb88fea5d","modified":1520048772845},{"_id":"source/_posts/Python3-单下划线和双下划线.md","hash":"9b5a3bf36a7164397847293f1d52023047a2e4e7","modified":1520015101034},{"_id":"source/_posts/Python3-单例模式.md","hash":"6ef996f904fea8bb668ad9b618173f1186ec1219","modified":1521485797784},{"_id":"source/_posts/Python3-向上取整ceil-向下取整floor-四舍五入round.md","hash":"40c8415634c798c59b6b08e7abcefd353138870a","modified":1520576834992},{"_id":"source/_posts/Python3-回文字符串的判断.md","hash":"546d9728505dd05b21dfe4550c8c3fd9d7e22304","modified":1521455602228},{"_id":"source/_posts/Python3-垃圾回收机制.md","hash":"9608340625e70d7dacd84d7148badd2e3f2ba4dc","modified":1520268680605},{"_id":"source/_posts/Python3-基于链表技术实现栈.md","hash":"4e5ef1c1ec0a089c58ef7aa2d8d3b00f3f532653","modified":1521403991735},{"_id":"source/_posts/Python3-基于顺序表技术实现栈类.md","hash":"9d7b04d950422cb58faf2b12d681698e8cd0ab24","modified":1521270729223},{"_id":"source/_posts/Python3-子类的查看与类的对象判断.md","hash":"c7629edc3f117b5f8fa3a8513e6c0749efd1ed72","modified":1520044766058},{"_id":"source/_posts/Python3-实现二分查找.md","hash":"5e181e0433187dd828225cab242a26ca55f9b3e3","modified":1520580397282},{"_id":"source/_posts/Python3-实现二叉树前、中、后序遍历及按层遍历.md","hash":"d978fdb81b12af6c37dd7860b8fd582c84344267","modified":1521403951302},{"_id":"source/_posts/Python3-实现常见的各种排序方法.md","hash":"a0354f2ebabdb91e03efc14202fb852c6eba91d8","modified":1521468990068},{"_id":"source/_posts/Python3-实现遍历目录与子目录，并抓取-py文件.md","hash":"aa62fa04f9b4743f5aea72984596e18df805b4eb","modified":1520845455759},{"_id":"source/_posts/Python3-对象操作的时间复杂度总结.md","hash":"7f797738a892dff12fe52f125e3ec38607aa6e7a","modified":1522325519404},{"_id":"source/_posts/Python3-将两个排好序的列表合并成一个有序列表.md","hash":"37a853bbaaf9e65e742c0c8399f718a6efd3031f","modified":1520791167116},{"_id":"source/_posts/Python3-拷贝对象-深拷贝deepcopy和浅拷贝copy.md","hash":"a74d664264a764b3099a2d3289b0d036ac198d18","modified":1520050449659},{"_id":"source/_posts/Python3-真假值对照表.md","hash":"14dd84be5b7590e2fbdc8507efd446aa024bad17","modified":1520054516663},{"_id":"source/_posts/Python3-类变量和实例变量.md","hash":"dcb3717191c637f8aa3535f343806ff8bd54695c","modified":1519891539909},{"_id":"source/_posts/Python3-自省.md","hash":"254d0ccbc934629c705becbd840cf235e899ff48","modified":1520011436828},{"_id":"source/_posts/Python3-解包和压包.md","hash":"c21390cac90f910aadeec4c88afa74055d65d79b","modified":1523034854402},{"_id":"source/_posts/Python3-让字典保持有序.md","hash":"f181c8d22beba91ac8edd6b5f3d18d8343f3fb70","modified":1520312157785},{"_id":"source/_posts/Python3-闭包.md","hash":"7a41404f8b826005912f0d953ba96e33d8ab0109","modified":1520319404733},{"_id":"source/_posts/Python3-鸭子类型.md","hash":"6015069f6196fac57c839f54ab2eb5df13e24acd","modified":1520055654624},{"_id":"source/_posts/TCP-套接字编程.md","hash":"31fdf136ff3f313d15ec42a26b77dbc3dca237cb","modified":1532760461361},{"_id":"source/_posts/Tesseract的使用.md","hash":"0300ce17a3047234c50b45766a6d280b58a04379","modified":1520836474885},{"_id":"source/_posts/What-is-the-difference-between-“-is-None-”-and-“-None-”-Reprint.md","hash":"67340ac1b05caf1f549aeb61cb26d1ca4eb60718","modified":1522264998970},{"_id":"source/_posts/hello-world.md","hash":"b8cefcae6e00fb9fc954a93587aa026a34878325","modified":1519713823774},{"_id":"source/_posts/if-name-main.md","hash":"13ecb200736f1cd552d82c258019a85c27bdb81c","modified":1519906398245},{"_id":"source/_posts/python3-产生随机字符串.md","hash":"78ad20149a0604088f98e24ca2a9c2092a9455ac","modified":1524126496623},{"_id":"source/_posts/python3-可迭代对象、迭代器和生成器.md","hash":"d97214db029e0a17a4302443642046e6eabb8eda","modified":1519966521925},{"_id":"source/_posts/python3-如何用一个表达式合并两个字典.md","hash":"b9f61028aec496143c62b71283853aeb486058b2","modified":1520010697046},{"_id":"source/_posts/一次完整的HTTP请求流程.md","hash":"ae02efba2601b686b274f76894fea09378df4c4b","modified":1521482453753},{"_id":"source/_posts/一种Git保留两个repo的commit信息进行合并的方法.md","hash":"483550b7fff39bb7aca857887ba23a3637839aee","modified":1519715982036},{"_id":"source/_posts/三次握手 | 四次挥手.md","hash":"0e22f9991ec3a44ad444944b166bb09a87879ee0","modified":1521475313251},{"_id":"source/_posts/三种多路复用IO实现方式：select，poll，epoll.md","hash":"3406f55b37cb789e368bbd42d4e3f96147e2409b","modified":1520419220981},{"_id":"source/_posts/什么是Socket-转.md","hash":"8cc25bf5f72cc55cde688e999f90d76104fda417","modified":1520874227890},{"_id":"source/_posts/从零开始学爬虫-01.md","hash":"d30857c41ef0b23aa34919b95a6896069d3670f0","modified":1519751080535},{"_id":"source/_posts/从零开始学爬虫-02.md","hash":"82c11b9d4650984af091d6e580e5ef3dfd0f4dd8","modified":1519751082158},{"_id":"source/_posts/从零开始学爬虫-03.md","hash":"6714ad7f64bdfaa8d5a899adb3adc285b0d589c1","modified":1519751083829},{"_id":"source/_posts/从零开始学爬虫-04.md","hash":"df009a65165b62f9cfb15c801f91270f8055493a","modified":1519751905138},{"_id":"source/_posts/从零开始学爬虫-05.md","hash":"616044ff7f3ef6558b80c583598de43bc0ad8d20","modified":1519752171289},{"_id":"source/_posts/原码、反码、补码.md","hash":"e357d8b93444800ea1ff540798226674e789a840","modified":1522155948413},{"_id":"source/_posts/如何理解操作系统中的同步和异步、阻塞和非阻塞.md","hash":"115637c5cc25ccf4267053b2db697f9ba67c4381","modified":1520576927749},{"_id":"source/_posts/正向代理和反向代理.md","hash":"626b73e1f6422bcf4f8792fdb2ae9dd8bcce2cbb","modified":1522052816270},{"_id":"source/_posts/浅谈Session和Cookie的区别与联系.md","hash":"a3d470160a3ae49b2ae86def8638f2b996c2657d","modified":1520362864896},{"_id":"source/_posts/浅谈TCP和UDP的区别以及应用.md","hash":"f799ec28de0b8646906dcb57d912f8babefb6d2e","modified":1520395812333},{"_id":"source/_posts/用户密码保存的方式有哪些.md","hash":"0f169c3a164757952608291104ef9bc594d34577","modified":1520445908274},{"_id":"source/_posts/简谈爬虫攻与防.md","hash":"c88ea54169cbd49bd82141ce828247a6ddd03fa4","modified":1523451519795},{"_id":"source/_posts/终端格式化打印json数据的方法.md","hash":"a7ff42dbef2ed34fa284e7a9fcf86c137793c200","modified":1525534258502},{"_id":"source/_posts/进程、线程、协程.md","hash":"294a4377f5c2c42a9cb97c477458710947e9b7d8","modified":1520404361417},{"_id":"source/_posts/进程间的通信方式-IPC.md","hash":"340067e8cae82eb1458bad066270e2e81e7163b4","modified":1520437757891},{"_id":"source/tags/index.md","hash":"c246461b696977ca1c1d9f018c95fe08579b9fbc","modified":1519728623228},{"_id":"source/_posts/UDP-套接字编程.md","hash":"a73f05ab1a1bcd6836182090acbd744dd0d3f243","modified":1532760560474},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1519624147194},{"_id":"themes/next/.git/config","hash":"bf7d1df65cf34d0f25a7184a58c37a09f72e4be7","modified":1519726463025},{"_id":"themes/next/.git/FETCH_HEAD","hash":"d67b7cbcc31216dec8e0329efb4eed8c0eec4cdb","modified":1519726468734},{"_id":"themes/next/.git/ORIG_HEAD","hash":"f4d9f6f8bc79e9bc071cf29324a74a1d78158ab9","modified":1519726468756},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1519624135722},{"_id":"themes/next/.git/index","hash":"4040cf935f10a7ba374f6c7adfe534e71a76b6b7","modified":1519640275157},{"_id":"themes/next/.git/packed-refs","hash":"339779e225d913a344c5e6210617badd049c4434","modified":1519624147186},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1519624147209},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"352093a1b210c72136687fd2eee649244cee402c","modified":1519624147209},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1519624147210},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1519624147210},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1519624147215},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1519624147215},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1519624147216},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1519624147216},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1519624147217},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1519624147217},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1519624147218},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1519624147218},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1519624147218},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1519624147218},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1519624147218},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1519624147219},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1519624147219},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1519624147219},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1519624147219},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1519624147220},{"_id":"themes/next/layout/_layout.swig","hash":"9f2e3f209579bdc27f87a4d1ef02a06a58fce03e","modified":1519795139298},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1519624147240},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1519624147241},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1519624147241},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1519624147242},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1519624147242},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1519624147242},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1519624147243},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1519624147244},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1519624147245},{"_id":"themes/next/source/.DS_Store","hash":"6266fdba27b0249947350a7214c960c4bc33b9b0","modified":1519703767860},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1519624147345},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1519624147345},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1519624147346},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1519624147279},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1519624135725},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1519624135723},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1519624135726},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1519624135726},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1519624135724},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1519624135726},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1519624135724},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1519624135725},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1519624135726},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1519624135727},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1519624135722},{"_id":"themes/next/.git/logs/HEAD","hash":"bc2442b4b1e426d613ede948ab87bb34810af65c","modified":1519624147197},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1519624147220},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1519624147221},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1519624147221},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1519624147221},{"_id":"themes/next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1519624147222},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1519624147222},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1519624147222},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1519624147222},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1519624147223},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1519624147223},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1519624147223},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1519624147224},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1519624147225},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1519624147225},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1519624147225},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1519624147228},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1519624147228},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1519624147229},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1519624147236},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1519624147236},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1519624147237},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1519624147237},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1519624147237},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1519624147238},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1519624147238},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1519624147245},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1519624147245},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1519624147246},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1519624147246},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1519624147246},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1519624147246},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1519624147246},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1519624147246},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1519624147247},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1519624147280},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1519624147280},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1519624147279},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1519624147281},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1519624147281},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1519624147279},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1519624147281},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1519624147282},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1519624147283},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1519624147283},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1519624147284},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1519624147283},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1519624147282},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1519624147282},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1519624147284},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1519624147285},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1519624147284},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1519624147285},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1519624147285},{"_id":"themes/next/source/uploads/avatar.jpg","hash":"486f26a392d7783a3e9ac1a81ddecbde060f47e5","modified":1519703513674},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1519624147229},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1519624147229},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1519624147270},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1519624147270},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1519624147270},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1519624147278},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1519624147279},{"_id":"themes/next/.git/refs/heads/master","hash":"f4d9f6f8bc79e9bc071cf29324a74a1d78158ab9","modified":1519624147195},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1519624147224},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1519624147224},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1519624147226},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1519624147226},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1519624147226},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1519624147227},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1519624147227},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1519624147227},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1519624147228},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1519624147228},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1519624147229},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1519624147229},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1519624147230},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1519624147230},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1519624147230},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1519624147231},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1519624147231},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1519624147231},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1519624147231},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1519624147232},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1519624147232},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1519624147232},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1519624147232},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1519624147233},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1519624147233},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1519624147234},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1519624147234},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1519624147235},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1519624147235},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1519624147235},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1519624147235},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1519624147236},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1519624147236},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1519624147236},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1519624147238},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1519624147239},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1519624147239},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1519624147240},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1519624147269},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1519624147270},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1519624147270},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1519624147270},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1519624147277},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1519624147278},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1519624147278},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1519624147278},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1519624147286},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1519624147287},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1519624147286},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1519624147286},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1519624147287},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1519624147287},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1519624147288},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1519624147287},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1519624147288},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1519624147289},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1519624147289},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1519624147300},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1519624147300},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1519624147295},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1519624147299},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1519624147306},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1519624147299},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1519624147309},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1519624147309},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1519624147309},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1519624147307},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1519624147310},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1519624147307},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1519624147307},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1519624147324},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1519624147326},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1519624147310},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1519624147326},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1519624147326},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1519624147327},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1519624147327},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1519624147330},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1519624147328},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1519624147329},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1519624147328},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1519624147330},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1519624147330},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1519624147329},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1519624147329},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1519624147330},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1519624147331},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1519624147327},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1519624147331},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1519624147331},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1519624147332},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1519624147332},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1519624147333},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1519624147333},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1519624147332},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1519624147341},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1519624147334},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1519624147335},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1519624147341},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1519624147334},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1519624147344},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1519624147345},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1519624147344},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1519624147325},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"bc2442b4b1e426d613ede948ab87bb34810af65c","modified":1519624147198},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1519624147193},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1519624147238},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1519624147238},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1519624147247},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1519624147247},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1519624147248},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1519624147248},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1519624147248},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1519624147252},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1519624147261},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1519624147267},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1519624147267},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1519624147268},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1519624147268},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1519624147268},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1519624147269},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1519624147269},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1519624147271},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1519624147271},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1519624147271},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1519624147272},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1519624147272},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1519624147272},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1519624147273},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1519624147273},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1519624147274},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1519624147274},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1519624147275},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1519624147275},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1519624147275},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1519624147276},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1519624147276},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1519624147276},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1519624147276},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1519624147277},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1519624147277},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1519624147288},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1519624147294},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1519624147292},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1519624147301},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1519624147301},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1519624147302},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1519624147301},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1519624147294},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1519624147302},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1519624147302},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1519624147305},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1519624147308},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1519624147306},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1519624147306},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1519624147308},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1519624147311},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1519624147311},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1519624147311},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1519624147340},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1519624147340},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1519624147293},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1519624147323},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1519624147324},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1519624147343},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"bc2442b4b1e426d613ede948ab87bb34810af65c","modified":1519624147193},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1519624147248},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1519624147248},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1519624147249},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1519624147249},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1519624147249},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1519624147249},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1519624147250},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1519624147250},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1519624147250},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1519624147251},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1519624147251},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1519624147251},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1519624147252},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1519624147252},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1519624147253},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1519624147253},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1519624147253},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1519624147254},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1519624147254},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1519624147254},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1519624147255},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1519624147255},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1519624147255},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1519624147255},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1519624147256},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1519624147256},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1519624147256},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1519624147257},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1519624147257},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1519624147257},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1519624147258},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1519624147259},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1519624147259},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1519624147259},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1519624147259},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1519624147260},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1519624147260},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1519624147260},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1519624147261},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1519624147261},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1519624147262},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1519624147262},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1519624147262},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1519624147262},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1519624147263},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1519624147263},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1519624147263},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1519624147264},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1519624147264},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1519624147264},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1519624147265},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1519624147265},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1519624147265},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1519624147265},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1519624147266},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1519624147266},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1519624147266},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1519624147266},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1519624147273},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1519624147274},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1519624147275},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1519624147290},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1519624147291},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1519624147290},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1519624147303},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1519624147291},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1519624147304},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1519624147303},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1519624147292},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1519624147304},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1519624147313},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1519624147305},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1519624147304},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1519624147316},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1519624147322},{"_id":"themes/next/.git/objects/pack/pack-b8112ba9b2c5bcb1cb04d783dc033a5ffee52826.idx","hash":"40b3e03b5059218f1654f42fa247459300719d43","modified":1519624147160},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1519624147299},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1519624147339},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1519624147320},{"_id":"themes/next/.git/objects/pack/pack-b8112ba9b2c5bcb1cb04d783dc033a5ffee52826.pack","hash":"e3ce8bde10cc496dd49a3dbb6e8adf7035e5faad","modified":1519624147155},{"_id":"public/atom.xml","hash":"9f05a56843d061ee7eb5dee3ebe356044298d1c3","modified":1532760603974},{"_id":"public/search.xml","hash":"8816410617176f37e8b45d71750a30de195b87a3","modified":1532760497710},{"_id":"public/about/index.html","hash":"71f8982ea38e15347ba6a6668e36cb13961b75f5","modified":1532760423738},{"_id":"public/categories/index.html","hash":"1dbf6672f448636d359cb3cbbf9255b283e34d6c","modified":1532523125851},{"_id":"public/tags/index.html","hash":"53e6eaa69ec98596b362381c8dfef1a6bec45b1a","modified":1532760423738},{"_id":"public/2018/07/25/UDP-套接字编程/index.html","hash":"a848afe0f0372b6c2fcbf867238360ff6f5fb05e","modified":1532760604054},{"_id":"public/2018/05/11/Mac下打开swf文件/index.html","hash":"d3e6d64d79af40b45ac1cb070b5487c3b0044ee4","modified":1532523125851},{"_id":"public/2018/05/08/Mac下profile文件/index.html","hash":"3bfb95057be9969dd87821d67c53aa6c0cbb3b7f","modified":1532523125851},{"_id":"public/2018/05/05/Linux之crontab命令/index.html","hash":"b7f10e944f136847097cddc96157899dc3f1625f","modified":1532523125851},{"_id":"public/2018/04/25/终端格式化打印json数据的方法/index.html","hash":"c3c82255b2b380c4624f6cf7e09807179a61970e","modified":1532523125851},{"_id":"public/2018/04/19/python3-产生随机字符串/index.html","hash":"2d6aea072de8b57f7e3eb620cc08351e79392612","modified":1532523125852},{"_id":"public/2018/04/09/HTML里引入CSS的四种方式/index.html","hash":"acfad17663bc5c3456ae9236f28eb08d87465549","modified":1532523125852},{"_id":"public/2018/03/29/Python3-对象操作的时间复杂度总结/index.html","hash":"3e14faf95af547cf98d9ffdd1714b933d4fa804d","modified":1532523125852},{"_id":"public/2018/03/29/Python3-for-else-陷阱/index.html","hash":"0d9e117358b7437d0a8495c814c695928647fd58","modified":1532523125852},{"_id":"public/2018/03/29/What-is-the-difference-between-“-is-None-”-and-“-None-”-Reprint/index.html","hash":"f71a332cb8b75f2eb3425be53b63ef1cc4fb42d0","modified":1532523125852},{"_id":"public/2018/03/29/Differences-between-and-is-in-Python3---(Reprint)/index.html","hash":"ed632c5e68e7b970a1f79679ec87e66a78291547","modified":1532523125852},{"_id":"public/2018/03/27/原码、反码、补码/index.html","hash":"51653e1fd163715d5748f0daba77056dff532e57","modified":1532523125852},{"_id":"public/2018/03/26/正向代理和反向代理/index.html","hash":"e186e0262e48aa960175b5a4a4ed51b3d9e0721b","modified":1532523125852},{"_id":"public/2018/03/20/一次完整的HTTP请求流程/index.html","hash":"9df4a6339ff6617d9dbf103c9c6992acae8e7f6e","modified":1532523125852},{"_id":"public/2018/03/19/三次握手 | 四次挥手/index.html","hash":"05dab8e9dabc58378d58ed1918ca095bfbb71f5e","modified":1532523125852},{"_id":"public/2018/03/19/Python3-回文字符串的判断/index.html","hash":"e649005211a89198537d7e03728b781351d18f64","modified":1532523125852},{"_id":"public/2018/03/17/Python3-基于链表技术实现栈/index.html","hash":"0535b77e2465d1383592c2f9ef21ab5716c8b984","modified":1532523125852},{"_id":"public/2018/03/17/Python3-基于顺序表技术实现栈类/index.html","hash":"6fb05da6563d2ea39f5f49cbdcf6ad2c8793be68","modified":1532523125852},{"_id":"public/2018/03/19/Python3-单例模式/index.html","hash":"2dcc517895397fa1cb0a93ee76f769a72fa25fa8","modified":1532523125853},{"_id":"public/2018/03/15/Python3-实现二叉树前、中、后序遍历及按层遍历/index.html","hash":"35f46528b252c9915373a2d101e575254d483207","modified":1532523125853},{"_id":"public/2018/03/13/什么是Socket-转/index.html","hash":"98e4e13b3a3b34d64ec38d3160c3fe6007b9671a","modified":1532523125853},{"_id":"public/2018/03/12/Python3-实现遍历目录与子目录，并抓取-py文件/index.html","hash":"60304d6a690ced5d33d94adb8c8d9e440acafadc","modified":1532523125853},{"_id":"public/2018/03/12/Python3-os和sys模块的作用，以及常用的模块方法/index.html","hash":"4feaddedd1babc743d18f2b918c0d11422aa1070","modified":1532523125853},{"_id":"public/2018/03/12/Tesseract的使用/index.html","hash":"9f7e23ff1fcefcad157137f1842aa30d47559a56","modified":1532523125853},{"_id":"public/2018/03/12/Python3-将两个排好序的列表合并成一个有序列表/index.html","hash":"f0f2d745ccaf02962650f7a8762e1f6672773fd8","modified":1532523125853},{"_id":"public/2018/03/09/Python3-实现常见的各种排序方法/index.html","hash":"d5014c739ab2396803c94bcf023e64644924bb95","modified":1532523125853},{"_id":"public/2018/03/09/Python3-实现二分查找/index.html","hash":"a1fc01e78867d54a5d3e7850c42c8d532f943f63","modified":1532523125853},{"_id":"public/2018/03/08/Apache和Nginx的对比/index.html","hash":"f90e03f1b58a2127034cd9e169500cba8aaec645","modified":1532523125853},{"_id":"public/2018/03/09/Python3-向上取整ceil-向下取整floor-四舍五入round/index.html","hash":"59f78e01d96551633ed737b5d354366aaca8343a","modified":1532523125853},{"_id":"public/2018/03/08/用户密码保存的方式有哪些/index.html","hash":"f0e090d414080cad4b68d3106299f9384f2fe5af","modified":1532523125853},{"_id":"public/2018/03/07/进程间的通信方式-IPC/index.html","hash":"b0a4ad7d7a2db0a9978987b38802df8275bbae03","modified":1532523125853},{"_id":"public/2018/03/07/Django运行方式以及处理流程简介-转载/index.html","hash":"f2b3d63128e2d63d912f4b8eeb49ab1b323e8ae8","modified":1532523125854},{"_id":"public/2018/03/07/三种多路复用IO实现方式：select，poll，epoll/index.html","hash":"4ea2abf86839ccc7ef946a23d8e30fa66badbac5","modified":1532523125854},{"_id":"public/2018/03/07/浅谈Session和Cookie的区别与联系/index.html","hash":"cee07e75d16d0d01421d17b8f1961f91e91b8d74","modified":1532523125854},{"_id":"public/2018/03/07/浅谈TCP和UDP的区别以及应用/index.html","hash":"2ec27249bc1eac29b8df703eb66257c8667b2daa","modified":1532523125854},{"_id":"public/2018/03/07/如何理解操作系统中的同步和异步、阻塞和非阻塞/index.html","hash":"27d184ef7e65a4ca0974b6981372759bf4c4b37e","modified":1532523125854},{"_id":"public/2018/03/06/Python3-nonlocal声明/index.html","hash":"28f0650822db7aa804980c302e6b528978d3e766","modified":1532523125854},{"_id":"public/2018/03/06/Python3-闭包/index.html","hash":"18a05a154a3ba329dbc8f2af9b76735569a3230e","modified":1532523125854},{"_id":"public/2018/03/06/Python3-让字典保持有序/index.html","hash":"f175b9b6f993b38a2fe9a5353316952540174cd9","modified":1532523125854},{"_id":"public/2018/03/06/Python2-7-x与Python3-x差异/index.html","hash":"6f1ab2eefd3c989b25b6a64affa47166ead4bd6e","modified":1532523125854},{"_id":"public/2018/03/05/Python3-垃圾回收机制/index.html","hash":"6c9133d6fbf62414320f52acc24398960be66de8","modified":1532523125854},{"_id":"public/2018/03/05/IO密集型任务、计算密集型任务，以及多线程、多进程/index.html","hash":"247e0a672fcd4c7c27ad61da3c2f78d607ac24fe","modified":1532523125854},{"_id":"public/2018/03/04/进程、线程、协程/index.html","hash":"00157e6f3ee32f17bfc41f28e372d2a2c1713a16","modified":1532523125855},{"_id":"public/2018/03/03/Mac-OS-命令之文件-夹-删除/index.html","hash":"f11b9c5826b7592b045cf5a3834eb8c1b34b7f90","modified":1532523125855},{"_id":"public/2018/03/03/Python3-使用virtualenv搭建虚拟环境/index.html","hash":"3d9afa295480560c5937e605596a8afa33e5104a","modified":1532523125855},{"_id":"public/2018/03/03/Python3-真假值对照表/index.html","hash":"1ad26c935bb4e767fe5796fb1e59a52461b95999","modified":1532523125855},{"_id":"public/2018/03/03/Markdown小技巧之空格输入/index.html","hash":"ac03560c41445dadf35f145ab92ab353bef5ac55","modified":1532523125855},{"_id":"public/2018/03/03/Python3-is和-的区别/index.html","hash":"5c74bc6f14812e9bb8d921406dda58a27b6a2871","modified":1532523125855},{"_id":"public/2018/03/03/Python3-作用域/index.html","hash":"31ce61db25d50845de0fb7ab150008939504dcd9","modified":1532523125855},{"_id":"public/2018/03/03/Python3-拷贝对象-深拷贝deepcopy和浅拷贝copy/index.html","hash":"9a89030cba0a8e8e4bd11e1a5634a24083cc2df4","modified":1532523125855},{"_id":"public/2018/03/03/Python3-函数重载/index.html","hash":"212ec51c16d16a3f5d9d45ade9b8b455a54e7f4f","modified":1532523125855},{"_id":"public/2018/03/03/Python3-子类的查看与类的对象判断/index.html","hash":"b4bf3b2c6168243f4480bf4a9594579d1c11d84a","modified":1532523125855},{"_id":"public/2018/03/03/Python3-鸭子类型/index.html","hash":"9e7f12ce0b0f0c45a9872e0a4e2236365fd12ab6","modified":1532523125855},{"_id":"public/2018/03/03/python3-如何用一个表达式合并两个字典/index.html","hash":"a782164c96f8c40deee9e8ca0c660004bd7b45e4","modified":1532523125855},{"_id":"public/2018/03/01/python3-可迭代对象、迭代器和生成器/index.html","hash":"06c4677b0a81d0d3390a660810fbd52c64554d67","modified":1532523125856},{"_id":"public/2018/03/01/if-name-main/index.html","hash":"3e76551a071a056a5c4838d0e223682e8286fd64","modified":1532523125856},{"_id":"public/2018/03/01/Python3-单下划线和双下划线/index.html","hash":"545a659727f3db211b5055e53b64a427277c0a16","modified":1532523125856},{"_id":"public/2018/03/01/Python3-自省/index.html","hash":"d6464a8902f06aa30cf2d254fac98ac48601fbef","modified":1532523125856},{"_id":"public/2018/03/01/Python3-staticmethod和-classmethod/index.html","hash":"06ae5106f91aa74ca5aa1c9eab0336fc093ac2ff","modified":1532523125856},{"_id":"public/2018/02/28/Hexo博客Next主题添加Fork-me-on-GitHub标签/index.html","hash":"99dfe7a2144ad3b38a9608f266c528ec5695ba87","modified":1532523125856},{"_id":"public/2018/02/28/Hexo部署的网站项目-deploy-git-中添加README-md/index.html","hash":"d5757c4b64025d25529d8f7f43a1678e8dd41df7","modified":1532523125856},{"_id":"public/2018/02/28/从零开始学爬虫-05/index.html","hash":"f8db5460ac33f4ca342abe26373daa1b91f4041b","modified":1532523125856},{"_id":"public/2018/02/28/从零开始学爬虫-04/index.html","hash":"a45f97d065c7b245494078ed9dd1450aa22ec48b","modified":1532523125856},{"_id":"public/2018/02/28/从零开始学爬虫-03/index.html","hash":"ef21aa2c943fd0cfffc57b19067c47e6de329f3f","modified":1532523125856},{"_id":"public/2018/02/28/从零开始学爬虫-02/index.html","hash":"05f440f5b009879abc414887c366e2e56cb13d77","modified":1532523125856},{"_id":"public/2018/02/28/从零开始学爬虫-01/index.html","hash":"c2cc03978db39e8a841f9d280d59ed9ea1958457","modified":1532523125857},{"_id":"public/2018/02/27/一种Git保留两个repo的commit信息进行合并的方法/index.html","hash":"2bb8637fef39a087bf146f852caef5a791474646","modified":1532523125857},{"_id":"public/2018/02/27/Python3-使用Selenium-PhantomJS爬火影忍者漫画/index.html","hash":"48679f6cedc3d2cc754d1689a7f6f0337f10928b","modified":1532523125857},{"_id":"public/2018/02/27/简谈爬虫攻与防/index.html","hash":"55969727c68762b8db85049236c45413e2067c5c","modified":1532523125857},{"_id":"public/2018/02/27/Django2-0-1搭建电影网站/index.html","hash":"c7314791c22d05d1458d401d1822c91547bb9558","modified":1532523125857},{"_id":"public/2018/02/27/Github多分支管理Hexo-Blog项目/index.html","hash":"cf8ce153a8eb2951aafae1917aaf7063178e03d6","modified":1532523125857},{"_id":"public/2018/02/26/hello-world/index.html","hash":"19297248f3e70bf0cdc99d330515767640450a11","modified":1532523125858},{"_id":"public/archives/index.html","hash":"a2ff21e22cf115c33723d5a8e2aac1afb89f180c","modified":1532523125858},{"_id":"public/archives/page/3/index.html","hash":"005adecf179981b2befaf3402e7b719b64d3ec6a","modified":1532523125858},{"_id":"public/archives/page/2/index.html","hash":"f9d5cb7c183fd2b54cb746ef2ef4f2a22da97c20","modified":1532523125859},{"_id":"public/archives/page/4/index.html","hash":"3d61fbffd216835e8c733936de1471e7674ab209","modified":1532523125859},{"_id":"public/archives/page/5/index.html","hash":"ccec6a47a2c9821fa8f895f49aa3dd38610ae7e8","modified":1532523125859},{"_id":"public/archives/page/7/index.html","hash":"e38f7dfa4f6c381dc45f0cb65843210e0cb8e666","modified":1532523125859},{"_id":"public/archives/page/8/index.html","hash":"1c4b1ed25ea39b37e7f02cc08be4e3ae611c87e9","modified":1532523125859},{"_id":"public/archives/page/6/index.html","hash":"61ca487ca41001c625efee38592a18272a0bb9c1","modified":1532523125859},{"_id":"public/archives/2018/index.html","hash":"20c40c561b56d7c5bdb58489d84869abb45d4231","modified":1532523125859},{"_id":"public/archives/2018/page/2/index.html","hash":"591aa2037f7a57a75cd9e3c20e577b2170a4792c","modified":1532523125859},{"_id":"public/archives/2018/page/3/index.html","hash":"fa0aea32af0dc0b32df21daff4661a5dfde6f87b","modified":1532523125859},{"_id":"public/archives/2018/page/4/index.html","hash":"8cbbe64e8ad7157d4c2016b87a8d47d88b2da565","modified":1532523125859},{"_id":"public/2018/04/06/Python3-解包和压包/index.html","hash":"6121b976ce0b92d6071ee7016b2c635dee0572cd","modified":1532523125859},{"_id":"public/archives/2018/page/5/index.html","hash":"4d9c5c5a713df9766360b26ded2a2951ae99e753","modified":1532523125860},{"_id":"public/archives/2018/page/6/index.html","hash":"7307956277ed03d0982239e9d7117397022cd680","modified":1532523125860},{"_id":"public/archives/2018/page/7/index.html","hash":"ef32caa0da6f0956da65bffa025ed4c8982d8119","modified":1532523125860},{"_id":"public/archives/2018/02/index.html","hash":"9cbaaea613059223d1bc437892ed8c16c20b24c8","modified":1532523125860},{"_id":"public/archives/2018/page/8/index.html","hash":"224ec1c451096349242234dd4cbb969e2fc2697a","modified":1532523125860},{"_id":"public/2018/03/01/Python3-类变量和实例变量/index.html","hash":"c433b004e6523911313757283a9774f2dbc125fa","modified":1532523125860},{"_id":"public/archives/2018/02/page/2/index.html","hash":"378c6a7ab6ebf113c2cae870fdfc9ca5a16244a2","modified":1532523125860},{"_id":"public/archives/2018/03/index.html","hash":"36785f47cb4c3a63fa809bb3fb79cb3b09afb34a","modified":1532523125860},{"_id":"public/archives/2018/03/page/2/index.html","hash":"11dc441e88d66f5527ff21b4ccde06cf9fade4c6","modified":1532523125860},{"_id":"public/archives/2018/03/page/3/index.html","hash":"b830c542484d9e8a67411820694852d7314cf914","modified":1532523125860},{"_id":"public/archives/2018/03/page/4/index.html","hash":"5ae74e585c07ea0ba98ea38e8acc42616c36951d","modified":1532523125861},{"_id":"public/archives/2018/03/page/5/index.html","hash":"d5b6c29e576c6cf7fed9b5e086e5e3e06b9ae650","modified":1532523125861},{"_id":"public/archives/2018/03/page/6/index.html","hash":"d6cbd40926319547252116a5f839719f1f2c2c00","modified":1532523125861},{"_id":"public/archives/2018/04/index.html","hash":"01a81d6c405c097592a493a8961cc441cf546fea","modified":1532523125861},{"_id":"public/archives/2018/05/index.html","hash":"ef1f63a477606308bca6e088c9a426ecce07f49d","modified":1532523125861},{"_id":"public/archives/2018/07/index.html","hash":"ca757696923c4ab9bb9f9632be00ece7c135fb6e","modified":1532523125862},{"_id":"public/categories/Python3-进阶/index.html","hash":"efabd94bc492ddc3f2db617e29237b2c6ecda53c","modified":1532523125862},{"_id":"public/categories/Python3-进阶/page/2/index.html","hash":"fe50c8fa9206b5b6e9c47444320091cd44995b24","modified":1532523125862},{"_id":"public/categories/Python3-进阶/page/3/index.html","hash":"7f1676980b720f816ccf1d0df9d13bc150d5b067","modified":1532523125862},{"_id":"public/categories/Django/index.html","hash":"f16635aff404edd55ba3b483237b21cddd220c63","modified":1532523125862},{"_id":"public/categories/Hexo/index.html","hash":"2b5792f5fda8788a36810f50f9a9d78abb2a9b00","modified":1532523125862},{"_id":"public/categories/Frontend/index.html","hash":"df6aae4ef614b32e464f92b5d11b2e5e8d736142","modified":1532523125862},{"_id":"public/categories/操作系统/index.html","hash":"dc39458709205cfeb1e5884115ac3fb7782caf42","modified":1532523125862},{"_id":"public/categories/Linux-Mac-OS/index.html","hash":"89b5f9a15e1c9d4edc515f34337db1f25f5399d3","modified":1532523125862},{"_id":"public/categories/Markdown/index.html","hash":"2661148c82aa50e8be61cb61575bd9504280040d","modified":1532523125863},{"_id":"public/categories/Python3-进阶/Python3-闭包/index.html","hash":"8c6b790a4b53b513557b02df96a0e1da7f405dd2","modified":1532523125863},{"_id":"public/categories/Python3-进阶/Staticmethod-Classmethod/index.html","hash":"e874458c3773ba65e38072f08118726df6f2a7a2","modified":1532523125863},{"_id":"public/categories/操作系统/多任务处理/index.html","hash":"88f553bdec42118f4a8cc6ca858b2ca780888bb0","modified":1532523125863},{"_id":"public/categories/Python3-进阶/Python3-作用域/index.html","hash":"f3046391ee7dde0653e559b61cbda2f962e93cc2","modified":1532523125863},{"_id":"public/categories/Spider/index.html","hash":"995951d47e8ec5348f9b5c6a70af4fe41f8c3d3f","modified":1532523125863},{"_id":"public/categories/Python3-进阶/Python3-virtualenv/index.html","hash":"8808d12cb4f50d40f0a759704c0fe6e78dcdc830","modified":1532523125863},{"_id":"public/categories/Python3-进阶/Python3-重载/index.html","hash":"70817759e78d49a4c4f4bf2e293b9b2e49f530b2","modified":1532523125863},{"_id":"public/categories/Python3-进阶/Python3-下划线/index.html","hash":"16cc44f8810d44294cf8e1d3d389d67d8395d248","modified":1532523125863},{"_id":"public/categories/Algorithm/index.html","hash":"65f5db4f86eb4bfd2e0a6662b44d22ff40bcc1f2","modified":1532523125863},{"_id":"public/categories/Data-Structures/index.html","hash":"ea48c96e23c1936160315e70b58f6b25bdccb0a1","modified":1532523125863},{"_id":"public/categories/Python3-进阶/Python3-拷贝对象/index.html","hash":"3da7c7b2c42f132168fa94ba545c7692ed08b6ec","modified":1532523125863},{"_id":"public/categories/Python3-进阶/Python3-True-or-False/index.html","hash":"fb75c08d5a1181d281b5cc8dd56201d31bca2a99","modified":1532523125864},{"_id":"public/categories/Python3-进阶/类变量-和-实例变量/index.html","hash":"4449f6592d2162602916c20c61b0a731d862ddcc","modified":1532523125864},{"_id":"public/categories/Spider/Selenium/index.html","hash":"aea3ee1b22c7b866b7ca0e549313c5d2d18961ba","modified":1532523125864},{"_id":"public/categories/Python3-进阶/Python3-自省/index.html","hash":"5b051854137f0bb850e4179a9aff05d22877db04","modified":1532523125864},{"_id":"public/categories/Python3-进阶/Python3-字典/index.html","hash":"a7599d3f6494e8dd65a570fd5e901f9eb67fd6a9","modified":1532523125864},{"_id":"public/categories/Python3-进阶/Python3-鸭子类型/index.html","hash":"2dbd630e818c28ffc3b5d9a6fb26675bf86b0343","modified":1532523125864},{"_id":"public/categories/网络/index.html","hash":"6df884860ec4e5d81caf4e90086592c25a099a0f","modified":1532523125864},{"_id":"public/categories/Tesseract/index.html","hash":"1283193820d5bc3e77a094d10ff303e75bb5b4f5","modified":1532523125864},{"_id":"public/categories/Python3-进阶/Python3-数据结构/index.html","hash":"0eab47ea54335aa757b6247730c47fd8a67a578c","modified":1532523125864},{"_id":"public/categories/Python3-进阶/Python3-迭代器和生成器/index.html","hash":"6629420c9f1d03a50f53e7baf015b85362b2f74f","modified":1532523125864},{"_id":"public/categories/Git/index.html","hash":"ad6f58bd5f7df66c453daa279cd9d26eb3a38ae5","modified":1532523125864},{"_id":"public/categories/Spider/Urllib/index.html","hash":"f1b1da85b5ade07a7d48569fc5f5a4da6611bb64","modified":1532523125864},{"_id":"public/categories/Spider/Scrapy/index.html","hash":"2f5a277752c55b22135f8661b391ffa51fc43930","modified":1532523125864},{"_id":"public/index.html","hash":"120bdbac54dd2192ef6140e51f41d907dab99870","modified":1532523125864},{"_id":"public/2018/07/25/TCP-套接字编程/index.html","hash":"b1be66d702ea2c8efeb748ae8ce164a4f4ade5c3","modified":1532760497724},{"_id":"public/page/2/index.html","hash":"47cae954e86dcf74413395a66d35c5bcc64ced62","modified":1532523125878},{"_id":"public/page/4/index.html","hash":"aa3e46dfd31fe1632b127a935c9dc16945ec0821","modified":1532523125879},{"_id":"public/page/3/index.html","hash":"332b6674e95d0bb476d693421284b48af12d5ef5","modified":1532523125880},{"_id":"public/page/8/index.html","hash":"fa3382af02ef55a427b277855a0cf65c12a83ae2","modified":1532523125880},{"_id":"public/page/5/index.html","hash":"f2946ad87ae0a9c07c3e2a32eb3f3c865ad4c128","modified":1532523125880},{"_id":"public/page/6/index.html","hash":"81a9d82a58442b020cb76c0c7a3af590a7ac6f8d","modified":1532523125880},{"_id":"public/tags/Web服务器/index.html","hash":"7bfa03c4bb8d5d1b80fc745deac7cdd328c7cfb1","modified":1532523125881},{"_id":"public/tags/Python3/index.html","hash":"1cb470302579bc1ea0ecdb10f33e5e694c60dc18","modified":1532523125881},{"_id":"public/tags/Python3/page/2/index.html","hash":"f9e9a30cd069657268dc0dd4d74f014fb7dc334c","modified":1532523125881},{"_id":"public/tags/Python3/page/3/index.html","hash":"9620161905d28cca76e3129c967f5866303afa12","modified":1532523125881},{"_id":"public/tags/Python3/page/4/index.html","hash":"a1b178487c9efb3496eec720aef02e248b94e48b","modified":1532523125881},{"_id":"public/tags/Python3/page/5/index.html","hash":"c6198c7614729ba80624db455e81137c184a5411","modified":1532523125882},{"_id":"public/tags/Django/index.html","hash":"d200b0f3ab54fcfcdce347e09e78d7c930b429d7","modified":1532523125882},{"_id":"public/tags/Hexo/index.html","hash":"d7b46389c7b2f86f848a50305d29ffefe929997e","modified":1532523125882},{"_id":"public/page/7/index.html","hash":"680ae75d0a258dd1b093b02c7e71c3e167a713b6","modified":1532523125882},{"_id":"public/tags/Git/index.html","hash":"01e61323a4235cafa900de83208d34f67ea552c4","modified":1532523125882},{"_id":"public/tags/Frontend/index.html","hash":"6404beccf4bfa65d22e11e55a9ecd5c0d5332d94","modified":1532523125882},{"_id":"public/tags/操作系统/index.html","hash":"652d37dab2f21922fb83e0c0dfba60f340fdf80b","modified":1532523125882},{"_id":"public/tags/Linux-Mac-OS/index.html","hash":"a3cb1935b8b5cd9657a10447626703faef488100","modified":1532523125882},{"_id":"public/tags/Markdown/index.html","hash":"d856bbde1678cc8cdeb28fe4672c211b270a5b81","modified":1532523125882},{"_id":"public/tags/Spider/index.html","hash":"eaef4f909254ca8a1a01afe7d3ce8809a6b5b72a","modified":1532523125882},{"_id":"public/tags/Selenium/index.html","hash":"24b8f0f40a67c677148daaf8987897b5db84dcd2","modified":1532523125882},{"_id":"public/tags/PhantomJS/index.html","hash":"7f3a934b54a0e1967250439adc199709b49315f5","modified":1532523125882},{"_id":"public/tags/设计模式/index.html","hash":"fc455af2cd8e854e1b63263d59c0766023b79158","modified":1532523125882},{"_id":"public/tags/Algorithm/index.html","hash":"b8cb0bd67233d4b3a876fc1b4548d57900ce0d59","modified":1532523125883},{"_id":"public/tags/Data-Structures/index.html","hash":"09de39e6f28001612931ccdee064d18843a747d4","modified":1532523125883},{"_id":"public/tags/网络/index.html","hash":"90981a1b3dcb99bf2fc3fb04f1ef9ee16dbe0950","modified":1532523125883},{"_id":"public/tags/Tesseract/index.html","hash":"3b52303e8a0339e2ece185c027d84b3640a43d51","modified":1532523125883},{"_id":"public/tags/Urllib/index.html","hash":"7cf2141eeddc2441570a84bf1c4a60758d727a34","modified":1532523125883},{"_id":"public/tags/计算机基础/index.html","hash":"4870e8b49369fa8c3761f0f5a265fa03d1890193","modified":1532523125883},{"_id":"public/tags/加密/index.html","hash":"757ae68b08c2bf6b35b47f9b9f4fda10a51b59bd","modified":1532523125884},{"_id":"public/tags/Scrapy/index.html","hash":"e65800aae9e1cfe176005d3822c567c406edbb3b","modified":1532523125884},{"_id":"public/CNAME","hash":"5db3e3c11d5692cb4315e39fb27af311a14cb878","modified":1532523125891},{"_id":"public/README.md","hash":"3535b5914786d3308f3b3d0b16d5de9d19fa9424","modified":1532523125891},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1532523125891},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1532523125891},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1532523125891},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1532523125891},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1532523125891},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1532523125891},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1532523125891},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1532523125891},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1532523125891},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1532523125891},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1532523125891},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1532523125891},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1532523125892},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1532523125892},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1532523125892},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1532523125892},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1532523125892},{"_id":"public/uploads/avatar.jpg","hash":"486f26a392d7783a3e9ac1a81ddecbde060f47e5","modified":1532523125892},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1532523125892},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1532523125892},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1532523125892},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1532523125892},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1532523125892},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1532523125892},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1532523125892},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1532523125892},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1532523125892},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1532523125892},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1532523125893},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1532523125893},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1532523125893},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1532523125893},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1532523125893},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1532523125893},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1532523126656},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1532523126661},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1532523126677},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1532523126677},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1532523126678},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1532523126678},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1532523126678},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1532523126678},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1532523126678},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1532523126678},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1532523126678},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1532523126678},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1532523126678},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1532523126678},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1532523126678},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1532523126678},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1532523126678},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1532523126679},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1532523126679},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1532523126679},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1532523126679},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1532523126679},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1532523126679},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1532523126679},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1532523126679},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1532523126679},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1532523126679},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1532523126679},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1532523126679},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1532523126679},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1532523126679},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1532523126679},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1532523126679},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1532523126680},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1532523126680},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1532523126680},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1532523126680},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1532523126680},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1532523126680},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1532523126680},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1532523126680},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1532523126680},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1532523126680},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1532523126680},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1532523126680},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1532523126680},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1532523126680},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1532523126680},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1532523126680},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1532523126680},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1532523126681},{"_id":"public/css/main.css","hash":"bda09044ed08f96c9cdd12f09acb5f04827eec42","modified":1532523126681},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1532523126681},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1532523126681},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1532523126681},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1532523126681},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1532523126681},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1532523126681},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1532523126681},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1532523126681},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1532523126681},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1532523126681},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1532523126681},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1532523126681},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1532523126681},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1532523126681},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1532523126681},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1532523126681},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1532523126682},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1532523126682},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1532523126682},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1532523126682},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1532523126682},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1532523126682},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1532523126682},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1532523126822}],"Category":[{"name":"Python3 进阶","_id":"cjk14ozjq00078motq1gluzpk"},{"name":"Django","_id":"cjk14ozjv000d8motm0c0y42k"},{"name":"Hexo","_id":"cjk14ozk6000n8motnwneek62"},{"name":"Frontend","_id":"cjk14ozk9000u8motc4ty2yex"},{"name":"操作系统","_id":"cjk14ozkj001d8motqsd5vrg8"},{"name":"Linux/Mac OS","_id":"cjk14ozkn001n8motnjtxcvwu"},{"name":"Markdown","_id":"cjk14ozl7002g8mot2ku9ltie"},{"name":"Python3 闭包","parent":"cjk14ozjq00078motq1gluzpk","_id":"cjk14ozla002p8mott910z7tk"},{"name":"Staticmethod & Classmethod","parent":"cjk14ozjq00078motq1gluzpk","_id":"cjk14ozlf002x8motctpcbv3v"},{"name":"多任务处理","parent":"cjk14ozkj001d8motqsd5vrg8","_id":"cjk14ozll00378motoeqk66j8"},{"name":"Python3 作用域","parent":"cjk14ozjq00078motq1gluzpk","_id":"cjk14ozlp003f8mot90brewg7"},{"name":"Spider","_id":"cjk14ozls003o8motav8zorcc"},{"name":"Python3 virtualenv","parent":"cjk14ozjq00078motq1gluzpk","_id":"cjk14ozly003w8mot04di4o2z"},{"name":"Python3 重载","parent":"cjk14ozjq00078motq1gluzpk","_id":"cjk14ozm200468motn2b096if"},{"name":"Python3 下划线","parent":"cjk14ozjq00078motq1gluzpk","_id":"cjk14ozm6004e8motorm9f7z7"},{"name":"Algorithm","_id":"cjk14ozma004n8motc8bcsd6z"},{"name":"Data Structures","_id":"cjk14ozmd004v8motl85ik1bv"},{"name":"Python3 拷贝对象","parent":"cjk14ozjq00078motq1gluzpk","_id":"cjk14ozn300688moti96xdj5e"},{"name":"Python3 True or False","parent":"cjk14ozjq00078motq1gluzpk","_id":"cjk14ozn9006h8motjhimgsk5"},{"name":"类变量 和 实例变量","parent":"cjk14ozjq00078motq1gluzpk","_id":"cjk14oznd006p8motrd1a25nf"},{"name":"Selenium","parent":"cjk14ozls003o8motav8zorcc","_id":"cjk14oznj006y8mot974rij2g"},{"name":"Python3 自省","parent":"cjk14ozjq00078motq1gluzpk","_id":"cjk14ozno00778motba4cz9zf"},{"name":"Python3 字典","parent":"cjk14ozjq00078motq1gluzpk","_id":"cjk14ozns007f8motcof8nmb1"},{"name":"Python3 鸭子类型","parent":"cjk14ozjq00078motq1gluzpk","_id":"cjk14oznu007n8motgded839r"},{"name":"网络","_id":"cjk14oznv007t8motunnf17fe"},{"name":"Tesseract","_id":"cjk14ozny007z8moto5lnfyvz"},{"name":"Python3 数据结构","parent":"cjk14ozjq00078motq1gluzpk","_id":"cjk14oznz00858motee1mngl0"},{"name":"Python3 迭代器和生成器","parent":"cjk14ozjq00078motq1gluzpk","_id":"cjk14ozo1008d8mot5h3mo1ym"},{"name":"Git","_id":"cjk14ozo5008p8motsnihxbdm"},{"name":"Urllib","parent":"cjk14ozls003o8motav8zorcc","_id":"cjk14ozoc00968motozkx5m8p"},{"name":"Scrapy","parent":"cjk14ozls003o8motav8zorcc","_id":"cjk14ozop00ab8motrff2g4ac"}],"Data":[],"Page":[{"title":"About","date":"2018-02-27T10:04:16.000Z","_content":"\n从学习涉及上千摄氏度的热能专业到研究2K超流氦极低温区的制冷及低温工程，最后竟然成了一个程序猿，简直不相信这是我寄几。\n","source":"about/index.md","raw":"---\ntitle: About\ndate: 2018-02-27 18:04:16\n---\n\n从学习涉及上千摄氏度的热能专业到研究2K超流氦极低温区的制冷及低温工程，最后竟然成了一个程序猿，简直不相信这是我寄几。\n","updated":"2018-05-06T05:06:28.585Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjk14ozdl00008motneog8xo9","content":"<p>从学习涉及上千摄氏度的热能专业到研究2K超流氦极低温区的制冷及低温工程，最后竟然成了一个程序猿，简直不相信这是我寄几。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>从学习涉及上千摄氏度的热能专业到研究2K超流氦极低温区的制冷及低温工程，最后竟然成了一个程序猿，简直不相信这是我寄几。</p>\n"},{"title":"分类","date":"2018-02-26T07:16:43.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2018-02-26 15:16:43\ntype: \"categories\"\n---\n","updated":"2018-02-27T10:50:06.227Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjk14ozdo00018motf3cksfx9","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2018-02-26T07:13:29.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2018-02-26 15:13:29\ntype: \"tags\"\n---\n","updated":"2018-02-27T10:50:23.228Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjk14ozji00038motd625xrog","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Apache和Nginx的对比","date":"2018-03-07T18:11:57.000Z","_content":"## Apache\n\n1. apache 的 rewrite 比 nginx 强大，在 rewrite 频繁的情况下，用 apache\n2. apache 发展到现在，模块超多，基本想到的都可以找到\n3. apache 更为成熟，少 bug ，nginx 的 bug 相对较多\n4. apache 超稳定\n5. apache 对 PHP 支持比较简单，nginx 需要配合其他后端用\n6. apache 在处理动态请求有优势，nginx 在这方面是鸡肋，一般动态请求要 apache 去做，nginx 适合静态和反向。\n7. apache 仍然是目前的主流，拥有丰富的特性，成熟的技术和开发社区\n\n<!-- more -->\n\n## Nginx\n\n1. 轻量级，采用 C 进行编写，同样的 web 服务，会占用更少的内存及资源\n2. 抗并发，nginx 以 epoll and kqueue 作为开发模型，处理请求是异步非阻塞的，负载能力比 apache 高很多，而 apache 则是阻塞型的。在高并发下 nginx 能保持低资源低消耗高性能 ，而 apache 在 PHP 处理慢或者前端压力很大的情况下，很容易出现进程数飙升，从而拒绝服务的现象。\n3. nginx 处理静态文件好，静态处理性能比 apache 高三倍以上\n4. nginx 的设计高度模块化，编写模块相对简单\n5. nginx 配置简洁，正则配置让很多事情变得简单，而且改完配置能使用 -t 测试配置有没有问题，apache 配置复杂 ，重启的时候发现配置出错了，会很崩溃\n6. nginx 作为负载均衡服务器，支持 7 层负载均衡\n7. nginx 本身就是一个反向代理服务器，而且可以作为非常优秀的邮件代理服务器\n8. 启动特别容易, 并且几乎可以做到 7*24 不间断运行，即使运行数个月也不需要重新启动，还能够不间断服务的情况下进行软件版本的升级\n9. 社区活跃，各种高性能模块出品迅速\n\n## 总结\n\nnginx 相对 apache 的优点：\n\n  * 轻量级，同样起web 服务，比apache 占用更少的内存及资源\n  * 抗并发，`nginx 处理请求是异步非阻塞的`，支持更多的并发连接，而`apache 则是阻塞型的`，在高并发下nginx 能保持低资源低消耗高性能\n  * 配置简洁\n  * 高度模块化的设计，编写模块相对简单\n  * 社区活跃\n\napache 相对nginx 的优点：\n\n  * rewrite ，比nginx 的rewrite 强大\n  * 模块超多，基本想到的都可以找到\n  * 少bug ，nginx 的bug 相对较多\n  * 超稳定\n\n两者最核心的区别在于 `apache 是同步多进程模型，一个连接对应一个进程`，而 `nginx 是异步的，多个连接（万级别）可以对应一个进程`\n\n一般来说，需要性能的 web 服务，用 nginx 。如果不需要性能只求稳定，更考虑 apache ，后者的各种功能模块实现得比前者，例如 ssl 的模块就比前者好，可配置项多。epoll(freebsd 上是 kqueue ) 网络 IO 模型是 nginx 处理性能高的根本理由，但并不是所有的情况下都是 epoll 大获全胜的，如果本身提供静态服务的就只有寥寥几个文件，apache 的 select 模型或许比 epoll 更高性能。当然，这只是根据网络 IO 模型的原理作的一个假设，真正的应用还是需要实测了再说的。\n\n更为通用的方案是，前端 nginx 抗并发，后端 apache 集群，配合起来会更好。\n","source":"_posts/Apache和Nginx的对比.md","raw":"---\ntitle: Apache和Nginx的对比\ndate: 2018-03-08 02:11:57\ntags:\n  - Web服务器\n---\n## Apache\n\n1. apache 的 rewrite 比 nginx 强大，在 rewrite 频繁的情况下，用 apache\n2. apache 发展到现在，模块超多，基本想到的都可以找到\n3. apache 更为成熟，少 bug ，nginx 的 bug 相对较多\n4. apache 超稳定\n5. apache 对 PHP 支持比较简单，nginx 需要配合其他后端用\n6. apache 在处理动态请求有优势，nginx 在这方面是鸡肋，一般动态请求要 apache 去做，nginx 适合静态和反向。\n7. apache 仍然是目前的主流，拥有丰富的特性，成熟的技术和开发社区\n\n<!-- more -->\n\n## Nginx\n\n1. 轻量级，采用 C 进行编写，同样的 web 服务，会占用更少的内存及资源\n2. 抗并发，nginx 以 epoll and kqueue 作为开发模型，处理请求是异步非阻塞的，负载能力比 apache 高很多，而 apache 则是阻塞型的。在高并发下 nginx 能保持低资源低消耗高性能 ，而 apache 在 PHP 处理慢或者前端压力很大的情况下，很容易出现进程数飙升，从而拒绝服务的现象。\n3. nginx 处理静态文件好，静态处理性能比 apache 高三倍以上\n4. nginx 的设计高度模块化，编写模块相对简单\n5. nginx 配置简洁，正则配置让很多事情变得简单，而且改完配置能使用 -t 测试配置有没有问题，apache 配置复杂 ，重启的时候发现配置出错了，会很崩溃\n6. nginx 作为负载均衡服务器，支持 7 层负载均衡\n7. nginx 本身就是一个反向代理服务器，而且可以作为非常优秀的邮件代理服务器\n8. 启动特别容易, 并且几乎可以做到 7*24 不间断运行，即使运行数个月也不需要重新启动，还能够不间断服务的情况下进行软件版本的升级\n9. 社区活跃，各种高性能模块出品迅速\n\n## 总结\n\nnginx 相对 apache 的优点：\n\n  * 轻量级，同样起web 服务，比apache 占用更少的内存及资源\n  * 抗并发，`nginx 处理请求是异步非阻塞的`，支持更多的并发连接，而`apache 则是阻塞型的`，在高并发下nginx 能保持低资源低消耗高性能\n  * 配置简洁\n  * 高度模块化的设计，编写模块相对简单\n  * 社区活跃\n\napache 相对nginx 的优点：\n\n  * rewrite ，比nginx 的rewrite 强大\n  * 模块超多，基本想到的都可以找到\n  * 少bug ，nginx 的bug 相对较多\n  * 超稳定\n\n两者最核心的区别在于 `apache 是同步多进程模型，一个连接对应一个进程`，而 `nginx 是异步的，多个连接（万级别）可以对应一个进程`\n\n一般来说，需要性能的 web 服务，用 nginx 。如果不需要性能只求稳定，更考虑 apache ，后者的各种功能模块实现得比前者，例如 ssl 的模块就比前者好，可配置项多。epoll(freebsd 上是 kqueue ) 网络 IO 模型是 nginx 处理性能高的根本理由，但并不是所有的情况下都是 epoll 大获全胜的，如果本身提供静态服务的就只有寥寥几个文件，apache 的 select 模型或许比 epoll 更高性能。当然，这只是根据网络 IO 模型的原理作的一个假设，真正的应用还是需要实测了再说的。\n\n更为通用的方案是，前端 nginx 抗并发，后端 apache 集群，配合起来会更好。\n","slug":"Apache和Nginx的对比","published":1,"updated":"2018-03-07T18:31:50.268Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozje00028motb6jf1qb7","content":"<h2 id=\"Apache\"><a href=\"#Apache\" class=\"headerlink\" title=\"Apache\"></a>Apache</h2><ol>\n<li>apache 的 rewrite 比 nginx 强大，在 rewrite 频繁的情况下，用 apache</li>\n<li>apache 发展到现在，模块超多，基本想到的都可以找到</li>\n<li>apache 更为成熟，少 bug ，nginx 的 bug 相对较多</li>\n<li>apache 超稳定</li>\n<li>apache 对 PHP 支持比较简单，nginx 需要配合其他后端用</li>\n<li>apache 在处理动态请求有优势，nginx 在这方面是鸡肋，一般动态请求要 apache 去做，nginx 适合静态和反向。</li>\n<li>apache 仍然是目前的主流，拥有丰富的特性，成熟的技术和开发社区</li>\n</ol>\n<a id=\"more\"></a>\n<h2 id=\"Nginx\"><a href=\"#Nginx\" class=\"headerlink\" title=\"Nginx\"></a>Nginx</h2><ol>\n<li>轻量级，采用 C 进行编写，同样的 web 服务，会占用更少的内存及资源</li>\n<li>抗并发，nginx 以 epoll and kqueue 作为开发模型，处理请求是异步非阻塞的，负载能力比 apache 高很多，而 apache 则是阻塞型的。在高并发下 nginx 能保持低资源低消耗高性能 ，而 apache 在 PHP 处理慢或者前端压力很大的情况下，很容易出现进程数飙升，从而拒绝服务的现象。</li>\n<li>nginx 处理静态文件好，静态处理性能比 apache 高三倍以上</li>\n<li>nginx 的设计高度模块化，编写模块相对简单</li>\n<li>nginx 配置简洁，正则配置让很多事情变得简单，而且改完配置能使用 -t 测试配置有没有问题，apache 配置复杂 ，重启的时候发现配置出错了，会很崩溃</li>\n<li>nginx 作为负载均衡服务器，支持 7 层负载均衡</li>\n<li>nginx 本身就是一个反向代理服务器，而且可以作为非常优秀的邮件代理服务器</li>\n<li>启动特别容易, 并且几乎可以做到 7*24 不间断运行，即使运行数个月也不需要重新启动，还能够不间断服务的情况下进行软件版本的升级</li>\n<li>社区活跃，各种高性能模块出品迅速</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>nginx 相对 apache 的优点：</p>\n<ul>\n<li>轻量级，同样起web 服务，比apache 占用更少的内存及资源</li>\n<li>抗并发，<code>nginx 处理请求是异步非阻塞的</code>，支持更多的并发连接，而<code>apache 则是阻塞型的</code>，在高并发下nginx 能保持低资源低消耗高性能</li>\n<li>配置简洁</li>\n<li>高度模块化的设计，编写模块相对简单</li>\n<li>社区活跃</li>\n</ul>\n<p>apache 相对nginx 的优点：</p>\n<ul>\n<li>rewrite ，比nginx 的rewrite 强大</li>\n<li>模块超多，基本想到的都可以找到</li>\n<li>少bug ，nginx 的bug 相对较多</li>\n<li>超稳定</li>\n</ul>\n<p>两者最核心的区别在于 <code>apache 是同步多进程模型，一个连接对应一个进程</code>，而 <code>nginx 是异步的，多个连接（万级别）可以对应一个进程</code></p>\n<p>一般来说，需要性能的 web 服务，用 nginx 。如果不需要性能只求稳定，更考虑 apache ，后者的各种功能模块实现得比前者，例如 ssl 的模块就比前者好，可配置项多。epoll(freebsd 上是 kqueue ) 网络 IO 模型是 nginx 处理性能高的根本理由，但并不是所有的情况下都是 epoll 大获全胜的，如果本身提供静态服务的就只有寥寥几个文件，apache 的 select 模型或许比 epoll 更高性能。当然，这只是根据网络 IO 模型的原理作的一个假设，真正的应用还是需要实测了再说的。</p>\n<p>更为通用的方案是，前端 nginx 抗并发，后端 apache 集群，配合起来会更好。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Apache\"><a href=\"#Apache\" class=\"headerlink\" title=\"Apache\"></a>Apache</h2><ol>\n<li>apache 的 rewrite 比 nginx 强大，在 rewrite 频繁的情况下，用 apache</li>\n<li>apache 发展到现在，模块超多，基本想到的都可以找到</li>\n<li>apache 更为成熟，少 bug ，nginx 的 bug 相对较多</li>\n<li>apache 超稳定</li>\n<li>apache 对 PHP 支持比较简单，nginx 需要配合其他后端用</li>\n<li>apache 在处理动态请求有优势，nginx 在这方面是鸡肋，一般动态请求要 apache 去做，nginx 适合静态和反向。</li>\n<li>apache 仍然是目前的主流，拥有丰富的特性，成熟的技术和开发社区</li>\n</ol>","more":"<h2 id=\"Nginx\"><a href=\"#Nginx\" class=\"headerlink\" title=\"Nginx\"></a>Nginx</h2><ol>\n<li>轻量级，采用 C 进行编写，同样的 web 服务，会占用更少的内存及资源</li>\n<li>抗并发，nginx 以 epoll and kqueue 作为开发模型，处理请求是异步非阻塞的，负载能力比 apache 高很多，而 apache 则是阻塞型的。在高并发下 nginx 能保持低资源低消耗高性能 ，而 apache 在 PHP 处理慢或者前端压力很大的情况下，很容易出现进程数飙升，从而拒绝服务的现象。</li>\n<li>nginx 处理静态文件好，静态处理性能比 apache 高三倍以上</li>\n<li>nginx 的设计高度模块化，编写模块相对简单</li>\n<li>nginx 配置简洁，正则配置让很多事情变得简单，而且改完配置能使用 -t 测试配置有没有问题，apache 配置复杂 ，重启的时候发现配置出错了，会很崩溃</li>\n<li>nginx 作为负载均衡服务器，支持 7 层负载均衡</li>\n<li>nginx 本身就是一个反向代理服务器，而且可以作为非常优秀的邮件代理服务器</li>\n<li>启动特别容易, 并且几乎可以做到 7*24 不间断运行，即使运行数个月也不需要重新启动，还能够不间断服务的情况下进行软件版本的升级</li>\n<li>社区活跃，各种高性能模块出品迅速</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>nginx 相对 apache 的优点：</p>\n<ul>\n<li>轻量级，同样起web 服务，比apache 占用更少的内存及资源</li>\n<li>抗并发，<code>nginx 处理请求是异步非阻塞的</code>，支持更多的并发连接，而<code>apache 则是阻塞型的</code>，在高并发下nginx 能保持低资源低消耗高性能</li>\n<li>配置简洁</li>\n<li>高度模块化的设计，编写模块相对简单</li>\n<li>社区活跃</li>\n</ul>\n<p>apache 相对nginx 的优点：</p>\n<ul>\n<li>rewrite ，比nginx 的rewrite 强大</li>\n<li>模块超多，基本想到的都可以找到</li>\n<li>少bug ，nginx 的bug 相对较多</li>\n<li>超稳定</li>\n</ul>\n<p>两者最核心的区别在于 <code>apache 是同步多进程模型，一个连接对应一个进程</code>，而 <code>nginx 是异步的，多个连接（万级别）可以对应一个进程</code></p>\n<p>一般来说，需要性能的 web 服务，用 nginx 。如果不需要性能只求稳定，更考虑 apache ，后者的各种功能模块实现得比前者，例如 ssl 的模块就比前者好，可配置项多。epoll(freebsd 上是 kqueue ) 网络 IO 模型是 nginx 处理性能高的根本理由，但并不是所有的情况下都是 epoll 大获全胜的，如果本身提供静态服务的就只有寥寥几个文件，apache 的 select 模型或许比 epoll 更高性能。当然，这只是根据网络 IO 模型的原理作的一个假设，真正的应用还是需要实测了再说的。</p>\n<p>更为通用的方案是，前端 nginx 抗并发，后端 apache 集群，配合起来会更好。</p>"},{"title":"Differences between `==` and `is` in Python3?---(Reprint)","date":"2018-03-28T18:47:37.000Z","_content":"\n## Source Question\nMy [Google-fu](https://english.stackexchange.com/questions/19967/what-does-google-fu-mean) has failed me.\n\nIn Python, are the following two tests for equality equivalent?\n\n```Python\nn = 5\n# Test one.\nif n == 5:\n    print 'Yay!'\n\n# Test two.\nif n is 5:\n    print 'Yay!'\n```\n\nDoes this hold true for objects where you would be comparing instances (a `list` say)?\n\nOkay, so this kind of answers my question:\n\n```python\nL = []\nL.append(1)\nif L == [1]:\n    print 'Yay!'\n# Holds true, but...\n\nif L is [1]:\n    print 'Yay!'\n# Doesn't.\n```\n\nSo `==` tests value where `is` tests to see if they are the same object?\n\n<!-- more -->\n\n\n## Answers 1\n\n`is` will return `True` if two variables point to the same object, `==` if the objects referred to by the variables are equal.\n\n```python\n>>> a = [1, 2, 3]\n>>> b = a\n>>> b is a\nTrue\n>>> b == a\nTrue\n>>> b = a[:]\n>>> b is a\nFalse\n>>> b == a\nTrue\n```\n\nIn your case, the second test only works `because Python caches small integer objects`, which is an implementation detail. For `larger integers`, this does not work:\n\n```python\n>>> 1000 is 10**3\nFalse\n>>> 1000 == 10**3\nTrue\n```\n\nThe same holds true for `string literals`:\n\n```python\n>>> \"a\" is \"a\"\nTrue\n>>> \"aa\" is \"a\" * 2\nTrue\n>>> x = \"a\"\n>>> \"aa\" is x * 2\nFalse\n>>> \"aa\" is intern(x*2)\nTrue\n```\nPlease see [this question](https://stackoverflow.com/questions/26595/is-there-any-difference-between-foo-is-none-and-foo-none) as well.\n\n## Answers 2\n\nThere is a simple rule of thumb to tell you when to use `==` or `is`.\n\n  * `==` is for _value equality_. Use it when you would like to know if two objects have the same value.\n  * `is` is for _reference equality_. Use it when you would like to know if two references refer to the same object.\n\nIn general, when you are comparing something to a simple type, you are usually checking for _value equality_, so you should use `==`. For example, the intention of your example is probably to check whether x has a value equal to 2 (`==`), not whether `x` is literally referring to the same object as 2.\n\n\nSomething else to note: because of the way the CPython reference implementation works, you'll get unexpected and inconsistent results if you mistakenly use `is` to compare for reference equality on integers:\n\n```python\n>>> a = 500\n>>> b = 500\n>>> a == b\nTrue\n>>> a is b\nFalse\n```\n\nThat's pretty much what we expected: `a` and `b` have the same value, but are distinct entities. But what about this?\n\n```python\n>>> c = 200\n>>> d = 200\n>>> c == d\nTrue\n>>> c is d\nTrue\n```\n\nThis is inconsistent with the earlier result. What's going on here? It turns out the reference implementation of Python caches integer objects in the range -5..256 as singleton instances for performance reasons. Here's an example demonstrating this:\n\n```python\n>>> for i in range(250, 260): a = i; print \"%i: %s\" % (i, a is int(str(i)));\n...\n250: True\n251: True\n252: True\n253: True\n254: True\n255: True\n256: True\n257: False\n258: False\n259: False\n```\n\nThis is another obvious reason not to use `is`: the behavior is left up to implementations when you're erroneously using it for value equality.\n\n\n## References\n\n1. [Is there a difference between `==` and `is` in Python?\n](https://stackoverflow.com/questions/132988/is-there-a-difference-between-and-is-in-python/134659#134659)\n","source":"_posts/Differences-between-and-is-in-Python3---(Reprint).md","raw":"---\ntitle: Differences between `==` and `is` in Python3?---(Reprint)\ndate: 2018-03-29 02:47:37\ntags:\n  - Python3\ncategories:\n  - Python3 进阶\n---\n\n## Source Question\nMy [Google-fu](https://english.stackexchange.com/questions/19967/what-does-google-fu-mean) has failed me.\n\nIn Python, are the following two tests for equality equivalent?\n\n```Python\nn = 5\n# Test one.\nif n == 5:\n    print 'Yay!'\n\n# Test two.\nif n is 5:\n    print 'Yay!'\n```\n\nDoes this hold true for objects where you would be comparing instances (a `list` say)?\n\nOkay, so this kind of answers my question:\n\n```python\nL = []\nL.append(1)\nif L == [1]:\n    print 'Yay!'\n# Holds true, but...\n\nif L is [1]:\n    print 'Yay!'\n# Doesn't.\n```\n\nSo `==` tests value where `is` tests to see if they are the same object?\n\n<!-- more -->\n\n\n## Answers 1\n\n`is` will return `True` if two variables point to the same object, `==` if the objects referred to by the variables are equal.\n\n```python\n>>> a = [1, 2, 3]\n>>> b = a\n>>> b is a\nTrue\n>>> b == a\nTrue\n>>> b = a[:]\n>>> b is a\nFalse\n>>> b == a\nTrue\n```\n\nIn your case, the second test only works `because Python caches small integer objects`, which is an implementation detail. For `larger integers`, this does not work:\n\n```python\n>>> 1000 is 10**3\nFalse\n>>> 1000 == 10**3\nTrue\n```\n\nThe same holds true for `string literals`:\n\n```python\n>>> \"a\" is \"a\"\nTrue\n>>> \"aa\" is \"a\" * 2\nTrue\n>>> x = \"a\"\n>>> \"aa\" is x * 2\nFalse\n>>> \"aa\" is intern(x*2)\nTrue\n```\nPlease see [this question](https://stackoverflow.com/questions/26595/is-there-any-difference-between-foo-is-none-and-foo-none) as well.\n\n## Answers 2\n\nThere is a simple rule of thumb to tell you when to use `==` or `is`.\n\n  * `==` is for _value equality_. Use it when you would like to know if two objects have the same value.\n  * `is` is for _reference equality_. Use it when you would like to know if two references refer to the same object.\n\nIn general, when you are comparing something to a simple type, you are usually checking for _value equality_, so you should use `==`. For example, the intention of your example is probably to check whether x has a value equal to 2 (`==`), not whether `x` is literally referring to the same object as 2.\n\n\nSomething else to note: because of the way the CPython reference implementation works, you'll get unexpected and inconsistent results if you mistakenly use `is` to compare for reference equality on integers:\n\n```python\n>>> a = 500\n>>> b = 500\n>>> a == b\nTrue\n>>> a is b\nFalse\n```\n\nThat's pretty much what we expected: `a` and `b` have the same value, but are distinct entities. But what about this?\n\n```python\n>>> c = 200\n>>> d = 200\n>>> c == d\nTrue\n>>> c is d\nTrue\n```\n\nThis is inconsistent with the earlier result. What's going on here? It turns out the reference implementation of Python caches integer objects in the range -5..256 as singleton instances for performance reasons. Here's an example demonstrating this:\n\n```python\n>>> for i in range(250, 260): a = i; print \"%i: %s\" % (i, a is int(str(i)));\n...\n250: True\n251: True\n252: True\n253: True\n254: True\n255: True\n256: True\n257: False\n258: False\n259: False\n```\n\nThis is another obvious reason not to use `is`: the behavior is left up to implementations when you're erroneously using it for value equality.\n\n\n## References\n\n1. [Is there a difference between `==` and `is` in Python?\n](https://stackoverflow.com/questions/132988/is-there-a-difference-between-and-is-in-python/134659#134659)\n","slug":"Differences-between-and-is-in-Python3---(Reprint)","published":1,"updated":"2018-03-28T19:25:46.867Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozjj00048motwdysh1nq","content":"<h2 id=\"Source-Question\"><a href=\"#Source-Question\" class=\"headerlink\" title=\"Source Question\"></a>Source Question</h2><p>My <a href=\"https://english.stackexchange.com/questions/19967/what-does-google-fu-mean\" target=\"_blank\" rel=\"noopener\">Google-fu</a> has failed me.</p>\n<p>In Python, are the following two tests for equality equivalent?</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n = <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"comment\"># Test one.</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> n == <span class=\"number\">5</span>:</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'Yay!'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Test two.</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> n <span class=\"keyword\">is</span> <span class=\"number\">5</span>:</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'Yay!'</span></span><br></pre></td></tr></table></figure>\n<p>Does this hold true for objects where you would be comparing instances (a <code>list</code> say)?</p>\n<p>Okay, so this kind of answers my question:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L = []</span><br><span class=\"line\">L.append(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> L == [<span class=\"number\">1</span>]:</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'Yay!'</span></span><br><span class=\"line\"><span class=\"comment\"># Holds true, but...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> L <span class=\"keyword\">is</span> [<span class=\"number\">1</span>]:</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'Yay!'</span></span><br><span class=\"line\"><span class=\"comment\"># Doesn't.</span></span><br></pre></td></tr></table></figure>\n<p>So <code>==</code> tests value where <code>is</code> tests to see if they are the same object?</p>\n<a id=\"more\"></a>\n<h2 id=\"Answers-1\"><a href=\"#Answers-1\" class=\"headerlink\" title=\"Answers 1\"></a>Answers 1</h2><p><code>is</code> will return <code>True</code> if two variables point to the same object, <code>==</code> if the objects referred to by the variables are equal.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b = a</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b <span class=\"keyword\">is</span> a</span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b == a</span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b = a[:]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b <span class=\"keyword\">is</span> a</span><br><span class=\"line\"><span class=\"keyword\">False</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b == a</span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br></pre></td></tr></table></figure>\n<p>In your case, the second test only works <code>because Python caches small integer objects</code>, which is an implementation detail. For <code>larger integers</code>, this does not work:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"number\">1000</span> <span class=\"keyword\">is</span> <span class=\"number\">10</span>**<span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"keyword\">False</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"number\">1000</span> == <span class=\"number\">10</span>**<span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br></pre></td></tr></table></figure>\n<p>The same holds true for <code>string literals</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">\"a\"</span> <span class=\"keyword\">is</span> <span class=\"string\">\"a\"</span></span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">\"aa\"</span> <span class=\"keyword\">is</span> <span class=\"string\">\"a\"</span> * <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>x = <span class=\"string\">\"a\"</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">\"aa\"</span> <span class=\"keyword\">is</span> x * <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">False</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">\"aa\"</span> <span class=\"keyword\">is</span> intern(x*<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br></pre></td></tr></table></figure>\n<p>Please see <a href=\"https://stackoverflow.com/questions/26595/is-there-any-difference-between-foo-is-none-and-foo-none\" target=\"_blank\" rel=\"noopener\">this question</a> as well.</p>\n<h2 id=\"Answers-2\"><a href=\"#Answers-2\" class=\"headerlink\" title=\"Answers 2\"></a>Answers 2</h2><p>There is a simple rule of thumb to tell you when to use <code>==</code> or <code>is</code>.</p>\n<ul>\n<li><code>==</code> is for <em>value equality</em>. Use it when you would like to know if two objects have the same value.</li>\n<li><code>is</code> is for <em>reference equality</em>. Use it when you would like to know if two references refer to the same object.</li>\n</ul>\n<p>In general, when you are comparing something to a simple type, you are usually checking for <em>value equality</em>, so you should use <code>==</code>. For example, the intention of your example is probably to check whether x has a value equal to 2 (<code>==</code>), not whether <code>x</code> is literally referring to the same object as 2.</p>\n<p>Something else to note: because of the way the CPython reference implementation works, you’ll get unexpected and inconsistent results if you mistakenly use <code>is</code> to compare for reference equality on integers:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a = <span class=\"number\">500</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b = <span class=\"number\">500</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a == b</span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a <span class=\"keyword\">is</span> b</span><br><span class=\"line\"><span class=\"keyword\">False</span></span><br></pre></td></tr></table></figure>\n<p>That’s pretty much what we expected: <code>a</code> and <code>b</code> have the same value, but are distinct entities. But what about this?</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>c = <span class=\"number\">200</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d = <span class=\"number\">200</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>c == d</span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>c <span class=\"keyword\">is</span> d</span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br></pre></td></tr></table></figure>\n<p>This is inconsistent with the earlier result. What’s going on here? It turns out the reference implementation of Python caches integer objects in the range -5..256 as singleton instances for performance reasons. Here’s an example demonstrating this:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">250</span>, <span class=\"number\">260</span>): a = i; <span class=\"keyword\">print</span> <span class=\"string\">\"%i: %s\"</span> % (i, a <span class=\"keyword\">is</span> int(str(i)));</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"number\">250</span>: <span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"number\">251</span>: <span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"number\">252</span>: <span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"number\">253</span>: <span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"number\">254</span>: <span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"number\">255</span>: <span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"number\">256</span>: <span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"number\">257</span>: <span class=\"keyword\">False</span></span><br><span class=\"line\"><span class=\"number\">258</span>: <span class=\"keyword\">False</span></span><br><span class=\"line\"><span class=\"number\">259</span>: <span class=\"keyword\">False</span></span><br></pre></td></tr></table></figure>\n<p>This is another obvious reason not to use <code>is</code>: the behavior is left up to implementations when you’re erroneously using it for value equality.</p>\n<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h2><ol>\n<li><a href=\"https://stackoverflow.com/questions/132988/is-there-a-difference-between-and-is-in-python/134659#134659\" target=\"_blank\" rel=\"noopener\">Is there a difference between <code>==</code> and <code>is</code> in Python?\n</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"Source-Question\"><a href=\"#Source-Question\" class=\"headerlink\" title=\"Source Question\"></a>Source Question</h2><p>My <a href=\"https://english.stackexchange.com/questions/19967/what-does-google-fu-mean\" target=\"_blank\" rel=\"noopener\">Google-fu</a> has failed me.</p>\n<p>In Python, are the following two tests for equality equivalent?</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n = <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"comment\"># Test one.</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> n == <span class=\"number\">5</span>:</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'Yay!'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Test two.</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> n <span class=\"keyword\">is</span> <span class=\"number\">5</span>:</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'Yay!'</span></span><br></pre></td></tr></table></figure>\n<p>Does this hold true for objects where you would be comparing instances (a <code>list</code> say)?</p>\n<p>Okay, so this kind of answers my question:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L = []</span><br><span class=\"line\">L.append(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> L == [<span class=\"number\">1</span>]:</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'Yay!'</span></span><br><span class=\"line\"><span class=\"comment\"># Holds true, but...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> L <span class=\"keyword\">is</span> [<span class=\"number\">1</span>]:</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'Yay!'</span></span><br><span class=\"line\"><span class=\"comment\"># Doesn't.</span></span><br></pre></td></tr></table></figure>\n<p>So <code>==</code> tests value where <code>is</code> tests to see if they are the same object?</p>","more":"<h2 id=\"Answers-1\"><a href=\"#Answers-1\" class=\"headerlink\" title=\"Answers 1\"></a>Answers 1</h2><p><code>is</code> will return <code>True</code> if two variables point to the same object, <code>==</code> if the objects referred to by the variables are equal.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b = a</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b <span class=\"keyword\">is</span> a</span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b == a</span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b = a[:]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b <span class=\"keyword\">is</span> a</span><br><span class=\"line\"><span class=\"keyword\">False</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b == a</span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br></pre></td></tr></table></figure>\n<p>In your case, the second test only works <code>because Python caches small integer objects</code>, which is an implementation detail. For <code>larger integers</code>, this does not work:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"number\">1000</span> <span class=\"keyword\">is</span> <span class=\"number\">10</span>**<span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"keyword\">False</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"number\">1000</span> == <span class=\"number\">10</span>**<span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br></pre></td></tr></table></figure>\n<p>The same holds true for <code>string literals</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">\"a\"</span> <span class=\"keyword\">is</span> <span class=\"string\">\"a\"</span></span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">\"aa\"</span> <span class=\"keyword\">is</span> <span class=\"string\">\"a\"</span> * <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>x = <span class=\"string\">\"a\"</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">\"aa\"</span> <span class=\"keyword\">is</span> x * <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">False</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">\"aa\"</span> <span class=\"keyword\">is</span> intern(x*<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br></pre></td></tr></table></figure>\n<p>Please see <a href=\"https://stackoverflow.com/questions/26595/is-there-any-difference-between-foo-is-none-and-foo-none\" target=\"_blank\" rel=\"noopener\">this question</a> as well.</p>\n<h2 id=\"Answers-2\"><a href=\"#Answers-2\" class=\"headerlink\" title=\"Answers 2\"></a>Answers 2</h2><p>There is a simple rule of thumb to tell you when to use <code>==</code> or <code>is</code>.</p>\n<ul>\n<li><code>==</code> is for <em>value equality</em>. Use it when you would like to know if two objects have the same value.</li>\n<li><code>is</code> is for <em>reference equality</em>. Use it when you would like to know if two references refer to the same object.</li>\n</ul>\n<p>In general, when you are comparing something to a simple type, you are usually checking for <em>value equality</em>, so you should use <code>==</code>. For example, the intention of your example is probably to check whether x has a value equal to 2 (<code>==</code>), not whether <code>x</code> is literally referring to the same object as 2.</p>\n<p>Something else to note: because of the way the CPython reference implementation works, you’ll get unexpected and inconsistent results if you mistakenly use <code>is</code> to compare for reference equality on integers:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a = <span class=\"number\">500</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b = <span class=\"number\">500</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a == b</span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a <span class=\"keyword\">is</span> b</span><br><span class=\"line\"><span class=\"keyword\">False</span></span><br></pre></td></tr></table></figure>\n<p>That’s pretty much what we expected: <code>a</code> and <code>b</code> have the same value, but are distinct entities. But what about this?</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>c = <span class=\"number\">200</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d = <span class=\"number\">200</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>c == d</span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>c <span class=\"keyword\">is</span> d</span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br></pre></td></tr></table></figure>\n<p>This is inconsistent with the earlier result. What’s going on here? It turns out the reference implementation of Python caches integer objects in the range -5..256 as singleton instances for performance reasons. Here’s an example demonstrating this:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">250</span>, <span class=\"number\">260</span>): a = i; <span class=\"keyword\">print</span> <span class=\"string\">\"%i: %s\"</span> % (i, a <span class=\"keyword\">is</span> int(str(i)));</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"number\">250</span>: <span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"number\">251</span>: <span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"number\">252</span>: <span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"number\">253</span>: <span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"number\">254</span>: <span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"number\">255</span>: <span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"number\">256</span>: <span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"number\">257</span>: <span class=\"keyword\">False</span></span><br><span class=\"line\"><span class=\"number\">258</span>: <span class=\"keyword\">False</span></span><br><span class=\"line\"><span class=\"number\">259</span>: <span class=\"keyword\">False</span></span><br></pre></td></tr></table></figure>\n<p>This is another obvious reason not to use <code>is</code>: the behavior is left up to implementations when you’re erroneously using it for value equality.</p>\n<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h2><ol>\n<li><a href=\"https://stackoverflow.com/questions/132988/is-there-a-difference-between-and-is-in-python/134659#134659\" target=\"_blank\" rel=\"noopener\">Is there a difference between <code>==</code> and <code>is</code> in Python?\n</a></li>\n</ol>"},{"title":"Django2.0.1搭建电影网站","date":"2018-02-27T05:48:44.000Z","_content":"![首页](https://school.thoughtworks.cn/bbs/assets/uploads/files/1517985555955-fireshot-capture-8-cinema-http___127.0.0.1_8000_.png)\n\n本项目已经部署到服务器，可以通过该IP查看\nhttp://59.110.221.56/\n[GitHub源代码](https://github.com/ByiProX/ThoughtWorks-Cinema)\n<!--more-->\n\n## 技术栈\n> Bootstrap 3 + Django 2.0.1 + MySQL 5.7.17 + Nginx + locust\n\n\n## 本地服务运行方法\n\n终端在venv文件夹路径下开启虚拟环境(根据自己的shell进行选择)：\n\n```python\nsource ../venv/bin/activate.fish\nsource ../venv/bin/activate\nsource ../venv/bin/activate.csh\n```\n然后执行：\n```python\npython3 TWS_Cinema/manage.py runserver\n```\n\n**如果报错**，终端进入requirements.txt所在目录，运行命令：\n```python3\npip3 install -r requirements.txt\n```\n\n然后执行：\n```python\npython3 TWS_Cinema/manage.py runserver\n```\n\n## 单元测试运行方法 ##\n在manage.py路径下终端运行\n\n```python\npython3 manage.py test\n```\n\n## 网站功能描述\n\n- 实现导航栏搜索电影，支持按年份搜索和类型搜索\n    -- 显示分类列表\n    -- 点击分类显示符合分类要求的电影\n\n- 实现搜索功能，支持按电影名称模糊搜索\n\n- 实现电影详细信息查看功能\n    -- 显示电影详细信息\n    -- 显示豆瓣 Top 5 影评\n    -- 在电影详细页面显示相似电影推荐\n    -- 增加电影观看链接\n\n## API\n\n- 按电影id搜索 —— api/movie/id/        # 例如：api/movie/id/1291545\n\n- 按电影名搜索 —— api/movie/title/     # 例如：api/movie/title/大鱼\n\n- 按电影原始名搜索 —— api/movie/original_title/     # 例如：api/movie/original_title/Big Fish\n\n- 按电影类型搜索 —— api/movie/genre/   # 例如：api/movie/genre/剧情\n\n- 按电影年份搜索 —— api/movie/year/    # 例如：api/movie/year/2003\n\n\n## 网站性能测试结果\n\n在文件locustfile.py路径下运行\n```python3\nlocust --host=http://59.110.221.56\n```\n\n### 压力测试\n* 采取的框架：**locust**\n* 服务器性能：\n    * CPU：1核\n    * 内存：2 GB (I/O优化)\n    * 带宽：1Mbps\n* 测试结果：\n    * 500人：100%正确\n    * 1000人：40%出错率\n* 测试截图\n\n\n\n![Screen Shot 2018-02-08 at 16.15.49.png](http://upload-images.jianshu.io/upload_images/2952111-4c41c64c40130ebe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![Screen Shot 2018-02-08 at 16.14.10.png](http://upload-images.jianshu.io/upload_images/2952111-c2c542dbf0ce9e58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![Screen Shot 2018-02-08 at 16.13.49.png](http://upload-images.jianshu.io/upload_images/2952111-f5e4ace67f22ddac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n## 电影网站的其他截图\n\n![list](https://school.thoughtworks.cn/bbs/assets/uploads/files/1517985569003-fireshot-capture-9-%E9%A6%96%E9%A1%B5-http___127.0.0.1_8000_movie_display_.png)\n![detail](https://school.thoughtworks.cn/bbs/assets/uploads/files/1517985586166-fireshot-capture-10-%E7%94%B5%E5%BD%B1%E8%AF%A6%E6%83%85-http___127.0.0.1_8000_movie_id_1291545_.png)\n\n\n## Reference\n\n[Locust 简介以及使用](https://my.oschina.net/u/1447352/blog/1499428/)\n","source":"_posts/Django2-0-1搭建电影网站.md","raw":"---\ntitle: Django2.0.1搭建电影网站\ndate: 2018-02-27 13:48:44\ntags:\n  - Django\n  - Python3\ncategories:\n  - Django\n---\n![首页](https://school.thoughtworks.cn/bbs/assets/uploads/files/1517985555955-fireshot-capture-8-cinema-http___127.0.0.1_8000_.png)\n\n本项目已经部署到服务器，可以通过该IP查看\nhttp://59.110.221.56/\n[GitHub源代码](https://github.com/ByiProX/ThoughtWorks-Cinema)\n<!--more-->\n\n## 技术栈\n> Bootstrap 3 + Django 2.0.1 + MySQL 5.7.17 + Nginx + locust\n\n\n## 本地服务运行方法\n\n终端在venv文件夹路径下开启虚拟环境(根据自己的shell进行选择)：\n\n```python\nsource ../venv/bin/activate.fish\nsource ../venv/bin/activate\nsource ../venv/bin/activate.csh\n```\n然后执行：\n```python\npython3 TWS_Cinema/manage.py runserver\n```\n\n**如果报错**，终端进入requirements.txt所在目录，运行命令：\n```python3\npip3 install -r requirements.txt\n```\n\n然后执行：\n```python\npython3 TWS_Cinema/manage.py runserver\n```\n\n## 单元测试运行方法 ##\n在manage.py路径下终端运行\n\n```python\npython3 manage.py test\n```\n\n## 网站功能描述\n\n- 实现导航栏搜索电影，支持按年份搜索和类型搜索\n    -- 显示分类列表\n    -- 点击分类显示符合分类要求的电影\n\n- 实现搜索功能，支持按电影名称模糊搜索\n\n- 实现电影详细信息查看功能\n    -- 显示电影详细信息\n    -- 显示豆瓣 Top 5 影评\n    -- 在电影详细页面显示相似电影推荐\n    -- 增加电影观看链接\n\n## API\n\n- 按电影id搜索 —— api/movie/id/        # 例如：api/movie/id/1291545\n\n- 按电影名搜索 —— api/movie/title/     # 例如：api/movie/title/大鱼\n\n- 按电影原始名搜索 —— api/movie/original_title/     # 例如：api/movie/original_title/Big Fish\n\n- 按电影类型搜索 —— api/movie/genre/   # 例如：api/movie/genre/剧情\n\n- 按电影年份搜索 —— api/movie/year/    # 例如：api/movie/year/2003\n\n\n## 网站性能测试结果\n\n在文件locustfile.py路径下运行\n```python3\nlocust --host=http://59.110.221.56\n```\n\n### 压力测试\n* 采取的框架：**locust**\n* 服务器性能：\n    * CPU：1核\n    * 内存：2 GB (I/O优化)\n    * 带宽：1Mbps\n* 测试结果：\n    * 500人：100%正确\n    * 1000人：40%出错率\n* 测试截图\n\n\n\n![Screen Shot 2018-02-08 at 16.15.49.png](http://upload-images.jianshu.io/upload_images/2952111-4c41c64c40130ebe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![Screen Shot 2018-02-08 at 16.14.10.png](http://upload-images.jianshu.io/upload_images/2952111-c2c542dbf0ce9e58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![Screen Shot 2018-02-08 at 16.13.49.png](http://upload-images.jianshu.io/upload_images/2952111-f5e4ace67f22ddac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n## 电影网站的其他截图\n\n![list](https://school.thoughtworks.cn/bbs/assets/uploads/files/1517985569003-fireshot-capture-9-%E9%A6%96%E9%A1%B5-http___127.0.0.1_8000_movie_display_.png)\n![detail](https://school.thoughtworks.cn/bbs/assets/uploads/files/1517985586166-fireshot-capture-10-%E7%94%B5%E5%BD%B1%E8%AF%A6%E6%83%85-http___127.0.0.1_8000_movie_id_1291545_.png)\n\n\n## Reference\n\n[Locust 简介以及使用](https://my.oschina.net/u/1447352/blog/1499428/)\n","slug":"Django2-0-1搭建电影网站","published":1,"updated":"2018-02-27T06:41:59.694Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozjo00068motsp4ev1qz","content":"<p><img src=\"https://school.thoughtworks.cn/bbs/assets/uploads/files/1517985555955-fireshot-capture-8-cinema-http___127.0.0.1_8000_.png\" alt=\"首页\"></p>\n<p>本项目已经部署到服务器，可以通过该IP查看<br><a href=\"http://59.110.221.56/\" target=\"_blank\" rel=\"noopener\">http://59.110.221.56/</a><br><a href=\"https://github.com/ByiProX/ThoughtWorks-Cinema\" target=\"_blank\" rel=\"noopener\">GitHub源代码</a><br><a id=\"more\"></a></p>\n<h2 id=\"技术栈\"><a href=\"#技术栈\" class=\"headerlink\" title=\"技术栈\"></a>技术栈</h2><blockquote>\n<p>Bootstrap 3 + Django 2.0.1 + MySQL 5.7.17 + Nginx + locust</p>\n</blockquote>\n<h2 id=\"本地服务运行方法\"><a href=\"#本地服务运行方法\" class=\"headerlink\" title=\"本地服务运行方法\"></a>本地服务运行方法</h2><p>终端在venv文件夹路径下开启虚拟环境(根据自己的shell进行选择)：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source ../venv/bin/activate.fish</span><br><span class=\"line\">source ../venv/bin/activate</span><br><span class=\"line\">source ../venv/bin/activate.csh</span><br></pre></td></tr></table></figure>\n<p>然后执行：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python3 TWS_Cinema/manage.py runserver</span><br></pre></td></tr></table></figure></p>\n<p><strong>如果报错</strong>，终端进入requirements.txt所在目录，运行命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip3 install -r requirements.txt</span><br></pre></td></tr></table></figure></p>\n<p>然后执行：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python3 TWS_Cinema/manage.py runserver</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"单元测试运行方法\"><a href=\"#单元测试运行方法\" class=\"headerlink\" title=\"单元测试运行方法\"></a>单元测试运行方法</h2><p>在manage.py路径下终端运行</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python3 manage.py test</span><br></pre></td></tr></table></figure>\n<h2 id=\"网站功能描述\"><a href=\"#网站功能描述\" class=\"headerlink\" title=\"网站功能描述\"></a>网站功能描述</h2><ul>\n<li><p>实现导航栏搜索电影，支持按年份搜索和类型搜索<br>  – 显示分类列表<br>  – 点击分类显示符合分类要求的电影</p>\n</li>\n<li><p>实现搜索功能，支持按电影名称模糊搜索</p>\n</li>\n<li><p>实现电影详细信息查看功能<br>  – 显示电影详细信息<br>  – 显示豆瓣 Top 5 影评<br>  – 在电影详细页面显示相似电影推荐<br>  – 增加电影观看链接</p>\n</li>\n</ul>\n<h2 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h2><ul>\n<li><p>按电影id搜索 —— api/movie/id/        # 例如：api/movie/id/1291545</p>\n</li>\n<li><p>按电影名搜索 —— api/movie/title/     # 例如：api/movie/title/大鱼</p>\n</li>\n<li><p>按电影原始名搜索 —— api/movie/original_title/     # 例如：api/movie/original_title/Big Fish</p>\n</li>\n<li><p>按电影类型搜索 —— api/movie/genre/   # 例如：api/movie/genre/剧情</p>\n</li>\n<li><p>按电影年份搜索 —— api/movie/year/    # 例如：api/movie/year/2003</p>\n</li>\n</ul>\n<h2 id=\"网站性能测试结果\"><a href=\"#网站性能测试结果\" class=\"headerlink\" title=\"网站性能测试结果\"></a>网站性能测试结果</h2><p>在文件locustfile.py路径下运行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">locust --host=http://59.110.221.56</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"压力测试\"><a href=\"#压力测试\" class=\"headerlink\" title=\"压力测试\"></a>压力测试</h3><ul>\n<li>采取的框架：<strong>locust</strong></li>\n<li>服务器性能：<ul>\n<li>CPU：1核</li>\n<li>内存：2 GB (I/O优化)</li>\n<li>带宽：1Mbps</li>\n</ul>\n</li>\n<li>测试结果：<ul>\n<li>500人：100%正确</li>\n<li>1000人：40%出错率</li>\n</ul>\n</li>\n<li>测试截图</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-4c41c64c40130ebe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Screen Shot 2018-02-08 at 16.15.49.png\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-c2c542dbf0ce9e58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Screen Shot 2018-02-08 at 16.14.10.png\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-f5e4ace67f22ddac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Screen Shot 2018-02-08 at 16.13.49.png\"></p>\n<h2 id=\"电影网站的其他截图\"><a href=\"#电影网站的其他截图\" class=\"headerlink\" title=\"电影网站的其他截图\"></a>电影网站的其他截图</h2><p><img src=\"https://school.thoughtworks.cn/bbs/assets/uploads/files/1517985569003-fireshot-capture-9-%E9%A6%96%E9%A1%B5-http___127.0.0.1_8000_movie_display_.png\" alt=\"list\"><br><img src=\"https://school.thoughtworks.cn/bbs/assets/uploads/files/1517985586166-fireshot-capture-10-%E7%94%B5%E5%BD%B1%E8%AF%A6%E6%83%85-http___127.0.0.1_8000_movie_id_1291545_.png\" alt=\"detail\"></p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://my.oschina.net/u/1447352/blog/1499428/\" target=\"_blank\" rel=\"noopener\">Locust 简介以及使用</a></p>\n","site":{"data":{}},"excerpt":"<p><img src=\"https://school.thoughtworks.cn/bbs/assets/uploads/files/1517985555955-fireshot-capture-8-cinema-http___127.0.0.1_8000_.png\" alt=\"首页\"></p>\n<p>本项目已经部署到服务器，可以通过该IP查看<br><a href=\"http://59.110.221.56/\" target=\"_blank\" rel=\"noopener\">http://59.110.221.56/</a><br><a href=\"https://github.com/ByiProX/ThoughtWorks-Cinema\" target=\"_blank\" rel=\"noopener\">GitHub源代码</a><br>","more":"</p>\n<h2 id=\"技术栈\"><a href=\"#技术栈\" class=\"headerlink\" title=\"技术栈\"></a>技术栈</h2><blockquote>\n<p>Bootstrap 3 + Django 2.0.1 + MySQL 5.7.17 + Nginx + locust</p>\n</blockquote>\n<h2 id=\"本地服务运行方法\"><a href=\"#本地服务运行方法\" class=\"headerlink\" title=\"本地服务运行方法\"></a>本地服务运行方法</h2><p>终端在venv文件夹路径下开启虚拟环境(根据自己的shell进行选择)：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source ../venv/bin/activate.fish</span><br><span class=\"line\">source ../venv/bin/activate</span><br><span class=\"line\">source ../venv/bin/activate.csh</span><br></pre></td></tr></table></figure>\n<p>然后执行：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python3 TWS_Cinema/manage.py runserver</span><br></pre></td></tr></table></figure></p>\n<p><strong>如果报错</strong>，终端进入requirements.txt所在目录，运行命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip3 install -r requirements.txt</span><br></pre></td></tr></table></figure></p>\n<p>然后执行：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python3 TWS_Cinema/manage.py runserver</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"单元测试运行方法\"><a href=\"#单元测试运行方法\" class=\"headerlink\" title=\"单元测试运行方法\"></a>单元测试运行方法</h2><p>在manage.py路径下终端运行</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python3 manage.py test</span><br></pre></td></tr></table></figure>\n<h2 id=\"网站功能描述\"><a href=\"#网站功能描述\" class=\"headerlink\" title=\"网站功能描述\"></a>网站功能描述</h2><ul>\n<li><p>实现导航栏搜索电影，支持按年份搜索和类型搜索<br>  – 显示分类列表<br>  – 点击分类显示符合分类要求的电影</p>\n</li>\n<li><p>实现搜索功能，支持按电影名称模糊搜索</p>\n</li>\n<li><p>实现电影详细信息查看功能<br>  – 显示电影详细信息<br>  – 显示豆瓣 Top 5 影评<br>  – 在电影详细页面显示相似电影推荐<br>  – 增加电影观看链接</p>\n</li>\n</ul>\n<h2 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h2><ul>\n<li><p>按电影id搜索 —— api/movie/id/        # 例如：api/movie/id/1291545</p>\n</li>\n<li><p>按电影名搜索 —— api/movie/title/     # 例如：api/movie/title/大鱼</p>\n</li>\n<li><p>按电影原始名搜索 —— api/movie/original_title/     # 例如：api/movie/original_title/Big Fish</p>\n</li>\n<li><p>按电影类型搜索 —— api/movie/genre/   # 例如：api/movie/genre/剧情</p>\n</li>\n<li><p>按电影年份搜索 —— api/movie/year/    # 例如：api/movie/year/2003</p>\n</li>\n</ul>\n<h2 id=\"网站性能测试结果\"><a href=\"#网站性能测试结果\" class=\"headerlink\" title=\"网站性能测试结果\"></a>网站性能测试结果</h2><p>在文件locustfile.py路径下运行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">locust --host=http://59.110.221.56</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"压力测试\"><a href=\"#压力测试\" class=\"headerlink\" title=\"压力测试\"></a>压力测试</h3><ul>\n<li>采取的框架：<strong>locust</strong></li>\n<li>服务器性能：<ul>\n<li>CPU：1核</li>\n<li>内存：2 GB (I/O优化)</li>\n<li>带宽：1Mbps</li>\n</ul>\n</li>\n<li>测试结果：<ul>\n<li>500人：100%正确</li>\n<li>1000人：40%出错率</li>\n</ul>\n</li>\n<li>测试截图</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-4c41c64c40130ebe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Screen Shot 2018-02-08 at 16.15.49.png\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-c2c542dbf0ce9e58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Screen Shot 2018-02-08 at 16.14.10.png\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-f5e4ace67f22ddac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Screen Shot 2018-02-08 at 16.13.49.png\"></p>\n<h2 id=\"电影网站的其他截图\"><a href=\"#电影网站的其他截图\" class=\"headerlink\" title=\"电影网站的其他截图\"></a>电影网站的其他截图</h2><p><img src=\"https://school.thoughtworks.cn/bbs/assets/uploads/files/1517985569003-fireshot-capture-9-%E9%A6%96%E9%A1%B5-http___127.0.0.1_8000_movie_display_.png\" alt=\"list\"><br><img src=\"https://school.thoughtworks.cn/bbs/assets/uploads/files/1517985586166-fireshot-capture-10-%E7%94%B5%E5%BD%B1%E8%AF%A6%E6%83%85-http___127.0.0.1_8000_movie_id_1291545_.png\" alt=\"detail\"></p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://my.oschina.net/u/1447352/blog/1499428/\" target=\"_blank\" rel=\"noopener\">Locust 简介以及使用</a></p>"},{"title":"Django运行方式以及处理流程简介(转载)","date":"2018-03-07T11:07:58.000Z","_content":"\n## Django的运行方式\n运行Django项目的方法很多，这里主要介绍一下常用的方法。一种是在开发和调试中经常用到`runserver`方法，使用Django自己的web server(WSGI Server)；另外一种就是使用`fastcgi，uWSGIt`等协议运行Django项目。\n\n<!-- more -->\n### runserver方法\nrunserver方法是调试Django时经常用到的运行方式，它使用Django自带的WSGI Server运行，主要在测试和开发中使用，使用方法如下：\n```Python\nUsage: manage.py runserver [options] [optional port number, or ipaddr:port]\n# python manager.py runserver    # default port is 8000\n# python manager.py runserver 8080\n# python manager.py runserver 127.0.0.1:9090\n```\n看一下manager.py的源码，你会发现上面的命令其实是通过Django的execute_from_command_line方法执行了内部实现的runserver命令，那么现在看一下runserver具体做了什么。。\n\n看了源码之后，可以发现runserver命令主要做了两件事情：\n\n    1). 解析参数，并通过django.core.servers.basehttp.get_internal_wsgi_application方法获取wsgi handler;\n\n    2). 根据ip_address和port生成一个WSGIServer对象，接受用户请求\n\nget_internal_wsgi_application的源码如下：\n```python\ndef get_internal_wsgi_application():\n    \"\"\"\n    Loads and returns the WSGI application as configured by the user in\n    ``settings.WSGI_APPLICATION``. With the default ``startproject`` layout,\n    this will be the ``application`` object in ``projectname/wsgi.py``.\n\n    This function, and the ``WSGI_APPLICATION`` setting itself, are only useful\n    for Django's internal servers (runserver, runfcgi); external WSGI servers\n    should just be configured to point to the correct application object\n    directly.\n\n    If settings.WSGI_APPLICATION is not set (is ``None``), we just return\n    whatever ``django.core.wsgi.get_wsgi_application`` returns.\n\n    \"\"\"\n    from django.conf import settings\n    app_path = getattr(settings, 'WSGI_APPLICATION')\n    if app_path is None:\n        return get_wsgi_application()\n\n    return import_by_path(\n        app_path,\n        error_prefix=\"WSGI application '%s' could not be loaded; \" % app_path\n    )\n\n```\n\n通过上面的代码我们可以知道，Django会先根据settings中的WSGI_APPLICATION来获取handler；在创建project的时候，Django会默认创建一个wsgi.py文件，而settings中的WSGI_APPLICATION配置也会默认指向这个文件。看一下这个wsgi.py文件，其实它也和上面的逻辑一样，最终调用get_wsgi_application实现。\n\n## uWSGI方法\nuWSGI + Nginx的方法是现在最常见的在生产环境中运行Django的方法，要了解这种方法，首先要了解一下WSGI和uWSGI协议。\n\nWSGI，全称`Web Server Gateway Interface`，或者`Python Web Server Gateway Interface`，是为Python语言定义的Web服务器和Web应用程序或框架之间的一种简单而通用的接口，基于现存的`CGI标准`而设计的。WSGI其实就是一个网关(Gateway)，其作用就是在协议之间进行转换。(PS: 这里只对WSGI做简单介绍，想要了解更多的内容可自行搜索)\n\n`uWSGI是一个Web服务器`，它实现了WSGI协议、uwsgi、http等协议。`注意!`uwsgi是一种通信协议，而uWSGI是实现uwsgi协议和WSGI协议的Web服务器。uWSGI具有超快的性能、低内存占用和多app管理等优点。以我的博客为例，uWSGI的xml配置如下：\n\n```xml\n<uwsgi>\n    <!-- 端口 -->\n    <socket>:7600</socket>\n    <stats>:40000</stats>\n    <!-- 系统环境变量 -->\n    <env>DJANGO_SETTINGS_MODULE=geek_blog.settings</env>\n    <!-- 指定的python WSGI模块 -->\n    <module>django.core.handlers.wsgi:WSGIHandler()</module>\n    <processes>6</processes>\n    <master />\n    <master-as-root />\n    <!-- 超时设置 -->\n    <harakiri>60</harakiri>\n    <harakiri-verbose/>\n    <daemonize>/var/app/log/blog/uwsgi.log</daemonize>\n    <!-- socket的监听队列大小 -->\n    <listen>32768</listen>\n    <!-- 内部超时时间 -->\n    <socket-timeout>60</socket-timeout>\n</uwsgi>\n\n```\nuWSGI和Nginx一起使用的配置方法就不在这里说明了，网上教程很多，需要的可以自行搜索。\n\n\n## HTTP请求处理流程\nDjango和其他Web框架一样，HTTP的处理流程基本类似：接受request，返回response内容。Django的具体处理流程大致如下图所示：\n\n**1. 加载project settings**\n\n在通过django-admin.py创建project的时候，Django会自动生成默认的settings文件和manager.py等文件，在创建WSGIServer之前会执行下面的引用：\n```Python\nfrom django.conf import settings\n```\n上面引用在执行时，会读取os.environ中的DJANGO_SETTINGS_MODULE配置，加载项目配置文件，生成settings对象。所以，在manager.py文件中你可以看到，在获取WSGIServer之前，会先将project的settings路径加到os路径中。\n\n**2. 创建WSGIServer**\n\n不管是使用runserver还是uWSGI运行Django项目，在启动时都会调用django.core.servers.basehttp中的run()方法，创建一个django.core.servers.basehttp.WSGIServer类的实例，之后调用其serve_forever()方法启动HTTP服务。run方法的源码如下：\n```python\ndef run(addr, port, wsgi_handler, ipv6=False, threading=False):\n    server_address = (addr, port)\n    if threading:\n        httpd_cls = type(str('WSGIServer'), (socketserver.ThreadingMixIn, WSGIServer), {})\n    else:\n        httpd_cls = WSGIServer\n    httpd = httpd_cls(server_address, WSGIRequestHandler, ipv6=ipv6)\n    # Sets the callable application as the WSGI application that will receive requests\n    httpd.set_app(wsgi_handler)\n    httpd.serve_forever()\n\n```\n\n如上，我们可以看到：在创建WSGIServer实例的时候会指定HTTP请求的Handler，上述代码使用WSGIRequestHandler。当用户的HTTP请求到达服务器时，WSGIServer会创建WSGIRequestHandler实例，使用其handler方法来处理HTTP请求(其实最终是调用wsgiref.handlers.BaseHandler中的run方法处理)。WSGIServer通过set_app方法设置一个可调用(callable)的对象作为application，上面提到的handler方法最终会调用设置的application处理request，并返回response。\n\n其中，WSGIServer继承自wsgiref.simple_server.WSGIServer，而WSGIRequestHandler继承自wsgiref.simple_server.WSGIRequestHandler，wsgiref是Python标准库给出的WSGI的参考实现。其源码可自行到[wsgiref](https://pypi.python.org/pypi/wsgiref)参看，这里不再细说.\n\n**3. 处理Request**\n\n第二步中说到的application，在Django中一般是django.core.handlers.wsgi.WSGIHandler对象，WSGIHandler继承自django.core.handlers.base.BaseHandler，这个是Django处理request的核心逻辑，它会创建一个WSGIRequest实例，而WSGIRequest是从http.HttpRequest继承而来\n\n\n**4. 返回Response**\n\n上面提到的BaseHandler中有个get_response方法，该方法会先加载Django项目的ROOT_URLCONF，然后根据url规则找到对应的view方法(类)，view逻辑会根据request实例生成并返回具体的response。\n\n在Django返回结果之后，第二步中提到wsgiref.handlers.BaseHandler.run方法会调用finish_response结束请求，并将内容返回给用户。\n\n## Django处理Request的详细流程\n\n上述的第三步和第四步逻辑只是大致说了一下处理过程，Django在处理request的时候其实做了很多事情，下面我们详细的过一下。首先给大家分享两个网上看到的Django流程图：\n![django.png](http://upload-images.jianshu.io/upload_images/2952111-5e684abfea788d78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![django_flow.png](http://upload-images.jianshu.io/upload_images/2952111-f72ffe64a49bd4d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n上面的两张流程图可以大致描述Django处理request的流程，按照流程图2的标注，可以分为以下几个步骤：\n\n    1. 用户通过浏览器请求一个页面\n\n    2. 请求到达Request Middlewares，中间件对request做一些预处理或者直接response请求\n\n    3. URLConf通过urls.py文件和请求的URL找到相应的View\n\n    4. View Middlewares被访问，它同样可以对request做一些处理或者直接返回response\n\n    5. 调用View中的函数\n\n    6. View中的方法可以选择性的通过Models访问底层的数据\n\n    7. 所有的Model-to-DB的交互都是通过manager完成的\n\n    8. 如果需要，Views可以使用一个特殊的Context\n\n    9. Context被传给Template用来生成页面\n\n    a. Template使用Filters和Tags去渲染输出\n\n    b. 输出被返回到View\n\n    c. HTTPResponse被发送到Response Middlewares\n\n    d. 任何Response Middlewares都可以丰富response或者返回一个完全不同的response\n\n    e. Response返回到浏览器，呈现给用户\n\n上述流程中最主要的几个部分分别是：Middleware(中间件，包括request, view, exception, response)，URLConf(url映射关系)，Template(模板系统)，下面一一介绍一下。\n\n**1. Middleware(中间件)**\n\nMiddleware并不是Django所独有的东西，在其他的Web框架中也有这种概念。在Django中，Middleware可以渗入处理流程的四个阶段：request，view，response和exception，相应的，在每个Middleware类中都有rocess_request，process_view， process_response 和 process_exception这四个方法。你可以定义其中任意一个或多个方法，这取决于你希望该Middleware作用于哪个处理阶段。每个方法都可以直接返回response对象。\n\nMiddleware是在Django BaseHandler的load_middleware方法执行时加载的，加载之后会建立四个列表作为处理器的实例变量：\n```\n    _request_middleware：process_request方法的列表\n\n    _view_middleware：process_view方法的列表\n\n    _response_middleware：process_response方法的列表\n\n    _exception_middleware：process_exception方法的列表\n```\nDjango的中间件是在其配置文件(settings.py)的MIDDLEWARE_CLASSES元组中定义的。在MIDDLEWARE_CLASSES中，中间件组件用字符串表示：指向中间件类名的完整Python路径。例如GeekBlog项目的配置：\n\n```python\nMIDDLEWARE_CLASSES = (\n    'django.middleware.cache.UpdateCacheMiddleware',\n    'django.middleware.common.CommonMiddleware',\n    'django.middleware.cache.FetchFromCacheMiddleware',\n    'django.contrib.sessions.middleware.SessionMiddleware',\n    'django.middleware.csrf.CsrfViewMiddleware',\n    'django.contrib.auth.middleware.AuthenticationMiddleware',\n    'django.contrib.messages.middleware.MessageMiddleware',\n    'django.middleware.locale.LocaleMiddleware',\n    'geek_blog.middlewares.MobileDetectionMiddleware',    # 自定义的Middleware\n)\n```\nDjango项目的安装并不强制要求任何中间件，如果你愿意，MIDDLEWARE_CLASSES可以为空。中间件出现的顺序非常重要：在request和view的处理阶段，Django按照MIDDLEWARE_CLASSES中出现的顺序来应用中间件，而在response和exception异常处理阶段，Django则按逆序来调用它们。也就是说，Django将MIDDLEWARE_CLASSES视为view函数外层的顺序包装子：在request阶段按顺序从上到下穿过，而在response则反过来。\n\n以下两张图可以更好地帮助你理解：\n\n![Django Middleware流程1](http://xianglong.qiniudn.com/django_middleware_flow.png)\n\n![Django Middleware流程图2](http://xianglong.qiniudn.com/django_middleware_flow2.png)\n\n**2. URLConf(URL映射)**\n\n如果处理request的中间件都没有直接返回response，那么Django会去解析用户请求的URL。URLconf就是Django所支撑网站的目录。它的本质是URL模式以及要为该URL模式调用的视图函数之间的映射表。通过这种方式可以告诉Django，对于这个URL调用这段代码，对于那个URL调用那段代码。具体的，在Django项目的配置文件中有ROOT_URLCONF常量，这个常量加上根目录\"/\"，作为参数来创建django.core.urlresolvers.RegexURLResolver的实例，然后通过它的resolve方法解析用户请求的URL，找到第一个匹配的view。\n\n其他有关URLConf的内容，这里不再具体介绍，大家可以看[DjangoBook](http://djangobook.py3k.cn/2.0/chapter03/)了解。\n\n\n**3. Template(模板)**\n\n大部分web框架都有自己的Template(模板)系统，Django也是。但是，Django模板不同于Mako模板和jinja2模板，在Django模板不能直接写Python代码，只能通过额外的定义filter和template tag实现。由于本文主要介绍Django流程，模板内容就不过多介绍。\n\n## 参考文章：\n\n1. [uWSGI Web服务器介绍](http://www.nowamagic.net/academy/detail/1330328)  \n2. [wsgiref源码分析](http://blog.csdn.net/on_1y/article/details/18818081)  \n3. [用Python写一个简单的Web框架](http://www.tuicool.com/articles/aYBRBz)  \n4. [Django 结构及处理流程分析](http://my.oschina.net/tenking/blog/29439)\n5. [Django运行方式及处理流程总结](http://blog.csdn.net/yongche_shi/article/details/49513431) \n\nPS: 以上代码和内容都是基于Django 1.6.5版本，其他版本可能与其不同，请参考阅读。\n","source":"_posts/Django运行方式以及处理流程简介-转载.md","raw":"---\ntitle: Django运行方式以及处理流程简介(转载)\ndate: 2018-03-07 19:07:58\ntags:\n  - Django\n  - Python3\ncategories:\n  - Django\n---\n\n## Django的运行方式\n运行Django项目的方法很多，这里主要介绍一下常用的方法。一种是在开发和调试中经常用到`runserver`方法，使用Django自己的web server(WSGI Server)；另外一种就是使用`fastcgi，uWSGIt`等协议运行Django项目。\n\n<!-- more -->\n### runserver方法\nrunserver方法是调试Django时经常用到的运行方式，它使用Django自带的WSGI Server运行，主要在测试和开发中使用，使用方法如下：\n```Python\nUsage: manage.py runserver [options] [optional port number, or ipaddr:port]\n# python manager.py runserver    # default port is 8000\n# python manager.py runserver 8080\n# python manager.py runserver 127.0.0.1:9090\n```\n看一下manager.py的源码，你会发现上面的命令其实是通过Django的execute_from_command_line方法执行了内部实现的runserver命令，那么现在看一下runserver具体做了什么。。\n\n看了源码之后，可以发现runserver命令主要做了两件事情：\n\n    1). 解析参数，并通过django.core.servers.basehttp.get_internal_wsgi_application方法获取wsgi handler;\n\n    2). 根据ip_address和port生成一个WSGIServer对象，接受用户请求\n\nget_internal_wsgi_application的源码如下：\n```python\ndef get_internal_wsgi_application():\n    \"\"\"\n    Loads and returns the WSGI application as configured by the user in\n    ``settings.WSGI_APPLICATION``. With the default ``startproject`` layout,\n    this will be the ``application`` object in ``projectname/wsgi.py``.\n\n    This function, and the ``WSGI_APPLICATION`` setting itself, are only useful\n    for Django's internal servers (runserver, runfcgi); external WSGI servers\n    should just be configured to point to the correct application object\n    directly.\n\n    If settings.WSGI_APPLICATION is not set (is ``None``), we just return\n    whatever ``django.core.wsgi.get_wsgi_application`` returns.\n\n    \"\"\"\n    from django.conf import settings\n    app_path = getattr(settings, 'WSGI_APPLICATION')\n    if app_path is None:\n        return get_wsgi_application()\n\n    return import_by_path(\n        app_path,\n        error_prefix=\"WSGI application '%s' could not be loaded; \" % app_path\n    )\n\n```\n\n通过上面的代码我们可以知道，Django会先根据settings中的WSGI_APPLICATION来获取handler；在创建project的时候，Django会默认创建一个wsgi.py文件，而settings中的WSGI_APPLICATION配置也会默认指向这个文件。看一下这个wsgi.py文件，其实它也和上面的逻辑一样，最终调用get_wsgi_application实现。\n\n## uWSGI方法\nuWSGI + Nginx的方法是现在最常见的在生产环境中运行Django的方法，要了解这种方法，首先要了解一下WSGI和uWSGI协议。\n\nWSGI，全称`Web Server Gateway Interface`，或者`Python Web Server Gateway Interface`，是为Python语言定义的Web服务器和Web应用程序或框架之间的一种简单而通用的接口，基于现存的`CGI标准`而设计的。WSGI其实就是一个网关(Gateway)，其作用就是在协议之间进行转换。(PS: 这里只对WSGI做简单介绍，想要了解更多的内容可自行搜索)\n\n`uWSGI是一个Web服务器`，它实现了WSGI协议、uwsgi、http等协议。`注意!`uwsgi是一种通信协议，而uWSGI是实现uwsgi协议和WSGI协议的Web服务器。uWSGI具有超快的性能、低内存占用和多app管理等优点。以我的博客为例，uWSGI的xml配置如下：\n\n```xml\n<uwsgi>\n    <!-- 端口 -->\n    <socket>:7600</socket>\n    <stats>:40000</stats>\n    <!-- 系统环境变量 -->\n    <env>DJANGO_SETTINGS_MODULE=geek_blog.settings</env>\n    <!-- 指定的python WSGI模块 -->\n    <module>django.core.handlers.wsgi:WSGIHandler()</module>\n    <processes>6</processes>\n    <master />\n    <master-as-root />\n    <!-- 超时设置 -->\n    <harakiri>60</harakiri>\n    <harakiri-verbose/>\n    <daemonize>/var/app/log/blog/uwsgi.log</daemonize>\n    <!-- socket的监听队列大小 -->\n    <listen>32768</listen>\n    <!-- 内部超时时间 -->\n    <socket-timeout>60</socket-timeout>\n</uwsgi>\n\n```\nuWSGI和Nginx一起使用的配置方法就不在这里说明了，网上教程很多，需要的可以自行搜索。\n\n\n## HTTP请求处理流程\nDjango和其他Web框架一样，HTTP的处理流程基本类似：接受request，返回response内容。Django的具体处理流程大致如下图所示：\n\n**1. 加载project settings**\n\n在通过django-admin.py创建project的时候，Django会自动生成默认的settings文件和manager.py等文件，在创建WSGIServer之前会执行下面的引用：\n```Python\nfrom django.conf import settings\n```\n上面引用在执行时，会读取os.environ中的DJANGO_SETTINGS_MODULE配置，加载项目配置文件，生成settings对象。所以，在manager.py文件中你可以看到，在获取WSGIServer之前，会先将project的settings路径加到os路径中。\n\n**2. 创建WSGIServer**\n\n不管是使用runserver还是uWSGI运行Django项目，在启动时都会调用django.core.servers.basehttp中的run()方法，创建一个django.core.servers.basehttp.WSGIServer类的实例，之后调用其serve_forever()方法启动HTTP服务。run方法的源码如下：\n```python\ndef run(addr, port, wsgi_handler, ipv6=False, threading=False):\n    server_address = (addr, port)\n    if threading:\n        httpd_cls = type(str('WSGIServer'), (socketserver.ThreadingMixIn, WSGIServer), {})\n    else:\n        httpd_cls = WSGIServer\n    httpd = httpd_cls(server_address, WSGIRequestHandler, ipv6=ipv6)\n    # Sets the callable application as the WSGI application that will receive requests\n    httpd.set_app(wsgi_handler)\n    httpd.serve_forever()\n\n```\n\n如上，我们可以看到：在创建WSGIServer实例的时候会指定HTTP请求的Handler，上述代码使用WSGIRequestHandler。当用户的HTTP请求到达服务器时，WSGIServer会创建WSGIRequestHandler实例，使用其handler方法来处理HTTP请求(其实最终是调用wsgiref.handlers.BaseHandler中的run方法处理)。WSGIServer通过set_app方法设置一个可调用(callable)的对象作为application，上面提到的handler方法最终会调用设置的application处理request，并返回response。\n\n其中，WSGIServer继承自wsgiref.simple_server.WSGIServer，而WSGIRequestHandler继承自wsgiref.simple_server.WSGIRequestHandler，wsgiref是Python标准库给出的WSGI的参考实现。其源码可自行到[wsgiref](https://pypi.python.org/pypi/wsgiref)参看，这里不再细说.\n\n**3. 处理Request**\n\n第二步中说到的application，在Django中一般是django.core.handlers.wsgi.WSGIHandler对象，WSGIHandler继承自django.core.handlers.base.BaseHandler，这个是Django处理request的核心逻辑，它会创建一个WSGIRequest实例，而WSGIRequest是从http.HttpRequest继承而来\n\n\n**4. 返回Response**\n\n上面提到的BaseHandler中有个get_response方法，该方法会先加载Django项目的ROOT_URLCONF，然后根据url规则找到对应的view方法(类)，view逻辑会根据request实例生成并返回具体的response。\n\n在Django返回结果之后，第二步中提到wsgiref.handlers.BaseHandler.run方法会调用finish_response结束请求，并将内容返回给用户。\n\n## Django处理Request的详细流程\n\n上述的第三步和第四步逻辑只是大致说了一下处理过程，Django在处理request的时候其实做了很多事情，下面我们详细的过一下。首先给大家分享两个网上看到的Django流程图：\n![django.png](http://upload-images.jianshu.io/upload_images/2952111-5e684abfea788d78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![django_flow.png](http://upload-images.jianshu.io/upload_images/2952111-f72ffe64a49bd4d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n上面的两张流程图可以大致描述Django处理request的流程，按照流程图2的标注，可以分为以下几个步骤：\n\n    1. 用户通过浏览器请求一个页面\n\n    2. 请求到达Request Middlewares，中间件对request做一些预处理或者直接response请求\n\n    3. URLConf通过urls.py文件和请求的URL找到相应的View\n\n    4. View Middlewares被访问，它同样可以对request做一些处理或者直接返回response\n\n    5. 调用View中的函数\n\n    6. View中的方法可以选择性的通过Models访问底层的数据\n\n    7. 所有的Model-to-DB的交互都是通过manager完成的\n\n    8. 如果需要，Views可以使用一个特殊的Context\n\n    9. Context被传给Template用来生成页面\n\n    a. Template使用Filters和Tags去渲染输出\n\n    b. 输出被返回到View\n\n    c. HTTPResponse被发送到Response Middlewares\n\n    d. 任何Response Middlewares都可以丰富response或者返回一个完全不同的response\n\n    e. Response返回到浏览器，呈现给用户\n\n上述流程中最主要的几个部分分别是：Middleware(中间件，包括request, view, exception, response)，URLConf(url映射关系)，Template(模板系统)，下面一一介绍一下。\n\n**1. Middleware(中间件)**\n\nMiddleware并不是Django所独有的东西，在其他的Web框架中也有这种概念。在Django中，Middleware可以渗入处理流程的四个阶段：request，view，response和exception，相应的，在每个Middleware类中都有rocess_request，process_view， process_response 和 process_exception这四个方法。你可以定义其中任意一个或多个方法，这取决于你希望该Middleware作用于哪个处理阶段。每个方法都可以直接返回response对象。\n\nMiddleware是在Django BaseHandler的load_middleware方法执行时加载的，加载之后会建立四个列表作为处理器的实例变量：\n```\n    _request_middleware：process_request方法的列表\n\n    _view_middleware：process_view方法的列表\n\n    _response_middleware：process_response方法的列表\n\n    _exception_middleware：process_exception方法的列表\n```\nDjango的中间件是在其配置文件(settings.py)的MIDDLEWARE_CLASSES元组中定义的。在MIDDLEWARE_CLASSES中，中间件组件用字符串表示：指向中间件类名的完整Python路径。例如GeekBlog项目的配置：\n\n```python\nMIDDLEWARE_CLASSES = (\n    'django.middleware.cache.UpdateCacheMiddleware',\n    'django.middleware.common.CommonMiddleware',\n    'django.middleware.cache.FetchFromCacheMiddleware',\n    'django.contrib.sessions.middleware.SessionMiddleware',\n    'django.middleware.csrf.CsrfViewMiddleware',\n    'django.contrib.auth.middleware.AuthenticationMiddleware',\n    'django.contrib.messages.middleware.MessageMiddleware',\n    'django.middleware.locale.LocaleMiddleware',\n    'geek_blog.middlewares.MobileDetectionMiddleware',    # 自定义的Middleware\n)\n```\nDjango项目的安装并不强制要求任何中间件，如果你愿意，MIDDLEWARE_CLASSES可以为空。中间件出现的顺序非常重要：在request和view的处理阶段，Django按照MIDDLEWARE_CLASSES中出现的顺序来应用中间件，而在response和exception异常处理阶段，Django则按逆序来调用它们。也就是说，Django将MIDDLEWARE_CLASSES视为view函数外层的顺序包装子：在request阶段按顺序从上到下穿过，而在response则反过来。\n\n以下两张图可以更好地帮助你理解：\n\n![Django Middleware流程1](http://xianglong.qiniudn.com/django_middleware_flow.png)\n\n![Django Middleware流程图2](http://xianglong.qiniudn.com/django_middleware_flow2.png)\n\n**2. URLConf(URL映射)**\n\n如果处理request的中间件都没有直接返回response，那么Django会去解析用户请求的URL。URLconf就是Django所支撑网站的目录。它的本质是URL模式以及要为该URL模式调用的视图函数之间的映射表。通过这种方式可以告诉Django，对于这个URL调用这段代码，对于那个URL调用那段代码。具体的，在Django项目的配置文件中有ROOT_URLCONF常量，这个常量加上根目录\"/\"，作为参数来创建django.core.urlresolvers.RegexURLResolver的实例，然后通过它的resolve方法解析用户请求的URL，找到第一个匹配的view。\n\n其他有关URLConf的内容，这里不再具体介绍，大家可以看[DjangoBook](http://djangobook.py3k.cn/2.0/chapter03/)了解。\n\n\n**3. Template(模板)**\n\n大部分web框架都有自己的Template(模板)系统，Django也是。但是，Django模板不同于Mako模板和jinja2模板，在Django模板不能直接写Python代码，只能通过额外的定义filter和template tag实现。由于本文主要介绍Django流程，模板内容就不过多介绍。\n\n## 参考文章：\n\n1. [uWSGI Web服务器介绍](http://www.nowamagic.net/academy/detail/1330328)  \n2. [wsgiref源码分析](http://blog.csdn.net/on_1y/article/details/18818081)  \n3. [用Python写一个简单的Web框架](http://www.tuicool.com/articles/aYBRBz)  \n4. [Django 结构及处理流程分析](http://my.oschina.net/tenking/blog/29439)\n5. [Django运行方式及处理流程总结](http://blog.csdn.net/yongche_shi/article/details/49513431) \n\nPS: 以上代码和内容都是基于Django 1.6.5版本，其他版本可能与其不同，请参考阅读。\n","slug":"Django运行方式以及处理流程简介-转载","published":1,"updated":"2018-03-07T12:09:44.924Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozjq00088motcgcfj1bk","content":"<h2 id=\"Django的运行方式\"><a href=\"#Django的运行方式\" class=\"headerlink\" title=\"Django的运行方式\"></a>Django的运行方式</h2><p>运行Django项目的方法很多，这里主要介绍一下常用的方法。一种是在开发和调试中经常用到<code>runserver</code>方法，使用Django自己的web server(WSGI Server)；另外一种就是使用<code>fastcgi，uWSGIt</code>等协议运行Django项目。</p>\n<a id=\"more\"></a>\n<h3 id=\"runserver方法\"><a href=\"#runserver方法\" class=\"headerlink\" title=\"runserver方法\"></a>runserver方法</h3><p>runserver方法是调试Django时经常用到的运行方式，它使用Django自带的WSGI Server运行，主要在测试和开发中使用，使用方法如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Usage: manage.py runserver [options] [optional port number, <span class=\"keyword\">or</span> ipaddr:port]</span><br><span class=\"line\"><span class=\"comment\"># python manager.py runserver    # default port is 8000</span></span><br><span class=\"line\"><span class=\"comment\"># python manager.py runserver 8080</span></span><br><span class=\"line\"><span class=\"comment\"># python manager.py runserver 127.0.0.1:9090</span></span><br></pre></td></tr></table></figure></p>\n<p>看一下manager.py的源码，你会发现上面的命令其实是通过Django的execute_from_command_line方法执行了内部实现的runserver命令，那么现在看一下runserver具体做了什么。。</p>\n<p>看了源码之后，可以发现runserver命令主要做了两件事情：</p>\n<pre><code>1). 解析参数，并通过django.core.servers.basehttp.get_internal_wsgi_application方法获取wsgi handler;\n\n2). 根据ip_address和port生成一个WSGIServer对象，接受用户请求\n</code></pre><p>get_internal_wsgi_application的源码如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_internal_wsgi_application</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    Loads and returns the WSGI application as configured by the user in</span></span><br><span class=\"line\"><span class=\"string\">    ``settings.WSGI_APPLICATION``. With the default ``startproject`` layout,</span></span><br><span class=\"line\"><span class=\"string\">    this will be the ``application`` object in ``projectname/wsgi.py``.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    This function, and the ``WSGI_APPLICATION`` setting itself, are only useful</span></span><br><span class=\"line\"><span class=\"string\">    for Django's internal servers (runserver, runfcgi); external WSGI servers</span></span><br><span class=\"line\"><span class=\"string\">    should just be configured to point to the correct application object</span></span><br><span class=\"line\"><span class=\"string\">    directly.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    If settings.WSGI_APPLICATION is not set (is ``None``), we just return</span></span><br><span class=\"line\"><span class=\"string\">    whatever ``django.core.wsgi.get_wsgi_application`` returns.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> django.conf <span class=\"keyword\">import</span> settings</span><br><span class=\"line\">    app_path = getattr(settings, <span class=\"string\">'WSGI_APPLICATION'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> app_path <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> get_wsgi_application()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> import_by_path(</span><br><span class=\"line\">        app_path,</span><br><span class=\"line\">        error_prefix=<span class=\"string\">\"WSGI application '%s' could not be loaded; \"</span> % app_path</span><br><span class=\"line\">    )</span><br></pre></td></tr></table></figure></p>\n<p>通过上面的代码我们可以知道，Django会先根据settings中的WSGI_APPLICATION来获取handler；在创建project的时候，Django会默认创建一个wsgi.py文件，而settings中的WSGI_APPLICATION配置也会默认指向这个文件。看一下这个wsgi.py文件，其实它也和上面的逻辑一样，最终调用get_wsgi_application实现。</p>\n<h2 id=\"uWSGI方法\"><a href=\"#uWSGI方法\" class=\"headerlink\" title=\"uWSGI方法\"></a>uWSGI方法</h2><p>uWSGI + Nginx的方法是现在最常见的在生产环境中运行Django的方法，要了解这种方法，首先要了解一下WSGI和uWSGI协议。</p>\n<p>WSGI，全称<code>Web Server Gateway Interface</code>，或者<code>Python Web Server Gateway Interface</code>，是为Python语言定义的Web服务器和Web应用程序或框架之间的一种简单而通用的接口，基于现存的<code>CGI标准</code>而设计的。WSGI其实就是一个网关(Gateway)，其作用就是在协议之间进行转换。(PS: 这里只对WSGI做简单介绍，想要了解更多的内容可自行搜索)</p>\n<p><code>uWSGI是一个Web服务器</code>，它实现了WSGI协议、uwsgi、http等协议。<code>注意!</code>uwsgi是一种通信协议，而uWSGI是实现uwsgi协议和WSGI协议的Web服务器。uWSGI具有超快的性能、低内存占用和多app管理等优点。以我的博客为例，uWSGI的xml配置如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">uwsgi</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 端口 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">socket</span>&gt;</span>:7600<span class=\"tag\">&lt;/<span class=\"name\">socket</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">stats</span>&gt;</span>:40000<span class=\"tag\">&lt;/<span class=\"name\">stats</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 系统环境变量 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">env</span>&gt;</span>DJANGO_SETTINGS_MODULE=geek_blog.settings<span class=\"tag\">&lt;/<span class=\"name\">env</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定的python WSGI模块 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">module</span>&gt;</span>django.core.handlers.wsgi:WSGIHandler()<span class=\"tag\">&lt;/<span class=\"name\">module</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">processes</span>&gt;</span>6<span class=\"tag\">&lt;/<span class=\"name\">processes</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">master</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">master-as-root</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 超时设置 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">harakiri</span>&gt;</span>60<span class=\"tag\">&lt;/<span class=\"name\">harakiri</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">harakiri-verbose</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">daemonize</span>&gt;</span>/var/app/log/blog/uwsgi.log<span class=\"tag\">&lt;/<span class=\"name\">daemonize</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- socket的监听队列大小 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">listen</span>&gt;</span>32768<span class=\"tag\">&lt;/<span class=\"name\">listen</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 内部超时时间 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">socket-timeout</span>&gt;</span>60<span class=\"tag\">&lt;/<span class=\"name\">socket-timeout</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">uwsgi</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>uWSGI和Nginx一起使用的配置方法就不在这里说明了，网上教程很多，需要的可以自行搜索。</p>\n<h2 id=\"HTTP请求处理流程\"><a href=\"#HTTP请求处理流程\" class=\"headerlink\" title=\"HTTP请求处理流程\"></a>HTTP请求处理流程</h2><p>Django和其他Web框架一样，HTTP的处理流程基本类似：接受request，返回response内容。Django的具体处理流程大致如下图所示：</p>\n<p><strong>1. 加载project settings</strong></p>\n<p>在通过django-admin.py创建project的时候，Django会自动生成默认的settings文件和manager.py等文件，在创建WSGIServer之前会执行下面的引用：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> django.conf <span class=\"keyword\">import</span> settings</span><br></pre></td></tr></table></figure></p>\n<p>上面引用在执行时，会读取os.environ中的DJANGO_SETTINGS_MODULE配置，加载项目配置文件，生成settings对象。所以，在manager.py文件中你可以看到，在获取WSGIServer之前，会先将project的settings路径加到os路径中。</p>\n<p><strong>2. 创建WSGIServer</strong></p>\n<p>不管是使用runserver还是uWSGI运行Django项目，在启动时都会调用django.core.servers.basehttp中的run()方法，创建一个django.core.servers.basehttp.WSGIServer类的实例，之后调用其serve_forever()方法启动HTTP服务。run方法的源码如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span><span class=\"params\">(addr, port, wsgi_handler, ipv6=False, threading=False)</span>:</span></span><br><span class=\"line\">    server_address = (addr, port)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> threading:</span><br><span class=\"line\">        httpd_cls = type(str(<span class=\"string\">'WSGIServer'</span>), (socketserver.ThreadingMixIn, WSGIServer), &#123;&#125;)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        httpd_cls = WSGIServer</span><br><span class=\"line\">    httpd = httpd_cls(server_address, WSGIRequestHandler, ipv6=ipv6)</span><br><span class=\"line\">    <span class=\"comment\"># Sets the callable application as the WSGI application that will receive requests</span></span><br><span class=\"line\">    httpd.set_app(wsgi_handler)</span><br><span class=\"line\">    httpd.serve_forever()</span><br></pre></td></tr></table></figure></p>\n<p>如上，我们可以看到：在创建WSGIServer实例的时候会指定HTTP请求的Handler，上述代码使用WSGIRequestHandler。当用户的HTTP请求到达服务器时，WSGIServer会创建WSGIRequestHandler实例，使用其handler方法来处理HTTP请求(其实最终是调用wsgiref.handlers.BaseHandler中的run方法处理)。WSGIServer通过set_app方法设置一个可调用(callable)的对象作为application，上面提到的handler方法最终会调用设置的application处理request，并返回response。</p>\n<p>其中，WSGIServer继承自wsgiref.simple_server.WSGIServer，而WSGIRequestHandler继承自wsgiref.simple_server.WSGIRequestHandler，wsgiref是Python标准库给出的WSGI的参考实现。其源码可自行到<a href=\"https://pypi.python.org/pypi/wsgiref\" target=\"_blank\" rel=\"noopener\">wsgiref</a>参看，这里不再细说.</p>\n<p><strong>3. 处理Request</strong></p>\n<p>第二步中说到的application，在Django中一般是django.core.handlers.wsgi.WSGIHandler对象，WSGIHandler继承自django.core.handlers.base.BaseHandler，这个是Django处理request的核心逻辑，它会创建一个WSGIRequest实例，而WSGIRequest是从http.HttpRequest继承而来</p>\n<p><strong>4. 返回Response</strong></p>\n<p>上面提到的BaseHandler中有个get_response方法，该方法会先加载Django项目的ROOT_URLCONF，然后根据url规则找到对应的view方法(类)，view逻辑会根据request实例生成并返回具体的response。</p>\n<p>在Django返回结果之后，第二步中提到wsgiref.handlers.BaseHandler.run方法会调用finish_response结束请求，并将内容返回给用户。</p>\n<h2 id=\"Django处理Request的详细流程\"><a href=\"#Django处理Request的详细流程\" class=\"headerlink\" title=\"Django处理Request的详细流程\"></a>Django处理Request的详细流程</h2><p>上述的第三步和第四步逻辑只是大致说了一下处理过程，Django在处理request的时候其实做了很多事情，下面我们详细的过一下。首先给大家分享两个网上看到的Django流程图：<br><img src=\"http://upload-images.jianshu.io/upload_images/2952111-5e684abfea788d78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"django.png\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-f72ffe64a49bd4d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"django_flow.png\"></p>\n<p>上面的两张流程图可以大致描述Django处理request的流程，按照流程图2的标注，可以分为以下几个步骤：</p>\n<pre><code>1. 用户通过浏览器请求一个页面\n\n2. 请求到达Request Middlewares，中间件对request做一些预处理或者直接response请求\n\n3. URLConf通过urls.py文件和请求的URL找到相应的View\n\n4. View Middlewares被访问，它同样可以对request做一些处理或者直接返回response\n\n5. 调用View中的函数\n\n6. View中的方法可以选择性的通过Models访问底层的数据\n\n7. 所有的Model-to-DB的交互都是通过manager完成的\n\n8. 如果需要，Views可以使用一个特殊的Context\n\n9. Context被传给Template用来生成页面\n\na. Template使用Filters和Tags去渲染输出\n\nb. 输出被返回到View\n\nc. HTTPResponse被发送到Response Middlewares\n\nd. 任何Response Middlewares都可以丰富response或者返回一个完全不同的response\n\ne. Response返回到浏览器，呈现给用户\n</code></pre><p>上述流程中最主要的几个部分分别是：Middleware(中间件，包括request, view, exception, response)，URLConf(url映射关系)，Template(模板系统)，下面一一介绍一下。</p>\n<p><strong>1. Middleware(中间件)</strong></p>\n<p>Middleware并不是Django所独有的东西，在其他的Web框架中也有这种概念。在Django中，Middleware可以渗入处理流程的四个阶段：request，view，response和exception，相应的，在每个Middleware类中都有rocess_request，process_view， process_response 和 process_exception这四个方法。你可以定义其中任意一个或多个方法，这取决于你希望该Middleware作用于哪个处理阶段。每个方法都可以直接返回response对象。</p>\n<p>Middleware是在Django BaseHandler的load_middleware方法执行时加载的，加载之后会建立四个列表作为处理器的实例变量：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_request_middleware：process_request方法的列表</span><br><span class=\"line\"></span><br><span class=\"line\">_view_middleware：process_view方法的列表</span><br><span class=\"line\"></span><br><span class=\"line\">_response_middleware：process_response方法的列表</span><br><span class=\"line\"></span><br><span class=\"line\">_exception_middleware：process_exception方法的列表</span><br></pre></td></tr></table></figure></p>\n<p>Django的中间件是在其配置文件(settings.py)的MIDDLEWARE_CLASSES元组中定义的。在MIDDLEWARE_CLASSES中，中间件组件用字符串表示：指向中间件类名的完整Python路径。例如GeekBlog项目的配置：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MIDDLEWARE_CLASSES = (</span><br><span class=\"line\">    <span class=\"string\">'django.middleware.cache.UpdateCacheMiddleware'</span>,</span><br><span class=\"line\">    <span class=\"string\">'django.middleware.common.CommonMiddleware'</span>,</span><br><span class=\"line\">    <span class=\"string\">'django.middleware.cache.FetchFromCacheMiddleware'</span>,</span><br><span class=\"line\">    <span class=\"string\">'django.contrib.sessions.middleware.SessionMiddleware'</span>,</span><br><span class=\"line\">    <span class=\"string\">'django.middleware.csrf.CsrfViewMiddleware'</span>,</span><br><span class=\"line\">    <span class=\"string\">'django.contrib.auth.middleware.AuthenticationMiddleware'</span>,</span><br><span class=\"line\">    <span class=\"string\">'django.contrib.messages.middleware.MessageMiddleware'</span>,</span><br><span class=\"line\">    <span class=\"string\">'django.middleware.locale.LocaleMiddleware'</span>,</span><br><span class=\"line\">    <span class=\"string\">'geek_blog.middlewares.MobileDetectionMiddleware'</span>,    <span class=\"comment\"># 自定义的Middleware</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>Django项目的安装并不强制要求任何中间件，如果你愿意，MIDDLEWARE_CLASSES可以为空。中间件出现的顺序非常重要：在request和view的处理阶段，Django按照MIDDLEWARE_CLASSES中出现的顺序来应用中间件，而在response和exception异常处理阶段，Django则按逆序来调用它们。也就是说，Django将MIDDLEWARE_CLASSES视为view函数外层的顺序包装子：在request阶段按顺序从上到下穿过，而在response则反过来。</p>\n<p>以下两张图可以更好地帮助你理解：</p>\n<p><img src=\"http://xianglong.qiniudn.com/django_middleware_flow.png\" alt=\"Django Middleware流程1\"></p>\n<p><img src=\"http://xianglong.qiniudn.com/django_middleware_flow2.png\" alt=\"Django Middleware流程图2\"></p>\n<p><strong>2. URLConf(URL映射)</strong></p>\n<p>如果处理request的中间件都没有直接返回response，那么Django会去解析用户请求的URL。URLconf就是Django所支撑网站的目录。它的本质是URL模式以及要为该URL模式调用的视图函数之间的映射表。通过这种方式可以告诉Django，对于这个URL调用这段代码，对于那个URL调用那段代码。具体的，在Django项目的配置文件中有ROOT_URLCONF常量，这个常量加上根目录”/“，作为参数来创建django.core.urlresolvers.RegexURLResolver的实例，然后通过它的resolve方法解析用户请求的URL，找到第一个匹配的view。</p>\n<p>其他有关URLConf的内容，这里不再具体介绍，大家可以看<a href=\"http://djangobook.py3k.cn/2.0/chapter03/\" target=\"_blank\" rel=\"noopener\">DjangoBook</a>了解。</p>\n<p><strong>3. Template(模板)</strong></p>\n<p>大部分web框架都有自己的Template(模板)系统，Django也是。但是，Django模板不同于Mako模板和jinja2模板，在Django模板不能直接写Python代码，只能通过额外的定义filter和template tag实现。由于本文主要介绍Django流程，模板内容就不过多介绍。</p>\n<h2 id=\"参考文章：\"><a href=\"#参考文章：\" class=\"headerlink\" title=\"参考文章：\"></a>参考文章：</h2><ol>\n<li><a href=\"http://www.nowamagic.net/academy/detail/1330328\" target=\"_blank\" rel=\"noopener\">uWSGI Web服务器介绍</a>  </li>\n<li><a href=\"http://blog.csdn.net/on_1y/article/details/18818081\" target=\"_blank\" rel=\"noopener\">wsgiref源码分析</a>  </li>\n<li><a href=\"http://www.tuicool.com/articles/aYBRBz\" target=\"_blank\" rel=\"noopener\">用Python写一个简单的Web框架</a>  </li>\n<li><a href=\"http://my.oschina.net/tenking/blog/29439\" target=\"_blank\" rel=\"noopener\">Django 结构及处理流程分析</a></li>\n<li><a href=\"http://blog.csdn.net/yongche_shi/article/details/49513431\" target=\"_blank\" rel=\"noopener\">Django运行方式及处理流程总结</a> </li>\n</ol>\n<p>PS: 以上代码和内容都是基于Django 1.6.5版本，其他版本可能与其不同，请参考阅读。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Django的运行方式\"><a href=\"#Django的运行方式\" class=\"headerlink\" title=\"Django的运行方式\"></a>Django的运行方式</h2><p>运行Django项目的方法很多，这里主要介绍一下常用的方法。一种是在开发和调试中经常用到<code>runserver</code>方法，使用Django自己的web server(WSGI Server)；另外一种就是使用<code>fastcgi，uWSGIt</code>等协议运行Django项目。</p>","more":"<h3 id=\"runserver方法\"><a href=\"#runserver方法\" class=\"headerlink\" title=\"runserver方法\"></a>runserver方法</h3><p>runserver方法是调试Django时经常用到的运行方式，它使用Django自带的WSGI Server运行，主要在测试和开发中使用，使用方法如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Usage: manage.py runserver [options] [optional port number, <span class=\"keyword\">or</span> ipaddr:port]</span><br><span class=\"line\"><span class=\"comment\"># python manager.py runserver    # default port is 8000</span></span><br><span class=\"line\"><span class=\"comment\"># python manager.py runserver 8080</span></span><br><span class=\"line\"><span class=\"comment\"># python manager.py runserver 127.0.0.1:9090</span></span><br></pre></td></tr></table></figure></p>\n<p>看一下manager.py的源码，你会发现上面的命令其实是通过Django的execute_from_command_line方法执行了内部实现的runserver命令，那么现在看一下runserver具体做了什么。。</p>\n<p>看了源码之后，可以发现runserver命令主要做了两件事情：</p>\n<pre><code>1). 解析参数，并通过django.core.servers.basehttp.get_internal_wsgi_application方法获取wsgi handler;\n\n2). 根据ip_address和port生成一个WSGIServer对象，接受用户请求\n</code></pre><p>get_internal_wsgi_application的源码如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_internal_wsgi_application</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    Loads and returns the WSGI application as configured by the user in</span></span><br><span class=\"line\"><span class=\"string\">    ``settings.WSGI_APPLICATION``. With the default ``startproject`` layout,</span></span><br><span class=\"line\"><span class=\"string\">    this will be the ``application`` object in ``projectname/wsgi.py``.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    This function, and the ``WSGI_APPLICATION`` setting itself, are only useful</span></span><br><span class=\"line\"><span class=\"string\">    for Django's internal servers (runserver, runfcgi); external WSGI servers</span></span><br><span class=\"line\"><span class=\"string\">    should just be configured to point to the correct application object</span></span><br><span class=\"line\"><span class=\"string\">    directly.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    If settings.WSGI_APPLICATION is not set (is ``None``), we just return</span></span><br><span class=\"line\"><span class=\"string\">    whatever ``django.core.wsgi.get_wsgi_application`` returns.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">from</span> django.conf <span class=\"keyword\">import</span> settings</span><br><span class=\"line\">    app_path = getattr(settings, <span class=\"string\">'WSGI_APPLICATION'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> app_path <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> get_wsgi_application()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> import_by_path(</span><br><span class=\"line\">        app_path,</span><br><span class=\"line\">        error_prefix=<span class=\"string\">\"WSGI application '%s' could not be loaded; \"</span> % app_path</span><br><span class=\"line\">    )</span><br></pre></td></tr></table></figure></p>\n<p>通过上面的代码我们可以知道，Django会先根据settings中的WSGI_APPLICATION来获取handler；在创建project的时候，Django会默认创建一个wsgi.py文件，而settings中的WSGI_APPLICATION配置也会默认指向这个文件。看一下这个wsgi.py文件，其实它也和上面的逻辑一样，最终调用get_wsgi_application实现。</p>\n<h2 id=\"uWSGI方法\"><a href=\"#uWSGI方法\" class=\"headerlink\" title=\"uWSGI方法\"></a>uWSGI方法</h2><p>uWSGI + Nginx的方法是现在最常见的在生产环境中运行Django的方法，要了解这种方法，首先要了解一下WSGI和uWSGI协议。</p>\n<p>WSGI，全称<code>Web Server Gateway Interface</code>，或者<code>Python Web Server Gateway Interface</code>，是为Python语言定义的Web服务器和Web应用程序或框架之间的一种简单而通用的接口，基于现存的<code>CGI标准</code>而设计的。WSGI其实就是一个网关(Gateway)，其作用就是在协议之间进行转换。(PS: 这里只对WSGI做简单介绍，想要了解更多的内容可自行搜索)</p>\n<p><code>uWSGI是一个Web服务器</code>，它实现了WSGI协议、uwsgi、http等协议。<code>注意!</code>uwsgi是一种通信协议，而uWSGI是实现uwsgi协议和WSGI协议的Web服务器。uWSGI具有超快的性能、低内存占用和多app管理等优点。以我的博客为例，uWSGI的xml配置如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">uwsgi</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 端口 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">socket</span>&gt;</span>:7600<span class=\"tag\">&lt;/<span class=\"name\">socket</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">stats</span>&gt;</span>:40000<span class=\"tag\">&lt;/<span class=\"name\">stats</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 系统环境变量 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">env</span>&gt;</span>DJANGO_SETTINGS_MODULE=geek_blog.settings<span class=\"tag\">&lt;/<span class=\"name\">env</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定的python WSGI模块 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">module</span>&gt;</span>django.core.handlers.wsgi:WSGIHandler()<span class=\"tag\">&lt;/<span class=\"name\">module</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">processes</span>&gt;</span>6<span class=\"tag\">&lt;/<span class=\"name\">processes</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">master</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">master-as-root</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 超时设置 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">harakiri</span>&gt;</span>60<span class=\"tag\">&lt;/<span class=\"name\">harakiri</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">harakiri-verbose</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">daemonize</span>&gt;</span>/var/app/log/blog/uwsgi.log<span class=\"tag\">&lt;/<span class=\"name\">daemonize</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- socket的监听队列大小 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">listen</span>&gt;</span>32768<span class=\"tag\">&lt;/<span class=\"name\">listen</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 内部超时时间 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">socket-timeout</span>&gt;</span>60<span class=\"tag\">&lt;/<span class=\"name\">socket-timeout</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">uwsgi</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>uWSGI和Nginx一起使用的配置方法就不在这里说明了，网上教程很多，需要的可以自行搜索。</p>\n<h2 id=\"HTTP请求处理流程\"><a href=\"#HTTP请求处理流程\" class=\"headerlink\" title=\"HTTP请求处理流程\"></a>HTTP请求处理流程</h2><p>Django和其他Web框架一样，HTTP的处理流程基本类似：接受request，返回response内容。Django的具体处理流程大致如下图所示：</p>\n<p><strong>1. 加载project settings</strong></p>\n<p>在通过django-admin.py创建project的时候，Django会自动生成默认的settings文件和manager.py等文件，在创建WSGIServer之前会执行下面的引用：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> django.conf <span class=\"keyword\">import</span> settings</span><br></pre></td></tr></table></figure></p>\n<p>上面引用在执行时，会读取os.environ中的DJANGO_SETTINGS_MODULE配置，加载项目配置文件，生成settings对象。所以，在manager.py文件中你可以看到，在获取WSGIServer之前，会先将project的settings路径加到os路径中。</p>\n<p><strong>2. 创建WSGIServer</strong></p>\n<p>不管是使用runserver还是uWSGI运行Django项目，在启动时都会调用django.core.servers.basehttp中的run()方法，创建一个django.core.servers.basehttp.WSGIServer类的实例，之后调用其serve_forever()方法启动HTTP服务。run方法的源码如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span><span class=\"params\">(addr, port, wsgi_handler, ipv6=False, threading=False)</span>:</span></span><br><span class=\"line\">    server_address = (addr, port)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> threading:</span><br><span class=\"line\">        httpd_cls = type(str(<span class=\"string\">'WSGIServer'</span>), (socketserver.ThreadingMixIn, WSGIServer), &#123;&#125;)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        httpd_cls = WSGIServer</span><br><span class=\"line\">    httpd = httpd_cls(server_address, WSGIRequestHandler, ipv6=ipv6)</span><br><span class=\"line\">    <span class=\"comment\"># Sets the callable application as the WSGI application that will receive requests</span></span><br><span class=\"line\">    httpd.set_app(wsgi_handler)</span><br><span class=\"line\">    httpd.serve_forever()</span><br></pre></td></tr></table></figure></p>\n<p>如上，我们可以看到：在创建WSGIServer实例的时候会指定HTTP请求的Handler，上述代码使用WSGIRequestHandler。当用户的HTTP请求到达服务器时，WSGIServer会创建WSGIRequestHandler实例，使用其handler方法来处理HTTP请求(其实最终是调用wsgiref.handlers.BaseHandler中的run方法处理)。WSGIServer通过set_app方法设置一个可调用(callable)的对象作为application，上面提到的handler方法最终会调用设置的application处理request，并返回response。</p>\n<p>其中，WSGIServer继承自wsgiref.simple_server.WSGIServer，而WSGIRequestHandler继承自wsgiref.simple_server.WSGIRequestHandler，wsgiref是Python标准库给出的WSGI的参考实现。其源码可自行到<a href=\"https://pypi.python.org/pypi/wsgiref\" target=\"_blank\" rel=\"noopener\">wsgiref</a>参看，这里不再细说.</p>\n<p><strong>3. 处理Request</strong></p>\n<p>第二步中说到的application，在Django中一般是django.core.handlers.wsgi.WSGIHandler对象，WSGIHandler继承自django.core.handlers.base.BaseHandler，这个是Django处理request的核心逻辑，它会创建一个WSGIRequest实例，而WSGIRequest是从http.HttpRequest继承而来</p>\n<p><strong>4. 返回Response</strong></p>\n<p>上面提到的BaseHandler中有个get_response方法，该方法会先加载Django项目的ROOT_URLCONF，然后根据url规则找到对应的view方法(类)，view逻辑会根据request实例生成并返回具体的response。</p>\n<p>在Django返回结果之后，第二步中提到wsgiref.handlers.BaseHandler.run方法会调用finish_response结束请求，并将内容返回给用户。</p>\n<h2 id=\"Django处理Request的详细流程\"><a href=\"#Django处理Request的详细流程\" class=\"headerlink\" title=\"Django处理Request的详细流程\"></a>Django处理Request的详细流程</h2><p>上述的第三步和第四步逻辑只是大致说了一下处理过程，Django在处理request的时候其实做了很多事情，下面我们详细的过一下。首先给大家分享两个网上看到的Django流程图：<br><img src=\"http://upload-images.jianshu.io/upload_images/2952111-5e684abfea788d78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"django.png\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-f72ffe64a49bd4d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"django_flow.png\"></p>\n<p>上面的两张流程图可以大致描述Django处理request的流程，按照流程图2的标注，可以分为以下几个步骤：</p>\n<pre><code>1. 用户通过浏览器请求一个页面\n\n2. 请求到达Request Middlewares，中间件对request做一些预处理或者直接response请求\n\n3. URLConf通过urls.py文件和请求的URL找到相应的View\n\n4. View Middlewares被访问，它同样可以对request做一些处理或者直接返回response\n\n5. 调用View中的函数\n\n6. View中的方法可以选择性的通过Models访问底层的数据\n\n7. 所有的Model-to-DB的交互都是通过manager完成的\n\n8. 如果需要，Views可以使用一个特殊的Context\n\n9. Context被传给Template用来生成页面\n\na. Template使用Filters和Tags去渲染输出\n\nb. 输出被返回到View\n\nc. HTTPResponse被发送到Response Middlewares\n\nd. 任何Response Middlewares都可以丰富response或者返回一个完全不同的response\n\ne. Response返回到浏览器，呈现给用户\n</code></pre><p>上述流程中最主要的几个部分分别是：Middleware(中间件，包括request, view, exception, response)，URLConf(url映射关系)，Template(模板系统)，下面一一介绍一下。</p>\n<p><strong>1. Middleware(中间件)</strong></p>\n<p>Middleware并不是Django所独有的东西，在其他的Web框架中也有这种概念。在Django中，Middleware可以渗入处理流程的四个阶段：request，view，response和exception，相应的，在每个Middleware类中都有rocess_request，process_view， process_response 和 process_exception这四个方法。你可以定义其中任意一个或多个方法，这取决于你希望该Middleware作用于哪个处理阶段。每个方法都可以直接返回response对象。</p>\n<p>Middleware是在Django BaseHandler的load_middleware方法执行时加载的，加载之后会建立四个列表作为处理器的实例变量：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_request_middleware：process_request方法的列表</span><br><span class=\"line\"></span><br><span class=\"line\">_view_middleware：process_view方法的列表</span><br><span class=\"line\"></span><br><span class=\"line\">_response_middleware：process_response方法的列表</span><br><span class=\"line\"></span><br><span class=\"line\">_exception_middleware：process_exception方法的列表</span><br></pre></td></tr></table></figure></p>\n<p>Django的中间件是在其配置文件(settings.py)的MIDDLEWARE_CLASSES元组中定义的。在MIDDLEWARE_CLASSES中，中间件组件用字符串表示：指向中间件类名的完整Python路径。例如GeekBlog项目的配置：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MIDDLEWARE_CLASSES = (</span><br><span class=\"line\">    <span class=\"string\">'django.middleware.cache.UpdateCacheMiddleware'</span>,</span><br><span class=\"line\">    <span class=\"string\">'django.middleware.common.CommonMiddleware'</span>,</span><br><span class=\"line\">    <span class=\"string\">'django.middleware.cache.FetchFromCacheMiddleware'</span>,</span><br><span class=\"line\">    <span class=\"string\">'django.contrib.sessions.middleware.SessionMiddleware'</span>,</span><br><span class=\"line\">    <span class=\"string\">'django.middleware.csrf.CsrfViewMiddleware'</span>,</span><br><span class=\"line\">    <span class=\"string\">'django.contrib.auth.middleware.AuthenticationMiddleware'</span>,</span><br><span class=\"line\">    <span class=\"string\">'django.contrib.messages.middleware.MessageMiddleware'</span>,</span><br><span class=\"line\">    <span class=\"string\">'django.middleware.locale.LocaleMiddleware'</span>,</span><br><span class=\"line\">    <span class=\"string\">'geek_blog.middlewares.MobileDetectionMiddleware'</span>,    <span class=\"comment\"># 自定义的Middleware</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>Django项目的安装并不强制要求任何中间件，如果你愿意，MIDDLEWARE_CLASSES可以为空。中间件出现的顺序非常重要：在request和view的处理阶段，Django按照MIDDLEWARE_CLASSES中出现的顺序来应用中间件，而在response和exception异常处理阶段，Django则按逆序来调用它们。也就是说，Django将MIDDLEWARE_CLASSES视为view函数外层的顺序包装子：在request阶段按顺序从上到下穿过，而在response则反过来。</p>\n<p>以下两张图可以更好地帮助你理解：</p>\n<p><img src=\"http://xianglong.qiniudn.com/django_middleware_flow.png\" alt=\"Django Middleware流程1\"></p>\n<p><img src=\"http://xianglong.qiniudn.com/django_middleware_flow2.png\" alt=\"Django Middleware流程图2\"></p>\n<p><strong>2. URLConf(URL映射)</strong></p>\n<p>如果处理request的中间件都没有直接返回response，那么Django会去解析用户请求的URL。URLconf就是Django所支撑网站的目录。它的本质是URL模式以及要为该URL模式调用的视图函数之间的映射表。通过这种方式可以告诉Django，对于这个URL调用这段代码，对于那个URL调用那段代码。具体的，在Django项目的配置文件中有ROOT_URLCONF常量，这个常量加上根目录”/“，作为参数来创建django.core.urlresolvers.RegexURLResolver的实例，然后通过它的resolve方法解析用户请求的URL，找到第一个匹配的view。</p>\n<p>其他有关URLConf的内容，这里不再具体介绍，大家可以看<a href=\"http://djangobook.py3k.cn/2.0/chapter03/\" target=\"_blank\" rel=\"noopener\">DjangoBook</a>了解。</p>\n<p><strong>3. Template(模板)</strong></p>\n<p>大部分web框架都有自己的Template(模板)系统，Django也是。但是，Django模板不同于Mako模板和jinja2模板，在Django模板不能直接写Python代码，只能通过额外的定义filter和template tag实现。由于本文主要介绍Django流程，模板内容就不过多介绍。</p>\n<h2 id=\"参考文章：\"><a href=\"#参考文章：\" class=\"headerlink\" title=\"参考文章：\"></a>参考文章：</h2><ol>\n<li><a href=\"http://www.nowamagic.net/academy/detail/1330328\" target=\"_blank\" rel=\"noopener\">uWSGI Web服务器介绍</a>  </li>\n<li><a href=\"http://blog.csdn.net/on_1y/article/details/18818081\" target=\"_blank\" rel=\"noopener\">wsgiref源码分析</a>  </li>\n<li><a href=\"http://www.tuicool.com/articles/aYBRBz\" target=\"_blank\" rel=\"noopener\">用Python写一个简单的Web框架</a>  </li>\n<li><a href=\"http://my.oschina.net/tenking/blog/29439\" target=\"_blank\" rel=\"noopener\">Django 结构及处理流程分析</a></li>\n<li><a href=\"http://blog.csdn.net/yongche_shi/article/details/49513431\" target=\"_blank\" rel=\"noopener\">Django运行方式及处理流程总结</a> </li>\n</ol>\n<p>PS: 以上代码和内容都是基于Django 1.6.5版本，其他版本可能与其不同，请参考阅读。</p>"},{"title":"Github多分支管理Hexo-Blog项目","date":"2018-02-26T16:23:41.000Z","_content":"\nHexo在部署之后在github的仓库中我们只能找到生成的静态文件。然而博客的源文件：主题、文章、配置等文件都还在本地，并没有备份。对于多台终端设备的用户不够友好，而且存在一定的风险，万一那天电脑坏了或者是出现一些其他问题，就得从头再来。为了解决上述问题，我们可以利用github的分支思想来备份我们的源文件。\n\n<!--more-->\n\n备份之前，需要了解博客根目录下面的文件以及文件夹作用：\n```python\n.deploy_git/        网站静态文件(git)\nnode_modules/       插件\npublic/             网站静态文件\nscaffolds/          文章模板\nsource/             博文等\nthemes/             主题\n_config.yml         网站配置文件\npackage.json        Hexo信息\ndb.json             数据文件\n```\n## 备份的思路\n`master分支存放部署生成的静态文件，Hexo-Bog分支存放我们要备份项目源文件。`实际备份中，.deploy_git、public文件夹和我们的master分支内容重复，所以略过。因此，我们在根目录下面建一个**.gitignore**文件来建立“黑名单”，禁止备份。\n\n## 编辑**.gitignore**过滤文件\n文件内容如下：\n```python\n.DS_Store\npublic/\n.deploy*/\n```\n## 关于备份\n终端中在项目的根目录下执行，对于作者自己的项目，命令执行的路径为ByiProX/下：\n```Bash\n$ git init\n$ git remote add origin git@github.com:username/username.github.io.git\t\t\n# username为博客项目的名称，也就是git的用户名\n$ git add .\n$ git commit -m \"ready for backup of the project\"\n$ git push origin master:Hexo-Blog\n```\n\n执行完毕后会发现github博客仓库已经有了一个新分支Hexo-Blog，于是备份工作完成。\n以后，开始写博文时，即终端运行\n```Bash\n$ hexo new [layout] <title>\n```\n完成文章后,对编辑后的文章进行备份保存，即终端运行,为下面的部署做准备\n```Bash\n    $ git add .\n    $ git commit -m \"add one article\"\n    $ git push origin master:Hexo-Blog\n```\n\n## 部署\n运行一下命令进行仓库master分支静态文件部署\n```Bash\n$ hexo clean\n$ hexo generate\n$ hexo deploy\n```\n\n以上完成项目源文件以及静态文件的Git管理\n\n## 参考文献及进阶\n[Hexo+github搭建个人博客并实现多终端管理](https://mrlrf.github.io/2017/05/05/Hexo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/)\n[如何在github上面备份Hexo](https://blog.zaihua.me/post/blog_github_backup.html)\n[Hexo的版本控制与持续集成](https://formulahendry.github.io/2016/12/04/hexo-ci/)\n[使用hexo，如果换了电脑怎么更新博客](https://www.zhihu.com/question/21193762)\n","source":"_posts/Github多分支管理Hexo-Blog项目.md","raw":"---\ntitle: Github多分支管理Hexo-Blog项目\ndate: 2018-02-27 00:23:41\ntags:\n  - Hexo\n  - Git\ncategories:\n  - Hexo\n---\n\nHexo在部署之后在github的仓库中我们只能找到生成的静态文件。然而博客的源文件：主题、文章、配置等文件都还在本地，并没有备份。对于多台终端设备的用户不够友好，而且存在一定的风险，万一那天电脑坏了或者是出现一些其他问题，就得从头再来。为了解决上述问题，我们可以利用github的分支思想来备份我们的源文件。\n\n<!--more-->\n\n备份之前，需要了解博客根目录下面的文件以及文件夹作用：\n```python\n.deploy_git/        网站静态文件(git)\nnode_modules/       插件\npublic/             网站静态文件\nscaffolds/          文章模板\nsource/             博文等\nthemes/             主题\n_config.yml         网站配置文件\npackage.json        Hexo信息\ndb.json             数据文件\n```\n## 备份的思路\n`master分支存放部署生成的静态文件，Hexo-Bog分支存放我们要备份项目源文件。`实际备份中，.deploy_git、public文件夹和我们的master分支内容重复，所以略过。因此，我们在根目录下面建一个**.gitignore**文件来建立“黑名单”，禁止备份。\n\n## 编辑**.gitignore**过滤文件\n文件内容如下：\n```python\n.DS_Store\npublic/\n.deploy*/\n```\n## 关于备份\n终端中在项目的根目录下执行，对于作者自己的项目，命令执行的路径为ByiProX/下：\n```Bash\n$ git init\n$ git remote add origin git@github.com:username/username.github.io.git\t\t\n# username为博客项目的名称，也就是git的用户名\n$ git add .\n$ git commit -m \"ready for backup of the project\"\n$ git push origin master:Hexo-Blog\n```\n\n执行完毕后会发现github博客仓库已经有了一个新分支Hexo-Blog，于是备份工作完成。\n以后，开始写博文时，即终端运行\n```Bash\n$ hexo new [layout] <title>\n```\n完成文章后,对编辑后的文章进行备份保存，即终端运行,为下面的部署做准备\n```Bash\n    $ git add .\n    $ git commit -m \"add one article\"\n    $ git push origin master:Hexo-Blog\n```\n\n## 部署\n运行一下命令进行仓库master分支静态文件部署\n```Bash\n$ hexo clean\n$ hexo generate\n$ hexo deploy\n```\n\n以上完成项目源文件以及静态文件的Git管理\n\n## 参考文献及进阶\n[Hexo+github搭建个人博客并实现多终端管理](https://mrlrf.github.io/2017/05/05/Hexo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/)\n[如何在github上面备份Hexo](https://blog.zaihua.me/post/blog_github_backup.html)\n[Hexo的版本控制与持续集成](https://formulahendry.github.io/2016/12/04/hexo-ci/)\n[使用hexo，如果换了电脑怎么更新博客](https://www.zhihu.com/question/21193762)\n","slug":"Github多分支管理Hexo-Blog项目","published":1,"updated":"2018-02-27T06:40:56.801Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozjr00098moty6exboj5","content":"<p>Hexo在部署之后在github的仓库中我们只能找到生成的静态文件。然而博客的源文件：主题、文章、配置等文件都还在本地，并没有备份。对于多台终端设备的用户不够友好，而且存在一定的风险，万一那天电脑坏了或者是出现一些其他问题，就得从头再来。为了解决上述问题，我们可以利用github的分支思想来备份我们的源文件。</p>\n<a id=\"more\"></a>\n<p>备份之前，需要了解博客根目录下面的文件以及文件夹作用：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.deploy_git/        网站静态文件(git)</span><br><span class=\"line\">node_modules/       插件</span><br><span class=\"line\">public/             网站静态文件</span><br><span class=\"line\">scaffolds/          文章模板</span><br><span class=\"line\">source/             博文等</span><br><span class=\"line\">themes/             主题</span><br><span class=\"line\">_config.yml         网站配置文件</span><br><span class=\"line\">package.json        Hexo信息</span><br><span class=\"line\">db.json             数据文件</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"备份的思路\"><a href=\"#备份的思路\" class=\"headerlink\" title=\"备份的思路\"></a>备份的思路</h2><p><code>master分支存放部署生成的静态文件，Hexo-Bog分支存放我们要备份项目源文件。</code>实际备份中，.deploy_git、public文件夹和我们的master分支内容重复，所以略过。因此，我们在根目录下面建一个<strong>.gitignore</strong>文件来建立“黑名单”，禁止备份。</p>\n<h2 id=\"编辑-gitignore过滤文件\"><a href=\"#编辑-gitignore过滤文件\" class=\"headerlink\" title=\"编辑.gitignore过滤文件\"></a>编辑<strong>.gitignore</strong>过滤文件</h2><p>文件内容如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.DS_Store</span><br><span class=\"line\">public/</span><br><span class=\"line\">.deploy*/</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"关于备份\"><a href=\"#关于备份\" class=\"headerlink\" title=\"关于备份\"></a>关于备份</h2><p>终端中在项目的根目录下执行，对于作者自己的项目，命令执行的路径为ByiProX/下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git init</span><br><span class=\"line\">$ git remote add origin git@github.com:username/username.github.io.git\t\t</span><br><span class=\"line\"><span class=\"comment\"># username为博客项目的名称，也就是git的用户名</span></span><br><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -m <span class=\"string\">\"ready for backup of the project\"</span></span><br><span class=\"line\">$ git push origin master:Hexo-Blog</span><br></pre></td></tr></table></figure></p>\n<p>执行完毕后会发现github博客仓库已经有了一个新分支Hexo-Blog，于是备份工作完成。<br>以后，开始写博文时，即终端运行<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure></p>\n<p>完成文章后,对编辑后的文章进行备份保存，即终端运行,为下面的部署做准备<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -m <span class=\"string\">\"add one article\"</span></span><br><span class=\"line\">$ git push origin master:Hexo-Blog</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h2><p>运行一下命令进行仓库master分支静态文件部署<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo clean</span><br><span class=\"line\">$ hexo generate</span><br><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure></p>\n<p>以上完成项目源文件以及静态文件的Git管理</p>\n<h2 id=\"参考文献及进阶\"><a href=\"#参考文献及进阶\" class=\"headerlink\" title=\"参考文献及进阶\"></a>参考文献及进阶</h2><p><a href=\"https://mrlrf.github.io/2017/05/05/Hexo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/\" target=\"_blank\" rel=\"noopener\">Hexo+github搭建个人博客并实现多终端管理</a><br><a href=\"https://blog.zaihua.me/post/blog_github_backup.html\" target=\"_blank\" rel=\"noopener\">如何在github上面备份Hexo</a><br><a href=\"https://formulahendry.github.io/2016/12/04/hexo-ci/\" target=\"_blank\" rel=\"noopener\">Hexo的版本控制与持续集成</a><br><a href=\"https://www.zhihu.com/question/21193762\" target=\"_blank\" rel=\"noopener\">使用hexo，如果换了电脑怎么更新博客</a></p>\n","site":{"data":{}},"excerpt":"<p>Hexo在部署之后在github的仓库中我们只能找到生成的静态文件。然而博客的源文件：主题、文章、配置等文件都还在本地，并没有备份。对于多台终端设备的用户不够友好，而且存在一定的风险，万一那天电脑坏了或者是出现一些其他问题，就得从头再来。为了解决上述问题，我们可以利用github的分支思想来备份我们的源文件。</p>","more":"<p>备份之前，需要了解博客根目录下面的文件以及文件夹作用：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.deploy_git/        网站静态文件(git)</span><br><span class=\"line\">node_modules/       插件</span><br><span class=\"line\">public/             网站静态文件</span><br><span class=\"line\">scaffolds/          文章模板</span><br><span class=\"line\">source/             博文等</span><br><span class=\"line\">themes/             主题</span><br><span class=\"line\">_config.yml         网站配置文件</span><br><span class=\"line\">package.json        Hexo信息</span><br><span class=\"line\">db.json             数据文件</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"备份的思路\"><a href=\"#备份的思路\" class=\"headerlink\" title=\"备份的思路\"></a>备份的思路</h2><p><code>master分支存放部署生成的静态文件，Hexo-Bog分支存放我们要备份项目源文件。</code>实际备份中，.deploy_git、public文件夹和我们的master分支内容重复，所以略过。因此，我们在根目录下面建一个<strong>.gitignore</strong>文件来建立“黑名单”，禁止备份。</p>\n<h2 id=\"编辑-gitignore过滤文件\"><a href=\"#编辑-gitignore过滤文件\" class=\"headerlink\" title=\"编辑.gitignore过滤文件\"></a>编辑<strong>.gitignore</strong>过滤文件</h2><p>文件内容如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.DS_Store</span><br><span class=\"line\">public/</span><br><span class=\"line\">.deploy*/</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"关于备份\"><a href=\"#关于备份\" class=\"headerlink\" title=\"关于备份\"></a>关于备份</h2><p>终端中在项目的根目录下执行，对于作者自己的项目，命令执行的路径为ByiProX/下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git init</span><br><span class=\"line\">$ git remote add origin git@github.com:username/username.github.io.git\t\t</span><br><span class=\"line\"><span class=\"comment\"># username为博客项目的名称，也就是git的用户名</span></span><br><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -m <span class=\"string\">\"ready for backup of the project\"</span></span><br><span class=\"line\">$ git push origin master:Hexo-Blog</span><br></pre></td></tr></table></figure></p>\n<p>执行完毕后会发现github博客仓库已经有了一个新分支Hexo-Blog，于是备份工作完成。<br>以后，开始写博文时，即终端运行<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure></p>\n<p>完成文章后,对编辑后的文章进行备份保存，即终端运行,为下面的部署做准备<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -m <span class=\"string\">\"add one article\"</span></span><br><span class=\"line\">$ git push origin master:Hexo-Blog</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h2><p>运行一下命令进行仓库master分支静态文件部署<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo clean</span><br><span class=\"line\">$ hexo generate</span><br><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure></p>\n<p>以上完成项目源文件以及静态文件的Git管理</p>\n<h2 id=\"参考文献及进阶\"><a href=\"#参考文献及进阶\" class=\"headerlink\" title=\"参考文献及进阶\"></a>参考文献及进阶</h2><p><a href=\"https://mrlrf.github.io/2017/05/05/Hexo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/\" target=\"_blank\" rel=\"noopener\">Hexo+github搭建个人博客并实现多终端管理</a><br><a href=\"https://blog.zaihua.me/post/blog_github_backup.html\" target=\"_blank\" rel=\"noopener\">如何在github上面备份Hexo</a><br><a href=\"https://formulahendry.github.io/2016/12/04/hexo-ci/\" target=\"_blank\" rel=\"noopener\">Hexo的版本控制与持续集成</a><br><a href=\"https://www.zhihu.com/question/21193762\" target=\"_blank\" rel=\"noopener\">使用hexo，如果换了电脑怎么更新博客</a></p>"},{"title":"HTML里引入CSS的四种方式","date":"2018-04-09T14:42:46.000Z","_content":"1. 行内式：也称内联式，在标记的style属性中设定CSS样式。这种方式没有体现出CSS的优势；\n\n2. 嵌入式：将CSS样式集中写在网页的<head></head>标签对的<style></style>标签对中；\n\n3. 链接式：跟第4个的导入式都称外部式或者外联式，使用link引用外部CSS文件；\n\n4. 导入式：使用@import引用外部CSS文件；\n","source":"_posts/HTML里引入CSS的四种方式.md","raw":"---\ntitle: HTML里引入CSS的四种方式\ndate: 2018-04-09 22:42:46\ntags:\n  - Frontend\ncategories:\n  - Frontend\n---\n1. 行内式：也称内联式，在标记的style属性中设定CSS样式。这种方式没有体现出CSS的优势；\n\n2. 嵌入式：将CSS样式集中写在网页的<head></head>标签对的<style></style>标签对中；\n\n3. 链接式：跟第4个的导入式都称外部式或者外联式，使用link引用外部CSS文件；\n\n4. 导入式：使用@import引用外部CSS文件；\n","slug":"HTML里引入CSS的四种方式","published":1,"updated":"2018-04-21T03:34:43.171Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozjt000c8motji1fu16c","content":"<ol>\n<li><p>行内式：也称内联式，在标记的style属性中设定CSS样式。这种方式没有体现出CSS的优势；</p>\n</li>\n<li><p>嵌入式：将CSS样式集中写在网页的<head></head>标签对的<style></style>标签对中；</p>\n</li>\n<li><p>链接式：跟第4个的导入式都称外部式或者外联式，使用link引用外部CSS文件；</p>\n</li>\n<li><p>导入式：使用@import引用外部CSS文件；</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>行内式：也称内联式，在标记的style属性中设定CSS样式。这种方式没有体现出CSS的优势；</p>\n</li>\n<li><p>嵌入式：将CSS样式集中写在网页的<head></head>标签对的<style></style>标签对中；</p>\n</li>\n<li><p>链接式：跟第4个的导入式都称外部式或者外联式，使用link引用外部CSS文件；</p>\n</li>\n<li><p>导入式：使用@import引用外部CSS文件；</p>\n</li>\n</ol>\n"},{"title":"Hexo博客Next主题添加Fork me on GitHub标签","date":"2018-02-28T10:09:26.000Z","_content":"\n给自己的个人博客添加Fork me on GitHub标签感觉很专业很逼格，添加的方法也很简单，介绍如下。\n\n打开文件：**hexo博客根目录/themes/next/layout/_layout.swig** 找到如下代码块\n```python\n...\n<div class=\"{{ container_class }} {% block page_class %}{% endblock %} \">\n    <div class=\"headband\"></div>\n    [样式代码]\n...\n\n```\n<!-- more -->\n样式代码 [**看这里**](https://link.jianshu.com/?t=https://github.com/blog/273-github-ribbons) ，挑选自己喜欢的样式。\n\n然后将样式代码添加到上述 **_layout.swig** 代码块后面，比如选择黑色经典款，即：\n```python\n...\n<div class=\"{{ container_class }} {% block page_class %}{% endblock %} \">\n    <div class=\"headband\"></div>\n    # [样式代码]\n    <a href=\"https://github.com/you\"><img style=\"position: absolute; top: 0; right: 0; border: 0;\" src=\"https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67\" alt=\"Fork me on GitHub\" data-canonical-src=\"https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png\"></a>\n\n...\n\n```\n\n\n重新部署一下就可以查看了，如果显示不出来，需要清理浏览器的cookie,多刷新几次就OK了。\n大家看我的，感觉很搭( ⊙ o ⊙ )！\n![fork me on github](http://upload-images.jianshu.io/upload_images/2952111-13a15afaa9450272.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n","source":"_posts/Hexo博客Next主题添加Fork-me-on-GitHub标签.md","raw":"---\ntitle: Hexo博客Next主题添加Fork me on GitHub标签\ndate: 2018-02-28 18:09:26\ntags:\n  - Hexo\ncategories:\n  - Hexo\n---\n\n给自己的个人博客添加Fork me on GitHub标签感觉很专业很逼格，添加的方法也很简单，介绍如下。\n\n打开文件：**hexo博客根目录/themes/next/layout/_layout.swig** 找到如下代码块\n```python\n...\n<div class=\"{{ container_class }} {% block page_class %}{% endblock %} \">\n    <div class=\"headband\"></div>\n    [样式代码]\n...\n\n```\n<!-- more -->\n样式代码 [**看这里**](https://link.jianshu.com/?t=https://github.com/blog/273-github-ribbons) ，挑选自己喜欢的样式。\n\n然后将样式代码添加到上述 **_layout.swig** 代码块后面，比如选择黑色经典款，即：\n```python\n...\n<div class=\"{{ container_class }} {% block page_class %}{% endblock %} \">\n    <div class=\"headband\"></div>\n    # [样式代码]\n    <a href=\"https://github.com/you\"><img style=\"position: absolute; top: 0; right: 0; border: 0;\" src=\"https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67\" alt=\"Fork me on GitHub\" data-canonical-src=\"https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png\"></a>\n\n...\n\n```\n\n\n重新部署一下就可以查看了，如果显示不出来，需要清理浏览器的cookie,多刷新几次就OK了。\n大家看我的，感觉很搭( ⊙ o ⊙ )！\n![fork me on github](http://upload-images.jianshu.io/upload_images/2952111-13a15afaa9450272.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n","slug":"Hexo博客Next主题添加Fork-me-on-GitHub标签","published":1,"updated":"2018-02-28T10:35:15.748Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozjw000e8mot9zwnq51f","content":"<p>给自己的个人博客添加Fork me on GitHub标签感觉很专业很逼格，添加的方法也很简单，介绍如下。</p>\n<p>打开文件：<strong>hexo博客根目录/themes/next/layout/_layout.swig</strong> 找到如下代码块<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">&lt;div class=\"&#123;&#123; container_class &#125;&#125; &#123;% block page_class %&#125;&#123;% endblock %&#125; \"&gt;</span><br><span class=\"line\">    &lt;div class=\"headband\"&gt;&lt;/div&gt;</span><br><span class=\"line\">    [样式代码]</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>样式代码 <a href=\"https://link.jianshu.com/?t=https://github.com/blog/273-github-ribbons\" target=\"_blank\" rel=\"noopener\"><strong>看这里</strong></a> ，挑选自己喜欢的样式。</p>\n<p>然后将样式代码添加到上述 <strong>_layout.swig</strong> 代码块后面，比如选择黑色经典款，即：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">&lt;div class=\"&#123;&#123; container_class &#125;&#125; &#123;% block page_class %&#125;&#123;% endblock %&#125; \"&gt;</span><br><span class=\"line\">    &lt;div class=\"headband\"&gt;&lt;/div&gt;</span><br><span class=\"line\">    <span class=\"comment\"># [样式代码]</span></span><br><span class=\"line\">    &lt;a href=\"https://github.com/you\"&gt;&lt;img style=\"position: absolute; top: 0; right: 0; border: 0;\" src=\"https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67\" alt=\"Fork me on GitHub\" data-canonical-src=\"https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png\"&gt;&lt;/a&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>重新部署一下就可以查看了，如果显示不出来，需要清理浏览器的cookie,多刷新几次就OK了。<br>大家看我的，感觉很搭( ⊙ o ⊙ )！<br><img src=\"http://upload-images.jianshu.io/upload_images/2952111-13a15afaa9450272.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"fork me on github\"></p>\n","site":{"data":{}},"excerpt":"<p>给自己的个人博客添加Fork me on GitHub标签感觉很专业很逼格，添加的方法也很简单，介绍如下。</p>\n<p>打开文件：<strong>hexo博客根目录/themes/next/layout/_layout.swig</strong> 找到如下代码块<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">&lt;div class=\"&#123;&#123; container_class &#125;&#125; &#123;% block page_class %&#125;&#123;% endblock %&#125; \"&gt;</span><br><span class=\"line\">    &lt;div class=\"headband\"&gt;&lt;/div&gt;</span><br><span class=\"line\">    [样式代码]</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>","more":"<p>样式代码 <a href=\"https://link.jianshu.com/?t=https://github.com/blog/273-github-ribbons\" target=\"_blank\" rel=\"noopener\"><strong>看这里</strong></a> ，挑选自己喜欢的样式。</p>\n<p>然后将样式代码添加到上述 <strong>_layout.swig</strong> 代码块后面，比如选择黑色经典款，即：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">&lt;div class=\"&#123;&#123; container_class &#125;&#125; &#123;% block page_class %&#125;&#123;% endblock %&#125; \"&gt;</span><br><span class=\"line\">    &lt;div class=\"headband\"&gt;&lt;/div&gt;</span><br><span class=\"line\">    <span class=\"comment\"># [样式代码]</span></span><br><span class=\"line\">    &lt;a href=\"https://github.com/you\"&gt;&lt;img style=\"position: absolute; top: 0; right: 0; border: 0;\" src=\"https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67\" alt=\"Fork me on GitHub\" data-canonical-src=\"https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png\"&gt;&lt;/a&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure></p>\n<p>重新部署一下就可以查看了，如果显示不出来，需要清理浏览器的cookie,多刷新几次就OK了。<br>大家看我的，感觉很搭( ⊙ o ⊙ )！<br><img src=\"http://upload-images.jianshu.io/upload_images/2952111-13a15afaa9450272.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"fork me on github\"></p>"},{"title":"Hexo部署的网站项目(.deploy_git)中添加README.md","date":"2018-02-28T06:05:20.000Z","_content":"终端中执行hexo generate时，会将source文件夹中的.md文件渲染为.html文件到public文件夹中，所以我们可以将README.md文件放到source文件夹中，这样在执行hexo deploy时，生成的.deploy_git文件夹中就会有README文件。但此时并不是我们想要的README.md。\n<!-- more -->\n需要注意的是，我们要防止此.md文件被渲染为.html文件，因此，需要在站点配置文件_config.yml中设置skip_render: README.md，这样部署完成后我们就可以在配置的.deploy_git中看到README.md了。\n\n配置截图如下：\n\n![](http://upload-images.jianshu.io/upload_images/2952111-1ce4c1b9e78bee3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n","source":"_posts/Hexo部署的网站项目-deploy-git-中添加README-md.md","raw":"---\ntitle: Hexo部署的网站项目(.deploy_git)中添加README.md\ndate: 2018-02-28 14:05:20\ntags:\n  - Hexo\ncategories:\n  - Hexo\n---\n终端中执行hexo generate时，会将source文件夹中的.md文件渲染为.html文件到public文件夹中，所以我们可以将README.md文件放到source文件夹中，这样在执行hexo deploy时，生成的.deploy_git文件夹中就会有README文件。但此时并不是我们想要的README.md。\n<!-- more -->\n需要注意的是，我们要防止此.md文件被渲染为.html文件，因此，需要在站点配置文件_config.yml中设置skip_render: README.md，这样部署完成后我们就可以在配置的.deploy_git中看到README.md了。\n\n配置截图如下：\n\n![](http://upload-images.jianshu.io/upload_images/2952111-1ce4c1b9e78bee3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n","slug":"Hexo部署的网站项目-deploy-git-中添加README-md","published":1,"updated":"2018-02-28T06:29:24.312Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozjy000g8mot9sbmbr17","content":"<p>终端中执行hexo generate时，会将source文件夹中的.md文件渲染为.html文件到public文件夹中，所以我们可以将README.md文件放到source文件夹中，这样在执行hexo deploy时，生成的.deploy_git文件夹中就会有README文件。但此时并不是我们想要的README.md。<br><a id=\"more\"></a><br>需要注意的是，我们要防止此.md文件被渲染为.html文件，因此，需要在站点配置文件_config.yml中设置skip_render: README.md，这样部署完成后我们就可以在配置的.deploy_git中看到README.md了。</p>\n<p>配置截图如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-1ce4c1b9e78bee3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p>终端中执行hexo generate时，会将source文件夹中的.md文件渲染为.html文件到public文件夹中，所以我们可以将README.md文件放到source文件夹中，这样在执行hexo deploy时，生成的.deploy_git文件夹中就会有README文件。但此时并不是我们想要的README.md。<br>","more":"<br>需要注意的是，我们要防止此.md文件被渲染为.html文件，因此，需要在站点配置文件_config.yml中设置skip_render: README.md，这样部署完成后我们就可以在配置的.deploy_git中看到README.md了。</p>\n<p>配置截图如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-1ce4c1b9e78bee3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>"},{"title":"IO密集型任务、计算密集型任务，以及多线程、多进程","date":"2018-03-05T02:41:27.000Z","_content":"## IO密集型任务 vs 计算密集型任务\n\n  * 所谓IO密集型任务，是指磁盘IO、网络IO占主要的任务，计算量很小。比如请求网页、读写文件等。当然我们在Python中可以利用sleep达到IO密集型任务的目的。  \n\n  * 所谓计算密集型任务，是指CPU计算占主要的任务，CPU一直处于满负荷状态。比如在一个很大的列表中查找元素（当然这不合理），复杂的加减乘除等。\n\n<!-- more -->\n计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。\n\n计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。\n\n第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。\n\nIO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。\n\n\n## 多线程 VS 多进程\n### 多线程\n多线程即在一个进程中启动多个线程执行任务。一般来说使用多线程可以达到并行的目的，但由于Python中使用了全局解释锁GIL的概念，导致Python中的多线程并不是并行执行，而是“交替执行”。类似于下图：（图片转自网络，侵删）\n\n![](https://pic2.zhimg.com/80/v2-dfad6468a9ddd7edd2494971296a00d0_hd.jpg)\n\n所以Python中的多线程适合IO密集型任务，而不适合计算密集型任务。\n\nPython提供两组多线程接口，一是thread模块_thread，提供低等级接口。二是threading模块，提供更容易使用的基于对象的接口，可以继承Thread对象来实现线程，此外其还提供了其它线程相关的对象，例如Timer，Lock等。\n\n多线程模式通常比多进程快一点，但是也快不到哪去，而且，多线程模式致命的缺点就是任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存。在Windows上，如果一个线程执行的代码出了问题，你经常可以看到这样的提示：“该程序执行了非法操作，即将关闭”，其实往往是某个线程出了问题，但是操作系统会强制结束整个进程。\n\n在Windows下，多线程的效率比多进程要高，所以微软的IIS服务器默认采用多线程模式。由于多线程存在稳定性的问题，IIS的稳定性就不如Apache。为了缓解这个问题，IIS和Apache现在又有多进程+多线程的混合模式，真是把问题越搞越复杂。\n\n### 多进程\n由于Python中GIL的原因，对于计算密集型任务，Python下比较好的并行方式是使用多进程，这样可以非常有效的使用CPU资源。当然同一时间执行的进程数量取决你电脑的CPU核心数。\n\n![](https://pic3.zhimg.com/80/v2-f1cdf422f5aef9a23f714a399e8e7016_hd.jpg)\n\nPython中的进程模块为mutliprocess模块，提供了很多容易使用的基于对象的接口。另外它提供了封装好的管道和队列，可以方便的在进程间传递消息。Python还提供了进程池Pool对象，可以方便的管理和控制线程。\n\n多进程模式最大的`优点`就是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程。（当然主进程挂了所有进程就全挂了，但是Master进程只负责分配任务，挂掉的概率低）著名的Apache最早就是采用多进程模式。\n\n多进程模式的`缺点`是创建进程的代价大，在Unix/Linux系统下，用fork调用还行，在Windows下创建进程开销巨大。另外，操作系统能同时运行的进程数也是有限的，在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都会成问题。\n\n## 举个栗子\n**实例讲解Python中的多线程、多进程如何应对IO密集型任务、计算密集型任务**\n\n这里通过一个实例，说明多线程适合IO密集型任务，多进程适合计算密集型任务。首先定义一个队列，并定义初始化队列的函数：\n\n```Python\nimport multiprocessing\n\n# 定义全局变量Queue\ng_queue = multiprocessing.Queue()\n\ndef init_queue():\n    print(\"init g_queue start\")\n    while not g_queue.empty():\n        print(g_queue.get())\n    for _index in range(10):\n        g_queue.put(_index)\n    print(\"init g_queue end\")\n    return\n```\n定义IO密集型任务和计算密集型任务，分别从队列中获取任务数据\n\n```python\n# 定义一个IO密集型任务：利用time.sleep()\ndef task_io(task_id):\n    print(\"IOTask[%s] start\" % task_id)\n    while not g_queue.empty():\n        time.sleep(1)\n        try:\n            data = g_queue.get(block=True, timeout=1)\n            print(\"IOTask[%s] get data: %s\" % (task_id, data))\n        except Exception as excep:\n            print(\"IOTask[%s] error: %s\" % (task_id, str(excep)))\n    print(\"IOTask[%s] end\" % task_id)\n    return\n\ng_search_list = list(range(10000))\n\n# 定义一个计算密集型任务：利用一些复杂加减乘除、列表查找等\ndef task_cpu(task_id):\n    print(\"CPUTask[%s] start\" % task_id)\n    while not g_queue.empty():\n        count = 0\n        for i in range(10000):\n            count += pow(3*2, 3*2) if i in g_search_list else 0\n        try:\n            data = g_queue.get(block=True, timeout=1)\n            print(\"CPUTask[%s] get data: %s\" % (task_id, data))\n        except Exception as excep:\n            print(\"CPUTask[%s] error: %s\" % (task_id, str(excep)))\n    print(\"CPUTask[%s] end\" % task_id)\n    return task_id\n```\n\n准备完上述代码之后，进行试验：\n```python\nif __name__ == '__main__':\n    print(\"cpu count:\", multiprocessing.cpu_count(), \"\\n\")\n\n    print(\"========== 直接执行IO密集型任务 ==========\")\n    init_queue()\n    time_0 = time.time()\n    task_io(0)\n    print(\"结束：\", time.time() - time_0, \"\\n\")\n\n    print(\"========== 多线程执行IO密集型任务 ==========\")\n    init_queue()\n    time_0 = time.time()\n    thread_list = [threading.Thread(target=task_io, args=(i,)) for i in range(5)]\n    for t in thread_list:\n        t.start()\n    for t in thread_list:\n        if t.is_alive():\n            t.join()\n    print(\"结束：\", time.time() - time_0, \"\\n\")\n\n    print(\"========== 多进程执行IO密集型任务 ==========\")\n    init_queue()\n    time_0 = time.time()\n    process_list = [multiprocessing.Process(target=task_io, args=(i,)) for i in range(multiprocessing.cpu_count())]\n    for p in process_list:\n        p.start()\n    for p in process_list:\n        if p.is_alive():\n            p.join()\n    print(\"结束：\", time.time() - time_0, \"\\n\")\n\n    print(\"========== 直接执行CPU密集型任务 ==========\")\n    init_queue()\n    time_0 = time.time()\n    task_cpu(0)\n    print(\"结束：\", time.time() - time_0, \"\\n\")\n\n    print(\"========== 多线程执行CPU密集型任务 ==========\")\n    init_queue()\n    time_0 = time.time()\n    thread_list = [threading.Thread(target=task_cpu, args=(i,)) for i in range(5)]\n    for t in thread_list:\n        t.start()\n    for t in thread_list:\n        if t.is_alive():\n            t.join()\n    print(\"结束：\", time.time() - time_0, \"\\n\")\n\n    print(\"========== 多进程执行cpu密集型任务 ==========\")\n    init_queue()\n    time_0 = time.time()\n    process_list = [multiprocessing.Process(target=task_cpu, args=(i,)) for i in range(multiprocessing.cpu_count())]\n    for p in process_list:\n        p.start()\n    for p in process_list:\n        if p.is_alive():\n            p.join()\n    print(\"结束：\", time.time() - time_0, \"\\n\")\n\n```\n\n结果说明：\n\n**对于IO密集型任务：**\n\n  * 直接执行用时：10.0333秒\n  * 多线程执行用时：4.0156秒\n  * 多进程执行用时：5.0182秒\n\n说明多线程适合IO密集型任务。\n\n**对于计算密集型任务**  \n\n\n* 直接执行用时：10.0273秒\n* 多线程执行用时：13.247秒\n* 多进程执行用时：6.8377秒\n\n说明多进程适合计算密集型任务\n\n\n## 参考\n\n1. https://zhuanlan.zhihu.com/p/24283040\n","source":"_posts/IO密集型任务、计算密集型任务，以及多线程、多进程.md","raw":"---\ntitle: IO密集型任务、计算密集型任务，以及多线程、多进程\ndate: 2018-03-05 10:41:27\ntags:\n  - 操作系统\ncategories:\n  - 操作系统\n  - 多任务处理\n---\n## IO密集型任务 vs 计算密集型任务\n\n  * 所谓IO密集型任务，是指磁盘IO、网络IO占主要的任务，计算量很小。比如请求网页、读写文件等。当然我们在Python中可以利用sleep达到IO密集型任务的目的。  \n\n  * 所谓计算密集型任务，是指CPU计算占主要的任务，CPU一直处于满负荷状态。比如在一个很大的列表中查找元素（当然这不合理），复杂的加减乘除等。\n\n<!-- more -->\n计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。\n\n计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。\n\n第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。\n\nIO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。\n\n\n## 多线程 VS 多进程\n### 多线程\n多线程即在一个进程中启动多个线程执行任务。一般来说使用多线程可以达到并行的目的，但由于Python中使用了全局解释锁GIL的概念，导致Python中的多线程并不是并行执行，而是“交替执行”。类似于下图：（图片转自网络，侵删）\n\n![](https://pic2.zhimg.com/80/v2-dfad6468a9ddd7edd2494971296a00d0_hd.jpg)\n\n所以Python中的多线程适合IO密集型任务，而不适合计算密集型任务。\n\nPython提供两组多线程接口，一是thread模块_thread，提供低等级接口。二是threading模块，提供更容易使用的基于对象的接口，可以继承Thread对象来实现线程，此外其还提供了其它线程相关的对象，例如Timer，Lock等。\n\n多线程模式通常比多进程快一点，但是也快不到哪去，而且，多线程模式致命的缺点就是任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存。在Windows上，如果一个线程执行的代码出了问题，你经常可以看到这样的提示：“该程序执行了非法操作，即将关闭”，其实往往是某个线程出了问题，但是操作系统会强制结束整个进程。\n\n在Windows下，多线程的效率比多进程要高，所以微软的IIS服务器默认采用多线程模式。由于多线程存在稳定性的问题，IIS的稳定性就不如Apache。为了缓解这个问题，IIS和Apache现在又有多进程+多线程的混合模式，真是把问题越搞越复杂。\n\n### 多进程\n由于Python中GIL的原因，对于计算密集型任务，Python下比较好的并行方式是使用多进程，这样可以非常有效的使用CPU资源。当然同一时间执行的进程数量取决你电脑的CPU核心数。\n\n![](https://pic3.zhimg.com/80/v2-f1cdf422f5aef9a23f714a399e8e7016_hd.jpg)\n\nPython中的进程模块为mutliprocess模块，提供了很多容易使用的基于对象的接口。另外它提供了封装好的管道和队列，可以方便的在进程间传递消息。Python还提供了进程池Pool对象，可以方便的管理和控制线程。\n\n多进程模式最大的`优点`就是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程。（当然主进程挂了所有进程就全挂了，但是Master进程只负责分配任务，挂掉的概率低）著名的Apache最早就是采用多进程模式。\n\n多进程模式的`缺点`是创建进程的代价大，在Unix/Linux系统下，用fork调用还行，在Windows下创建进程开销巨大。另外，操作系统能同时运行的进程数也是有限的，在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都会成问题。\n\n## 举个栗子\n**实例讲解Python中的多线程、多进程如何应对IO密集型任务、计算密集型任务**\n\n这里通过一个实例，说明多线程适合IO密集型任务，多进程适合计算密集型任务。首先定义一个队列，并定义初始化队列的函数：\n\n```Python\nimport multiprocessing\n\n# 定义全局变量Queue\ng_queue = multiprocessing.Queue()\n\ndef init_queue():\n    print(\"init g_queue start\")\n    while not g_queue.empty():\n        print(g_queue.get())\n    for _index in range(10):\n        g_queue.put(_index)\n    print(\"init g_queue end\")\n    return\n```\n定义IO密集型任务和计算密集型任务，分别从队列中获取任务数据\n\n```python\n# 定义一个IO密集型任务：利用time.sleep()\ndef task_io(task_id):\n    print(\"IOTask[%s] start\" % task_id)\n    while not g_queue.empty():\n        time.sleep(1)\n        try:\n            data = g_queue.get(block=True, timeout=1)\n            print(\"IOTask[%s] get data: %s\" % (task_id, data))\n        except Exception as excep:\n            print(\"IOTask[%s] error: %s\" % (task_id, str(excep)))\n    print(\"IOTask[%s] end\" % task_id)\n    return\n\ng_search_list = list(range(10000))\n\n# 定义一个计算密集型任务：利用一些复杂加减乘除、列表查找等\ndef task_cpu(task_id):\n    print(\"CPUTask[%s] start\" % task_id)\n    while not g_queue.empty():\n        count = 0\n        for i in range(10000):\n            count += pow(3*2, 3*2) if i in g_search_list else 0\n        try:\n            data = g_queue.get(block=True, timeout=1)\n            print(\"CPUTask[%s] get data: %s\" % (task_id, data))\n        except Exception as excep:\n            print(\"CPUTask[%s] error: %s\" % (task_id, str(excep)))\n    print(\"CPUTask[%s] end\" % task_id)\n    return task_id\n```\n\n准备完上述代码之后，进行试验：\n```python\nif __name__ == '__main__':\n    print(\"cpu count:\", multiprocessing.cpu_count(), \"\\n\")\n\n    print(\"========== 直接执行IO密集型任务 ==========\")\n    init_queue()\n    time_0 = time.time()\n    task_io(0)\n    print(\"结束：\", time.time() - time_0, \"\\n\")\n\n    print(\"========== 多线程执行IO密集型任务 ==========\")\n    init_queue()\n    time_0 = time.time()\n    thread_list = [threading.Thread(target=task_io, args=(i,)) for i in range(5)]\n    for t in thread_list:\n        t.start()\n    for t in thread_list:\n        if t.is_alive():\n            t.join()\n    print(\"结束：\", time.time() - time_0, \"\\n\")\n\n    print(\"========== 多进程执行IO密集型任务 ==========\")\n    init_queue()\n    time_0 = time.time()\n    process_list = [multiprocessing.Process(target=task_io, args=(i,)) for i in range(multiprocessing.cpu_count())]\n    for p in process_list:\n        p.start()\n    for p in process_list:\n        if p.is_alive():\n            p.join()\n    print(\"结束：\", time.time() - time_0, \"\\n\")\n\n    print(\"========== 直接执行CPU密集型任务 ==========\")\n    init_queue()\n    time_0 = time.time()\n    task_cpu(0)\n    print(\"结束：\", time.time() - time_0, \"\\n\")\n\n    print(\"========== 多线程执行CPU密集型任务 ==========\")\n    init_queue()\n    time_0 = time.time()\n    thread_list = [threading.Thread(target=task_cpu, args=(i,)) for i in range(5)]\n    for t in thread_list:\n        t.start()\n    for t in thread_list:\n        if t.is_alive():\n            t.join()\n    print(\"结束：\", time.time() - time_0, \"\\n\")\n\n    print(\"========== 多进程执行cpu密集型任务 ==========\")\n    init_queue()\n    time_0 = time.time()\n    process_list = [multiprocessing.Process(target=task_cpu, args=(i,)) for i in range(multiprocessing.cpu_count())]\n    for p in process_list:\n        p.start()\n    for p in process_list:\n        if p.is_alive():\n            p.join()\n    print(\"结束：\", time.time() - time_0, \"\\n\")\n\n```\n\n结果说明：\n\n**对于IO密集型任务：**\n\n  * 直接执行用时：10.0333秒\n  * 多线程执行用时：4.0156秒\n  * 多进程执行用时：5.0182秒\n\n说明多线程适合IO密集型任务。\n\n**对于计算密集型任务**  \n\n\n* 直接执行用时：10.0273秒\n* 多线程执行用时：13.247秒\n* 多进程执行用时：6.8377秒\n\n说明多进程适合计算密集型任务\n\n\n## 参考\n\n1. https://zhuanlan.zhihu.com/p/24283040\n","slug":"IO密集型任务、计算密集型任务，以及多线程、多进程","published":1,"updated":"2018-03-05T15:54:17.211Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozk1000k8mot56mf2f1x","content":"<h2 id=\"IO密集型任务-vs-计算密集型任务\"><a href=\"#IO密集型任务-vs-计算密集型任务\" class=\"headerlink\" title=\"IO密集型任务 vs 计算密集型任务\"></a>IO密集型任务 vs 计算密集型任务</h2><ul>\n<li><p>所谓IO密集型任务，是指磁盘IO、网络IO占主要的任务，计算量很小。比如请求网页、读写文件等。当然我们在Python中可以利用sleep达到IO密集型任务的目的。  </p>\n</li>\n<li><p>所谓计算密集型任务，是指CPU计算占主要的任务，CPU一直处于满负荷状态。比如在一个很大的列表中查找元素（当然这不合理），复杂的加减乘除等。</p>\n</li>\n</ul>\n<a id=\"more\"></a>\n<p>计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。</p>\n<p>计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。</p>\n<p>第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。</p>\n<p>IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。</p>\n<h2 id=\"多线程-VS-多进程\"><a href=\"#多线程-VS-多进程\" class=\"headerlink\" title=\"多线程 VS 多进程\"></a>多线程 VS 多进程</h2><h3 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h3><p>多线程即在一个进程中启动多个线程执行任务。一般来说使用多线程可以达到并行的目的，但由于Python中使用了全局解释锁GIL的概念，导致Python中的多线程并不是并行执行，而是“交替执行”。类似于下图：（图片转自网络，侵删）</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-dfad6468a9ddd7edd2494971296a00d0_hd.jpg\" alt=\"\"></p>\n<p>所以Python中的多线程适合IO密集型任务，而不适合计算密集型任务。</p>\n<p>Python提供两组多线程接口，一是thread模块_thread，提供低等级接口。二是threading模块，提供更容易使用的基于对象的接口，可以继承Thread对象来实现线程，此外其还提供了其它线程相关的对象，例如Timer，Lock等。</p>\n<p>多线程模式通常比多进程快一点，但是也快不到哪去，而且，多线程模式致命的缺点就是任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存。在Windows上，如果一个线程执行的代码出了问题，你经常可以看到这样的提示：“该程序执行了非法操作，即将关闭”，其实往往是某个线程出了问题，但是操作系统会强制结束整个进程。</p>\n<p>在Windows下，多线程的效率比多进程要高，所以微软的IIS服务器默认采用多线程模式。由于多线程存在稳定性的问题，IIS的稳定性就不如Apache。为了缓解这个问题，IIS和Apache现在又有多进程+多线程的混合模式，真是把问题越搞越复杂。</p>\n<h3 id=\"多进程\"><a href=\"#多进程\" class=\"headerlink\" title=\"多进程\"></a>多进程</h3><p>由于Python中GIL的原因，对于计算密集型任务，Python下比较好的并行方式是使用多进程，这样可以非常有效的使用CPU资源。当然同一时间执行的进程数量取决你电脑的CPU核心数。</p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-f1cdf422f5aef9a23f714a399e8e7016_hd.jpg\" alt=\"\"></p>\n<p>Python中的进程模块为mutliprocess模块，提供了很多容易使用的基于对象的接口。另外它提供了封装好的管道和队列，可以方便的在进程间传递消息。Python还提供了进程池Pool对象，可以方便的管理和控制线程。</p>\n<p>多进程模式最大的<code>优点</code>就是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程。（当然主进程挂了所有进程就全挂了，但是Master进程只负责分配任务，挂掉的概率低）著名的Apache最早就是采用多进程模式。</p>\n<p>多进程模式的<code>缺点</code>是创建进程的代价大，在Unix/Linux系统下，用fork调用还行，在Windows下创建进程开销巨大。另外，操作系统能同时运行的进程数也是有限的，在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都会成问题。</p>\n<h2 id=\"举个栗子\"><a href=\"#举个栗子\" class=\"headerlink\" title=\"举个栗子\"></a>举个栗子</h2><p><strong>实例讲解Python中的多线程、多进程如何应对IO密集型任务、计算密集型任务</strong></p>\n<p>这里通过一个实例，说明多线程适合IO密集型任务，多进程适合计算密集型任务。首先定义一个队列，并定义初始化队列的函数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> multiprocessing</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义全局变量Queue</span></span><br><span class=\"line\">g_queue = multiprocessing.Queue()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">init_queue</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"init g_queue start\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> g_queue.empty():</span><br><span class=\"line\">        print(g_queue.get())</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _index <span class=\"keyword\">in</span> range(<span class=\"number\">10</span>):</span><br><span class=\"line\">        g_queue.put(_index)</span><br><span class=\"line\">    print(<span class=\"string\">\"init g_queue end\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br></pre></td></tr></table></figure>\n<p>定义IO密集型任务和计算密集型任务，分别从队列中获取任务数据</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 定义一个IO密集型任务：利用time.sleep()</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">task_io</span><span class=\"params\">(task_id)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"IOTask[%s] start\"</span> % task_id)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> g_queue.empty():</span><br><span class=\"line\">        time.sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            data = g_queue.get(block=<span class=\"keyword\">True</span>, timeout=<span class=\"number\">1</span>)</span><br><span class=\"line\">            print(<span class=\"string\">\"IOTask[%s] get data: %s\"</span> % (task_id, data))</span><br><span class=\"line\">        <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> excep:</span><br><span class=\"line\">            print(<span class=\"string\">\"IOTask[%s] error: %s\"</span> % (task_id, str(excep)))</span><br><span class=\"line\">    print(<span class=\"string\">\"IOTask[%s] end\"</span> % task_id)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">g_search_list = list(range(<span class=\"number\">10000</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义一个计算密集型任务：利用一些复杂加减乘除、列表查找等</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">task_cpu</span><span class=\"params\">(task_id)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"CPUTask[%s] start\"</span> % task_id)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> g_queue.empty():</span><br><span class=\"line\">        count = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">10000</span>):</span><br><span class=\"line\">            count += pow(<span class=\"number\">3</span>*<span class=\"number\">2</span>, <span class=\"number\">3</span>*<span class=\"number\">2</span>) <span class=\"keyword\">if</span> i <span class=\"keyword\">in</span> g_search_list <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            data = g_queue.get(block=<span class=\"keyword\">True</span>, timeout=<span class=\"number\">1</span>)</span><br><span class=\"line\">            print(<span class=\"string\">\"CPUTask[%s] get data: %s\"</span> % (task_id, data))</span><br><span class=\"line\">        <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> excep:</span><br><span class=\"line\">            print(<span class=\"string\">\"CPUTask[%s] error: %s\"</span> % (task_id, str(excep)))</span><br><span class=\"line\">    print(<span class=\"string\">\"CPUTask[%s] end\"</span> % task_id)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> task_id</span><br></pre></td></tr></table></figure>\n<p>准备完上述代码之后，进行试验：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    print(<span class=\"string\">\"cpu count:\"</span>, multiprocessing.cpu_count(), <span class=\"string\">\"\\n\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    print(<span class=\"string\">\"========== 直接执行IO密集型任务 ==========\"</span>)</span><br><span class=\"line\">    init_queue()</span><br><span class=\"line\">    time_0 = time.time()</span><br><span class=\"line\">    task_io(<span class=\"number\">0</span>)</span><br><span class=\"line\">    print(<span class=\"string\">\"结束：\"</span>, time.time() - time_0, <span class=\"string\">\"\\n\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    print(<span class=\"string\">\"========== 多线程执行IO密集型任务 ==========\"</span>)</span><br><span class=\"line\">    init_queue()</span><br><span class=\"line\">    time_0 = time.time()</span><br><span class=\"line\">    thread_list = [threading.Thread(target=task_io, args=(i,)) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">5</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> thread_list:</span><br><span class=\"line\">        t.start()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> thread_list:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> t.is_alive():</span><br><span class=\"line\">            t.join()</span><br><span class=\"line\">    print(<span class=\"string\">\"结束：\"</span>, time.time() - time_0, <span class=\"string\">\"\\n\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    print(<span class=\"string\">\"========== 多进程执行IO密集型任务 ==========\"</span>)</span><br><span class=\"line\">    init_queue()</span><br><span class=\"line\">    time_0 = time.time()</span><br><span class=\"line\">    process_list = [multiprocessing.Process(target=task_io, args=(i,)) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(multiprocessing.cpu_count())]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> process_list:</span><br><span class=\"line\">        p.start()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> process_list:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> p.is_alive():</span><br><span class=\"line\">            p.join()</span><br><span class=\"line\">    print(<span class=\"string\">\"结束：\"</span>, time.time() - time_0, <span class=\"string\">\"\\n\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    print(<span class=\"string\">\"========== 直接执行CPU密集型任务 ==========\"</span>)</span><br><span class=\"line\">    init_queue()</span><br><span class=\"line\">    time_0 = time.time()</span><br><span class=\"line\">    task_cpu(<span class=\"number\">0</span>)</span><br><span class=\"line\">    print(<span class=\"string\">\"结束：\"</span>, time.time() - time_0, <span class=\"string\">\"\\n\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    print(<span class=\"string\">\"========== 多线程执行CPU密集型任务 ==========\"</span>)</span><br><span class=\"line\">    init_queue()</span><br><span class=\"line\">    time_0 = time.time()</span><br><span class=\"line\">    thread_list = [threading.Thread(target=task_cpu, args=(i,)) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">5</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> thread_list:</span><br><span class=\"line\">        t.start()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> thread_list:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> t.is_alive():</span><br><span class=\"line\">            t.join()</span><br><span class=\"line\">    print(<span class=\"string\">\"结束：\"</span>, time.time() - time_0, <span class=\"string\">\"\\n\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    print(<span class=\"string\">\"========== 多进程执行cpu密集型任务 ==========\"</span>)</span><br><span class=\"line\">    init_queue()</span><br><span class=\"line\">    time_0 = time.time()</span><br><span class=\"line\">    process_list = [multiprocessing.Process(target=task_cpu, args=(i,)) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(multiprocessing.cpu_count())]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> process_list:</span><br><span class=\"line\">        p.start()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> process_list:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> p.is_alive():</span><br><span class=\"line\">            p.join()</span><br><span class=\"line\">    print(<span class=\"string\">\"结束：\"</span>, time.time() - time_0, <span class=\"string\">\"\\n\"</span>)</span><br></pre></td></tr></table></figure></p>\n<p>结果说明：</p>\n<p><strong>对于IO密集型任务：</strong></p>\n<ul>\n<li>直接执行用时：10.0333秒</li>\n<li>多线程执行用时：4.0156秒</li>\n<li>多进程执行用时：5.0182秒</li>\n</ul>\n<p>说明多线程适合IO密集型任务。</p>\n<p><strong>对于计算密集型任务</strong>  </p>\n<ul>\n<li>直接执行用时：10.0273秒</li>\n<li>多线程执行用时：13.247秒</li>\n<li>多进程执行用时：6.8377秒</li>\n</ul>\n<p>说明多进程适合计算密集型任务</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://zhuanlan.zhihu.com/p/24283040\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/24283040</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"IO密集型任务-vs-计算密集型任务\"><a href=\"#IO密集型任务-vs-计算密集型任务\" class=\"headerlink\" title=\"IO密集型任务 vs 计算密集型任务\"></a>IO密集型任务 vs 计算密集型任务</h2><ul>\n<li><p>所谓IO密集型任务，是指磁盘IO、网络IO占主要的任务，计算量很小。比如请求网页、读写文件等。当然我们在Python中可以利用sleep达到IO密集型任务的目的。  </p>\n</li>\n<li><p>所谓计算密集型任务，是指CPU计算占主要的任务，CPU一直处于满负荷状态。比如在一个很大的列表中查找元素（当然这不合理），复杂的加减乘除等。</p>\n</li>\n</ul>","more":"<p>计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。</p>\n<p>计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。</p>\n<p>第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。</p>\n<p>IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。</p>\n<h2 id=\"多线程-VS-多进程\"><a href=\"#多线程-VS-多进程\" class=\"headerlink\" title=\"多线程 VS 多进程\"></a>多线程 VS 多进程</h2><h3 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h3><p>多线程即在一个进程中启动多个线程执行任务。一般来说使用多线程可以达到并行的目的，但由于Python中使用了全局解释锁GIL的概念，导致Python中的多线程并不是并行执行，而是“交替执行”。类似于下图：（图片转自网络，侵删）</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-dfad6468a9ddd7edd2494971296a00d0_hd.jpg\" alt=\"\"></p>\n<p>所以Python中的多线程适合IO密集型任务，而不适合计算密集型任务。</p>\n<p>Python提供两组多线程接口，一是thread模块_thread，提供低等级接口。二是threading模块，提供更容易使用的基于对象的接口，可以继承Thread对象来实现线程，此外其还提供了其它线程相关的对象，例如Timer，Lock等。</p>\n<p>多线程模式通常比多进程快一点，但是也快不到哪去，而且，多线程模式致命的缺点就是任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存。在Windows上，如果一个线程执行的代码出了问题，你经常可以看到这样的提示：“该程序执行了非法操作，即将关闭”，其实往往是某个线程出了问题，但是操作系统会强制结束整个进程。</p>\n<p>在Windows下，多线程的效率比多进程要高，所以微软的IIS服务器默认采用多线程模式。由于多线程存在稳定性的问题，IIS的稳定性就不如Apache。为了缓解这个问题，IIS和Apache现在又有多进程+多线程的混合模式，真是把问题越搞越复杂。</p>\n<h3 id=\"多进程\"><a href=\"#多进程\" class=\"headerlink\" title=\"多进程\"></a>多进程</h3><p>由于Python中GIL的原因，对于计算密集型任务，Python下比较好的并行方式是使用多进程，这样可以非常有效的使用CPU资源。当然同一时间执行的进程数量取决你电脑的CPU核心数。</p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-f1cdf422f5aef9a23f714a399e8e7016_hd.jpg\" alt=\"\"></p>\n<p>Python中的进程模块为mutliprocess模块，提供了很多容易使用的基于对象的接口。另外它提供了封装好的管道和队列，可以方便的在进程间传递消息。Python还提供了进程池Pool对象，可以方便的管理和控制线程。</p>\n<p>多进程模式最大的<code>优点</code>就是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程。（当然主进程挂了所有进程就全挂了，但是Master进程只负责分配任务，挂掉的概率低）著名的Apache最早就是采用多进程模式。</p>\n<p>多进程模式的<code>缺点</code>是创建进程的代价大，在Unix/Linux系统下，用fork调用还行，在Windows下创建进程开销巨大。另外，操作系统能同时运行的进程数也是有限的，在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都会成问题。</p>\n<h2 id=\"举个栗子\"><a href=\"#举个栗子\" class=\"headerlink\" title=\"举个栗子\"></a>举个栗子</h2><p><strong>实例讲解Python中的多线程、多进程如何应对IO密集型任务、计算密集型任务</strong></p>\n<p>这里通过一个实例，说明多线程适合IO密集型任务，多进程适合计算密集型任务。首先定义一个队列，并定义初始化队列的函数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> multiprocessing</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义全局变量Queue</span></span><br><span class=\"line\">g_queue = multiprocessing.Queue()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">init_queue</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"init g_queue start\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> g_queue.empty():</span><br><span class=\"line\">        print(g_queue.get())</span><br><span class=\"line\">    <span class=\"keyword\">for</span> _index <span class=\"keyword\">in</span> range(<span class=\"number\">10</span>):</span><br><span class=\"line\">        g_queue.put(_index)</span><br><span class=\"line\">    print(<span class=\"string\">\"init g_queue end\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br></pre></td></tr></table></figure>\n<p>定义IO密集型任务和计算密集型任务，分别从队列中获取任务数据</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 定义一个IO密集型任务：利用time.sleep()</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">task_io</span><span class=\"params\">(task_id)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"IOTask[%s] start\"</span> % task_id)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> g_queue.empty():</span><br><span class=\"line\">        time.sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            data = g_queue.get(block=<span class=\"keyword\">True</span>, timeout=<span class=\"number\">1</span>)</span><br><span class=\"line\">            print(<span class=\"string\">\"IOTask[%s] get data: %s\"</span> % (task_id, data))</span><br><span class=\"line\">        <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> excep:</span><br><span class=\"line\">            print(<span class=\"string\">\"IOTask[%s] error: %s\"</span> % (task_id, str(excep)))</span><br><span class=\"line\">    print(<span class=\"string\">\"IOTask[%s] end\"</span> % task_id)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">g_search_list = list(range(<span class=\"number\">10000</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义一个计算密集型任务：利用一些复杂加减乘除、列表查找等</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">task_cpu</span><span class=\"params\">(task_id)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"CPUTask[%s] start\"</span> % task_id)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> g_queue.empty():</span><br><span class=\"line\">        count = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">10000</span>):</span><br><span class=\"line\">            count += pow(<span class=\"number\">3</span>*<span class=\"number\">2</span>, <span class=\"number\">3</span>*<span class=\"number\">2</span>) <span class=\"keyword\">if</span> i <span class=\"keyword\">in</span> g_search_list <span class=\"keyword\">else</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            data = g_queue.get(block=<span class=\"keyword\">True</span>, timeout=<span class=\"number\">1</span>)</span><br><span class=\"line\">            print(<span class=\"string\">\"CPUTask[%s] get data: %s\"</span> % (task_id, data))</span><br><span class=\"line\">        <span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> excep:</span><br><span class=\"line\">            print(<span class=\"string\">\"CPUTask[%s] error: %s\"</span> % (task_id, str(excep)))</span><br><span class=\"line\">    print(<span class=\"string\">\"CPUTask[%s] end\"</span> % task_id)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> task_id</span><br></pre></td></tr></table></figure>\n<p>准备完上述代码之后，进行试验：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    print(<span class=\"string\">\"cpu count:\"</span>, multiprocessing.cpu_count(), <span class=\"string\">\"\\n\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    print(<span class=\"string\">\"========== 直接执行IO密集型任务 ==========\"</span>)</span><br><span class=\"line\">    init_queue()</span><br><span class=\"line\">    time_0 = time.time()</span><br><span class=\"line\">    task_io(<span class=\"number\">0</span>)</span><br><span class=\"line\">    print(<span class=\"string\">\"结束：\"</span>, time.time() - time_0, <span class=\"string\">\"\\n\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    print(<span class=\"string\">\"========== 多线程执行IO密集型任务 ==========\"</span>)</span><br><span class=\"line\">    init_queue()</span><br><span class=\"line\">    time_0 = time.time()</span><br><span class=\"line\">    thread_list = [threading.Thread(target=task_io, args=(i,)) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">5</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> thread_list:</span><br><span class=\"line\">        t.start()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> thread_list:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> t.is_alive():</span><br><span class=\"line\">            t.join()</span><br><span class=\"line\">    print(<span class=\"string\">\"结束：\"</span>, time.time() - time_0, <span class=\"string\">\"\\n\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    print(<span class=\"string\">\"========== 多进程执行IO密集型任务 ==========\"</span>)</span><br><span class=\"line\">    init_queue()</span><br><span class=\"line\">    time_0 = time.time()</span><br><span class=\"line\">    process_list = [multiprocessing.Process(target=task_io, args=(i,)) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(multiprocessing.cpu_count())]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> process_list:</span><br><span class=\"line\">        p.start()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> process_list:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> p.is_alive():</span><br><span class=\"line\">            p.join()</span><br><span class=\"line\">    print(<span class=\"string\">\"结束：\"</span>, time.time() - time_0, <span class=\"string\">\"\\n\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    print(<span class=\"string\">\"========== 直接执行CPU密集型任务 ==========\"</span>)</span><br><span class=\"line\">    init_queue()</span><br><span class=\"line\">    time_0 = time.time()</span><br><span class=\"line\">    task_cpu(<span class=\"number\">0</span>)</span><br><span class=\"line\">    print(<span class=\"string\">\"结束：\"</span>, time.time() - time_0, <span class=\"string\">\"\\n\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    print(<span class=\"string\">\"========== 多线程执行CPU密集型任务 ==========\"</span>)</span><br><span class=\"line\">    init_queue()</span><br><span class=\"line\">    time_0 = time.time()</span><br><span class=\"line\">    thread_list = [threading.Thread(target=task_cpu, args=(i,)) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">5</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> thread_list:</span><br><span class=\"line\">        t.start()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> t <span class=\"keyword\">in</span> thread_list:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> t.is_alive():</span><br><span class=\"line\">            t.join()</span><br><span class=\"line\">    print(<span class=\"string\">\"结束：\"</span>, time.time() - time_0, <span class=\"string\">\"\\n\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    print(<span class=\"string\">\"========== 多进程执行cpu密集型任务 ==========\"</span>)</span><br><span class=\"line\">    init_queue()</span><br><span class=\"line\">    time_0 = time.time()</span><br><span class=\"line\">    process_list = [multiprocessing.Process(target=task_cpu, args=(i,)) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(multiprocessing.cpu_count())]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> process_list:</span><br><span class=\"line\">        p.start()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> p <span class=\"keyword\">in</span> process_list:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> p.is_alive():</span><br><span class=\"line\">            p.join()</span><br><span class=\"line\">    print(<span class=\"string\">\"结束：\"</span>, time.time() - time_0, <span class=\"string\">\"\\n\"</span>)</span><br></pre></td></tr></table></figure></p>\n<p>结果说明：</p>\n<p><strong>对于IO密集型任务：</strong></p>\n<ul>\n<li>直接执行用时：10.0333秒</li>\n<li>多线程执行用时：4.0156秒</li>\n<li>多进程执行用时：5.0182秒</li>\n</ul>\n<p>说明多线程适合IO密集型任务。</p>\n<p><strong>对于计算密集型任务</strong>  </p>\n<ul>\n<li>直接执行用时：10.0273秒</li>\n<li>多线程执行用时：13.247秒</li>\n<li>多进程执行用时：6.8377秒</li>\n</ul>\n<p>说明多进程适合计算密集型任务</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://zhuanlan.zhihu.com/p/24283040\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/24283040</a></li>\n</ol>"},{"title":"Linux之crontab命令","date":"2018-05-05T15:24:12.000Z","_content":"## tldr 基本用法\n```bash\nSchedule cron jobs to run on a time interval for the current user.\nJob definition format: \"(min) (hour) (day_of_month) (month) (day_of_week) command_to_execute\".\n\n- Edit the crontab file for the current user:\n    crontab -e\n\n- View a list of existing cron jobs for current user:\n    crontab -l\n\n- Remove all cron jobs for the current user:\n    crontab -r\n\n- Sample job which runs at 10:00 every day. * means any value:\n    0 10 * * * path/to/script.sh\n\n- Sample job which runs every minute on the 3rd of April:\n    * * 3 Apr * path/to/script.sh\n\n- Sample job which runs at 02:30 every Friday:\n    30 2 * * Fri path/to/script.sh\n```\n<!-- more -->\n## 时间格式\ncrontab通过固定的的时间设置格式设置任务的执行时间\n```python\n# Example of job definition:\n# .---------------- minute (0 - 59)\n# |  .------------- hour (0 - 23)\n# |  |  .---------- day of month (1 - 31)\n# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...\n# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat\n# |  |  |  |  |\n# *  *  *  *  * user-name command to be executed\n```\n第一个参数代表分，其次是小时，然后是日期，之后是月份，最后是所在周的周几。各个字段可以使用特殊字符来代表时间逻辑。\n\n```python\n星号（*）：        代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。\n逗号（a,b,c）： 可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”\n中杠（x-y）：    可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”\n正斜线（/）：    可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。\n组合（*/x）：    指定时间类型下，每x分钟或每小时执行一次\n组合(x-y/z)：    指定时间类型下，从x到y时间段内，每z分或每z秒执行一次\n```\n如果是当前用户设置自己的定时任务，可以直接通过crontab -e编辑任务，命令格式* * * * * command即可。\n编辑好任务需要重启crontab，注意需要以root身份执行。\n","source":"_posts/Linux之crontab命令.md","raw":"---\ntitle: Linux之crontab命令\ndate: 2018-05-05 23:24:12\ntags:\n  - Linux/Mac OS\ncategories:\n  - Linux/Mac OS\n---\n## tldr 基本用法\n```bash\nSchedule cron jobs to run on a time interval for the current user.\nJob definition format: \"(min) (hour) (day_of_month) (month) (day_of_week) command_to_execute\".\n\n- Edit the crontab file for the current user:\n    crontab -e\n\n- View a list of existing cron jobs for current user:\n    crontab -l\n\n- Remove all cron jobs for the current user:\n    crontab -r\n\n- Sample job which runs at 10:00 every day. * means any value:\n    0 10 * * * path/to/script.sh\n\n- Sample job which runs every minute on the 3rd of April:\n    * * 3 Apr * path/to/script.sh\n\n- Sample job which runs at 02:30 every Friday:\n    30 2 * * Fri path/to/script.sh\n```\n<!-- more -->\n## 时间格式\ncrontab通过固定的的时间设置格式设置任务的执行时间\n```python\n# Example of job definition:\n# .---------------- minute (0 - 59)\n# |  .------------- hour (0 - 23)\n# |  |  .---------- day of month (1 - 31)\n# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...\n# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat\n# |  |  |  |  |\n# *  *  *  *  * user-name command to be executed\n```\n第一个参数代表分，其次是小时，然后是日期，之后是月份，最后是所在周的周几。各个字段可以使用特殊字符来代表时间逻辑。\n\n```python\n星号（*）：        代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。\n逗号（a,b,c）： 可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”\n中杠（x-y）：    可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”\n正斜线（/）：    可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。\n组合（*/x）：    指定时间类型下，每x分钟或每小时执行一次\n组合(x-y/z)：    指定时间类型下，从x到y时间段内，每z分或每z秒执行一次\n```\n如果是当前用户设置自己的定时任务，可以直接通过crontab -e编辑任务，命令格式* * * * * command即可。\n编辑好任务需要重启crontab，注意需要以root身份执行。\n","slug":"Linux之crontab命令","published":1,"updated":"2018-05-08T10:14:10.479Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozk5000m8motg8ruodzq","content":"<h2 id=\"tldr-基本用法\"><a href=\"#tldr-基本用法\" class=\"headerlink\" title=\"tldr 基本用法\"></a>tldr 基本用法</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Schedule cron <span class=\"built_in\">jobs</span> to run on a time interval <span class=\"keyword\">for</span> the current user.</span><br><span class=\"line\">Job definition format: <span class=\"string\">\"(min) (hour) (day_of_month) (month) (day_of_week) command_to_execute\"</span>.</span><br><span class=\"line\"></span><br><span class=\"line\">- Edit the crontab file <span class=\"keyword\">for</span> the current user:</span><br><span class=\"line\">    crontab -e</span><br><span class=\"line\"></span><br><span class=\"line\">- View a list of existing cron <span class=\"built_in\">jobs</span> <span class=\"keyword\">for</span> current user:</span><br><span class=\"line\">    crontab -l</span><br><span class=\"line\"></span><br><span class=\"line\">- Remove all cron <span class=\"built_in\">jobs</span> <span class=\"keyword\">for</span> the current user:</span><br><span class=\"line\">    crontab -r</span><br><span class=\"line\"></span><br><span class=\"line\">- Sample job <span class=\"built_in\">which</span> runs at 10:00 every day. * means any value:</span><br><span class=\"line\">    0 10 * * * path/to/script.sh</span><br><span class=\"line\"></span><br><span class=\"line\">- Sample job <span class=\"built_in\">which</span> runs every minute on the 3rd of April:</span><br><span class=\"line\">    * * 3 Apr * path/to/script.sh</span><br><span class=\"line\"></span><br><span class=\"line\">- Sample job <span class=\"built_in\">which</span> runs at 02:30 every Friday:</span><br><span class=\"line\">    30 2 * * Fri path/to/script.sh</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h2 id=\"时间格式\"><a href=\"#时间格式\" class=\"headerlink\" title=\"时间格式\"></a>时间格式</h2><p>crontab通过固定的的时间设置格式设置任务的执行时间<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Example of job definition:</span></span><br><span class=\"line\"><span class=\"comment\"># .---------------- minute (0 - 59)</span></span><br><span class=\"line\"><span class=\"comment\"># |  .------------- hour (0 - 23)</span></span><br><span class=\"line\"><span class=\"comment\"># |  |  .---------- day of month (1 - 31)</span></span><br><span class=\"line\"><span class=\"comment\"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class=\"line\"><span class=\"comment\"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span></span><br><span class=\"line\"><span class=\"comment\"># |  |  |  |  |</span></span><br><span class=\"line\"><span class=\"comment\"># *  *  *  *  * user-name command to be executed</span></span><br></pre></td></tr></table></figure></p>\n<p>第一个参数代表分，其次是小时，然后是日期，之后是月份，最后是所在周的周几。各个字段可以使用特殊字符来代表时间逻辑。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">星号（*）：        代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。</span><br><span class=\"line\">逗号（a,b,c）： 可以用逗号隔开的值指定一个列表范围，例如，“<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>”</span><br><span class=\"line\">中杠（x-y）：    可以用整数之间的中杠表示一个整数范围，例如“<span class=\"number\">2</span><span class=\"number\">-6</span>”表示“<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>”</span><br><span class=\"line\">正斜线（/）：    可以用正斜线指定时间的间隔频率，例如“<span class=\"number\">0</span><span class=\"number\">-23</span>/<span class=\"number\">2</span>”表示每两小时执行一次。</span><br><span class=\"line\">组合（*/x）：    指定时间类型下，每x分钟或每小时执行一次</span><br><span class=\"line\">组合(x-y/z)：    指定时间类型下，从x到y时间段内，每z分或每z秒执行一次</span><br></pre></td></tr></table></figure>\n<p>如果是当前用户设置自己的定时任务，可以直接通过crontab -e编辑任务，命令格式<em> </em> <em> </em> * command即可。<br>编辑好任务需要重启crontab，注意需要以root身份执行。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"tldr-基本用法\"><a href=\"#tldr-基本用法\" class=\"headerlink\" title=\"tldr 基本用法\"></a>tldr 基本用法</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Schedule cron <span class=\"built_in\">jobs</span> to run on a time interval <span class=\"keyword\">for</span> the current user.</span><br><span class=\"line\">Job definition format: <span class=\"string\">\"(min) (hour) (day_of_month) (month) (day_of_week) command_to_execute\"</span>.</span><br><span class=\"line\"></span><br><span class=\"line\">- Edit the crontab file <span class=\"keyword\">for</span> the current user:</span><br><span class=\"line\">    crontab -e</span><br><span class=\"line\"></span><br><span class=\"line\">- View a list of existing cron <span class=\"built_in\">jobs</span> <span class=\"keyword\">for</span> current user:</span><br><span class=\"line\">    crontab -l</span><br><span class=\"line\"></span><br><span class=\"line\">- Remove all cron <span class=\"built_in\">jobs</span> <span class=\"keyword\">for</span> the current user:</span><br><span class=\"line\">    crontab -r</span><br><span class=\"line\"></span><br><span class=\"line\">- Sample job <span class=\"built_in\">which</span> runs at 10:00 every day. * means any value:</span><br><span class=\"line\">    0 10 * * * path/to/script.sh</span><br><span class=\"line\"></span><br><span class=\"line\">- Sample job <span class=\"built_in\">which</span> runs every minute on the 3rd of April:</span><br><span class=\"line\">    * * 3 Apr * path/to/script.sh</span><br><span class=\"line\"></span><br><span class=\"line\">- Sample job <span class=\"built_in\">which</span> runs at 02:30 every Friday:</span><br><span class=\"line\">    30 2 * * Fri path/to/script.sh</span><br></pre></td></tr></table></figure>","more":"<h2 id=\"时间格式\"><a href=\"#时间格式\" class=\"headerlink\" title=\"时间格式\"></a>时间格式</h2><p>crontab通过固定的的时间设置格式设置任务的执行时间<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Example of job definition:</span></span><br><span class=\"line\"><span class=\"comment\"># .---------------- minute (0 - 59)</span></span><br><span class=\"line\"><span class=\"comment\"># |  .------------- hour (0 - 23)</span></span><br><span class=\"line\"><span class=\"comment\"># |  |  .---------- day of month (1 - 31)</span></span><br><span class=\"line\"><span class=\"comment\"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class=\"line\"><span class=\"comment\"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span></span><br><span class=\"line\"><span class=\"comment\"># |  |  |  |  |</span></span><br><span class=\"line\"><span class=\"comment\"># *  *  *  *  * user-name command to be executed</span></span><br></pre></td></tr></table></figure></p>\n<p>第一个参数代表分，其次是小时，然后是日期，之后是月份，最后是所在周的周几。各个字段可以使用特殊字符来代表时间逻辑。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">星号（*）：        代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。</span><br><span class=\"line\">逗号（a,b,c）： 可以用逗号隔开的值指定一个列表范围，例如，“<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>”</span><br><span class=\"line\">中杠（x-y）：    可以用整数之间的中杠表示一个整数范围，例如“<span class=\"number\">2</span><span class=\"number\">-6</span>”表示“<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>”</span><br><span class=\"line\">正斜线（/）：    可以用正斜线指定时间的间隔频率，例如“<span class=\"number\">0</span><span class=\"number\">-23</span>/<span class=\"number\">2</span>”表示每两小时执行一次。</span><br><span class=\"line\">组合（*/x）：    指定时间类型下，每x分钟或每小时执行一次</span><br><span class=\"line\">组合(x-y/z)：    指定时间类型下，从x到y时间段内，每z分或每z秒执行一次</span><br></pre></td></tr></table></figure>\n<p>如果是当前用户设置自己的定时任务，可以直接通过crontab -e编辑任务，命令格式<em> </em> <em> </em> * command即可。<br>编辑好任务需要重启crontab，注意需要以root身份执行。</p>"},{"title":"Mac OS 命令之文件(夹)删除","date":"2018-03-03T05:40:34.000Z","_content":"`rmdir`删除空目录，不过一旦目录非空会提示\nDirectiry not empty\n\n使用`rm`既可以删除文件又可以删除文件夹\n删除文件夹（无论文件夹是否为空），使用 `-rf` 命令即可。\n即：\n```bash\n$ rm -rf 目录名字\n```\n`-r` 就是向下递归，不管有多少级目录，一并删除\n`-f` 就是直接强行删除，不作任何提示的意思\n<!-- more -->\n删除`文件夹`实例：\n```bash\n$ rm -rf  /User/Dhyana/desktop\n```\n将会删除 /User/Dhyana/desktop目录以及其下所有文件、文件夹\n\n删除`文件`使用实例：\n```bash\n$ rm -f  /User/Dhyana/desktop/test.py\n```\n将会**强制删除**/User/Dhyana/desktop/test.py这个文件\n\n值得注意的是：\n使用这个rm -rf的时候一定要格外小心，linux没有回收站的，删除之后再想找回就很难了。有一个非常好笑的笑话就是命令行中输入\n```bash\n$ rm -rf /.*\n# 千万不要输入此命令，否则清空整个操作系统，后果自负\n```\n","source":"_posts/Mac-OS-命令之文件-夹-删除.md","raw":"---\ntitle: Mac OS 命令之文件(夹)删除\ndate: 2018-03-03 13:40:34\ntags:\n  - Linux/Mac OS\ncategories:\n  - Linux/Mac OS\n---\n`rmdir`删除空目录，不过一旦目录非空会提示\nDirectiry not empty\n\n使用`rm`既可以删除文件又可以删除文件夹\n删除文件夹（无论文件夹是否为空），使用 `-rf` 命令即可。\n即：\n```bash\n$ rm -rf 目录名字\n```\n`-r` 就是向下递归，不管有多少级目录，一并删除\n`-f` 就是直接强行删除，不作任何提示的意思\n<!-- more -->\n删除`文件夹`实例：\n```bash\n$ rm -rf  /User/Dhyana/desktop\n```\n将会删除 /User/Dhyana/desktop目录以及其下所有文件、文件夹\n\n删除`文件`使用实例：\n```bash\n$ rm -f  /User/Dhyana/desktop/test.py\n```\n将会**强制删除**/User/Dhyana/desktop/test.py这个文件\n\n值得注意的是：\n使用这个rm -rf的时候一定要格外小心，linux没有回收站的，删除之后再想找回就很难了。有一个非常好笑的笑话就是命令行中输入\n```bash\n$ rm -rf /.*\n# 千万不要输入此命令，否则清空整个操作系统，后果自负\n```\n","slug":"Mac-OS-命令之文件-夹-删除","published":1,"updated":"2018-05-05T15:31:00.225Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozk7000p8motk1qvez51","content":"<p><code>rmdir</code>删除空目录，不过一旦目录非空会提示<br>Directiry not empty</p>\n<p>使用<code>rm</code>既可以删除文件又可以删除文件夹<br>删除文件夹（无论文件夹是否为空），使用 <code>-rf</code> 命令即可。<br>即：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rm -rf 目录名字</span><br></pre></td></tr></table></figure></p>\n<p><code>-r</code> 就是向下递归，不管有多少级目录，一并删除<br><code>-f</code> 就是直接强行删除，不作任何提示的意思<br><a id=\"more\"></a><br>删除<code>文件夹</code>实例：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rm -rf  /User/Dhyana/desktop</span><br></pre></td></tr></table></figure></p>\n<p>将会删除 /User/Dhyana/desktop目录以及其下所有文件、文件夹</p>\n<p>删除<code>文件</code>使用实例：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rm -f  /User/Dhyana/desktop/test.py</span><br></pre></td></tr></table></figure></p>\n<p>将会<strong>强制删除</strong>/User/Dhyana/desktop/test.py这个文件</p>\n<p>值得注意的是：<br>使用这个rm -rf的时候一定要格外小心，linux没有回收站的，删除之后再想找回就很难了。有一个非常好笑的笑话就是命令行中输入<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rm -rf /.*</span><br><span class=\"line\"><span class=\"comment\"># 千万不要输入此命令，否则清空整个操作系统，后果自负</span></span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p><code>rmdir</code>删除空目录，不过一旦目录非空会提示<br>Directiry not empty</p>\n<p>使用<code>rm</code>既可以删除文件又可以删除文件夹<br>删除文件夹（无论文件夹是否为空），使用 <code>-rf</code> 命令即可。<br>即：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rm -rf 目录名字</span><br></pre></td></tr></table></figure></p>\n<p><code>-r</code> 就是向下递归，不管有多少级目录，一并删除<br><code>-f</code> 就是直接强行删除，不作任何提示的意思<br>","more":"<br>删除<code>文件夹</code>实例：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rm -rf  /User/Dhyana/desktop</span><br></pre></td></tr></table></figure></p>\n<p>将会删除 /User/Dhyana/desktop目录以及其下所有文件、文件夹</p>\n<p>删除<code>文件</code>使用实例：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rm -f  /User/Dhyana/desktop/test.py</span><br></pre></td></tr></table></figure></p>\n<p>将会<strong>强制删除</strong>/User/Dhyana/desktop/test.py这个文件</p>\n<p>值得注意的是：<br>使用这个rm -rf的时候一定要格外小心，linux没有回收站的，删除之后再想找回就很难了。有一个非常好笑的笑话就是命令行中输入<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rm -rf /.*</span><br><span class=\"line\"><span class=\"comment\"># 千万不要输入此命令，否则清空整个操作系统，后果自负</span></span><br></pre></td></tr></table></figure></p>"},{"title":"Mac下profile文件","date":"2018-05-08T10:50:47.000Z","_content":"\n当你的home下面有`.bash_profile`或者`.bash_login`的时候,会忽略调`.profile`.   \n\n`.profile`主要有一下几种方式   \n/etc/profile    \n~/.bash_profile    \n~/.bash_login    \n~/.profile    \n~/.bashrc    \n~/.bash_logout   \n\n/etc/profile   \n`登录的时候`读入,默认的设定文件.   \n~/.bash_profile   \n`登录之后`在/etc/profile载入之后载入,十分重要的配置文件   \n~/.bash_login   \n`登录之后`如果~/.bash_profile不存在的话,载入这个文件   \n~/.profile   \n登录之后~/.bash_login不存在的话,才载入这个文件   \n~/.bashrc   \nbash shell打开的时候载入\n\n<!-- more -->\n`etc下的配置是针对系统,~下的主要是针对用户`\n\n参考：https://blog.csdn.net/xdonx/article/details/8312938\n","source":"_posts/Mac下profile文件.md","raw":"---\ntitle: Mac下profile文件\ndate: 2018-05-08 18:50:47\ntags:\n  - Linux/Mac OS\ncategories:\n  - Linux/Mac OS\n---\n\n当你的home下面有`.bash_profile`或者`.bash_login`的时候,会忽略调`.profile`.   \n\n`.profile`主要有一下几种方式   \n/etc/profile    \n~/.bash_profile    \n~/.bash_login    \n~/.profile    \n~/.bashrc    \n~/.bash_logout   \n\n/etc/profile   \n`登录的时候`读入,默认的设定文件.   \n~/.bash_profile   \n`登录之后`在/etc/profile载入之后载入,十分重要的配置文件   \n~/.bash_login   \n`登录之后`如果~/.bash_profile不存在的话,载入这个文件   \n~/.profile   \n登录之后~/.bash_login不存在的话,才载入这个文件   \n~/.bashrc   \nbash shell打开的时候载入\n\n<!-- more -->\n`etc下的配置是针对系统,~下的主要是针对用户`\n\n参考：https://blog.csdn.net/xdonx/article/details/8312938\n","slug":"Mac下profile文件","published":1,"updated":"2018-05-11T06:11:47.289Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozk8000r8motrifojd5i","content":"<p>当你的home下面有<code>.bash_profile</code>或者<code>.bash_login</code>的时候,会忽略调<code>.profile</code>.   </p>\n<p><code>.profile</code>主要有一下几种方式<br>/etc/profile<br>~/.bash_profile<br>~/.bash_login<br>~/.profile<br>~/.bashrc<br>~/.bash_logout   </p>\n<p>/etc/profile<br><code>登录的时候</code>读入,默认的设定文件.<br>~/.bash_profile<br><code>登录之后</code>在/etc/profile载入之后载入,十分重要的配置文件<br>~/.bash_login<br><code>登录之后</code>如果~/.bash_profile不存在的话,载入这个文件<br>~/.profile<br>登录之后~/.bash_login不存在的话,才载入这个文件<br>~/.bashrc<br>bash shell打开的时候载入</p>\n<a id=\"more\"></a>\n<p><code>etc下的配置是针对系统,~下的主要是针对用户</code></p>\n<p>参考：<a href=\"https://blog.csdn.net/xdonx/article/details/8312938\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/xdonx/article/details/8312938</a></p>\n","site":{"data":{}},"excerpt":"<p>当你的home下面有<code>.bash_profile</code>或者<code>.bash_login</code>的时候,会忽略调<code>.profile</code>.   </p>\n<p><code>.profile</code>主要有一下几种方式<br>/etc/profile<br>~/.bash_profile<br>~/.bash_login<br>~/.profile<br>~/.bashrc<br>~/.bash_logout   </p>\n<p>/etc/profile<br><code>登录的时候</code>读入,默认的设定文件.<br>~/.bash_profile<br><code>登录之后</code>在/etc/profile载入之后载入,十分重要的配置文件<br>~/.bash_login<br><code>登录之后</code>如果~/.bash_profile不存在的话,载入这个文件<br>~/.profile<br>登录之后~/.bash_login不存在的话,才载入这个文件<br>~/.bashrc<br>bash shell打开的时候载入</p>","more":"<p><code>etc下的配置是针对系统,~下的主要是针对用户</code></p>\n<p>参考：<a href=\"https://blog.csdn.net/xdonx/article/details/8312938\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/xdonx/article/details/8312938</a></p>"},{"title":"Mac下打开swf文件","date":"2018-05-11T05:23:17.000Z","_content":"\n编辑一个HTML文件，写入如下代码：\n```HTML\n<html>\n    <body>\n        <embed src=\"your-file-name-of-swf.swf\" width=\"500\" height=\"500\"></embed>\n    </body>\n</html>\n```\n然后使用chrome打开即可，在chrome下使用打印功能，可以将swf文件保存为pdf格式。\n<!-- more -->\n","source":"_posts/Mac下打开swf文件.md","raw":"---\ntitle: Mac下打开swf文件\ndate: 2018-05-11 13:23:17\ntags:\n  - Linux/Mac OS\ncategories:\n  - Linux/Mac OS\n---\n\n编辑一个HTML文件，写入如下代码：\n```HTML\n<html>\n    <body>\n        <embed src=\"your-file-name-of-swf.swf\" width=\"500\" height=\"500\"></embed>\n    </body>\n</html>\n```\n然后使用chrome打开即可，在chrome下使用打印功能，可以将swf文件保存为pdf格式。\n<!-- more -->\n","slug":"Mac下打开swf文件","published":1,"updated":"2018-05-11T05:30:19.985Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozka000v8motiuea1xet","content":"<p>编辑一个HTML文件，写入如下代码：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">embed</span> <span class=\"attr\">src</span>=<span class=\"string\">\"your-file-name-of-swf.swf\"</span> <span class=\"attr\">width</span>=<span class=\"string\">\"500\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"500\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">embed</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>然后使用chrome打开即可，在chrome下使用打印功能，可以将swf文件保存为pdf格式。<br><a id=\"more\"></a></p>\n","site":{"data":{}},"excerpt":"<p>编辑一个HTML文件，写入如下代码：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">embed</span> <span class=\"attr\">src</span>=<span class=\"string\">\"your-file-name-of-swf.swf\"</span> <span class=\"attr\">width</span>=<span class=\"string\">\"500\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"500\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">embed</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>然后使用chrome打开即可，在chrome下使用打印功能，可以将swf文件保存为pdf格式。<br>","more":"</p>"},{"title":"Markdown小技巧之空格输入","date":"2018-03-03T05:06:47.000Z","_content":"在使用Markdown的时候，有时候会与到这样的需求——为Markdown添加空格。跟word等其他编辑器不同，Markdown只能识别一个空格（在半角输入状态下）。通过搜寻资料找到了两个解决方案。\n\n1. 手动输入空格 （**&nbsp；**）。**注意！此时的分号为英文分号**，但是不推荐使用此方法，太麻烦！\n\n2. 使用**全角空格**。即：在**全角**输入状态下直接使用空格键就ok了\n","source":"_posts/Markdown小技巧之空格输入.md","raw":"---\ntitle: Markdown小技巧之空格输入\ndate: 2018-03-03 13:06:47\ntags:\n  - Markdown\ncategories:\n  - Markdown\n---\n在使用Markdown的时候，有时候会与到这样的需求——为Markdown添加空格。跟word等其他编辑器不同，Markdown只能识别一个空格（在半角输入状态下）。通过搜寻资料找到了两个解决方案。\n\n1. 手动输入空格 （**&nbsp；**）。**注意！此时的分号为英文分号**，但是不推荐使用此方法，太麻烦！\n\n2. 使用**全角空格**。即：在**全角**输入状态下直接使用空格键就ok了\n","slug":"Markdown小技巧之空格输入","published":1,"updated":"2018-03-03T05:07:54.804Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozkc000y8mot8x0q4e2d","content":"<p>在使用Markdown的时候，有时候会与到这样的需求——为Markdown添加空格。跟word等其他编辑器不同，Markdown只能识别一个空格（在半角输入状态下）。通过搜寻资料找到了两个解决方案。</p>\n<ol>\n<li><p>手动输入空格 （<strong>&amp;nbsp；</strong>）。<strong>注意！此时的分号为英文分号</strong>，但是不推荐使用此方法，太麻烦！</p>\n</li>\n<li><p>使用<strong>全角空格</strong>。即：在<strong>全角</strong>输入状态下直接使用空格键就ok了</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>在使用Markdown的时候，有时候会与到这样的需求——为Markdown添加空格。跟word等其他编辑器不同，Markdown只能识别一个空格（在半角输入状态下）。通过搜寻资料找到了两个解决方案。</p>\n<ol>\n<li><p>手动输入空格 （<strong>&amp;nbsp；</strong>）。<strong>注意！此时的分号为英文分号</strong>，但是不推荐使用此方法，太麻烦！</p>\n</li>\n<li><p>使用<strong>全角空格</strong>。即：在<strong>全角</strong>输入状态下直接使用空格键就ok了</p>\n</li>\n</ol>\n"},{"title":"Python2.7.x与Python3.x差异","date":"2018-03-05T17:08:15.000Z","_content":"**Contents**\n\n1. [`__future__模块`](http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#__future__%E6%A8%A1%E5%9D%97)\n2. [`print函数`](http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#print%E5%87%BD%E6%95%B0)\n3. [`整除`](http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#%E6%95%B4%E9%99%A4)\n4. [`Unicode`](http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#Unicode)\n5. [`xrange模块`](http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#xrange%E6%A8%A1%E5%9D%97)\n6. [`Python3中的range对象的__contains__方法`](http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#Python3%E4%B8%AD%E7%9A%84range%E5%AF%B9%E8%B1%A1%E7%9A%84__contains__%E6%96%B9%E6%B3%95)\n7. [`Raising exceptions`](http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#Raising_exceptions)\n8. [`Handling exceptions`](http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#Handling_exceptions)\n9. [`next()函数 and .next()方法`](http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#next()\n10. [`For循环变量和全局命名空间泄漏`](http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#For%E5%BE%AA%E7%8E%AF%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%B3%84%E6%BC%8F)\n11. [`比较不可排序类型`](http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#%E6%AF%94%E8%BE%83%E4%B8%8D%E5%8F%AF%E6%8E%92%E5%BA%8F%E7%B1%BB%E5%9E%8B)\n12. [`通过input()解析用户的输入`](http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#%E9%80%9A%E8%BF%87input()\n13. [`返回可迭代对象，而不是列表`](http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#%E8%BF%94%E5%9B%9E%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E5%88%97%E8%A1%A8)\n14. [`更多的关于 Python 2 和 Python 3 的文章`](http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#%E6%9B%B4%E5%A4%9A%E7%9A%84%E5%85%B3%E4%BA%8E_Python_2_%E5%92%8C_Python_3_%E7%9A%84%E6%96%87%E7%AB%A0)\n\n **参考：**\n 1. [Python2.x与Python3.x差异](http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/)\n\n 2. [Key differences between Python 2.7.x and Python 3.x](http://nbviewer.jupyter.org/github/rasbt/python_reference/blob/master/tutorials/key_differences_between_python_2_and_3.ipynb?create=1)\n","source":"_posts/Python2-7-x与Python3-x差异.md","raw":"---\ntitle: Python2.7.x与Python3.x差异\ndate: 2018-03-06 01:08:15\ntags:\n  - Python3\ncategories:\n  - Python3 进阶\n---\n**Contents**\n\n1. [`__future__模块`](http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#__future__%E6%A8%A1%E5%9D%97)\n2. [`print函数`](http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#print%E5%87%BD%E6%95%B0)\n3. [`整除`](http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#%E6%95%B4%E9%99%A4)\n4. [`Unicode`](http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#Unicode)\n5. [`xrange模块`](http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#xrange%E6%A8%A1%E5%9D%97)\n6. [`Python3中的range对象的__contains__方法`](http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#Python3%E4%B8%AD%E7%9A%84range%E5%AF%B9%E8%B1%A1%E7%9A%84__contains__%E6%96%B9%E6%B3%95)\n7. [`Raising exceptions`](http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#Raising_exceptions)\n8. [`Handling exceptions`](http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#Handling_exceptions)\n9. [`next()函数 and .next()方法`](http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#next()\n10. [`For循环变量和全局命名空间泄漏`](http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#For%E5%BE%AA%E7%8E%AF%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%B3%84%E6%BC%8F)\n11. [`比较不可排序类型`](http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#%E6%AF%94%E8%BE%83%E4%B8%8D%E5%8F%AF%E6%8E%92%E5%BA%8F%E7%B1%BB%E5%9E%8B)\n12. [`通过input()解析用户的输入`](http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#%E9%80%9A%E8%BF%87input()\n13. [`返回可迭代对象，而不是列表`](http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#%E8%BF%94%E5%9B%9E%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E5%88%97%E8%A1%A8)\n14. [`更多的关于 Python 2 和 Python 3 的文章`](http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#%E6%9B%B4%E5%A4%9A%E7%9A%84%E5%85%B3%E4%BA%8E_Python_2_%E5%92%8C_Python_3_%E7%9A%84%E6%96%87%E7%AB%A0)\n\n **参考：**\n 1. [Python2.x与Python3.x差异](http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/)\n\n 2. [Key differences between Python 2.7.x and Python 3.x](http://nbviewer.jupyter.org/github/rasbt/python_reference/blob/master/tutorials/key_differences_between_python_2_and_3.ipynb?create=1)\n","slug":"Python2-7-x与Python3-x差异","published":1,"updated":"2018-03-06T17:20:06.242Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozkd00118motvc4evwmn","content":"<p><strong>Contents</strong></p>\n<ol>\n<li><a href=\"http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#__future__%E6%A8%A1%E5%9D%97\" target=\"_blank\" rel=\"noopener\"><code>__future__模块</code></a></li>\n<li><a href=\"http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#print%E5%87%BD%E6%95%B0\" target=\"_blank\" rel=\"noopener\"><code>print函数</code></a></li>\n<li><a href=\"http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#%E6%95%B4%E9%99%A4\" target=\"_blank\" rel=\"noopener\"><code>整除</code></a></li>\n<li><a href=\"http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#Unicode\" target=\"_blank\" rel=\"noopener\"><code>Unicode</code></a></li>\n<li><a href=\"http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#xrange%E6%A8%A1%E5%9D%97\" target=\"_blank\" rel=\"noopener\"><code>xrange模块</code></a></li>\n<li><a href=\"http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#Python3%E4%B8%AD%E7%9A%84range%E5%AF%B9%E8%B1%A1%E7%9A%84__contains__%E6%96%B9%E6%B3%95\" target=\"_blank\" rel=\"noopener\"><code>Python3中的range对象的__contains__方法</code></a></li>\n<li><a href=\"http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#Raising_exceptions\" target=\"_blank\" rel=\"noopener\"><code>Raising exceptions</code></a></li>\n<li><a href=\"http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#Handling_exceptions\" target=\"_blank\" rel=\"noopener\"><code>Handling exceptions</code></a></li>\n<li><a href=\"http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#next(\" target=\"_blank\" rel=\"noopener\"><code>next()函数 and .next()方法</code></a></li>\n<li><a href=\"http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#For%E5%BE%AA%E7%8E%AF%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%B3%84%E6%BC%8F\" target=\"_blank\" rel=\"noopener\"><code>For循环变量和全局命名空间泄漏</code></a></li>\n<li><a href=\"http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#%E6%AF%94%E8%BE%83%E4%B8%8D%E5%8F%AF%E6%8E%92%E5%BA%8F%E7%B1%BB%E5%9E%8B\" target=\"_blank\" rel=\"noopener\"><code>比较不可排序类型</code></a></li>\n<li><a href=\"http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#%E9%80%9A%E8%BF%87input(\" target=\"_blank\" rel=\"noopener\"><code>通过input()解析用户的输入</code></a></li>\n<li><a href=\"http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#%E8%BF%94%E5%9B%9E%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E5%88%97%E8%A1%A8\" target=\"_blank\" rel=\"noopener\"><code>返回可迭代对象，而不是列表</code></a></li>\n<li><p><a href=\"http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#%E6%9B%B4%E5%A4%9A%E7%9A%84%E5%85%B3%E4%BA%8E_Python_2_%E5%92%8C_Python_3_%E7%9A%84%E6%96%87%E7%AB%A0\" target=\"_blank\" rel=\"noopener\"><code>更多的关于 Python 2 和 Python 3 的文章</code></a></p>\n<p><strong>参考：</strong></p>\n<ol>\n<li><p><a href=\"http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/\" target=\"_blank\" rel=\"noopener\">Python2.x与Python3.x差异</a></p>\n</li>\n<li><p><a href=\"http://nbviewer.jupyter.org/github/rasbt/python_reference/blob/master/tutorials/key_differences_between_python_2_and_3.ipynb?create=1\" target=\"_blank\" rel=\"noopener\">Key differences between Python 2.7.x and Python 3.x</a></p>\n</li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>Contents</strong></p>\n<ol>\n<li><a href=\"http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#__future__%E6%A8%A1%E5%9D%97\" target=\"_blank\" rel=\"noopener\"><code>__future__模块</code></a></li>\n<li><a href=\"http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#print%E5%87%BD%E6%95%B0\" target=\"_blank\" rel=\"noopener\"><code>print函数</code></a></li>\n<li><a href=\"http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#%E6%95%B4%E9%99%A4\" target=\"_blank\" rel=\"noopener\"><code>整除</code></a></li>\n<li><a href=\"http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#Unicode\" target=\"_blank\" rel=\"noopener\"><code>Unicode</code></a></li>\n<li><a href=\"http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#xrange%E6%A8%A1%E5%9D%97\" target=\"_blank\" rel=\"noopener\"><code>xrange模块</code></a></li>\n<li><a href=\"http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#Python3%E4%B8%AD%E7%9A%84range%E5%AF%B9%E8%B1%A1%E7%9A%84__contains__%E6%96%B9%E6%B3%95\" target=\"_blank\" rel=\"noopener\"><code>Python3中的range对象的__contains__方法</code></a></li>\n<li><a href=\"http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#Raising_exceptions\" target=\"_blank\" rel=\"noopener\"><code>Raising exceptions</code></a></li>\n<li><a href=\"http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#Handling_exceptions\" target=\"_blank\" rel=\"noopener\"><code>Handling exceptions</code></a></li>\n<li><a href=\"http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#next(\" target=\"_blank\" rel=\"noopener\"><code>next()函数 and .next()方法</code></a></li>\n<li><a href=\"http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#For%E5%BE%AA%E7%8E%AF%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%B3%84%E6%BC%8F\" target=\"_blank\" rel=\"noopener\"><code>For循环变量和全局命名空间泄漏</code></a></li>\n<li><a href=\"http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#%E6%AF%94%E8%BE%83%E4%B8%8D%E5%8F%AF%E6%8E%92%E5%BA%8F%E7%B1%BB%E5%9E%8B\" target=\"_blank\" rel=\"noopener\"><code>比较不可排序类型</code></a></li>\n<li><a href=\"http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#%E9%80%9A%E8%BF%87input(\" target=\"_blank\" rel=\"noopener\"><code>通过input()解析用户的输入</code></a></li>\n<li><a href=\"http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#%E8%BF%94%E5%9B%9E%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E5%88%97%E8%A1%A8\" target=\"_blank\" rel=\"noopener\"><code>返回可迭代对象，而不是列表</code></a></li>\n<li><p><a href=\"http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#%E6%9B%B4%E5%A4%9A%E7%9A%84%E5%85%B3%E4%BA%8E_Python_2_%E5%92%8C_Python_3_%E7%9A%84%E6%96%87%E7%AB%A0\" target=\"_blank\" rel=\"noopener\"><code>更多的关于 Python 2 和 Python 3 的文章</code></a></p>\n<p><strong>参考：</strong></p>\n<ol>\n<li><p><a href=\"http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/\" target=\"_blank\" rel=\"noopener\">Python2.x与Python3.x差异</a></p>\n</li>\n<li><p><a href=\"http://nbviewer.jupyter.org/github/rasbt/python_reference/blob/master/tutorials/key_differences_between_python_2_and_3.ipynb?create=1\" target=\"_blank\" rel=\"noopener\">Key differences between Python 2.7.x and Python 3.x</a></p>\n</li>\n</ol>\n</li>\n</ol>\n"},{"title":"Python3 for ... else ...陷阱","date":"2018-03-29T09:49:49.000Z","_content":"假设有如下代码：\n```Python\nfor i in range(10):\n    if i == 5:\n        print 'found it! i = %s' % i\nelse:\n    print 'not found it ...'\n\n```\n我们期望的结果是，当找到5时打印出：\n```python\nfound it! i = 5\n```\n实际上打印出来的结果为：\n```python\nfound it! i = 5\nnot found it ...\n```\n显然这不是我们期望的结果。\n<!-- more -->\n\n根据官方文档说法：\n>When the items are exhausted (which is immediately when the sequence is empty), the suite in the else clause, if present, is executed, and the loop terminates.\n\n>A break statement executed in the first suite terminates the loop without executing the else clause’s suite. A continue statement executed in the first suite skips the rest of the suite and continues with the next item, or with the else clause if there was no next item.\n\n>https://docs.python.org/2/reference/compound_stmts.html#the-for-statement\n\n\n大意是说`当迭代的对象迭代完并为空时，位于else的子句将执行`，`而如果在for循环中含有break时则直接终止循环，并不会执行else子句`。\n\n所以正确的写法应该为：\n```python\nfor i in range(10):\n    if i == 5:\n        print 'found it! i = %s' % i\n        break\nelse:\n    print 'not found it ...'\n```\n\n当使用pylint检测代码时会提示:\n```python\nElse clause on loop without a break statement (useless-else-on-loop)\n```\n所以养成使用pylint检测代码的习惯还是很有必要的，像这种逻辑错误不注意点还是很难发现的。\n\n**同样的原理适用于`while ... else`循环**\n\n**参考**\n\n1. https://www.cnblogs.com/dspace/p/6622799.html\n","source":"_posts/Python3-for-else-陷阱.md","raw":"---\ntitle: Python3 for ... else ...陷阱\ndate: 2018-03-29 17:49:49\ntags:\n  - Python3\ncategories:\n  - Python3 进阶\n---\n假设有如下代码：\n```Python\nfor i in range(10):\n    if i == 5:\n        print 'found it! i = %s' % i\nelse:\n    print 'not found it ...'\n\n```\n我们期望的结果是，当找到5时打印出：\n```python\nfound it! i = 5\n```\n实际上打印出来的结果为：\n```python\nfound it! i = 5\nnot found it ...\n```\n显然这不是我们期望的结果。\n<!-- more -->\n\n根据官方文档说法：\n>When the items are exhausted (which is immediately when the sequence is empty), the suite in the else clause, if present, is executed, and the loop terminates.\n\n>A break statement executed in the first suite terminates the loop without executing the else clause’s suite. A continue statement executed in the first suite skips the rest of the suite and continues with the next item, or with the else clause if there was no next item.\n\n>https://docs.python.org/2/reference/compound_stmts.html#the-for-statement\n\n\n大意是说`当迭代的对象迭代完并为空时，位于else的子句将执行`，`而如果在for循环中含有break时则直接终止循环，并不会执行else子句`。\n\n所以正确的写法应该为：\n```python\nfor i in range(10):\n    if i == 5:\n        print 'found it! i = %s' % i\n        break\nelse:\n    print 'not found it ...'\n```\n\n当使用pylint检测代码时会提示:\n```python\nElse clause on loop without a break statement (useless-else-on-loop)\n```\n所以养成使用pylint检测代码的习惯还是很有必要的，像这种逻辑错误不注意点还是很难发现的。\n\n**同样的原理适用于`while ... else`循环**\n\n**参考**\n\n1. https://www.cnblogs.com/dspace/p/6622799.html\n","slug":"Python3-for-else-陷阱","published":1,"updated":"2018-03-29T10:00:17.633Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozkf00138mot7db0b7aj","content":"<p>假设有如下代码：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">10</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> i == <span class=\"number\">5</span>:</span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">'found it! i = %s'</span> % i</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'not found it ...'</span></span><br></pre></td></tr></table></figure></p>\n<p>我们期望的结果是，当找到5时打印出：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">found it! i = <span class=\"number\">5</span></span><br></pre></td></tr></table></figure></p>\n<p>实际上打印出来的结果为：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">found it! i = <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"keyword\">not</span> found it ...</span><br></pre></td></tr></table></figure></p>\n<p>显然这不是我们期望的结果。<br><a id=\"more\"></a></p>\n<p>根据官方文档说法：</p>\n<blockquote>\n<p>When the items are exhausted (which is immediately when the sequence is empty), the suite in the else clause, if present, is executed, and the loop terminates.</p>\n</blockquote>\n<blockquote>\n<p>A break statement executed in the first suite terminates the loop without executing the else clause’s suite. A continue statement executed in the first suite skips the rest of the suite and continues with the next item, or with the else clause if there was no next item.</p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://docs.python.org/2/reference/compound_stmts.html#the-for-statement\" target=\"_blank\" rel=\"noopener\">https://docs.python.org/2/reference/compound_stmts.html#the-for-statement</a></p>\n</blockquote>\n<p>大意是说<code>当迭代的对象迭代完并为空时，位于else的子句将执行</code>，<code>而如果在for循环中含有break时则直接终止循环，并不会执行else子句</code>。</p>\n<p>所以正确的写法应该为：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">10</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> i == <span class=\"number\">5</span>:</span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">'found it! i = %s'</span> % i</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'not found it ...'</span></span><br></pre></td></tr></table></figure></p>\n<p>当使用pylint检测代码时会提示:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Else clause on loop without a <span class=\"keyword\">break</span> statement (useless-<span class=\"keyword\">else</span>-on-loop)</span><br></pre></td></tr></table></figure></p>\n<p>所以养成使用pylint检测代码的习惯还是很有必要的，像这种逻辑错误不注意点还是很难发现的。</p>\n<p><strong>同样的原理适用于<code>while ... else</code>循环</strong></p>\n<p><strong>参考</strong></p>\n<ol>\n<li><a href=\"https://www.cnblogs.com/dspace/p/6622799.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/dspace/p/6622799.html</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>假设有如下代码：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">10</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> i == <span class=\"number\">5</span>:</span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">'found it! i = %s'</span> % i</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'not found it ...'</span></span><br></pre></td></tr></table></figure></p>\n<p>我们期望的结果是，当找到5时打印出：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">found it! i = <span class=\"number\">5</span></span><br></pre></td></tr></table></figure></p>\n<p>实际上打印出来的结果为：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">found it! i = <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"keyword\">not</span> found it ...</span><br></pre></td></tr></table></figure></p>\n<p>显然这不是我们期望的结果。<br>","more":"</p>\n<p>根据官方文档说法：</p>\n<blockquote>\n<p>When the items are exhausted (which is immediately when the sequence is empty), the suite in the else clause, if present, is executed, and the loop terminates.</p>\n</blockquote>\n<blockquote>\n<p>A break statement executed in the first suite terminates the loop without executing the else clause’s suite. A continue statement executed in the first suite skips the rest of the suite and continues with the next item, or with the else clause if there was no next item.</p>\n</blockquote>\n<blockquote>\n<p><a href=\"https://docs.python.org/2/reference/compound_stmts.html#the-for-statement\" target=\"_blank\" rel=\"noopener\">https://docs.python.org/2/reference/compound_stmts.html#the-for-statement</a></p>\n</blockquote>\n<p>大意是说<code>当迭代的对象迭代完并为空时，位于else的子句将执行</code>，<code>而如果在for循环中含有break时则直接终止循环，并不会执行else子句</code>。</p>\n<p>所以正确的写法应该为：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">10</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> i == <span class=\"number\">5</span>:</span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">'found it! i = %s'</span> % i</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'not found it ...'</span></span><br></pre></td></tr></table></figure></p>\n<p>当使用pylint检测代码时会提示:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Else clause on loop without a <span class=\"keyword\">break</span> statement (useless-<span class=\"keyword\">else</span>-on-loop)</span><br></pre></td></tr></table></figure></p>\n<p>所以养成使用pylint检测代码的习惯还是很有必要的，像这种逻辑错误不注意点还是很难发现的。</p>\n<p><strong>同样的原理适用于<code>while ... else</code>循环</strong></p>\n<p><strong>参考</strong></p>\n<ol>\n<li><a href=\"https://www.cnblogs.com/dspace/p/6622799.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/dspace/p/6622799.html</a></li>\n</ol>"},{"title":"Python3 is和==的区别","date":"2018-03-03T04:16:34.000Z","_content":"\n## Python 对象三要素\n要理解Python中is和==的区别，首先要理解Python对象的三个要素:\n\n\n| 要素        | 说明         |获取方式   |\n| :-----:       | :-----:      | :-----:   |\n| id      | 身份标识，基本就是内存地址，用来唯一标识一个对象  | id(obj)  |\n|type      | 数据类型   | type(obj)  |\n|value      | 值   | :-----:   |\n\n<!-- more -->\n## is和==区别\n\n| 标识       | 名称         |判断方法   |\n| :-----:       | :-----:      | :-----:   |\n| is      | 同一性运算符  | id  |\n| ==      | 比较运算符  | value  |\n\n---\n## 程序举例\n\n### 例1：\n![屏幕截图2.jpg](http://upload-images.jianshu.io/upload_images/2952111-ec5fa82d12a42a34.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```python\na = {\"a\":1, \"b\":2}\nb = a.copy()\n\n\na == b  # True value一样\na is b  # False id不一样\n```\n---\n### 例2：\n![屏幕截图.jpg](http://upload-images.jianshu.io/upload_images/2952111-21696bc9de2d0e56.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```python\n>>> x = y = [4,5,6]\n>>> z = [4,5,6]\n>>> x == y\nTrue\n>>> x == z\nTrue\n>>> x is y\nTrue\n>>> x is z\nFalse\n>>>\n>>> print id(x)\n>>> print id(y)\n>>> print id(z)\n```\n\n---\n```python\n>>> a = 1 #a和b为数值类型\n>>> b = 1\n>>> a is b\nTrue\n>>> id(a)\n>>> id(b)\n>>> a = 'cheesezh' #a和b为字符串类型\n>>> b = 'cheesezh'\n>>> a is b\nTrue\n>>> id(a)\n>>> id(b)\n>>> a = (1,2,3) #a和b为元组类型\n>>> b = (1,2,3)\n>>> a is b\nFalse\n>>> id(a)\n>>> id(b)\n>>> a = [1,2,3] #a和b为list类型\n>>> b = [1,2,3]\n>>> a is b\nFalse\n>>> id(a)\n>>> id(b)\n>>> a = {'cheese':1,'zh':2} #a和b为dict类型\n>>> b = {'cheese':1,'zh':2}\n>>> a is b\nFalse\n>>> id(a)\n>>> id(b)\n>>> a = set([1,2,3])#a和b为set类型\n>>> b = set([1,2,3])\n>>> a is b\nFalse\n>>> id(a)\n>>> id(b)\n```\n","source":"_posts/Python3-is和-的区别.md","raw":"---\ntitle: Python3 is和==的区别\ndate: 2018-03-03 12:16:34\ntags:\n  - Python3\ncategories:\n  - Python3 进阶\n---\n\n## Python 对象三要素\n要理解Python中is和==的区别，首先要理解Python对象的三个要素:\n\n\n| 要素        | 说明         |获取方式   |\n| :-----:       | :-----:      | :-----:   |\n| id      | 身份标识，基本就是内存地址，用来唯一标识一个对象  | id(obj)  |\n|type      | 数据类型   | type(obj)  |\n|value      | 值   | :-----:   |\n\n<!-- more -->\n## is和==区别\n\n| 标识       | 名称         |判断方法   |\n| :-----:       | :-----:      | :-----:   |\n| is      | 同一性运算符  | id  |\n| ==      | 比较运算符  | value  |\n\n---\n## 程序举例\n\n### 例1：\n![屏幕截图2.jpg](http://upload-images.jianshu.io/upload_images/2952111-ec5fa82d12a42a34.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```python\na = {\"a\":1, \"b\":2}\nb = a.copy()\n\n\na == b  # True value一样\na is b  # False id不一样\n```\n---\n### 例2：\n![屏幕截图.jpg](http://upload-images.jianshu.io/upload_images/2952111-21696bc9de2d0e56.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```python\n>>> x = y = [4,5,6]\n>>> z = [4,5,6]\n>>> x == y\nTrue\n>>> x == z\nTrue\n>>> x is y\nTrue\n>>> x is z\nFalse\n>>>\n>>> print id(x)\n>>> print id(y)\n>>> print id(z)\n```\n\n---\n```python\n>>> a = 1 #a和b为数值类型\n>>> b = 1\n>>> a is b\nTrue\n>>> id(a)\n>>> id(b)\n>>> a = 'cheesezh' #a和b为字符串类型\n>>> b = 'cheesezh'\n>>> a is b\nTrue\n>>> id(a)\n>>> id(b)\n>>> a = (1,2,3) #a和b为元组类型\n>>> b = (1,2,3)\n>>> a is b\nFalse\n>>> id(a)\n>>> id(b)\n>>> a = [1,2,3] #a和b为list类型\n>>> b = [1,2,3]\n>>> a is b\nFalse\n>>> id(a)\n>>> id(b)\n>>> a = {'cheese':1,'zh':2} #a和b为dict类型\n>>> b = {'cheese':1,'zh':2}\n>>> a is b\nFalse\n>>> id(a)\n>>> id(b)\n>>> a = set([1,2,3])#a和b为set类型\n>>> b = set([1,2,3])\n>>> a is b\nFalse\n>>> id(a)\n>>> id(b)\n```\n","slug":"Python3-is和-的区别","published":1,"updated":"2018-04-21T03:34:54.494Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozkg00178mot83822igp","content":"<h2 id=\"Python-对象三要素\"><a href=\"#Python-对象三要素\" class=\"headerlink\" title=\"Python 对象三要素\"></a>Python 对象三要素</h2><p>要理解Python中is和==的区别，首先要理解Python对象的三个要素:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">要素</th>\n<th style=\"text-align:center\">说明</th>\n<th style=\"text-align:center\">获取方式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">id</td>\n<td style=\"text-align:center\">身份标识，基本就是内存地址，用来唯一标识一个对象</td>\n<td style=\"text-align:center\">id(obj)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">type</td>\n<td style=\"text-align:center\">数据类型</td>\n<td style=\"text-align:center\">type(obj)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">value</td>\n<td style=\"text-align:center\">值</td>\n<td style=\"text-align:center\">:—–:</td>\n</tr>\n</tbody>\n</table>\n<a id=\"more\"></a>\n<h2 id=\"is和-区别\"><a href=\"#is和-区别\" class=\"headerlink\" title=\"is和==区别\"></a>is和==区别</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">标识</th>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:center\">判断方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">is</td>\n<td style=\"text-align:center\">同一性运算符</td>\n<td style=\"text-align:center\">id</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">==</td>\n<td style=\"text-align:center\">比较运算符</td>\n<td style=\"text-align:center\">value</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2 id=\"程序举例\"><a href=\"#程序举例\" class=\"headerlink\" title=\"程序举例\"></a>程序举例</h2><h3 id=\"例1：\"><a href=\"#例1：\" class=\"headerlink\" title=\"例1：\"></a>例1：</h3><p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-ec5fa82d12a42a34.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕截图2.jpg\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = &#123;<span class=\"string\">\"a\"</span>:<span class=\"number\">1</span>, <span class=\"string\">\"b\"</span>:<span class=\"number\">2</span>&#125;</span><br><span class=\"line\">b = a.copy()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">a == b  <span class=\"comment\"># True value一样</span></span><br><span class=\"line\">a <span class=\"keyword\">is</span> b  <span class=\"comment\"># False id不一样</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"例2：\"><a href=\"#例2：\" class=\"headerlink\" title=\"例2：\"></a>例2：</h3><p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-21696bc9de2d0e56.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕截图.jpg\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>x = y = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>z = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>x == y</span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>x == z</span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>x <span class=\"keyword\">is</span> y</span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>x <span class=\"keyword\">is</span> z</span><br><span class=\"line\"><span class=\"keyword\">False</span></span><br><span class=\"line\">&gt;&gt;&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> id(x)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> id(y)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> id(z)</span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a = <span class=\"number\">1</span> <span class=\"comment\">#a和b为数值类型</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a <span class=\"keyword\">is</span> b</span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>id(a)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>id(b)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a = <span class=\"string\">'cheesezh'</span> <span class=\"comment\">#a和b为字符串类型</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b = <span class=\"string\">'cheesezh'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a <span class=\"keyword\">is</span> b</span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>id(a)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>id(b)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a = (<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>) <span class=\"comment\">#a和b为元组类型</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b = (<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a <span class=\"keyword\">is</span> b</span><br><span class=\"line\"><span class=\"keyword\">False</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>id(a)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>id(b)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>] <span class=\"comment\">#a和b为list类型</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a <span class=\"keyword\">is</span> b</span><br><span class=\"line\"><span class=\"keyword\">False</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>id(a)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>id(b)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a = &#123;<span class=\"string\">'cheese'</span>:<span class=\"number\">1</span>,<span class=\"string\">'zh'</span>:<span class=\"number\">2</span>&#125; <span class=\"comment\">#a和b为dict类型</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b = &#123;<span class=\"string\">'cheese'</span>:<span class=\"number\">1</span>,<span class=\"string\">'zh'</span>:<span class=\"number\">2</span>&#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a <span class=\"keyword\">is</span> b</span><br><span class=\"line\"><span class=\"keyword\">False</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>id(a)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>id(b)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a = set([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>])<span class=\"comment\">#a和b为set类型</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b = set([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a <span class=\"keyword\">is</span> b</span><br><span class=\"line\"><span class=\"keyword\">False</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>id(a)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>id(b)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"Python-对象三要素\"><a href=\"#Python-对象三要素\" class=\"headerlink\" title=\"Python 对象三要素\"></a>Python 对象三要素</h2><p>要理解Python中is和==的区别，首先要理解Python对象的三个要素:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">要素</th>\n<th style=\"text-align:center\">说明</th>\n<th style=\"text-align:center\">获取方式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">id</td>\n<td style=\"text-align:center\">身份标识，基本就是内存地址，用来唯一标识一个对象</td>\n<td style=\"text-align:center\">id(obj)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">type</td>\n<td style=\"text-align:center\">数据类型</td>\n<td style=\"text-align:center\">type(obj)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">value</td>\n<td style=\"text-align:center\">值</td>\n<td style=\"text-align:center\">:—–:</td>\n</tr>\n</tbody>\n</table>","more":"<h2 id=\"is和-区别\"><a href=\"#is和-区别\" class=\"headerlink\" title=\"is和==区别\"></a>is和==区别</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">标识</th>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:center\">判断方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">is</td>\n<td style=\"text-align:center\">同一性运算符</td>\n<td style=\"text-align:center\">id</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">==</td>\n<td style=\"text-align:center\">比较运算符</td>\n<td style=\"text-align:center\">value</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2 id=\"程序举例\"><a href=\"#程序举例\" class=\"headerlink\" title=\"程序举例\"></a>程序举例</h2><h3 id=\"例1：\"><a href=\"#例1：\" class=\"headerlink\" title=\"例1：\"></a>例1：</h3><p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-ec5fa82d12a42a34.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕截图2.jpg\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = &#123;<span class=\"string\">\"a\"</span>:<span class=\"number\">1</span>, <span class=\"string\">\"b\"</span>:<span class=\"number\">2</span>&#125;</span><br><span class=\"line\">b = a.copy()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">a == b  <span class=\"comment\"># True value一样</span></span><br><span class=\"line\">a <span class=\"keyword\">is</span> b  <span class=\"comment\"># False id不一样</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"例2：\"><a href=\"#例2：\" class=\"headerlink\" title=\"例2：\"></a>例2：</h3><p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-21696bc9de2d0e56.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕截图.jpg\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>x = y = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>z = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>x == y</span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>x == z</span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>x <span class=\"keyword\">is</span> y</span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>x <span class=\"keyword\">is</span> z</span><br><span class=\"line\"><span class=\"keyword\">False</span></span><br><span class=\"line\">&gt;&gt;&gt;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> id(x)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> id(y)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> id(z)</span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a = <span class=\"number\">1</span> <span class=\"comment\">#a和b为数值类型</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a <span class=\"keyword\">is</span> b</span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>id(a)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>id(b)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a = <span class=\"string\">'cheesezh'</span> <span class=\"comment\">#a和b为字符串类型</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b = <span class=\"string\">'cheesezh'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a <span class=\"keyword\">is</span> b</span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>id(a)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>id(b)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a = (<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>) <span class=\"comment\">#a和b为元组类型</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b = (<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a <span class=\"keyword\">is</span> b</span><br><span class=\"line\"><span class=\"keyword\">False</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>id(a)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>id(b)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>] <span class=\"comment\">#a和b为list类型</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a <span class=\"keyword\">is</span> b</span><br><span class=\"line\"><span class=\"keyword\">False</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>id(a)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>id(b)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a = &#123;<span class=\"string\">'cheese'</span>:<span class=\"number\">1</span>,<span class=\"string\">'zh'</span>:<span class=\"number\">2</span>&#125; <span class=\"comment\">#a和b为dict类型</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b = &#123;<span class=\"string\">'cheese'</span>:<span class=\"number\">1</span>,<span class=\"string\">'zh'</span>:<span class=\"number\">2</span>&#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a <span class=\"keyword\">is</span> b</span><br><span class=\"line\"><span class=\"keyword\">False</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>id(a)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>id(b)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a = set([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>])<span class=\"comment\">#a和b为set类型</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b = set([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a <span class=\"keyword\">is</span> b</span><br><span class=\"line\"><span class=\"keyword\">False</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>id(a)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>id(b)</span><br></pre></td></tr></table></figure>"},{"title":"Python3 nonlocal声明","date":"2018-03-06T06:58:07.000Z","_content":"前一节讲闭包时用到以下代码：\n```python\n# 示例2\ndef make_averager():\n    series = []\n\n    def averager(new_value):\n        series.append(new_value)\n        total = sum(series)\n        return total/len(series)\n\n    return averager\n```\n以上实现make_averager函数的方法效率不高。在如下示例中,我们把所有值存储在历史数列中，然后在每次调用averager时使用sum求和。更好的实现方式是，只存储目前的总和以及元素个数，然后使用这两个值计算平均数。以下是实现方式，这种实现方式存在缺陷，只是为了引出`nonlocal声明`。\n<!-- more -->\n```python\ndef make_averager():\n    count = 0\n    total = 0\n    def averager(new_value):\n        count += 1\n        total += new_value\n        return total/count\n\n    return averager\n\n```\n\n尝试使用以上定义的函数，得到如下结果：\n```python\n>>> avg = make_averager()\n>>> avg(10)\n---------------------------------------------------------------------------\nUnboundLocalError                         Traceback (most recent call last)\n<ipython-input-42-ace390caaa2e> in <module>()\n----> 1 avg(10)\n\n<ipython-input-38-371a27b41829> in averager(new_value)\n      3     total = 0\n      4     def averager(new_value):\n----> 5         count += 1\n      6         total += new_value\n      7         return total/count\n\nUnboundLocalError: local variable 'count' referenced before assignment\n```\n\n问题是，当count是数字或任何不可变类型时，`count += 1`语句的作用其实与`count = count + 1`一样，因此我们在averager的定义体中为count赋值了，这样会把count变量变为局部变量，而不是自由变量。total变量也会受到这样的影响。\n\n示例2 中没有遇到这样的问题是因为我们没有给series赋值，我们只是调用`series.append`，并把它传给sum和len。也就是说，我们利用了列表是可变的对象这一事实。\n\n但是对数字和字符串、元组等不可变类型来说，只能读取，不能更新。如果尝试重新绑定，例如count += 1,其实会隐式的创建局部变量count。`这样count就不是自由变量了，也就不会保存在闭包中`。\n\n为了解决这个问题，python3引入了`nonlocal声明`。他的作用是把变量标记为自由变量，即使在函数中变量赋予新值，也会变成自由变量。如果为nonlocal声明的变量赋予新值，闭包中保存的绑定会更新。正确版的make_averager的正确实现如下：\n```python\ndef make_averager():\n    count = 0\n    total = 0\n    def averager(new_value):\n        nonlocal count, total\n        count += 1\n        total += new_value\n        return total/count\n\n    return averager\n\n```\n这样一来，上面的错误就没有了。\n","source":"_posts/Python3-nonlocal声明.md","raw":"---\ntitle: Python3 nonlocal声明\ndate: 2018-03-06 14:58:07\ntags:\n  - Python3\ncategories:\n  - Python3 进阶\n  - Python3 闭包\n---\n前一节讲闭包时用到以下代码：\n```python\n# 示例2\ndef make_averager():\n    series = []\n\n    def averager(new_value):\n        series.append(new_value)\n        total = sum(series)\n        return total/len(series)\n\n    return averager\n```\n以上实现make_averager函数的方法效率不高。在如下示例中,我们把所有值存储在历史数列中，然后在每次调用averager时使用sum求和。更好的实现方式是，只存储目前的总和以及元素个数，然后使用这两个值计算平均数。以下是实现方式，这种实现方式存在缺陷，只是为了引出`nonlocal声明`。\n<!-- more -->\n```python\ndef make_averager():\n    count = 0\n    total = 0\n    def averager(new_value):\n        count += 1\n        total += new_value\n        return total/count\n\n    return averager\n\n```\n\n尝试使用以上定义的函数，得到如下结果：\n```python\n>>> avg = make_averager()\n>>> avg(10)\n---------------------------------------------------------------------------\nUnboundLocalError                         Traceback (most recent call last)\n<ipython-input-42-ace390caaa2e> in <module>()\n----> 1 avg(10)\n\n<ipython-input-38-371a27b41829> in averager(new_value)\n      3     total = 0\n      4     def averager(new_value):\n----> 5         count += 1\n      6         total += new_value\n      7         return total/count\n\nUnboundLocalError: local variable 'count' referenced before assignment\n```\n\n问题是，当count是数字或任何不可变类型时，`count += 1`语句的作用其实与`count = count + 1`一样，因此我们在averager的定义体中为count赋值了，这样会把count变量变为局部变量，而不是自由变量。total变量也会受到这样的影响。\n\n示例2 中没有遇到这样的问题是因为我们没有给series赋值，我们只是调用`series.append`，并把它传给sum和len。也就是说，我们利用了列表是可变的对象这一事实。\n\n但是对数字和字符串、元组等不可变类型来说，只能读取，不能更新。如果尝试重新绑定，例如count += 1,其实会隐式的创建局部变量count。`这样count就不是自由变量了，也就不会保存在闭包中`。\n\n为了解决这个问题，python3引入了`nonlocal声明`。他的作用是把变量标记为自由变量，即使在函数中变量赋予新值，也会变成自由变量。如果为nonlocal声明的变量赋予新值，闭包中保存的绑定会更新。正确版的make_averager的正确实现如下：\n```python\ndef make_averager():\n    count = 0\n    total = 0\n    def averager(new_value):\n        nonlocal count, total\n        count += 1\n        total += new_value\n        return total/count\n\n    return averager\n\n```\n这样一来，上面的错误就没有了。\n","slug":"Python3-nonlocal声明","published":1,"updated":"2018-03-06T07:23:38.494Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozki001a8mot7wlppxm0","content":"<p>前一节讲闭包时用到以下代码：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 示例2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">make_averager</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    series = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">averager</span><span class=\"params\">(new_value)</span>:</span></span><br><span class=\"line\">        series.append(new_value)</span><br><span class=\"line\">        total = sum(series)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> total/len(series)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> averager</span><br></pre></td></tr></table></figure></p>\n<p>以上实现make_averager函数的方法效率不高。在如下示例中,我们把所有值存储在历史数列中，然后在每次调用averager时使用sum求和。更好的实现方式是，只存储目前的总和以及元素个数，然后使用这两个值计算平均数。以下是实现方式，这种实现方式存在缺陷，只是为了引出<code>nonlocal声明</code>。<br><a id=\"more\"></a><br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">make_averager</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    count = <span class=\"number\">0</span></span><br><span class=\"line\">    total = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">averager</span><span class=\"params\">(new_value)</span>:</span></span><br><span class=\"line\">        count += <span class=\"number\">1</span></span><br><span class=\"line\">        total += new_value</span><br><span class=\"line\">        <span class=\"keyword\">return</span> total/count</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> averager</span><br></pre></td></tr></table></figure></p>\n<p>尝试使用以上定义的函数，得到如下结果：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>avg = make_averager()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>avg(<span class=\"number\">10</span>)</span><br><span class=\"line\">---------------------------------------------------------------------------</span><br><span class=\"line\">UnboundLocalError                         Traceback (most recent call last)</span><br><span class=\"line\">&lt;ipython-input<span class=\"number\">-42</span>-ace390caaa2e&gt; <span class=\"keyword\">in</span> &lt;module&gt;()</span><br><span class=\"line\">----&gt; 1 avg(10)</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;ipython-input<span class=\"number\">-38</span><span class=\"number\">-371</span>a27b41829&gt; <span class=\"keyword\">in</span> averager(new_value)</span><br><span class=\"line\">      <span class=\"number\">3</span>     total = <span class=\"number\">0</span></span><br><span class=\"line\">      <span class=\"number\">4</span>     <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">averager</span><span class=\"params\">(new_value)</span>:</span></span><br><span class=\"line\">----&gt; 5         count += 1</span><br><span class=\"line\">      <span class=\"number\">6</span>         total += new_value</span><br><span class=\"line\">      <span class=\"number\">7</span>         <span class=\"keyword\">return</span> total/count</span><br><span class=\"line\"></span><br><span class=\"line\">UnboundLocalError: local variable <span class=\"string\">'count'</span> referenced before assignment</span><br></pre></td></tr></table></figure></p>\n<p>问题是，当count是数字或任何不可变类型时，<code>count += 1</code>语句的作用其实与<code>count = count + 1</code>一样，因此我们在averager的定义体中为count赋值了，这样会把count变量变为局部变量，而不是自由变量。total变量也会受到这样的影响。</p>\n<p>示例2 中没有遇到这样的问题是因为我们没有给series赋值，我们只是调用<code>series.append</code>，并把它传给sum和len。也就是说，我们利用了列表是可变的对象这一事实。</p>\n<p>但是对数字和字符串、元组等不可变类型来说，只能读取，不能更新。如果尝试重新绑定，例如count += 1,其实会隐式的创建局部变量count。<code>这样count就不是自由变量了，也就不会保存在闭包中</code>。</p>\n<p>为了解决这个问题，python3引入了<code>nonlocal声明</code>。他的作用是把变量标记为自由变量，即使在函数中变量赋予新值，也会变成自由变量。如果为nonlocal声明的变量赋予新值，闭包中保存的绑定会更新。正确版的make_averager的正确实现如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">make_averager</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    count = <span class=\"number\">0</span></span><br><span class=\"line\">    total = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">averager</span><span class=\"params\">(new_value)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">nonlocal</span> count, total</span><br><span class=\"line\">        count += <span class=\"number\">1</span></span><br><span class=\"line\">        total += new_value</span><br><span class=\"line\">        <span class=\"keyword\">return</span> total/count</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> averager</span><br></pre></td></tr></table></figure></p>\n<p>这样一来，上面的错误就没有了。</p>\n","site":{"data":{}},"excerpt":"<p>前一节讲闭包时用到以下代码：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 示例2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">make_averager</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    series = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">averager</span><span class=\"params\">(new_value)</span>:</span></span><br><span class=\"line\">        series.append(new_value)</span><br><span class=\"line\">        total = sum(series)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> total/len(series)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> averager</span><br></pre></td></tr></table></figure></p>\n<p>以上实现make_averager函数的方法效率不高。在如下示例中,我们把所有值存储在历史数列中，然后在每次调用averager时使用sum求和。更好的实现方式是，只存储目前的总和以及元素个数，然后使用这两个值计算平均数。以下是实现方式，这种实现方式存在缺陷，只是为了引出<code>nonlocal声明</code>。<br>","more":"<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">make_averager</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    count = <span class=\"number\">0</span></span><br><span class=\"line\">    total = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">averager</span><span class=\"params\">(new_value)</span>:</span></span><br><span class=\"line\">        count += <span class=\"number\">1</span></span><br><span class=\"line\">        total += new_value</span><br><span class=\"line\">        <span class=\"keyword\">return</span> total/count</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> averager</span><br></pre></td></tr></table></figure></p>\n<p>尝试使用以上定义的函数，得到如下结果：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>avg = make_averager()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>avg(<span class=\"number\">10</span>)</span><br><span class=\"line\">---------------------------------------------------------------------------</span><br><span class=\"line\">UnboundLocalError                         Traceback (most recent call last)</span><br><span class=\"line\">&lt;ipython-input<span class=\"number\">-42</span>-ace390caaa2e&gt; <span class=\"keyword\">in</span> &lt;module&gt;()</span><br><span class=\"line\">----&gt; 1 avg(10)</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;ipython-input<span class=\"number\">-38</span><span class=\"number\">-371</span>a27b41829&gt; <span class=\"keyword\">in</span> averager(new_value)</span><br><span class=\"line\">      <span class=\"number\">3</span>     total = <span class=\"number\">0</span></span><br><span class=\"line\">      <span class=\"number\">4</span>     <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">averager</span><span class=\"params\">(new_value)</span>:</span></span><br><span class=\"line\">----&gt; 5         count += 1</span><br><span class=\"line\">      <span class=\"number\">6</span>         total += new_value</span><br><span class=\"line\">      <span class=\"number\">7</span>         <span class=\"keyword\">return</span> total/count</span><br><span class=\"line\"></span><br><span class=\"line\">UnboundLocalError: local variable <span class=\"string\">'count'</span> referenced before assignment</span><br></pre></td></tr></table></figure></p>\n<p>问题是，当count是数字或任何不可变类型时，<code>count += 1</code>语句的作用其实与<code>count = count + 1</code>一样，因此我们在averager的定义体中为count赋值了，这样会把count变量变为局部变量，而不是自由变量。total变量也会受到这样的影响。</p>\n<p>示例2 中没有遇到这样的问题是因为我们没有给series赋值，我们只是调用<code>series.append</code>，并把它传给sum和len。也就是说，我们利用了列表是可变的对象这一事实。</p>\n<p>但是对数字和字符串、元组等不可变类型来说，只能读取，不能更新。如果尝试重新绑定，例如count += 1,其实会隐式的创建局部变量count。<code>这样count就不是自由变量了，也就不会保存在闭包中</code>。</p>\n<p>为了解决这个问题，python3引入了<code>nonlocal声明</code>。他的作用是把变量标记为自由变量，即使在函数中变量赋予新值，也会变成自由变量。如果为nonlocal声明的变量赋予新值，闭包中保存的绑定会更新。正确版的make_averager的正确实现如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">make_averager</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    count = <span class=\"number\">0</span></span><br><span class=\"line\">    total = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">averager</span><span class=\"params\">(new_value)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">nonlocal</span> count, total</span><br><span class=\"line\">        count += <span class=\"number\">1</span></span><br><span class=\"line\">        total += new_value</span><br><span class=\"line\">        <span class=\"keyword\">return</span> total/count</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> averager</span><br></pre></td></tr></table></figure></p>\n<p>这样一来，上面的错误就没有了。</p>"},{"title":"Python3 os和sys模块的作用，以及常用的模块方法","date":"2018-03-12T08:43:03.000Z","_content":"官方解释：\n> os： This module provides a portable way of using operating system dependent functionality.\n\n翻译：提供一种方便的使用`操作系统函数`的方法。\n\n> sys：This module provides access to some variables used or maintained by the interpreter and to functions that interact strongly with the interpreter.\n\n翻译：提供访问由`解释器`使用或维护的变量和在与`解释器交互`使用到的函数。\n\n<!-- more -->\n\n## os 常用方法\n```Python\nos.remove()  # 删除文件  \nos.rename()  # 重命名文件  \nos.walk()  # 生成目录树下的所有文件名  \nos.chdir()  # 改变目录  \nos.mkdir/makedirs  # 创建目录/多层目录  \nos.rmdir/removedirs  # 删除目录/多层目录  \nos.listdir()  # 列出指定目录的文件  \nos.getcwd()  # 取得当前工作目录  \nos.chmod()  # 改变目录权限  \nos.path.basename()  # 去掉目录路径，返回文件名  \nos.path.dirname()  # 去掉文件名，返回目录路径  \nos.path.join()  # 将分离的各部分组合成一个路径名  \nos.path.split()  # 返回（dirname(),basename())元组  \nos.path.splitext()  # 返回(filename,extension)元组  \nos.path.getatime|ctime|mtime   # 分别返回最近访问、创建、修改时间  \nos.path.getsize()  # 返回文件大小  \nos.path.exists()  # 是否存在  \nos.path.isabs()  # 是否为绝对路径  \nos.path.isdir()  # 是否为目录  \nos.path.isfile()  # 是否为文件  \n\n```\n## sys 常用方法\n```Python\nsys.argv           # 命令行参数List，第一个元素是程序本身路径    \nsys.modules.keys() # 返回所有已经导入的模块列表    \nsys.exc_info()     # 获取当前正在处理的异常类,exc_type、exc_value、exc_traceback当前处理的异常详细信息    \nsys.exit(n)        # 退出程序，正常退出时exit(0)    \nsys.hexversion     # 获取Python解释程序的版本值，16进制格式如：0x020403F0    \nsys.version        # 获取Python解释程序的版本信息    \nsys.maxint         # 最大的Int值    \nsys.maxunicode     # 最大的Unicode值    \nsys.modules        # 返回系统导入的模块字段，key是模块名，value是模块    \nsys.path           # 返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值    \nsys.platform       # 返回操作系统平台名称    \nsys.stdout         # 标准输出   \nsys.stdin          # 标准输入   \nsys.stderr         # 错误输出   \nsys.exc_clear()    # 用来清除当前线程所出现的当前的或最近的错误信息   \nsys.exec_prefix    # 返回平台独立的python文件安装的位置   \nsys.byteorder      # 本地字节规则的指示器，big-endian平台的值是'big',little-endian平台的值是'little'   \nsys.copyright      # 记录python版权相关的东西   \nsys.api_version    # 解释器的C的API版本   \nsys.version_info\n```\n","source":"_posts/Python3-os和sys模块的作用，以及常用的模块方法.md","raw":"---\ntitle: Python3 os和sys模块的作用，以及常用的模块方法\ndate: 2018-03-12 16:43:03\ntags:\n  - Python3\ncategories:\n  - Python3 进阶\n---\n官方解释：\n> os： This module provides a portable way of using operating system dependent functionality.\n\n翻译：提供一种方便的使用`操作系统函数`的方法。\n\n> sys：This module provides access to some variables used or maintained by the interpreter and to functions that interact strongly with the interpreter.\n\n翻译：提供访问由`解释器`使用或维护的变量和在与`解释器交互`使用到的函数。\n\n<!-- more -->\n\n## os 常用方法\n```Python\nos.remove()  # 删除文件  \nos.rename()  # 重命名文件  \nos.walk()  # 生成目录树下的所有文件名  \nos.chdir()  # 改变目录  \nos.mkdir/makedirs  # 创建目录/多层目录  \nos.rmdir/removedirs  # 删除目录/多层目录  \nos.listdir()  # 列出指定目录的文件  \nos.getcwd()  # 取得当前工作目录  \nos.chmod()  # 改变目录权限  \nos.path.basename()  # 去掉目录路径，返回文件名  \nos.path.dirname()  # 去掉文件名，返回目录路径  \nos.path.join()  # 将分离的各部分组合成一个路径名  \nos.path.split()  # 返回（dirname(),basename())元组  \nos.path.splitext()  # 返回(filename,extension)元组  \nos.path.getatime|ctime|mtime   # 分别返回最近访问、创建、修改时间  \nos.path.getsize()  # 返回文件大小  \nos.path.exists()  # 是否存在  \nos.path.isabs()  # 是否为绝对路径  \nos.path.isdir()  # 是否为目录  \nos.path.isfile()  # 是否为文件  \n\n```\n## sys 常用方法\n```Python\nsys.argv           # 命令行参数List，第一个元素是程序本身路径    \nsys.modules.keys() # 返回所有已经导入的模块列表    \nsys.exc_info()     # 获取当前正在处理的异常类,exc_type、exc_value、exc_traceback当前处理的异常详细信息    \nsys.exit(n)        # 退出程序，正常退出时exit(0)    \nsys.hexversion     # 获取Python解释程序的版本值，16进制格式如：0x020403F0    \nsys.version        # 获取Python解释程序的版本信息    \nsys.maxint         # 最大的Int值    \nsys.maxunicode     # 最大的Unicode值    \nsys.modules        # 返回系统导入的模块字段，key是模块名，value是模块    \nsys.path           # 返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值    \nsys.platform       # 返回操作系统平台名称    \nsys.stdout         # 标准输出   \nsys.stdin          # 标准输入   \nsys.stderr         # 错误输出   \nsys.exc_clear()    # 用来清除当前线程所出现的当前的或最近的错误信息   \nsys.exec_prefix    # 返回平台独立的python文件安装的位置   \nsys.byteorder      # 本地字节规则的指示器，big-endian平台的值是'big',little-endian平台的值是'little'   \nsys.copyright      # 记录python版权相关的东西   \nsys.api_version    # 解释器的C的API版本   \nsys.version_info\n```\n","slug":"Python3-os和sys模块的作用，以及常用的模块方法","published":1,"updated":"2018-03-12T08:49:03.868Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozkj001e8motoqsr86qu","content":"<p>官方解释：</p>\n<blockquote>\n<p>os： This module provides a portable way of using operating system dependent functionality.</p>\n</blockquote>\n<p>翻译：提供一种方便的使用<code>操作系统函数</code>的方法。</p>\n<blockquote>\n<p>sys：This module provides access to some variables used or maintained by the interpreter and to functions that interact strongly with the interpreter.</p>\n</blockquote>\n<p>翻译：提供访问由<code>解释器</code>使用或维护的变量和在与<code>解释器交互</code>使用到的函数。</p>\n<a id=\"more\"></a>\n<h2 id=\"os-常用方法\"><a href=\"#os-常用方法\" class=\"headerlink\" title=\"os 常用方法\"></a>os 常用方法</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">os.remove()  <span class=\"comment\"># 删除文件  </span></span><br><span class=\"line\">os.rename()  <span class=\"comment\"># 重命名文件  </span></span><br><span class=\"line\">os.walk()  <span class=\"comment\"># 生成目录树下的所有文件名  </span></span><br><span class=\"line\">os.chdir()  <span class=\"comment\"># 改变目录  </span></span><br><span class=\"line\">os.mkdir/makedirs  <span class=\"comment\"># 创建目录/多层目录  </span></span><br><span class=\"line\">os.rmdir/removedirs  <span class=\"comment\"># 删除目录/多层目录  </span></span><br><span class=\"line\">os.listdir()  <span class=\"comment\"># 列出指定目录的文件  </span></span><br><span class=\"line\">os.getcwd()  <span class=\"comment\"># 取得当前工作目录  </span></span><br><span class=\"line\">os.chmod()  <span class=\"comment\"># 改变目录权限  </span></span><br><span class=\"line\">os.path.basename()  <span class=\"comment\"># 去掉目录路径，返回文件名  </span></span><br><span class=\"line\">os.path.dirname()  <span class=\"comment\"># 去掉文件名，返回目录路径  </span></span><br><span class=\"line\">os.path.join()  <span class=\"comment\"># 将分离的各部分组合成一个路径名  </span></span><br><span class=\"line\">os.path.split()  <span class=\"comment\"># 返回（dirname(),basename())元组  </span></span><br><span class=\"line\">os.path.splitext()  <span class=\"comment\"># 返回(filename,extension)元组  </span></span><br><span class=\"line\">os.path.getatime|ctime|mtime   <span class=\"comment\"># 分别返回最近访问、创建、修改时间  </span></span><br><span class=\"line\">os.path.getsize()  <span class=\"comment\"># 返回文件大小  </span></span><br><span class=\"line\">os.path.exists()  <span class=\"comment\"># 是否存在  </span></span><br><span class=\"line\">os.path.isabs()  <span class=\"comment\"># 是否为绝对路径  </span></span><br><span class=\"line\">os.path.isdir()  <span class=\"comment\"># 是否为目录  </span></span><br><span class=\"line\">os.path.isfile()  <span class=\"comment\"># 是否为文件</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"sys-常用方法\"><a href=\"#sys-常用方法\" class=\"headerlink\" title=\"sys 常用方法\"></a>sys 常用方法</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sys.argv           <span class=\"comment\"># 命令行参数List，第一个元素是程序本身路径    </span></span><br><span class=\"line\">sys.modules.keys() <span class=\"comment\"># 返回所有已经导入的模块列表    </span></span><br><span class=\"line\">sys.exc_info()     <span class=\"comment\"># 获取当前正在处理的异常类,exc_type、exc_value、exc_traceback当前处理的异常详细信息    </span></span><br><span class=\"line\">sys.exit(n)        <span class=\"comment\"># 退出程序，正常退出时exit(0)    </span></span><br><span class=\"line\">sys.hexversion     <span class=\"comment\"># 获取Python解释程序的版本值，16进制格式如：0x020403F0    </span></span><br><span class=\"line\">sys.version        <span class=\"comment\"># 获取Python解释程序的版本信息    </span></span><br><span class=\"line\">sys.maxint         <span class=\"comment\"># 最大的Int值    </span></span><br><span class=\"line\">sys.maxunicode     <span class=\"comment\"># 最大的Unicode值    </span></span><br><span class=\"line\">sys.modules        <span class=\"comment\"># 返回系统导入的模块字段，key是模块名，value是模块    </span></span><br><span class=\"line\">sys.path           <span class=\"comment\"># 返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值    </span></span><br><span class=\"line\">sys.platform       <span class=\"comment\"># 返回操作系统平台名称    </span></span><br><span class=\"line\">sys.stdout         <span class=\"comment\"># 标准输出   </span></span><br><span class=\"line\">sys.stdin          <span class=\"comment\"># 标准输入   </span></span><br><span class=\"line\">sys.stderr         <span class=\"comment\"># 错误输出   </span></span><br><span class=\"line\">sys.exc_clear()    <span class=\"comment\"># 用来清除当前线程所出现的当前的或最近的错误信息   </span></span><br><span class=\"line\">sys.exec_prefix    <span class=\"comment\"># 返回平台独立的python文件安装的位置   </span></span><br><span class=\"line\">sys.byteorder      <span class=\"comment\"># 本地字节规则的指示器，big-endian平台的值是'big',little-endian平台的值是'little'   </span></span><br><span class=\"line\">sys.copyright      <span class=\"comment\"># 记录python版权相关的东西   </span></span><br><span class=\"line\">sys.api_version    <span class=\"comment\"># 解释器的C的API版本   </span></span><br><span class=\"line\">sys.version_info</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>官方解释：</p>\n<blockquote>\n<p>os： This module provides a portable way of using operating system dependent functionality.</p>\n</blockquote>\n<p>翻译：提供一种方便的使用<code>操作系统函数</code>的方法。</p>\n<blockquote>\n<p>sys：This module provides access to some variables used or maintained by the interpreter and to functions that interact strongly with the interpreter.</p>\n</blockquote>\n<p>翻译：提供访问由<code>解释器</code>使用或维护的变量和在与<code>解释器交互</code>使用到的函数。</p>","more":"<h2 id=\"os-常用方法\"><a href=\"#os-常用方法\" class=\"headerlink\" title=\"os 常用方法\"></a>os 常用方法</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">os.remove()  <span class=\"comment\"># 删除文件  </span></span><br><span class=\"line\">os.rename()  <span class=\"comment\"># 重命名文件  </span></span><br><span class=\"line\">os.walk()  <span class=\"comment\"># 生成目录树下的所有文件名  </span></span><br><span class=\"line\">os.chdir()  <span class=\"comment\"># 改变目录  </span></span><br><span class=\"line\">os.mkdir/makedirs  <span class=\"comment\"># 创建目录/多层目录  </span></span><br><span class=\"line\">os.rmdir/removedirs  <span class=\"comment\"># 删除目录/多层目录  </span></span><br><span class=\"line\">os.listdir()  <span class=\"comment\"># 列出指定目录的文件  </span></span><br><span class=\"line\">os.getcwd()  <span class=\"comment\"># 取得当前工作目录  </span></span><br><span class=\"line\">os.chmod()  <span class=\"comment\"># 改变目录权限  </span></span><br><span class=\"line\">os.path.basename()  <span class=\"comment\"># 去掉目录路径，返回文件名  </span></span><br><span class=\"line\">os.path.dirname()  <span class=\"comment\"># 去掉文件名，返回目录路径  </span></span><br><span class=\"line\">os.path.join()  <span class=\"comment\"># 将分离的各部分组合成一个路径名  </span></span><br><span class=\"line\">os.path.split()  <span class=\"comment\"># 返回（dirname(),basename())元组  </span></span><br><span class=\"line\">os.path.splitext()  <span class=\"comment\"># 返回(filename,extension)元组  </span></span><br><span class=\"line\">os.path.getatime|ctime|mtime   <span class=\"comment\"># 分别返回最近访问、创建、修改时间  </span></span><br><span class=\"line\">os.path.getsize()  <span class=\"comment\"># 返回文件大小  </span></span><br><span class=\"line\">os.path.exists()  <span class=\"comment\"># 是否存在  </span></span><br><span class=\"line\">os.path.isabs()  <span class=\"comment\"># 是否为绝对路径  </span></span><br><span class=\"line\">os.path.isdir()  <span class=\"comment\"># 是否为目录  </span></span><br><span class=\"line\">os.path.isfile()  <span class=\"comment\"># 是否为文件</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"sys-常用方法\"><a href=\"#sys-常用方法\" class=\"headerlink\" title=\"sys 常用方法\"></a>sys 常用方法</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sys.argv           <span class=\"comment\"># 命令行参数List，第一个元素是程序本身路径    </span></span><br><span class=\"line\">sys.modules.keys() <span class=\"comment\"># 返回所有已经导入的模块列表    </span></span><br><span class=\"line\">sys.exc_info()     <span class=\"comment\"># 获取当前正在处理的异常类,exc_type、exc_value、exc_traceback当前处理的异常详细信息    </span></span><br><span class=\"line\">sys.exit(n)        <span class=\"comment\"># 退出程序，正常退出时exit(0)    </span></span><br><span class=\"line\">sys.hexversion     <span class=\"comment\"># 获取Python解释程序的版本值，16进制格式如：0x020403F0    </span></span><br><span class=\"line\">sys.version        <span class=\"comment\"># 获取Python解释程序的版本信息    </span></span><br><span class=\"line\">sys.maxint         <span class=\"comment\"># 最大的Int值    </span></span><br><span class=\"line\">sys.maxunicode     <span class=\"comment\"># 最大的Unicode值    </span></span><br><span class=\"line\">sys.modules        <span class=\"comment\"># 返回系统导入的模块字段，key是模块名，value是模块    </span></span><br><span class=\"line\">sys.path           <span class=\"comment\"># 返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值    </span></span><br><span class=\"line\">sys.platform       <span class=\"comment\"># 返回操作系统平台名称    </span></span><br><span class=\"line\">sys.stdout         <span class=\"comment\"># 标准输出   </span></span><br><span class=\"line\">sys.stdin          <span class=\"comment\"># 标准输入   </span></span><br><span class=\"line\">sys.stderr         <span class=\"comment\"># 错误输出   </span></span><br><span class=\"line\">sys.exc_clear()    <span class=\"comment\"># 用来清除当前线程所出现的当前的或最近的错误信息   </span></span><br><span class=\"line\">sys.exec_prefix    <span class=\"comment\"># 返回平台独立的python文件安装的位置   </span></span><br><span class=\"line\">sys.byteorder      <span class=\"comment\"># 本地字节规则的指示器，big-endian平台的值是'big',little-endian平台的值是'little'   </span></span><br><span class=\"line\">sys.copyright      <span class=\"comment\"># 记录python版权相关的东西   </span></span><br><span class=\"line\">sys.api_version    <span class=\"comment\"># 解释器的C的API版本   </span></span><br><span class=\"line\">sys.version_info</span><br></pre></td></tr></table></figure>"},{"title":"Python3 @staticmethod和@classmethod","date":"2018-02-28T18:01:19.000Z","_content":"\nPython其实有3个方法,即静态方法(staticmethod),类方法(classmethod)和实例方法,如下:\n\n```python\ndef foo(x):\n    print \"executing foo(%s)\"%(x)\n\nclass A(object):\n    def foo(self,x):\n        print \"executing foo(%s,%s)\"%(self,x)\n\n    @classmethod\n    def class_foo(cls,x):\n        print \"executing class_foo(%s,%s)\"%(cls,x)\n\n    @staticmethod\n    def static_foo(x):\n        print \"executing static_foo(%s)\"%x\n\na=A()\n\n```\n<!-- more -->\n这里先理解下函数参数里面的self和cls。这个self和cls是对类或者实例的绑定,对于一般的函数来说我们可以这么调用`foo(x)`,这个函数就是最常用的,它的工作跟任何东西(类,实例)无关。\n对于实例方法,我们知道在类里每次定义方法的时候都需要绑定这个实例,就是`foo(self, x)`,为什么要这么做呢?因为实例方法的调用离不开实例,我们需要把实例自己传给函数,调用的时候是这样的`a.foo(x)`(其实是`foo(a, x)`)。\n类方法一样,只不过它传递的是`类`而不是实例,`A.class_foo(x)`。注意这里的self和cls可以替换别的参数,但是python的约定是这俩,还是不要改的好。\n\n对于静态方法其实和普通的方法一样,不需要对谁进行绑定,唯一的区别是调用的时候需要使用`a.static_foo(x)`或者`A.static_foo(x)`来调用.\n\n| \\\\      | 实例方法     | 类方法            | 静态方法            |\n| :------ | :------- | :------------- | :-------------- |\n| a = A() | a.foo(x) | a.class_foo(x) | a.static_foo(x) |\n| A       | 不可用      | A.class_foo(x) | A.static_foo(x) |\n\n更多关于这个问题:\n1. http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python\n2. https://realpython.com/blog/python/instance-class-and-static-methods-demystified/\n","source":"_posts/Python3-staticmethod和-classmethod.md","raw":"---\ntitle: Python3 @staticmethod和@classmethod\ndate: 2018-03-01 02:01:19\ntags:\n  - Python3\ncategories:\n  - Python3 进阶\n  - Staticmethod & Classmethod\n---\n\nPython其实有3个方法,即静态方法(staticmethod),类方法(classmethod)和实例方法,如下:\n\n```python\ndef foo(x):\n    print \"executing foo(%s)\"%(x)\n\nclass A(object):\n    def foo(self,x):\n        print \"executing foo(%s,%s)\"%(self,x)\n\n    @classmethod\n    def class_foo(cls,x):\n        print \"executing class_foo(%s,%s)\"%(cls,x)\n\n    @staticmethod\n    def static_foo(x):\n        print \"executing static_foo(%s)\"%x\n\na=A()\n\n```\n<!-- more -->\n这里先理解下函数参数里面的self和cls。这个self和cls是对类或者实例的绑定,对于一般的函数来说我们可以这么调用`foo(x)`,这个函数就是最常用的,它的工作跟任何东西(类,实例)无关。\n对于实例方法,我们知道在类里每次定义方法的时候都需要绑定这个实例,就是`foo(self, x)`,为什么要这么做呢?因为实例方法的调用离不开实例,我们需要把实例自己传给函数,调用的时候是这样的`a.foo(x)`(其实是`foo(a, x)`)。\n类方法一样,只不过它传递的是`类`而不是实例,`A.class_foo(x)`。注意这里的self和cls可以替换别的参数,但是python的约定是这俩,还是不要改的好。\n\n对于静态方法其实和普通的方法一样,不需要对谁进行绑定,唯一的区别是调用的时候需要使用`a.static_foo(x)`或者`A.static_foo(x)`来调用.\n\n| \\\\      | 实例方法     | 类方法            | 静态方法            |\n| :------ | :------- | :------------- | :-------------- |\n| a = A() | a.foo(x) | a.class_foo(x) | a.static_foo(x) |\n| A       | 不可用      | A.class_foo(x) | A.static_foo(x) |\n\n更多关于这个问题:\n1. http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python\n2. https://realpython.com/blog/python/instance-class-and-static-methods-demystified/\n","slug":"Python3-staticmethod和-classmethod","published":1,"updated":"2018-03-01T06:36:20.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozkl001h8motnm9grrgq","content":"<p>Python其实有3个方法,即静态方法(staticmethod),类方法(classmethod)和实例方法,如下:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">foo</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">\"executing foo(%s)\"</span>%(x)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">foo</span><span class=\"params\">(self,x)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"executing foo(%s,%s)\"</span>%(self,x)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @classmethod</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">class_foo</span><span class=\"params\">(cls,x)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"executing class_foo(%s,%s)\"</span>%(cls,x)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @staticmethod</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">static_foo</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"executing static_foo(%s)\"</span>%x</span><br><span class=\"line\"></span><br><span class=\"line\">a=A()</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>这里先理解下函数参数里面的self和cls。这个self和cls是对类或者实例的绑定,对于一般的函数来说我们可以这么调用<code>foo(x)</code>,这个函数就是最常用的,它的工作跟任何东西(类,实例)无关。<br>对于实例方法,我们知道在类里每次定义方法的时候都需要绑定这个实例,就是<code>foo(self, x)</code>,为什么要这么做呢?因为实例方法的调用离不开实例,我们需要把实例自己传给函数,调用的时候是这样的<code>a.foo(x)</code>(其实是<code>foo(a, x)</code>)。<br>类方法一样,只不过它传递的是<code>类</code>而不是实例,<code>A.class_foo(x)</code>。注意这里的self和cls可以替换别的参数,但是python的约定是这俩,还是不要改的好。</p>\n<p>对于静态方法其实和普通的方法一样,不需要对谁进行绑定,唯一的区别是调用的时候需要使用<code>a.static_foo(x)</code>或者<code>A.static_foo(x)</code>来调用.</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">\\</th>\n<th style=\"text-align:left\">实例方法</th>\n<th style=\"text-align:left\">类方法</th>\n<th style=\"text-align:left\">静态方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">a = A()</td>\n<td style=\"text-align:left\">a.foo(x)</td>\n<td style=\"text-align:left\">a.class_foo(x)</td>\n<td style=\"text-align:left\">a.static_foo(x)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">A</td>\n<td style=\"text-align:left\">不可用</td>\n<td style=\"text-align:left\">A.class_foo(x)</td>\n<td style=\"text-align:left\">A.static_foo(x)</td>\n</tr>\n</tbody>\n</table>\n<p>更多关于这个问题:</p>\n<ol>\n<li><a href=\"http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python\" target=\"_blank\" rel=\"noopener\">http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python</a></li>\n<li><a href=\"https://realpython.com/blog/python/instance-class-and-static-methods-demystified/\" target=\"_blank\" rel=\"noopener\">https://realpython.com/blog/python/instance-class-and-static-methods-demystified/</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>Python其实有3个方法,即静态方法(staticmethod),类方法(classmethod)和实例方法,如下:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">foo</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">\"executing foo(%s)\"</span>%(x)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">foo</span><span class=\"params\">(self,x)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"executing foo(%s,%s)\"</span>%(self,x)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @classmethod</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">class_foo</span><span class=\"params\">(cls,x)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"executing class_foo(%s,%s)\"</span>%(cls,x)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @staticmethod</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">static_foo</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"executing static_foo(%s)\"</span>%x</span><br><span class=\"line\"></span><br><span class=\"line\">a=A()</span><br></pre></td></tr></table></figure>","more":"<p>这里先理解下函数参数里面的self和cls。这个self和cls是对类或者实例的绑定,对于一般的函数来说我们可以这么调用<code>foo(x)</code>,这个函数就是最常用的,它的工作跟任何东西(类,实例)无关。<br>对于实例方法,我们知道在类里每次定义方法的时候都需要绑定这个实例,就是<code>foo(self, x)</code>,为什么要这么做呢?因为实例方法的调用离不开实例,我们需要把实例自己传给函数,调用的时候是这样的<code>a.foo(x)</code>(其实是<code>foo(a, x)</code>)。<br>类方法一样,只不过它传递的是<code>类</code>而不是实例,<code>A.class_foo(x)</code>。注意这里的self和cls可以替换别的参数,但是python的约定是这俩,还是不要改的好。</p>\n<p>对于静态方法其实和普通的方法一样,不需要对谁进行绑定,唯一的区别是调用的时候需要使用<code>a.static_foo(x)</code>或者<code>A.static_foo(x)</code>来调用.</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">\\</th>\n<th style=\"text-align:left\">实例方法</th>\n<th style=\"text-align:left\">类方法</th>\n<th style=\"text-align:left\">静态方法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">a = A()</td>\n<td style=\"text-align:left\">a.foo(x)</td>\n<td style=\"text-align:left\">a.class_foo(x)</td>\n<td style=\"text-align:left\">a.static_foo(x)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">A</td>\n<td style=\"text-align:left\">不可用</td>\n<td style=\"text-align:left\">A.class_foo(x)</td>\n<td style=\"text-align:left\">A.static_foo(x)</td>\n</tr>\n</tbody>\n</table>\n<p>更多关于这个问题:</p>\n<ol>\n<li><a href=\"http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python\" target=\"_blank\" rel=\"noopener\">http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python</a></li>\n<li><a href=\"https://realpython.com/blog/python/instance-class-and-static-methods-demystified/\" target=\"_blank\" rel=\"noopener\">https://realpython.com/blog/python/instance-class-and-static-methods-demystified/</a></li>\n</ol>"},{"title":"Python3 作用域","date":"2018-03-03T03:48:30.000Z","_content":"Python 中，一个变量的作用域总是由在代码中被赋值的地方所决定的。\n\nPython 获取变量中的值的搜索顺序为：\n\n本地作用域（Local）→ 当前作用域被嵌入的本地作用域（Enclosing locals）→ 全局/模块作用域（Global）→内置作用域（Built-in）\n","source":"_posts/Python3-作用域.md","raw":"---\ntitle: Python3 作用域\ndate: 2018-03-03 11:48:30\ntags:\n  - Python3\ncategories:\n  - Python3 进阶\n  - Python3 作用域\n---\nPython 中，一个变量的作用域总是由在代码中被赋值的地方所决定的。\n\nPython 获取变量中的值的搜索顺序为：\n\n本地作用域（Local）→ 当前作用域被嵌入的本地作用域（Enclosing locals）→ 全局/模块作用域（Global）→内置作用域（Built-in）\n","slug":"Python3-作用域","published":1,"updated":"2018-03-03T03:56:30.508Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozkm001l8motbav7nhtm","content":"<p>Python 中，一个变量的作用域总是由在代码中被赋值的地方所决定的。</p>\n<p>Python 获取变量中的值的搜索顺序为：</p>\n<p>本地作用域（Local）→ 当前作用域被嵌入的本地作用域（Enclosing locals）→ 全局/模块作用域（Global）→内置作用域（Built-in）</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Python 中，一个变量的作用域总是由在代码中被赋值的地方所决定的。</p>\n<p>Python 获取变量中的值的搜索顺序为：</p>\n<p>本地作用域（Local）→ 当前作用域被嵌入的本地作用域（Enclosing locals）→ 全局/模块作用域（Global）→内置作用域（Built-in）</p>\n"},{"title":"Python3 使用Selenium&PhantomJS爬火影忍者漫画","date":"2018-02-27T06:16:38.000Z","_content":"\n近期学习爬虫，发现懂的越多，不懂的知识点越多（所以当个傻子还是很幸福的）。好记性不如烂笔头，之前都是把看到的资料链接直接挂到一些平台，比如知乎、简书、Github等。今天有点时间，就好好码一下字，排排版，方便以后查阅。\n\nSelenium用来模拟浏览器的行为，比如点击、最大化、滚动窗口等；PhantomJS是一种浏览器，不过这种浏览器没有UI界面，感觉就像是专门为爬虫设计，优点很明显，可以有效减小内存的使用。\n\n<!--more-->\n\n## 爬虫使用到的模块\n```Python\nfrom selenium import webdriver\nfrom myLogging import MyLogging\nimport os\nimport time\nimport re\n```\n\nmyLogging模块是自己配置的日志包，想要的可以点击**_[这里](http://link.zhihu.com/?target=https%3A//github.com/ByiProX/DownloadPicsBySeleniumAndPhantomJS)_**自己看\n\n爬虫很关键的一点就是能够看懂网页的源代码，记得当初刚刚真正开始接触编程的时候，有很长的一段时间在看HTML、CSS、JS的一些知识，虽然忘得很多，但是印象还是有的，对于后面看网页源代码很有帮助。学习爬虫，除了会基本的python知识以外，还要会网页的一些知识。\n\n## 爬取图片思路：\n\n  * 已知连接，分析网页的代码结构，看所需的数据是否需要切换frame，并定位所需数据的位于哪个标签之下\n  * 采用不同的模块有不同的保存图片方式，如果采用request模块，保存图片方式是可以采用**requests.get(comicUrl).content**方法，使用该方法需要确定网页的地址。该项目中没有涉及request的使用，所以此后不再表述。对于selenium可以使用 **get_screenshot_as_file()** 方法，使用该方法强烈建议使用phantomjs，如果使用chrome浏览器，图片尺寸太大的话，会出现截图不完整，对比如下：\n  ![对比](http://upload-images.jianshu.io/upload_images/2952111-2323c462a546dcc3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  * 找到下一张图片的连接位置并点击更新网页，一般来讲新网页与之前网页结构相同。\n  * 在新网页的基础上保存图片，设置循环如此反复。\n\n爬取网页的URL为：[爬取火影漫画第一话](http://link.zhihu.com/?target=http%3A//comic.kukudm.com/comiclist/3/3/1.htm)\n\n## 代码\n\n```Python\nclass DownloadPics(object):\n\n    def __init__(self, url):\n        self.url = url\n        self.log = MyLogging()\n        self.browser = self.get_browser()\n        self.save_pics(self.browser)\n\n    def get_browser(self):\n        browser = webdriver.PhantomJS()\n        try:\n            browser.get(self.url)\n        except:\n            MyLogging.error('open the url %s failed' % self.url)\n        browser.implicitly_wait(20)\n        return browser\n\n    def save_pics(self, browser):\n        pics_title = browser.title.split('_')[0]\n        self.create_dir(pics_title)\n        os.chdir(pics_title)\n        sum_page = self.find_total_page_num(browser)\n        i = 1\n        while i < sum_page:\n            image_name = str(i) + '.png'\n            browser.get_screenshot_as_file(image_name)  \n            # 使用PhantomJS避免了截图的不完整，可以与Chrome比较\n            self.log.info('saving image %s' % image_name)\n            i += 1\n            css_selector = \"a[href='/comiclist/3/3/%s.htm']\" % i  \n            # 该方法感觉还不错呢，不过这个网站确实挺差劲的\n            next_page = browser.find_element_by_css_selector(css_selector)\n            next_page.click()\n            time.sleep(2)\n            # browser.implicitly_wait(20)\n\n    def find_total_page_num(self, browser):\n        page_element = browser.find_element_by_css_selector(\"table[cellspacing='1']\")\n        num = re.search(r'共\\d+页', page_element.text).group()[1:-1]  \n        return int(num)\n\n    def create_dir(self, dir_name):\n        if os.path.exists(dir_name):\n            self.log.error('create directory %s failed cause a same directory exists' % dir_name)\n        else:\n            try:\n                os.makedirs(dir_name)\n            except:\n                self.log.error('create directory %s failed' % dir_name)\n            else:\n                self.log.info('create directory %s success' % dir_name)\n\nif __name__ == '__main__':\n    start_url = 'http://comic.kukudm.com/comiclist/3/3/1.htm'\n    DL = DownloadPics(start_url)\n```\n\n## 运行结果\n\n\n![gif](http://upload-images.jianshu.io/upload_images/2952111-e7e2cf39116b5fea.gif?imageMogr2/auto-orient/strip)\n","source":"_posts/Python3-使用Selenium-PhantomJS爬火影忍者漫画.md","raw":"---\ntitle: Python3 使用Selenium&PhantomJS爬火影忍者漫画\ndate: 2018-02-27 14:16:38\ntags:\n  - Spider\n  - Selenium\n  - PhantomJS\n  - Python3\ncategories:\n  - Spider\n  - Selenium\n\n---\n\n近期学习爬虫，发现懂的越多，不懂的知识点越多（所以当个傻子还是很幸福的）。好记性不如烂笔头，之前都是把看到的资料链接直接挂到一些平台，比如知乎、简书、Github等。今天有点时间，就好好码一下字，排排版，方便以后查阅。\n\nSelenium用来模拟浏览器的行为，比如点击、最大化、滚动窗口等；PhantomJS是一种浏览器，不过这种浏览器没有UI界面，感觉就像是专门为爬虫设计，优点很明显，可以有效减小内存的使用。\n\n<!--more-->\n\n## 爬虫使用到的模块\n```Python\nfrom selenium import webdriver\nfrom myLogging import MyLogging\nimport os\nimport time\nimport re\n```\n\nmyLogging模块是自己配置的日志包，想要的可以点击**_[这里](http://link.zhihu.com/?target=https%3A//github.com/ByiProX/DownloadPicsBySeleniumAndPhantomJS)_**自己看\n\n爬虫很关键的一点就是能够看懂网页的源代码，记得当初刚刚真正开始接触编程的时候，有很长的一段时间在看HTML、CSS、JS的一些知识，虽然忘得很多，但是印象还是有的，对于后面看网页源代码很有帮助。学习爬虫，除了会基本的python知识以外，还要会网页的一些知识。\n\n## 爬取图片思路：\n\n  * 已知连接，分析网页的代码结构，看所需的数据是否需要切换frame，并定位所需数据的位于哪个标签之下\n  * 采用不同的模块有不同的保存图片方式，如果采用request模块，保存图片方式是可以采用**requests.get(comicUrl).content**方法，使用该方法需要确定网页的地址。该项目中没有涉及request的使用，所以此后不再表述。对于selenium可以使用 **get_screenshot_as_file()** 方法，使用该方法强烈建议使用phantomjs，如果使用chrome浏览器，图片尺寸太大的话，会出现截图不完整，对比如下：\n  ![对比](http://upload-images.jianshu.io/upload_images/2952111-2323c462a546dcc3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  * 找到下一张图片的连接位置并点击更新网页，一般来讲新网页与之前网页结构相同。\n  * 在新网页的基础上保存图片，设置循环如此反复。\n\n爬取网页的URL为：[爬取火影漫画第一话](http://link.zhihu.com/?target=http%3A//comic.kukudm.com/comiclist/3/3/1.htm)\n\n## 代码\n\n```Python\nclass DownloadPics(object):\n\n    def __init__(self, url):\n        self.url = url\n        self.log = MyLogging()\n        self.browser = self.get_browser()\n        self.save_pics(self.browser)\n\n    def get_browser(self):\n        browser = webdriver.PhantomJS()\n        try:\n            browser.get(self.url)\n        except:\n            MyLogging.error('open the url %s failed' % self.url)\n        browser.implicitly_wait(20)\n        return browser\n\n    def save_pics(self, browser):\n        pics_title = browser.title.split('_')[0]\n        self.create_dir(pics_title)\n        os.chdir(pics_title)\n        sum_page = self.find_total_page_num(browser)\n        i = 1\n        while i < sum_page:\n            image_name = str(i) + '.png'\n            browser.get_screenshot_as_file(image_name)  \n            # 使用PhantomJS避免了截图的不完整，可以与Chrome比较\n            self.log.info('saving image %s' % image_name)\n            i += 1\n            css_selector = \"a[href='/comiclist/3/3/%s.htm']\" % i  \n            # 该方法感觉还不错呢，不过这个网站确实挺差劲的\n            next_page = browser.find_element_by_css_selector(css_selector)\n            next_page.click()\n            time.sleep(2)\n            # browser.implicitly_wait(20)\n\n    def find_total_page_num(self, browser):\n        page_element = browser.find_element_by_css_selector(\"table[cellspacing='1']\")\n        num = re.search(r'共\\d+页', page_element.text).group()[1:-1]  \n        return int(num)\n\n    def create_dir(self, dir_name):\n        if os.path.exists(dir_name):\n            self.log.error('create directory %s failed cause a same directory exists' % dir_name)\n        else:\n            try:\n                os.makedirs(dir_name)\n            except:\n                self.log.error('create directory %s failed' % dir_name)\n            else:\n                self.log.info('create directory %s success' % dir_name)\n\nif __name__ == '__main__':\n    start_url = 'http://comic.kukudm.com/comiclist/3/3/1.htm'\n    DL = DownloadPics(start_url)\n```\n\n## 运行结果\n\n\n![gif](http://upload-images.jianshu.io/upload_images/2952111-e7e2cf39116b5fea.gif?imageMogr2/auto-orient/strip)\n","slug":"Python3-使用Selenium-PhantomJS爬火影忍者漫画","published":1,"updated":"2018-03-02T18:25:45.955Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozko001p8motm68arqt0","content":"<p>近期学习爬虫，发现懂的越多，不懂的知识点越多（所以当个傻子还是很幸福的）。好记性不如烂笔头，之前都是把看到的资料链接直接挂到一些平台，比如知乎、简书、Github等。今天有点时间，就好好码一下字，排排版，方便以后查阅。</p>\n<p>Selenium用来模拟浏览器的行为，比如点击、最大化、滚动窗口等；PhantomJS是一种浏览器，不过这种浏览器没有UI界面，感觉就像是专门为爬虫设计，优点很明显，可以有效减小内存的使用。</p>\n<a id=\"more\"></a>\n<h2 id=\"爬虫使用到的模块\"><a href=\"#爬虫使用到的模块\" class=\"headerlink\" title=\"爬虫使用到的模块\"></a>爬虫使用到的模块</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</span><br><span class=\"line\"><span class=\"keyword\">from</span> myLogging <span class=\"keyword\">import</span> MyLogging</span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br></pre></td></tr></table></figure>\n<p>myLogging模块是自己配置的日志包，想要的可以点击<strong><em><a href=\"http://link.zhihu.com/?target=https%3A//github.com/ByiProX/DownloadPicsBySeleniumAndPhantomJS\" target=\"_blank\" rel=\"noopener\">这里</a></em></strong>自己看</p>\n<p>爬虫很关键的一点就是能够看懂网页的源代码，记得当初刚刚真正开始接触编程的时候，有很长的一段时间在看HTML、CSS、JS的一些知识，虽然忘得很多，但是印象还是有的，对于后面看网页源代码很有帮助。学习爬虫，除了会基本的python知识以外，还要会网页的一些知识。</p>\n<h2 id=\"爬取图片思路：\"><a href=\"#爬取图片思路：\" class=\"headerlink\" title=\"爬取图片思路：\"></a>爬取图片思路：</h2><ul>\n<li>已知连接，分析网页的代码结构，看所需的数据是否需要切换frame，并定位所需数据的位于哪个标签之下</li>\n<li>采用不同的模块有不同的保存图片方式，如果采用request模块，保存图片方式是可以采用<strong>requests.get(comicUrl).content</strong>方法，使用该方法需要确定网页的地址。该项目中没有涉及request的使用，所以此后不再表述。对于selenium可以使用 <strong>get_screenshot_as_file()</strong> 方法，使用该方法强烈建议使用phantomjs，如果使用chrome浏览器，图片尺寸太大的话，会出现截图不完整，对比如下：<br><img src=\"http://upload-images.jianshu.io/upload_images/2952111-2323c462a546dcc3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"对比\"></li>\n<li>找到下一张图片的连接位置并点击更新网页，一般来讲新网页与之前网页结构相同。</li>\n<li>在新网页的基础上保存图片，设置循环如此反复。</li>\n</ul>\n<p>爬取网页的URL为：<a href=\"http://link.zhihu.com/?target=http%3A//comic.kukudm.com/comiclist/3/3/1.htm\" target=\"_blank\" rel=\"noopener\">爬取火影漫画第一话</a></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DownloadPics</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, url)</span>:</span></span><br><span class=\"line\">        self.url = url</span><br><span class=\"line\">        self.log = MyLogging()</span><br><span class=\"line\">        self.browser = self.get_browser()</span><br><span class=\"line\">        self.save_pics(self.browser)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_browser</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        browser = webdriver.PhantomJS()</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            browser.get(self.url)</span><br><span class=\"line\">        <span class=\"keyword\">except</span>:</span><br><span class=\"line\">            MyLogging.error(<span class=\"string\">'open the url %s failed'</span> % self.url)</span><br><span class=\"line\">        browser.implicitly_wait(<span class=\"number\">20</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> browser</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">save_pics</span><span class=\"params\">(self, browser)</span>:</span></span><br><span class=\"line\">        pics_title = browser.title.split(<span class=\"string\">'_'</span>)[<span class=\"number\">0</span>]</span><br><span class=\"line\">        self.create_dir(pics_title)</span><br><span class=\"line\">        os.chdir(pics_title)</span><br><span class=\"line\">        sum_page = self.find_total_page_num(browser)</span><br><span class=\"line\">        i = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; sum_page:</span><br><span class=\"line\">            image_name = str(i) + <span class=\"string\">'.png'</span></span><br><span class=\"line\">            browser.get_screenshot_as_file(image_name)  </span><br><span class=\"line\">            <span class=\"comment\"># 使用PhantomJS避免了截图的不完整，可以与Chrome比较</span></span><br><span class=\"line\">            self.log.info(<span class=\"string\">'saving image %s'</span> % image_name)</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">            css_selector = <span class=\"string\">\"a[href='/comiclist/3/3/%s.htm']\"</span> % i  </span><br><span class=\"line\">            <span class=\"comment\"># 该方法感觉还不错呢，不过这个网站确实挺差劲的</span></span><br><span class=\"line\">            next_page = browser.find_element_by_css_selector(css_selector)</span><br><span class=\"line\">            next_page.click()</span><br><span class=\"line\">            time.sleep(<span class=\"number\">2</span>)</span><br><span class=\"line\">            <span class=\"comment\"># browser.implicitly_wait(20)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">find_total_page_num</span><span class=\"params\">(self, browser)</span>:</span></span><br><span class=\"line\">        page_element = browser.find_element_by_css_selector(<span class=\"string\">\"table[cellspacing='1']\"</span>)</span><br><span class=\"line\">        num = re.search(<span class=\"string\">r'共\\d+页'</span>, page_element.text).group()[<span class=\"number\">1</span>:<span class=\"number\">-1</span>]  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> int(num)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">create_dir</span><span class=\"params\">(self, dir_name)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> os.path.exists(dir_name):</span><br><span class=\"line\">            self.log.error(<span class=\"string\">'create directory %s failed cause a same directory exists'</span> % dir_name)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                os.makedirs(dir_name)</span><br><span class=\"line\">            <span class=\"keyword\">except</span>:</span><br><span class=\"line\">                self.log.error(<span class=\"string\">'create directory %s failed'</span> % dir_name)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                self.log.info(<span class=\"string\">'create directory %s success'</span> % dir_name)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    start_url = <span class=\"string\">'http://comic.kukudm.com/comiclist/3/3/1.htm'</span></span><br><span class=\"line\">    DL = DownloadPics(start_url)</span><br></pre></td></tr></table></figure>\n<h2 id=\"运行结果\"><a href=\"#运行结果\" class=\"headerlink\" title=\"运行结果\"></a>运行结果</h2><p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-e7e2cf39116b5fea.gif?imageMogr2/auto-orient/strip\" alt=\"gif\"></p>\n","site":{"data":{}},"excerpt":"<p>近期学习爬虫，发现懂的越多，不懂的知识点越多（所以当个傻子还是很幸福的）。好记性不如烂笔头，之前都是把看到的资料链接直接挂到一些平台，比如知乎、简书、Github等。今天有点时间，就好好码一下字，排排版，方便以后查阅。</p>\n<p>Selenium用来模拟浏览器的行为，比如点击、最大化、滚动窗口等；PhantomJS是一种浏览器，不过这种浏览器没有UI界面，感觉就像是专门为爬虫设计，优点很明显，可以有效减小内存的使用。</p>","more":"<h2 id=\"爬虫使用到的模块\"><a href=\"#爬虫使用到的模块\" class=\"headerlink\" title=\"爬虫使用到的模块\"></a>爬虫使用到的模块</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> selenium <span class=\"keyword\">import</span> webdriver</span><br><span class=\"line\"><span class=\"keyword\">from</span> myLogging <span class=\"keyword\">import</span> MyLogging</span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br></pre></td></tr></table></figure>\n<p>myLogging模块是自己配置的日志包，想要的可以点击<strong><em><a href=\"http://link.zhihu.com/?target=https%3A//github.com/ByiProX/DownloadPicsBySeleniumAndPhantomJS\" target=\"_blank\" rel=\"noopener\">这里</a></em></strong>自己看</p>\n<p>爬虫很关键的一点就是能够看懂网页的源代码，记得当初刚刚真正开始接触编程的时候，有很长的一段时间在看HTML、CSS、JS的一些知识，虽然忘得很多，但是印象还是有的，对于后面看网页源代码很有帮助。学习爬虫，除了会基本的python知识以外，还要会网页的一些知识。</p>\n<h2 id=\"爬取图片思路：\"><a href=\"#爬取图片思路：\" class=\"headerlink\" title=\"爬取图片思路：\"></a>爬取图片思路：</h2><ul>\n<li>已知连接，分析网页的代码结构，看所需的数据是否需要切换frame，并定位所需数据的位于哪个标签之下</li>\n<li>采用不同的模块有不同的保存图片方式，如果采用request模块，保存图片方式是可以采用<strong>requests.get(comicUrl).content</strong>方法，使用该方法需要确定网页的地址。该项目中没有涉及request的使用，所以此后不再表述。对于selenium可以使用 <strong>get_screenshot_as_file()</strong> 方法，使用该方法强烈建议使用phantomjs，如果使用chrome浏览器，图片尺寸太大的话，会出现截图不完整，对比如下：<br><img src=\"http://upload-images.jianshu.io/upload_images/2952111-2323c462a546dcc3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"对比\"></li>\n<li>找到下一张图片的连接位置并点击更新网页，一般来讲新网页与之前网页结构相同。</li>\n<li>在新网页的基础上保存图片，设置循环如此反复。</li>\n</ul>\n<p>爬取网页的URL为：<a href=\"http://link.zhihu.com/?target=http%3A//comic.kukudm.com/comiclist/3/3/1.htm\" target=\"_blank\" rel=\"noopener\">爬取火影漫画第一话</a></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DownloadPics</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, url)</span>:</span></span><br><span class=\"line\">        self.url = url</span><br><span class=\"line\">        self.log = MyLogging()</span><br><span class=\"line\">        self.browser = self.get_browser()</span><br><span class=\"line\">        self.save_pics(self.browser)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_browser</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        browser = webdriver.PhantomJS()</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            browser.get(self.url)</span><br><span class=\"line\">        <span class=\"keyword\">except</span>:</span><br><span class=\"line\">            MyLogging.error(<span class=\"string\">'open the url %s failed'</span> % self.url)</span><br><span class=\"line\">        browser.implicitly_wait(<span class=\"number\">20</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> browser</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">save_pics</span><span class=\"params\">(self, browser)</span>:</span></span><br><span class=\"line\">        pics_title = browser.title.split(<span class=\"string\">'_'</span>)[<span class=\"number\">0</span>]</span><br><span class=\"line\">        self.create_dir(pics_title)</span><br><span class=\"line\">        os.chdir(pics_title)</span><br><span class=\"line\">        sum_page = self.find_total_page_num(browser)</span><br><span class=\"line\">        i = <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; sum_page:</span><br><span class=\"line\">            image_name = str(i) + <span class=\"string\">'.png'</span></span><br><span class=\"line\">            browser.get_screenshot_as_file(image_name)  </span><br><span class=\"line\">            <span class=\"comment\"># 使用PhantomJS避免了截图的不完整，可以与Chrome比较</span></span><br><span class=\"line\">            self.log.info(<span class=\"string\">'saving image %s'</span> % image_name)</span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">            css_selector = <span class=\"string\">\"a[href='/comiclist/3/3/%s.htm']\"</span> % i  </span><br><span class=\"line\">            <span class=\"comment\"># 该方法感觉还不错呢，不过这个网站确实挺差劲的</span></span><br><span class=\"line\">            next_page = browser.find_element_by_css_selector(css_selector)</span><br><span class=\"line\">            next_page.click()</span><br><span class=\"line\">            time.sleep(<span class=\"number\">2</span>)</span><br><span class=\"line\">            <span class=\"comment\"># browser.implicitly_wait(20)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">find_total_page_num</span><span class=\"params\">(self, browser)</span>:</span></span><br><span class=\"line\">        page_element = browser.find_element_by_css_selector(<span class=\"string\">\"table[cellspacing='1']\"</span>)</span><br><span class=\"line\">        num = re.search(<span class=\"string\">r'共\\d+页'</span>, page_element.text).group()[<span class=\"number\">1</span>:<span class=\"number\">-1</span>]  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> int(num)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">create_dir</span><span class=\"params\">(self, dir_name)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> os.path.exists(dir_name):</span><br><span class=\"line\">            self.log.error(<span class=\"string\">'create directory %s failed cause a same directory exists'</span> % dir_name)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">try</span>:</span><br><span class=\"line\">                os.makedirs(dir_name)</span><br><span class=\"line\">            <span class=\"keyword\">except</span>:</span><br><span class=\"line\">                self.log.error(<span class=\"string\">'create directory %s failed'</span> % dir_name)</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                self.log.info(<span class=\"string\">'create directory %s success'</span> % dir_name)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    start_url = <span class=\"string\">'http://comic.kukudm.com/comiclist/3/3/1.htm'</span></span><br><span class=\"line\">    DL = DownloadPics(start_url)</span><br></pre></td></tr></table></figure>\n<h2 id=\"运行结果\"><a href=\"#运行结果\" class=\"headerlink\" title=\"运行结果\"></a>运行结果</h2><p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-e7e2cf39116b5fea.gif?imageMogr2/auto-orient/strip\" alt=\"gif\"></p>"},{"title":"Python3 使用virtualenv搭建虚拟环境","date":"2018-03-03T05:28:31.000Z","_content":"\n在使用Python进行多个项目开发时，每个项目可能会需要安装不同的组件。把这些组件安装在同一台计算机下可能会导致组件之间的相互冲突，比如项目A使用Django 1.10，而项目B使用Django 1.8，那么同时安装两个版本可能在具体使用时产生冲突。使用虚拟环境可以有效避免这样的问题。\n\nPython虚拟环境是一套由Ian Bicking编写的管理独立Python运行环境的系统。这样，开发者可以让每个项目运行在独立的虚拟环境中，从而避免了不同项目之间组件配置的冲突。\n<!-- more -->\n#### 1.虚拟环境安装\n\n在终端中执行命令：\n```bash\n$ pip install virtualenv\n```\n#### 2.虚拟环境使用  \n\n\n假定我们要开发一个新的项目，需要一套独立的Python运行环境，或者为已有的项目建立虚拟环境，终端执行如下命令：\n```bash\n$ cd   [项目所在目录]\n$ virtualenv venv\n```\n该命令执行后，将在当前目录下建立一个venv目录，**该目录拷贝一份完整的当前系统的Python环境**；\n\n我么也可以执行\n```bash\n$ virtualenv --no-site-packages venv\n```\n这样，已经安装到系统Python环境中的所有第三方包都不会复制过来，这样，我们就得到了一个不带任何第三方包的“干净”的Python运行环境。新建的Python环境被放到当前目录下的venv目录。\n\n有了venv这个Python环境，可以用source进入该环境（注意是在cd之后的目录）：\n```bash\n$ source venv/bin/activate[.fish|.zsh]\n```\n注意到命令提示符变了，有个(venv)前缀，表示当前环境是一个名为venv的Python环境。在venv环境下，用pip安装的包都被安装到venv/lib目录，而不会影响系统的Python环境。\n\n退出当前的venv环境，使用deactivate命令：\n```bash\n$ deactivate\n```\n此时回到了正常的环境，现在pip或python均是在系统Python环境下执行。\n\n#### 3.注意\n\n为保证项目之间的独立性，建议所有使用pip安装的组件都在项目虚拟环境中进行，避免不同版本的冲突。\n\n最后附上[Virtualenv的官方文档](https://virtualenv.pypa.io/en/stable/)\n","source":"_posts/Python3-使用virtualenv搭建虚拟环境.md","raw":"---\ntitle: Python3 使用virtualenv搭建虚拟环境\ndate: 2018-03-03 13:28:31\ntags:\n  - Python3\ncategories:\n  - Python3 进阶\n  - Python3 virtualenv\n---\n\n在使用Python进行多个项目开发时，每个项目可能会需要安装不同的组件。把这些组件安装在同一台计算机下可能会导致组件之间的相互冲突，比如项目A使用Django 1.10，而项目B使用Django 1.8，那么同时安装两个版本可能在具体使用时产生冲突。使用虚拟环境可以有效避免这样的问题。\n\nPython虚拟环境是一套由Ian Bicking编写的管理独立Python运行环境的系统。这样，开发者可以让每个项目运行在独立的虚拟环境中，从而避免了不同项目之间组件配置的冲突。\n<!-- more -->\n#### 1.虚拟环境安装\n\n在终端中执行命令：\n```bash\n$ pip install virtualenv\n```\n#### 2.虚拟环境使用  \n\n\n假定我们要开发一个新的项目，需要一套独立的Python运行环境，或者为已有的项目建立虚拟环境，终端执行如下命令：\n```bash\n$ cd   [项目所在目录]\n$ virtualenv venv\n```\n该命令执行后，将在当前目录下建立一个venv目录，**该目录拷贝一份完整的当前系统的Python环境**；\n\n我么也可以执行\n```bash\n$ virtualenv --no-site-packages venv\n```\n这样，已经安装到系统Python环境中的所有第三方包都不会复制过来，这样，我们就得到了一个不带任何第三方包的“干净”的Python运行环境。新建的Python环境被放到当前目录下的venv目录。\n\n有了venv这个Python环境，可以用source进入该环境（注意是在cd之后的目录）：\n```bash\n$ source venv/bin/activate[.fish|.zsh]\n```\n注意到命令提示符变了，有个(venv)前缀，表示当前环境是一个名为venv的Python环境。在venv环境下，用pip安装的包都被安装到venv/lib目录，而不会影响系统的Python环境。\n\n退出当前的venv环境，使用deactivate命令：\n```bash\n$ deactivate\n```\n此时回到了正常的环境，现在pip或python均是在系统Python环境下执行。\n\n#### 3.注意\n\n为保证项目之间的独立性，建议所有使用pip安装的组件都在项目虚拟环境中进行，避免不同版本的冲突。\n\n最后附上[Virtualenv的官方文档](https://virtualenv.pypa.io/en/stable/)\n","slug":"Python3-使用virtualenv搭建虚拟环境","published":1,"updated":"2018-03-03T05:32:43.613Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozkp001t8motdi3vkuwd","content":"<p>在使用Python进行多个项目开发时，每个项目可能会需要安装不同的组件。把这些组件安装在同一台计算机下可能会导致组件之间的相互冲突，比如项目A使用Django 1.10，而项目B使用Django 1.8，那么同时安装两个版本可能在具体使用时产生冲突。使用虚拟环境可以有效避免这样的问题。</p>\n<p>Python虚拟环境是一套由Ian Bicking编写的管理独立Python运行环境的系统。这样，开发者可以让每个项目运行在独立的虚拟环境中，从而避免了不同项目之间组件配置的冲突。<br><a id=\"more\"></a></p>\n<h4 id=\"1-虚拟环境安装\"><a href=\"#1-虚拟环境安装\" class=\"headerlink\" title=\"1.虚拟环境安装\"></a>1.虚拟环境安装</h4><p>在终端中执行命令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pip install virtualenv</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-虚拟环境使用\"><a href=\"#2-虚拟环境使用\" class=\"headerlink\" title=\"2.虚拟环境使用\"></a>2.虚拟环境使用</h4><p>假定我们要开发一个新的项目，需要一套独立的Python运行环境，或者为已有的项目建立虚拟环境，终端执行如下命令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span>   [项目所在目录]</span><br><span class=\"line\">$ virtualenv venv</span><br></pre></td></tr></table></figure></p>\n<p>该命令执行后，将在当前目录下建立一个venv目录，<strong>该目录拷贝一份完整的当前系统的Python环境</strong>；</p>\n<p>我么也可以执行<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ virtualenv --no-site-packages venv</span><br></pre></td></tr></table></figure></p>\n<p>这样，已经安装到系统Python环境中的所有第三方包都不会复制过来，这样，我们就得到了一个不带任何第三方包的“干净”的Python运行环境。新建的Python环境被放到当前目录下的venv目录。</p>\n<p>有了venv这个Python环境，可以用source进入该环境（注意是在cd之后的目录）：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">source</span> venv/bin/activate[.fish|.zsh]</span><br></pre></td></tr></table></figure></p>\n<p>注意到命令提示符变了，有个(venv)前缀，表示当前环境是一个名为venv的Python环境。在venv环境下，用pip安装的包都被安装到venv/lib目录，而不会影响系统的Python环境。</p>\n<p>退出当前的venv环境，使用deactivate命令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ deactivate</span><br></pre></td></tr></table></figure></p>\n<p>此时回到了正常的环境，现在pip或python均是在系统Python环境下执行。</p>\n<h4 id=\"3-注意\"><a href=\"#3-注意\" class=\"headerlink\" title=\"3.注意\"></a>3.注意</h4><p>为保证项目之间的独立性，建议所有使用pip安装的组件都在项目虚拟环境中进行，避免不同版本的冲突。</p>\n<p>最后附上<a href=\"https://virtualenv.pypa.io/en/stable/\" target=\"_blank\" rel=\"noopener\">Virtualenv的官方文档</a></p>\n","site":{"data":{}},"excerpt":"<p>在使用Python进行多个项目开发时，每个项目可能会需要安装不同的组件。把这些组件安装在同一台计算机下可能会导致组件之间的相互冲突，比如项目A使用Django 1.10，而项目B使用Django 1.8，那么同时安装两个版本可能在具体使用时产生冲突。使用虚拟环境可以有效避免这样的问题。</p>\n<p>Python虚拟环境是一套由Ian Bicking编写的管理独立Python运行环境的系统。这样，开发者可以让每个项目运行在独立的虚拟环境中，从而避免了不同项目之间组件配置的冲突。<br>","more":"</p>\n<h4 id=\"1-虚拟环境安装\"><a href=\"#1-虚拟环境安装\" class=\"headerlink\" title=\"1.虚拟环境安装\"></a>1.虚拟环境安装</h4><p>在终端中执行命令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ pip install virtualenv</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"2-虚拟环境使用\"><a href=\"#2-虚拟环境使用\" class=\"headerlink\" title=\"2.虚拟环境使用\"></a>2.虚拟环境使用</h4><p>假定我们要开发一个新的项目，需要一套独立的Python运行环境，或者为已有的项目建立虚拟环境，终端执行如下命令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span>   [项目所在目录]</span><br><span class=\"line\">$ virtualenv venv</span><br></pre></td></tr></table></figure></p>\n<p>该命令执行后，将在当前目录下建立一个venv目录，<strong>该目录拷贝一份完整的当前系统的Python环境</strong>；</p>\n<p>我么也可以执行<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ virtualenv --no-site-packages venv</span><br></pre></td></tr></table></figure></p>\n<p>这样，已经安装到系统Python环境中的所有第三方包都不会复制过来，这样，我们就得到了一个不带任何第三方包的“干净”的Python运行环境。新建的Python环境被放到当前目录下的venv目录。</p>\n<p>有了venv这个Python环境，可以用source进入该环境（注意是在cd之后的目录）：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">source</span> venv/bin/activate[.fish|.zsh]</span><br></pre></td></tr></table></figure></p>\n<p>注意到命令提示符变了，有个(venv)前缀，表示当前环境是一个名为venv的Python环境。在venv环境下，用pip安装的包都被安装到venv/lib目录，而不会影响系统的Python环境。</p>\n<p>退出当前的venv环境，使用deactivate命令：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ deactivate</span><br></pre></td></tr></table></figure></p>\n<p>此时回到了正常的环境，现在pip或python均是在系统Python环境下执行。</p>\n<h4 id=\"3-注意\"><a href=\"#3-注意\" class=\"headerlink\" title=\"3.注意\"></a>3.注意</h4><p>为保证项目之间的独立性，建议所有使用pip安装的组件都在项目虚拟环境中进行，避免不同版本的冲突。</p>\n<p>最后附上<a href=\"https://virtualenv.pypa.io/en/stable/\" target=\"_blank\" rel=\"noopener\">Virtualenv的官方文档</a></p>"},{"title":"Python3 函数重载","date":"2018-03-03T02:54:44.000Z","_content":"## 函数重载的目的\n\n动态语言中，有鸭子类型，如果走起路来像鸭子，叫起来也像鸭子，那么它就是鸭子。一个对象的特征不是由它的类型决定，而是通过对象中的方法决定，所以函数重载在动态语言中就显得没有意义了，因为函数可以通过鸭子类型来处理不同类型的对象，鸭子类型也是多态性的一种表现。\n\n在Python中实现函数重载：\n```python\nfrom io import StringIO\n\nclass Writer:\n    @staticmethod\n    def write(output, content):\n        # output对象只要实现了write方法就行\n        output.write(content)\n\n# stringIO类型\noutput = StringIO()\nWriter.write(output, 'hello world')\n\n# file 类型\noutput = open('out.txt', 'w')\nWriter.write(output, 'hello world')  \n\n```\n<!-- more -->\n在静态语言中，方法重载是希望类可以以统一的方式处理不同类型的数据提供了可能。多个同名函数同时存在，具有不同的参数个数/类型，重载是一个类中多态性的一种表现。\n\n在Java中实现函数重载：\n```python\n\nclass Writer{\n    public static void write(StringIO output, String content){\n        output.write(content);\n        return null;\n    }\n\n    public static void write(File output, String content){\n        output.write(content);\n        return null;\n    }\n\n```\n\n参考自知乎用户刘志军：https://www.zhihu.com/question/20053359\n\n---\n\n## 函数重载主要是为了解决两个问题\n\n1. 可变参数类型。\n2. 可变参数个数。\n\n>另外，一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载，如果两个函数的功能其实不同，那么不应当使用重载，而应当使用一个名字不同的函数。\n\n那么对于情况 1 ，函数功能相同，但是参数类型不同，python 如何处理？答案是根本不需要处理，因为 python 可以接受任何类型的参数，如果函数的功能相同，那么不同的参数类型在 python 中很可能是相同的代码，没有必要做成两个不同函数。\n\n那么对于情况 2 ，函数功能相同，但参数个数不同，python 如何处理？大家知道，答案就是`缺省参数`。对那些缺少的参数设定为缺省参数即可解决问题。因为你假设函数功能相同，那么那些缺少的参数终归是需要用的。好了，鉴于情况 1 跟 情况 2 都有了解决方案，python 自然就不需要函数重载了。\n\n参考自知乎用户`pansz`：https://www.zhihu.com/question/20053359\n","source":"_posts/Python3-函数重载.md","raw":"---\ntitle: Python3 函数重载\ndate: 2018-03-03 10:54:44\ntags:\n  - Python3\ncategories:\n  - Python3 进阶\n  - Python3 重载\n---\n## 函数重载的目的\n\n动态语言中，有鸭子类型，如果走起路来像鸭子，叫起来也像鸭子，那么它就是鸭子。一个对象的特征不是由它的类型决定，而是通过对象中的方法决定，所以函数重载在动态语言中就显得没有意义了，因为函数可以通过鸭子类型来处理不同类型的对象，鸭子类型也是多态性的一种表现。\n\n在Python中实现函数重载：\n```python\nfrom io import StringIO\n\nclass Writer:\n    @staticmethod\n    def write(output, content):\n        # output对象只要实现了write方法就行\n        output.write(content)\n\n# stringIO类型\noutput = StringIO()\nWriter.write(output, 'hello world')\n\n# file 类型\noutput = open('out.txt', 'w')\nWriter.write(output, 'hello world')  \n\n```\n<!-- more -->\n在静态语言中，方法重载是希望类可以以统一的方式处理不同类型的数据提供了可能。多个同名函数同时存在，具有不同的参数个数/类型，重载是一个类中多态性的一种表现。\n\n在Java中实现函数重载：\n```python\n\nclass Writer{\n    public static void write(StringIO output, String content){\n        output.write(content);\n        return null;\n    }\n\n    public static void write(File output, String content){\n        output.write(content);\n        return null;\n    }\n\n```\n\n参考自知乎用户刘志军：https://www.zhihu.com/question/20053359\n\n---\n\n## 函数重载主要是为了解决两个问题\n\n1. 可变参数类型。\n2. 可变参数个数。\n\n>另外，一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载，如果两个函数的功能其实不同，那么不应当使用重载，而应当使用一个名字不同的函数。\n\n那么对于情况 1 ，函数功能相同，但是参数类型不同，python 如何处理？答案是根本不需要处理，因为 python 可以接受任何类型的参数，如果函数的功能相同，那么不同的参数类型在 python 中很可能是相同的代码，没有必要做成两个不同函数。\n\n那么对于情况 2 ，函数功能相同，但参数个数不同，python 如何处理？大家知道，答案就是`缺省参数`。对那些缺少的参数设定为缺省参数即可解决问题。因为你假设函数功能相同，那么那些缺少的参数终归是需要用的。好了，鉴于情况 1 跟 情况 2 都有了解决方案，python 自然就不需要函数重载了。\n\n参考自知乎用户`pansz`：https://www.zhihu.com/question/20053359\n","slug":"Python3-函数重载","published":1,"updated":"2018-03-03T03:46:12.845Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozkr001x8motdmsoyy18","content":"<h2 id=\"函数重载的目的\"><a href=\"#函数重载的目的\" class=\"headerlink\" title=\"函数重载的目的\"></a>函数重载的目的</h2><p>动态语言中，有鸭子类型，如果走起路来像鸭子，叫起来也像鸭子，那么它就是鸭子。一个对象的特征不是由它的类型决定，而是通过对象中的方法决定，所以函数重载在动态语言中就显得没有意义了，因为函数可以通过鸭子类型来处理不同类型的对象，鸭子类型也是多态性的一种表现。</p>\n<p>在Python中实现函数重载：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> io <span class=\"keyword\">import</span> StringIO</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Writer</span>:</span></span><br><span class=\"line\"><span class=\"meta\">    @staticmethod</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">write</span><span class=\"params\">(output, content)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># output对象只要实现了write方法就行</span></span><br><span class=\"line\">        output.write(content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># stringIO类型</span></span><br><span class=\"line\">output = StringIO()</span><br><span class=\"line\">Writer.write(output, <span class=\"string\">'hello world'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># file 类型</span></span><br><span class=\"line\">output = open(<span class=\"string\">'out.txt'</span>, <span class=\"string\">'w'</span>)</span><br><span class=\"line\">Writer.write(output, <span class=\"string\">'hello world'</span>)</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>在静态语言中，方法重载是希望类可以以统一的方式处理不同类型的数据提供了可能。多个同名函数同时存在，具有不同的参数个数/类型，重载是一个类中多态性的一种表现。</p>\n<p>在Java中实现函数重载：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">class Writer&#123;</span><br><span class=\"line\">    public static void write(StringIO output, String content)&#123;</span><br><span class=\"line\">        output.write(content);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void write(File output, String content)&#123;</span><br><span class=\"line\">        output.write(content);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> null;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>参考自知乎用户刘志军：<a href=\"https://www.zhihu.com/question/20053359\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/20053359</a></p>\n<hr>\n<h2 id=\"函数重载主要是为了解决两个问题\"><a href=\"#函数重载主要是为了解决两个问题\" class=\"headerlink\" title=\"函数重载主要是为了解决两个问题\"></a>函数重载主要是为了解决两个问题</h2><ol>\n<li>可变参数类型。</li>\n<li>可变参数个数。</li>\n</ol>\n<blockquote>\n<p>另外，一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载，如果两个函数的功能其实不同，那么不应当使用重载，而应当使用一个名字不同的函数。</p>\n</blockquote>\n<p>那么对于情况 1 ，函数功能相同，但是参数类型不同，python 如何处理？答案是根本不需要处理，因为 python 可以接受任何类型的参数，如果函数的功能相同，那么不同的参数类型在 python 中很可能是相同的代码，没有必要做成两个不同函数。</p>\n<p>那么对于情况 2 ，函数功能相同，但参数个数不同，python 如何处理？大家知道，答案就是<code>缺省参数</code>。对那些缺少的参数设定为缺省参数即可解决问题。因为你假设函数功能相同，那么那些缺少的参数终归是需要用的。好了，鉴于情况 1 跟 情况 2 都有了解决方案，python 自然就不需要函数重载了。</p>\n<p>参考自知乎用户<code>pansz</code>：<a href=\"https://www.zhihu.com/question/20053359\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/20053359</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"函数重载的目的\"><a href=\"#函数重载的目的\" class=\"headerlink\" title=\"函数重载的目的\"></a>函数重载的目的</h2><p>动态语言中，有鸭子类型，如果走起路来像鸭子，叫起来也像鸭子，那么它就是鸭子。一个对象的特征不是由它的类型决定，而是通过对象中的方法决定，所以函数重载在动态语言中就显得没有意义了，因为函数可以通过鸭子类型来处理不同类型的对象，鸭子类型也是多态性的一种表现。</p>\n<p>在Python中实现函数重载：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> io <span class=\"keyword\">import</span> StringIO</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Writer</span>:</span></span><br><span class=\"line\"><span class=\"meta\">    @staticmethod</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">write</span><span class=\"params\">(output, content)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># output对象只要实现了write方法就行</span></span><br><span class=\"line\">        output.write(content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># stringIO类型</span></span><br><span class=\"line\">output = StringIO()</span><br><span class=\"line\">Writer.write(output, <span class=\"string\">'hello world'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># file 类型</span></span><br><span class=\"line\">output = open(<span class=\"string\">'out.txt'</span>, <span class=\"string\">'w'</span>)</span><br><span class=\"line\">Writer.write(output, <span class=\"string\">'hello world'</span>)</span><br></pre></td></tr></table></figure></p>","more":"<p>在静态语言中，方法重载是希望类可以以统一的方式处理不同类型的数据提供了可能。多个同名函数同时存在，具有不同的参数个数/类型，重载是一个类中多态性的一种表现。</p>\n<p>在Java中实现函数重载：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">class Writer&#123;</span><br><span class=\"line\">    public static void write(StringIO output, String content)&#123;</span><br><span class=\"line\">        output.write(content);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void write(File output, String content)&#123;</span><br><span class=\"line\">        output.write(content);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> null;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>参考自知乎用户刘志军：<a href=\"https://www.zhihu.com/question/20053359\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/20053359</a></p>\n<hr>\n<h2 id=\"函数重载主要是为了解决两个问题\"><a href=\"#函数重载主要是为了解决两个问题\" class=\"headerlink\" title=\"函数重载主要是为了解决两个问题\"></a>函数重载主要是为了解决两个问题</h2><ol>\n<li>可变参数类型。</li>\n<li>可变参数个数。</li>\n</ol>\n<blockquote>\n<p>另外，一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载，如果两个函数的功能其实不同，那么不应当使用重载，而应当使用一个名字不同的函数。</p>\n</blockquote>\n<p>那么对于情况 1 ，函数功能相同，但是参数类型不同，python 如何处理？答案是根本不需要处理，因为 python 可以接受任何类型的参数，如果函数的功能相同，那么不同的参数类型在 python 中很可能是相同的代码，没有必要做成两个不同函数。</p>\n<p>那么对于情况 2 ，函数功能相同，但参数个数不同，python 如何处理？大家知道，答案就是<code>缺省参数</code>。对那些缺少的参数设定为缺省参数即可解决问题。因为你假设函数功能相同，那么那些缺少的参数终归是需要用的。好了，鉴于情况 1 跟 情况 2 都有了解决方案，python 自然就不需要函数重载了。</p>\n<p>参考自知乎用户<code>pansz</code>：<a href=\"https://www.zhihu.com/question/20053359\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/20053359</a></p>"},{"title":"Python3 中的单下划线和双下划线","date":"2018-03-01T10:01:50.000Z","_content":"\n### 单下划线\n\n#### 在解释器中\n在交互解释器中，`_`符号还是指交互解释器中最后一次执行语句的返回结果。这种用法最初出现在CPython解释器中，其他解释器后来也都跟进了。\n\n#### 作为名称使用\n这个跟上面有点类似。`_`用作被丢弃的名称。按照惯例，这样做可以让阅读你代码的人知道，这是个不会被使用的特定名称。举个例子，你可能无所谓一个循环计数的值：\n```Python\nn = 42\nfor _ in range(n):\n    do_something()\n```\n\n<!-- more -->\n#### i18n\n`_`还可以被用作函数名。这种情况，单下划线经常被用作国际化和本地化字符串翻译查询的函数名。举个例子，在 [Django documentation for translation](https://docs.djangoproject.com/en/dev/topics/i18n/translation/) 中你可能会看到：\n\n```python\nfrom django.utils.translation import ugettext as _\nfrom django.http import HttpResponse\n\ndef my_view(request):\n    output = _(\"Welcome to my site.\")\n    return HttpResponse(output)\n```\n**注意**：第二种和第三种用法会引起冲突，所以在任意代码块中，如果使用了_作i18n翻译查询函数，就应该避免再用作被丢弃的变量名。\n\n#### 单下划线前缀的名称\n\n\n首先是单下划线开头，这个被常用于模块中，在一个模块中以单下划线开头的变量和函数被默认当作内部函数,用来指定私有变量。如果使用 `from a_module import *` 导入时，这部分变量和函数不会被导入。**不过值得注意的是**，如果使用 `import a_module` 这样导入模块，仍然可以用 `a_module._some_var` 这样的形式访问到这样的对象。\n\n另外单下划线开头还有一种一般不会用到的情况在于使用一个 C 编写的扩展库有时会用下划线开头命名，然后使用一个去掉下划线的 Python 模块进行包装。如 struct 这个模块实际上是 C 模块 `_struct` 的一个 Python 包装。\n\n#### 单下划线后缀的名称\n在 Python 的官方推荐的代码样式中，还有一种单下划线结尾的样式，这在解析时并没有特别的含义，但通常用于和 Python 关键词区分开来，比如如果我们需要一个变量叫做 class，但 class 是 Python 的关键词，就可以以单下划线结尾写作 class_。\n\n\n\n### 双下划线\n\n双下划线开头的命名形式在 Python 的类成员中使用表示名字改编 (Name Mangling)，即如果有一 `Test 类`里有一成员 `__x`，那么 dir(Test) 时会看到 `_Test__x` 而非 `__x`。这是为了避免该成员的名称与子类中的名称冲突。**但要注意这要求该名称末尾最多有一个下划线** [python document](https://docs.python.org/3.4/tutorial/classes.html#tut-private).\n\n双下划线开头双下划线结尾的是一些 Python 的“魔术”对象，如类成员的 `__init__`、`__del__`、`__add__`、`__getitem__` 等，以及全局的 `__file__`、`__name__` 等。 Python `官方推荐永远不要`将这样的命名方式应用于自己的变量或函数，而是按照文档说明来使用。\n\n### 举个栗子\n\n\n```python\n>>> class MyClass():\n...     def __init__(self):\n...             self.__superprivate = \"Hello\"\n...             self._semiprivate = \", world!\"\n...\n>>> mc = MyClass()\n>>> print mc.__superprivate\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nAttributeError: myClass instance has no attribute '__superprivate'\n>>> print mc._semiprivate\n, world!\n>>> print mc.__dict__\n{'_MyClass__superprivate': 'Hello', '_semiprivate': ', world!'}\n```\n\n`__foo__`:一种约定,Python内部的名字,用来区别其他用户自定义的命名,以防冲突，就是例如`__init__()`,`__del__()`,`__call__()`这些特殊方法\n\n`_foo`:一种约定,用来指定变量私有.程序员用来指定私有变量的一种方式.不能用from module import * 导入，其他方面和公有一样访问；\n\n`__foo`:这个有真正的意义:解析器用`_classname__foo`来代替这个名字,以区别和其他类相同的命名,它无法直接像公有成员一样随便访问,但是可以通过对象名 `_类名__xxx` 这样的方式可以访问.\n\n### 参考\n详情见:\n1. http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python\n\n2. http://www.zhihu.com/question/19754941\n\n3. https://segmentfault.com/a/1190000002611411\n\n4. https://docs.python.org/3.4/tutorial/classes.html#tut-private\n","source":"_posts/Python3-单下划线和双下划线.md","raw":"---\ntitle: Python3 中的单下划线和双下划线\ndate: 2018-03-01 18:01:50\ntags:\n  - Python3\ncategories:\n  - Python3 进阶\n  - Python3 下划线\n---\n\n### 单下划线\n\n#### 在解释器中\n在交互解释器中，`_`符号还是指交互解释器中最后一次执行语句的返回结果。这种用法最初出现在CPython解释器中，其他解释器后来也都跟进了。\n\n#### 作为名称使用\n这个跟上面有点类似。`_`用作被丢弃的名称。按照惯例，这样做可以让阅读你代码的人知道，这是个不会被使用的特定名称。举个例子，你可能无所谓一个循环计数的值：\n```Python\nn = 42\nfor _ in range(n):\n    do_something()\n```\n\n<!-- more -->\n#### i18n\n`_`还可以被用作函数名。这种情况，单下划线经常被用作国际化和本地化字符串翻译查询的函数名。举个例子，在 [Django documentation for translation](https://docs.djangoproject.com/en/dev/topics/i18n/translation/) 中你可能会看到：\n\n```python\nfrom django.utils.translation import ugettext as _\nfrom django.http import HttpResponse\n\ndef my_view(request):\n    output = _(\"Welcome to my site.\")\n    return HttpResponse(output)\n```\n**注意**：第二种和第三种用法会引起冲突，所以在任意代码块中，如果使用了_作i18n翻译查询函数，就应该避免再用作被丢弃的变量名。\n\n#### 单下划线前缀的名称\n\n\n首先是单下划线开头，这个被常用于模块中，在一个模块中以单下划线开头的变量和函数被默认当作内部函数,用来指定私有变量。如果使用 `from a_module import *` 导入时，这部分变量和函数不会被导入。**不过值得注意的是**，如果使用 `import a_module` 这样导入模块，仍然可以用 `a_module._some_var` 这样的形式访问到这样的对象。\n\n另外单下划线开头还有一种一般不会用到的情况在于使用一个 C 编写的扩展库有时会用下划线开头命名，然后使用一个去掉下划线的 Python 模块进行包装。如 struct 这个模块实际上是 C 模块 `_struct` 的一个 Python 包装。\n\n#### 单下划线后缀的名称\n在 Python 的官方推荐的代码样式中，还有一种单下划线结尾的样式，这在解析时并没有特别的含义，但通常用于和 Python 关键词区分开来，比如如果我们需要一个变量叫做 class，但 class 是 Python 的关键词，就可以以单下划线结尾写作 class_。\n\n\n\n### 双下划线\n\n双下划线开头的命名形式在 Python 的类成员中使用表示名字改编 (Name Mangling)，即如果有一 `Test 类`里有一成员 `__x`，那么 dir(Test) 时会看到 `_Test__x` 而非 `__x`。这是为了避免该成员的名称与子类中的名称冲突。**但要注意这要求该名称末尾最多有一个下划线** [python document](https://docs.python.org/3.4/tutorial/classes.html#tut-private).\n\n双下划线开头双下划线结尾的是一些 Python 的“魔术”对象，如类成员的 `__init__`、`__del__`、`__add__`、`__getitem__` 等，以及全局的 `__file__`、`__name__` 等。 Python `官方推荐永远不要`将这样的命名方式应用于自己的变量或函数，而是按照文档说明来使用。\n\n### 举个栗子\n\n\n```python\n>>> class MyClass():\n...     def __init__(self):\n...             self.__superprivate = \"Hello\"\n...             self._semiprivate = \", world!\"\n...\n>>> mc = MyClass()\n>>> print mc.__superprivate\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nAttributeError: myClass instance has no attribute '__superprivate'\n>>> print mc._semiprivate\n, world!\n>>> print mc.__dict__\n{'_MyClass__superprivate': 'Hello', '_semiprivate': ', world!'}\n```\n\n`__foo__`:一种约定,Python内部的名字,用来区别其他用户自定义的命名,以防冲突，就是例如`__init__()`,`__del__()`,`__call__()`这些特殊方法\n\n`_foo`:一种约定,用来指定变量私有.程序员用来指定私有变量的一种方式.不能用from module import * 导入，其他方面和公有一样访问；\n\n`__foo`:这个有真正的意义:解析器用`_classname__foo`来代替这个名字,以区别和其他类相同的命名,它无法直接像公有成员一样随便访问,但是可以通过对象名 `_类名__xxx` 这样的方式可以访问.\n\n### 参考\n详情见:\n1. http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python\n\n2. http://www.zhihu.com/question/19754941\n\n3. https://segmentfault.com/a/1190000002611411\n\n4. https://docs.python.org/3.4/tutorial/classes.html#tut-private\n","slug":"Python3-单下划线和双下划线","published":1,"updated":"2018-03-02T18:25:01.034Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozkt00208mota6p8ex1w","content":"<h3 id=\"单下划线\"><a href=\"#单下划线\" class=\"headerlink\" title=\"单下划线\"></a>单下划线</h3><h4 id=\"在解释器中\"><a href=\"#在解释器中\" class=\"headerlink\" title=\"在解释器中\"></a>在解释器中</h4><p>在交互解释器中，<code>_</code>符号还是指交互解释器中最后一次执行语句的返回结果。这种用法最初出现在CPython解释器中，其他解释器后来也都跟进了。</p>\n<h4 id=\"作为名称使用\"><a href=\"#作为名称使用\" class=\"headerlink\" title=\"作为名称使用\"></a>作为名称使用</h4><p>这个跟上面有点类似。<code>_</code>用作被丢弃的名称。按照惯例，这样做可以让阅读你代码的人知道，这是个不会被使用的特定名称。举个例子，你可能无所谓一个循环计数的值：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n = <span class=\"number\">42</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">    do_something()</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<h4 id=\"i18n\"><a href=\"#i18n\" class=\"headerlink\" title=\"i18n\"></a>i18n</h4><p><code>_</code>还可以被用作函数名。这种情况，单下划线经常被用作国际化和本地化字符串翻译查询的函数名。举个例子，在 <a href=\"https://docs.djangoproject.com/en/dev/topics/i18n/translation/\" target=\"_blank\" rel=\"noopener\">Django documentation for translation</a> 中你可能会看到：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> django.utils.translation <span class=\"keyword\">import</span> ugettext <span class=\"keyword\">as</span> _</span><br><span class=\"line\"><span class=\"keyword\">from</span> django.http <span class=\"keyword\">import</span> HttpResponse</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_view</span><span class=\"params\">(request)</span>:</span></span><br><span class=\"line\">    output = _(<span class=\"string\">\"Welcome to my site.\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> HttpResponse(output)</span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong>：第二种和第三种用法会引起冲突，所以在任意代码块中，如果使用了_作i18n翻译查询函数，就应该避免再用作被丢弃的变量名。</p>\n<h4 id=\"单下划线前缀的名称\"><a href=\"#单下划线前缀的名称\" class=\"headerlink\" title=\"单下划线前缀的名称\"></a>单下划线前缀的名称</h4><p>首先是单下划线开头，这个被常用于模块中，在一个模块中以单下划线开头的变量和函数被默认当作内部函数,用来指定私有变量。如果使用 <code>from a_module import *</code> 导入时，这部分变量和函数不会被导入。<strong>不过值得注意的是</strong>，如果使用 <code>import a_module</code> 这样导入模块，仍然可以用 <code>a_module._some_var</code> 这样的形式访问到这样的对象。</p>\n<p>另外单下划线开头还有一种一般不会用到的情况在于使用一个 C 编写的扩展库有时会用下划线开头命名，然后使用一个去掉下划线的 Python 模块进行包装。如 struct 这个模块实际上是 C 模块 <code>_struct</code> 的一个 Python 包装。</p>\n<h4 id=\"单下划线后缀的名称\"><a href=\"#单下划线后缀的名称\" class=\"headerlink\" title=\"单下划线后缀的名称\"></a>单下划线后缀的名称</h4><p>在 Python 的官方推荐的代码样式中，还有一种单下划线结尾的样式，这在解析时并没有特别的含义，但通常用于和 Python 关键词区分开来，比如如果我们需要一个变量叫做 class，但 class 是 Python 的关键词，就可以以单下划线结尾写作 class_。</p>\n<h3 id=\"双下划线\"><a href=\"#双下划线\" class=\"headerlink\" title=\"双下划线\"></a>双下划线</h3><p>双下划线开头的命名形式在 Python 的类成员中使用表示名字改编 (Name Mangling)，即如果有一 <code>Test 类</code>里有一成员 <code>__x</code>，那么 dir(Test) 时会看到 <code>_Test__x</code> 而非 <code>__x</code>。这是为了避免该成员的名称与子类中的名称冲突。<strong>但要注意这要求该名称末尾最多有一个下划线</strong> <a href=\"https://docs.python.org/3.4/tutorial/classes.html#tut-private\" target=\"_blank\" rel=\"noopener\">python document</a>.</p>\n<p>双下划线开头双下划线结尾的是一些 Python 的“魔术”对象，如类成员的 <code>__init__</code>、<code>__del__</code>、<code>__add__</code>、<code>__getitem__</code> 等，以及全局的 <code>__file__</code>、<code>__name__</code> 等。 Python <code>官方推荐永远不要</code>将这样的命名方式应用于自己的变量或函数，而是按照文档说明来使用。</p>\n<h3 id=\"举个栗子\"><a href=\"#举个栗子\" class=\"headerlink\" title=\"举个栗子\"></a>举个栗子</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">... </span>            self.__superprivate = <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\"><span class=\"meta\">... </span>            self._semiprivate = <span class=\"string\">\", world!\"</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>mc = MyClass()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> mc.__superprivate</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File <span class=\"string\">\"&lt;stdin&gt;\"</span>, line <span class=\"number\">1</span>, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">AttributeError: myClass instance has no attribute <span class=\"string\">'__superprivate'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> mc._semiprivate</span><br><span class=\"line\">, world!</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> mc.__dict__</span><br><span class=\"line\">&#123;<span class=\"string\">'_MyClass__superprivate'</span>: <span class=\"string\">'Hello'</span>, <span class=\"string\">'_semiprivate'</span>: <span class=\"string\">', world!'</span>&#125;</span><br></pre></td></tr></table></figure>\n<p><code>__foo__</code>:一种约定,Python内部的名字,用来区别其他用户自定义的命名,以防冲突，就是例如<code>__init__()</code>,<code>__del__()</code>,<code>__call__()</code>这些特殊方法</p>\n<p><code>_foo</code>:一种约定,用来指定变量私有.程序员用来指定私有变量的一种方式.不能用from module import * 导入，其他方面和公有一样访问；</p>\n<p><code>__foo</code>:这个有真正的意义:解析器用<code>_classname__foo</code>来代替这个名字,以区别和其他类相同的命名,它无法直接像公有成员一样随便访问,但是可以通过对象名 <code>_类名__xxx</code> 这样的方式可以访问.</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>详情见:</p>\n<ol>\n<li><p><a href=\"http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python\" target=\"_blank\" rel=\"noopener\">http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python</a></p>\n</li>\n<li><p><a href=\"http://www.zhihu.com/question/19754941\" target=\"_blank\" rel=\"noopener\">http://www.zhihu.com/question/19754941</a></p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000002611411\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000002611411</a></p>\n</li>\n<li><p><a href=\"https://docs.python.org/3.4/tutorial/classes.html#tut-private\" target=\"_blank\" rel=\"noopener\">https://docs.python.org/3.4/tutorial/classes.html#tut-private</a></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"单下划线\"><a href=\"#单下划线\" class=\"headerlink\" title=\"单下划线\"></a>单下划线</h3><h4 id=\"在解释器中\"><a href=\"#在解释器中\" class=\"headerlink\" title=\"在解释器中\"></a>在解释器中</h4><p>在交互解释器中，<code>_</code>符号还是指交互解释器中最后一次执行语句的返回结果。这种用法最初出现在CPython解释器中，其他解释器后来也都跟进了。</p>\n<h4 id=\"作为名称使用\"><a href=\"#作为名称使用\" class=\"headerlink\" title=\"作为名称使用\"></a>作为名称使用</h4><p>这个跟上面有点类似。<code>_</code>用作被丢弃的名称。按照惯例，这样做可以让阅读你代码的人知道，这是个不会被使用的特定名称。举个例子，你可能无所谓一个循环计数的值：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n = <span class=\"number\">42</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">    do_something()</span><br></pre></td></tr></table></figure></p>","more":"<h4 id=\"i18n\"><a href=\"#i18n\" class=\"headerlink\" title=\"i18n\"></a>i18n</h4><p><code>_</code>还可以被用作函数名。这种情况，单下划线经常被用作国际化和本地化字符串翻译查询的函数名。举个例子，在 <a href=\"https://docs.djangoproject.com/en/dev/topics/i18n/translation/\" target=\"_blank\" rel=\"noopener\">Django documentation for translation</a> 中你可能会看到：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> django.utils.translation <span class=\"keyword\">import</span> ugettext <span class=\"keyword\">as</span> _</span><br><span class=\"line\"><span class=\"keyword\">from</span> django.http <span class=\"keyword\">import</span> HttpResponse</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_view</span><span class=\"params\">(request)</span>:</span></span><br><span class=\"line\">    output = _(<span class=\"string\">\"Welcome to my site.\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> HttpResponse(output)</span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong>：第二种和第三种用法会引起冲突，所以在任意代码块中，如果使用了_作i18n翻译查询函数，就应该避免再用作被丢弃的变量名。</p>\n<h4 id=\"单下划线前缀的名称\"><a href=\"#单下划线前缀的名称\" class=\"headerlink\" title=\"单下划线前缀的名称\"></a>单下划线前缀的名称</h4><p>首先是单下划线开头，这个被常用于模块中，在一个模块中以单下划线开头的变量和函数被默认当作内部函数,用来指定私有变量。如果使用 <code>from a_module import *</code> 导入时，这部分变量和函数不会被导入。<strong>不过值得注意的是</strong>，如果使用 <code>import a_module</code> 这样导入模块，仍然可以用 <code>a_module._some_var</code> 这样的形式访问到这样的对象。</p>\n<p>另外单下划线开头还有一种一般不会用到的情况在于使用一个 C 编写的扩展库有时会用下划线开头命名，然后使用一个去掉下划线的 Python 模块进行包装。如 struct 这个模块实际上是 C 模块 <code>_struct</code> 的一个 Python 包装。</p>\n<h4 id=\"单下划线后缀的名称\"><a href=\"#单下划线后缀的名称\" class=\"headerlink\" title=\"单下划线后缀的名称\"></a>单下划线后缀的名称</h4><p>在 Python 的官方推荐的代码样式中，还有一种单下划线结尾的样式，这在解析时并没有特别的含义，但通常用于和 Python 关键词区分开来，比如如果我们需要一个变量叫做 class，但 class 是 Python 的关键词，就可以以单下划线结尾写作 class_。</p>\n<h3 id=\"双下划线\"><a href=\"#双下划线\" class=\"headerlink\" title=\"双下划线\"></a>双下划线</h3><p>双下划线开头的命名形式在 Python 的类成员中使用表示名字改编 (Name Mangling)，即如果有一 <code>Test 类</code>里有一成员 <code>__x</code>，那么 dir(Test) 时会看到 <code>_Test__x</code> 而非 <code>__x</code>。这是为了避免该成员的名称与子类中的名称冲突。<strong>但要注意这要求该名称末尾最多有一个下划线</strong> <a href=\"https://docs.python.org/3.4/tutorial/classes.html#tut-private\" target=\"_blank\" rel=\"noopener\">python document</a>.</p>\n<p>双下划线开头双下划线结尾的是一些 Python 的“魔术”对象，如类成员的 <code>__init__</code>、<code>__del__</code>、<code>__add__</code>、<code>__getitem__</code> 等，以及全局的 <code>__file__</code>、<code>__name__</code> 等。 Python <code>官方推荐永远不要</code>将这样的命名方式应用于自己的变量或函数，而是按照文档说明来使用。</p>\n<h3 id=\"举个栗子\"><a href=\"#举个栗子\" class=\"headerlink\" title=\"举个栗子\"></a>举个栗子</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">... </span>            self.__superprivate = <span class=\"string\">\"Hello\"</span></span><br><span class=\"line\"><span class=\"meta\">... </span>            self._semiprivate = <span class=\"string\">\", world!\"</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>mc = MyClass()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> mc.__superprivate</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File <span class=\"string\">\"&lt;stdin&gt;\"</span>, line <span class=\"number\">1</span>, <span class=\"keyword\">in</span> &lt;module&gt;</span><br><span class=\"line\">AttributeError: myClass instance has no attribute <span class=\"string\">'__superprivate'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> mc._semiprivate</span><br><span class=\"line\">, world!</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> mc.__dict__</span><br><span class=\"line\">&#123;<span class=\"string\">'_MyClass__superprivate'</span>: <span class=\"string\">'Hello'</span>, <span class=\"string\">'_semiprivate'</span>: <span class=\"string\">', world!'</span>&#125;</span><br></pre></td></tr></table></figure>\n<p><code>__foo__</code>:一种约定,Python内部的名字,用来区别其他用户自定义的命名,以防冲突，就是例如<code>__init__()</code>,<code>__del__()</code>,<code>__call__()</code>这些特殊方法</p>\n<p><code>_foo</code>:一种约定,用来指定变量私有.程序员用来指定私有变量的一种方式.不能用from module import * 导入，其他方面和公有一样访问；</p>\n<p><code>__foo</code>:这个有真正的意义:解析器用<code>_classname__foo</code>来代替这个名字,以区别和其他类相同的命名,它无法直接像公有成员一样随便访问,但是可以通过对象名 <code>_类名__xxx</code> 这样的方式可以访问.</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>详情见:</p>\n<ol>\n<li><p><a href=\"http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python\" target=\"_blank\" rel=\"noopener\">http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python</a></p>\n</li>\n<li><p><a href=\"http://www.zhihu.com/question/19754941\" target=\"_blank\" rel=\"noopener\">http://www.zhihu.com/question/19754941</a></p>\n</li>\n<li><p><a href=\"https://segmentfault.com/a/1190000002611411\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000002611411</a></p>\n</li>\n<li><p><a href=\"https://docs.python.org/3.4/tutorial/classes.html#tut-private\" target=\"_blank\" rel=\"noopener\">https://docs.python.org/3.4/tutorial/classes.html#tut-private</a></p>\n</li>\n</ol>"},{"title":"Python3 单例模式","date":"2018-03-19T05:44:05.000Z","_content":"单例模式（Singleton Pattern）是最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。\n\n**注意：**\n\n  * 1、单例类只能有一个实例。\n  * 2、单例类必须自己创建自己的唯一实例。\n  * 3、单例类必须给所有其他对象提供这一实例。\n<!-- more -->\n## 单例模式介绍\n**意图：** 保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n\n**主要解决：** 一个全局使用的类频繁地创建与销毁。\n\n**何时使用：** 当您想控制实例数目，节省系统资源的时候。\n\n**如何解决：** 判断系统是否已经有这个单例，如果有则返回，如果没有则创建。\n\n**关键代码：** 构造函数是私有的。\n\n**应用实例：** 1、一个党只能有一个主席。 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。\n\n**优点：** 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。\n\n**缺点：** 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。\n\n**使用场景：** 1、要求生产唯一序列号。 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。\n\n**注意事项：** getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。\n\n## 单例模式的实现\n在 Python 中，我们可以用多种方法来实现单例模式：\n\n  * 使用基类 `__new__`\n  * 使用模块\n  * 使用装饰器（decorator）\n  * 使用元类（metaclass）\n\n\n### 使用基类 `__new__`\n\n`__new__` 是真正创建实例对象的方法，所以重写基类的`__new__`方法，以此来保证创建对象的时候只生成一个实例\n\n```python\nclass Singleton(object):\n    def __new__(cls, *args, **kwargs):\n        if not hasattr(cls, '_instance'):\n            cls._instance = super(Singleton, cls).__new__(cls, *args, **kwargs)\n        return cls._instance  \n\nclass MyClass(Singleton):  \n    a = 1\n\n```\n在上面的代码中，我们将类的实例和一个类变量 `_instance` 关联起来，如果 `cls._instance` 为 None 则创建实例，否则直接返回 `cls._instance`。执行结果如下：\n```python\n>>> one = MyClass()\n>>> two = MyClass()\n>>> one == two\nTrue\n>>> one is two\nTrue\n>>> id(one), id(two)\n(4303862608, 4303862608)\n```\n\n### 使用元类\n元类（参考：[深刻理解Python中的元类](http://blog.jobbole.com/21351/)）是用于创建类对象的类，类对象创建实例对象时一定会调用`__call__`方法，因此在调用`__call__`时候保证始终只创建一个实例即可，`type`是python中的一个元类。\n\n元类（metaclass）可以控制类的创建过程，它主要做三件事：\n\n  * 拦截类的创建\n  * 修改类的定义\n  * 返回修改后的类\n\n使用元类实现单例模式的代码如下：\n\n```python\nclass Singleton(type):\n    def __call__(cls, *args, **kwargs):\n        if not hasattr(cls, '_instance'):\n            cls._instance = super(Singleton, cls).__call__(*args, **kwargs)\n        return cls._instance\n\nclass MyClass(metaclass=Singleton):  \n    a = 1\n\n## 执行结果如下\n>>> one = MyClass()\n>>> two = MyClass()\n>>> one == two\nTrue\n>>> one is two\nTrue\n>>> id(one), id(two)\n(4303862608, 4303862608)\n```\n\n### 使用装饰器\n装饰器（decorator）可以动态地修改一个类或函数的功能。这里，我们也可以使用装饰器来装饰某个类，使其只能生成一个实例，代码如下：\n\n```python\ndef singleton(cls):\n    instances = {}\n    def wrapper(*args, **kwargs):\n        if cls not in instances:\n            instances[cls] = cls(*args, **kwargs)\n        return instances[cls]\n    return wrapper\n\n@singleton\nclass Foo(object):\n    pass\n```\n\n**将装饰器写成类形式**\n```python\nclass single03(object):  \n        def __init__(self, cls):  \n            self._cls = cls  \n            self._instances = None;  \n        def __call__(self, *args):  \n            if not self._instances:  \n                self._instances = self._cls(*args)  \n            return self._instances  \n\n@single03  \nclass A(object):  \n    def __init__(self, name):  \n        self.name = name\n```\n\n在上面，我们定义了一个装饰器 singleton，它返回了一个内部函数 `warpper`，该函数会判断某个类是否在字典 instances 中，如果不存在，则会将 cls 作为 key，`cls(*args, **kw)` 作为 value 存到 instances 中，否则，直接返回 instances[cls]\n\n### 使用模块\nPython 的模块就是天然的单例模式，因为模块在第一次导入时，会生成 .pyc 文件，当第二次导入时，就会直接加载 .pyc 文件，而不会再次执行模块代码。因此，我们只需把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了。如果我们真的想要一个单例类，可以考虑这样做：\n```python\n# mysingleton.py\nclass My_Singleton(object):\n    def foo(self):\n        pass\n\nmy_singleton = My_Singleton()\n```\n\n将上面的代码保存在文件 mysingleton.py 中，然后这样使用:\n```python\nfrom mysingleton import my_singleton\n\nmy_singleton.foo()\n```\n\n\n## 参考\n1. http://python.jobbole.com/87294/\n2. http://python.jobbole.com/87791/?utm_source=blog.jobbole.com&utm_medium=relatedPosts\n","source":"_posts/Python3-单例模式.md","raw":"---\ntitle: Python3 单例模式\ndate: 2018-03-19 13:44:05\ntags:\n  - Python3\n  - 设计模式\ncategories:\n  - Python3 进阶\n---\n单例模式（Singleton Pattern）是最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。\n\n**注意：**\n\n  * 1、单例类只能有一个实例。\n  * 2、单例类必须自己创建自己的唯一实例。\n  * 3、单例类必须给所有其他对象提供这一实例。\n<!-- more -->\n## 单例模式介绍\n**意图：** 保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n\n**主要解决：** 一个全局使用的类频繁地创建与销毁。\n\n**何时使用：** 当您想控制实例数目，节省系统资源的时候。\n\n**如何解决：** 判断系统是否已经有这个单例，如果有则返回，如果没有则创建。\n\n**关键代码：** 构造函数是私有的。\n\n**应用实例：** 1、一个党只能有一个主席。 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。\n\n**优点：** 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。\n\n**缺点：** 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。\n\n**使用场景：** 1、要求生产唯一序列号。 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。\n\n**注意事项：** getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。\n\n## 单例模式的实现\n在 Python 中，我们可以用多种方法来实现单例模式：\n\n  * 使用基类 `__new__`\n  * 使用模块\n  * 使用装饰器（decorator）\n  * 使用元类（metaclass）\n\n\n### 使用基类 `__new__`\n\n`__new__` 是真正创建实例对象的方法，所以重写基类的`__new__`方法，以此来保证创建对象的时候只生成一个实例\n\n```python\nclass Singleton(object):\n    def __new__(cls, *args, **kwargs):\n        if not hasattr(cls, '_instance'):\n            cls._instance = super(Singleton, cls).__new__(cls, *args, **kwargs)\n        return cls._instance  \n\nclass MyClass(Singleton):  \n    a = 1\n\n```\n在上面的代码中，我们将类的实例和一个类变量 `_instance` 关联起来，如果 `cls._instance` 为 None 则创建实例，否则直接返回 `cls._instance`。执行结果如下：\n```python\n>>> one = MyClass()\n>>> two = MyClass()\n>>> one == two\nTrue\n>>> one is two\nTrue\n>>> id(one), id(two)\n(4303862608, 4303862608)\n```\n\n### 使用元类\n元类（参考：[深刻理解Python中的元类](http://blog.jobbole.com/21351/)）是用于创建类对象的类，类对象创建实例对象时一定会调用`__call__`方法，因此在调用`__call__`时候保证始终只创建一个实例即可，`type`是python中的一个元类。\n\n元类（metaclass）可以控制类的创建过程，它主要做三件事：\n\n  * 拦截类的创建\n  * 修改类的定义\n  * 返回修改后的类\n\n使用元类实现单例模式的代码如下：\n\n```python\nclass Singleton(type):\n    def __call__(cls, *args, **kwargs):\n        if not hasattr(cls, '_instance'):\n            cls._instance = super(Singleton, cls).__call__(*args, **kwargs)\n        return cls._instance\n\nclass MyClass(metaclass=Singleton):  \n    a = 1\n\n## 执行结果如下\n>>> one = MyClass()\n>>> two = MyClass()\n>>> one == two\nTrue\n>>> one is two\nTrue\n>>> id(one), id(two)\n(4303862608, 4303862608)\n```\n\n### 使用装饰器\n装饰器（decorator）可以动态地修改一个类或函数的功能。这里，我们也可以使用装饰器来装饰某个类，使其只能生成一个实例，代码如下：\n\n```python\ndef singleton(cls):\n    instances = {}\n    def wrapper(*args, **kwargs):\n        if cls not in instances:\n            instances[cls] = cls(*args, **kwargs)\n        return instances[cls]\n    return wrapper\n\n@singleton\nclass Foo(object):\n    pass\n```\n\n**将装饰器写成类形式**\n```python\nclass single03(object):  \n        def __init__(self, cls):  \n            self._cls = cls  \n            self._instances = None;  \n        def __call__(self, *args):  \n            if not self._instances:  \n                self._instances = self._cls(*args)  \n            return self._instances  \n\n@single03  \nclass A(object):  \n    def __init__(self, name):  \n        self.name = name\n```\n\n在上面，我们定义了一个装饰器 singleton，它返回了一个内部函数 `warpper`，该函数会判断某个类是否在字典 instances 中，如果不存在，则会将 cls 作为 key，`cls(*args, **kw)` 作为 value 存到 instances 中，否则，直接返回 instances[cls]\n\n### 使用模块\nPython 的模块就是天然的单例模式，因为模块在第一次导入时，会生成 .pyc 文件，当第二次导入时，就会直接加载 .pyc 文件，而不会再次执行模块代码。因此，我们只需把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了。如果我们真的想要一个单例类，可以考虑这样做：\n```python\n# mysingleton.py\nclass My_Singleton(object):\n    def foo(self):\n        pass\n\nmy_singleton = My_Singleton()\n```\n\n将上面的代码保存在文件 mysingleton.py 中，然后这样使用:\n```python\nfrom mysingleton import my_singleton\n\nmy_singleton.foo()\n```\n\n\n## 参考\n1. http://python.jobbole.com/87294/\n2. http://python.jobbole.com/87791/?utm_source=blog.jobbole.com&utm_medium=relatedPosts\n","slug":"Python3-单例模式","published":1,"updated":"2018-03-19T18:56:37.784Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozkw00248motr86gq0fl","content":"<p>单例模式（Singleton Pattern）是最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>\n<p><strong>注意：</strong></p>\n<ul>\n<li>1、单例类只能有一个实例。</li>\n<li>2、单例类必须自己创建自己的唯一实例。</li>\n<li>3、单例类必须给所有其他对象提供这一实例。<a id=\"more\"></a>\n<h2 id=\"单例模式介绍\"><a href=\"#单例模式介绍\" class=\"headerlink\" title=\"单例模式介绍\"></a>单例模式介绍</h2><strong>意图：</strong> 保证一个类仅有一个实例，并提供一个访问它的全局访问点。</li>\n</ul>\n<p><strong>主要解决：</strong> 一个全局使用的类频繁地创建与销毁。</p>\n<p><strong>何时使用：</strong> 当您想控制实例数目，节省系统资源的时候。</p>\n<p><strong>如何解决：</strong> 判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p>\n<p><strong>关键代码：</strong> 构造函数是私有的。</p>\n<p><strong>应用实例：</strong> 1、一个党只能有一个主席。 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</p>\n<p><strong>优点：</strong> 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。</p>\n<p><strong>缺点：</strong> 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>\n<p><strong>使用场景：</strong> 1、要求生产唯一序列号。 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</p>\n<p><strong>注意事项：</strong> getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。</p>\n<h2 id=\"单例模式的实现\"><a href=\"#单例模式的实现\" class=\"headerlink\" title=\"单例模式的实现\"></a>单例模式的实现</h2><p>在 Python 中，我们可以用多种方法来实现单例模式：</p>\n<ul>\n<li>使用基类 <code>__new__</code></li>\n<li>使用模块</li>\n<li>使用装饰器（decorator）</li>\n<li>使用元类（metaclass）</li>\n</ul>\n<h3 id=\"使用基类-new\"><a href=\"#使用基类-new\" class=\"headerlink\" title=\"使用基类 __new__\"></a>使用基类 <code>__new__</code></h3><p><code>__new__</code> 是真正创建实例对象的方法，所以重写基类的<code>__new__</code>方法，以此来保证创建对象的时候只生成一个实例</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__new__</span><span class=\"params\">(cls, *args, **kwargs)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> hasattr(cls, <span class=\"string\">'_instance'</span>):</span><br><span class=\"line\">            cls._instance = super(Singleton, cls).__new__(cls, *args, **kwargs)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cls._instance  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span><span class=\"params\">(Singleton)</span>:</span>  </span><br><span class=\"line\">    a = <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>在上面的代码中，我们将类的实例和一个类变量 <code>_instance</code> 关联起来，如果 <code>cls._instance</code> 为 None 则创建实例，否则直接返回 <code>cls._instance</code>。执行结果如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>one = MyClass()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>two = MyClass()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>one == two</span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>one <span class=\"keyword\">is</span> two</span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>id(one), id(two)</span><br><span class=\"line\">(<span class=\"number\">4303862608</span>, <span class=\"number\">4303862608</span>)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"使用元类\"><a href=\"#使用元类\" class=\"headerlink\" title=\"使用元类\"></a>使用元类</h3><p>元类（参考：<a href=\"http://blog.jobbole.com/21351/\" target=\"_blank\" rel=\"noopener\">深刻理解Python中的元类</a>）是用于创建类对象的类，类对象创建实例对象时一定会调用<code>__call__</code>方法，因此在调用<code>__call__</code>时候保证始终只创建一个实例即可，<code>type</code>是python中的一个元类。</p>\n<p>元类（metaclass）可以控制类的创建过程，它主要做三件事：</p>\n<ul>\n<li>拦截类的创建</li>\n<li>修改类的定义</li>\n<li>返回修改后的类</li>\n</ul>\n<p>使用元类实现单例模式的代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span><span class=\"params\">(type)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__call__</span><span class=\"params\">(cls, *args, **kwargs)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> hasattr(cls, <span class=\"string\">'_instance'</span>):</span><br><span class=\"line\">            cls._instance = super(Singleton, cls).__call__(*args, **kwargs)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cls._instance</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span><span class=\"params\">(metaclass=Singleton)</span>:</span>  </span><br><span class=\"line\">    a = <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 执行结果如下</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>one = MyClass()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>two = MyClass()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>one == two</span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>one <span class=\"keyword\">is</span> two</span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>id(one), id(two)</span><br><span class=\"line\">(<span class=\"number\">4303862608</span>, <span class=\"number\">4303862608</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用装饰器\"><a href=\"#使用装饰器\" class=\"headerlink\" title=\"使用装饰器\"></a>使用装饰器</h3><p>装饰器（decorator）可以动态地修改一个类或函数的功能。这里，我们也可以使用装饰器来装饰某个类，使其只能生成一个实例，代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">singleton</span><span class=\"params\">(cls)</span>:</span></span><br><span class=\"line\">    instances = &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kwargs)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> cls <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> instances:</span><br><span class=\"line\">            instances[cls] = cls(*args, **kwargs)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instances[cls]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@singleton</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<p><strong>将装饰器写成类形式</strong><br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">single03</span><span class=\"params\">(object)</span>:</span>  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, cls)</span>:</span>  </span><br><span class=\"line\">            self._cls = cls  </span><br><span class=\"line\">            self._instances = <span class=\"keyword\">None</span>;  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__call__</span><span class=\"params\">(self, *args)</span>:</span>  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self._instances:  </span><br><span class=\"line\">                self._instances = self._cls(*args)  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> self._instances  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@single03  </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span><span class=\"params\">(object)</span>:</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, name)</span>:</span>  </span><br><span class=\"line\">        self.name = name</span><br></pre></td></tr></table></figure></p>\n<p>在上面，我们定义了一个装饰器 singleton，它返回了一个内部函数 <code>warpper</code>，该函数会判断某个类是否在字典 instances 中，如果不存在，则会将 cls 作为 key，<code>cls(*args, **kw)</code> 作为 value 存到 instances 中，否则，直接返回 instances[cls]</p>\n<h3 id=\"使用模块\"><a href=\"#使用模块\" class=\"headerlink\" title=\"使用模块\"></a>使用模块</h3><p>Python 的模块就是天然的单例模式，因为模块在第一次导入时，会生成 .pyc 文件，当第二次导入时，就会直接加载 .pyc 文件，而不会再次执行模块代码。因此，我们只需把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了。如果我们真的想要一个单例类，可以考虑这样做：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># mysingleton.py</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">My_Singleton</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">foo</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">my_singleton = My_Singleton()</span><br></pre></td></tr></table></figure></p>\n<p>将上面的代码保存在文件 mysingleton.py 中，然后这样使用:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> mysingleton <span class=\"keyword\">import</span> my_singleton</span><br><span class=\"line\"></span><br><span class=\"line\">my_singleton.foo()</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"http://python.jobbole.com/87294/\" target=\"_blank\" rel=\"noopener\">http://python.jobbole.com/87294/</a></li>\n<li><a href=\"http://python.jobbole.com/87791/?utm_source=blog.jobbole.com&amp;utm_medium=relatedPosts\" target=\"_blank\" rel=\"noopener\">http://python.jobbole.com/87791/?utm_source=blog.jobbole.com&amp;utm_medium=relatedPosts</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>单例模式（Singleton Pattern）是最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>\n<p><strong>注意：</strong></p>\n<ul>\n<li>1、单例类只能有一个实例。</li>\n<li>2、单例类必须自己创建自己的唯一实例。</li>\n<li>3、单例类必须给所有其他对象提供这一实例。","more":"<h2 id=\"单例模式介绍\"><a href=\"#单例模式介绍\" class=\"headerlink\" title=\"单例模式介绍\"></a>单例模式介绍</h2><strong>意图：</strong> 保证一个类仅有一个实例，并提供一个访问它的全局访问点。</li>\n</ul>\n<p><strong>主要解决：</strong> 一个全局使用的类频繁地创建与销毁。</p>\n<p><strong>何时使用：</strong> 当您想控制实例数目，节省系统资源的时候。</p>\n<p><strong>如何解决：</strong> 判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p>\n<p><strong>关键代码：</strong> 构造函数是私有的。</p>\n<p><strong>应用实例：</strong> 1、一个党只能有一个主席。 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</p>\n<p><strong>优点：</strong> 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。</p>\n<p><strong>缺点：</strong> 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>\n<p><strong>使用场景：</strong> 1、要求生产唯一序列号。 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</p>\n<p><strong>注意事项：</strong> getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。</p>\n<h2 id=\"单例模式的实现\"><a href=\"#单例模式的实现\" class=\"headerlink\" title=\"单例模式的实现\"></a>单例模式的实现</h2><p>在 Python 中，我们可以用多种方法来实现单例模式：</p>\n<ul>\n<li>使用基类 <code>__new__</code></li>\n<li>使用模块</li>\n<li>使用装饰器（decorator）</li>\n<li>使用元类（metaclass）</li>\n</ul>\n<h3 id=\"使用基类-new\"><a href=\"#使用基类-new\" class=\"headerlink\" title=\"使用基类 __new__\"></a>使用基类 <code>__new__</code></h3><p><code>__new__</code> 是真正创建实例对象的方法，所以重写基类的<code>__new__</code>方法，以此来保证创建对象的时候只生成一个实例</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__new__</span><span class=\"params\">(cls, *args, **kwargs)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> hasattr(cls, <span class=\"string\">'_instance'</span>):</span><br><span class=\"line\">            cls._instance = super(Singleton, cls).__new__(cls, *args, **kwargs)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cls._instance  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span><span class=\"params\">(Singleton)</span>:</span>  </span><br><span class=\"line\">    a = <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<p>在上面的代码中，我们将类的实例和一个类变量 <code>_instance</code> 关联起来，如果 <code>cls._instance</code> 为 None 则创建实例，否则直接返回 <code>cls._instance</code>。执行结果如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>one = MyClass()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>two = MyClass()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>one == two</span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>one <span class=\"keyword\">is</span> two</span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>id(one), id(two)</span><br><span class=\"line\">(<span class=\"number\">4303862608</span>, <span class=\"number\">4303862608</span>)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"使用元类\"><a href=\"#使用元类\" class=\"headerlink\" title=\"使用元类\"></a>使用元类</h3><p>元类（参考：<a href=\"http://blog.jobbole.com/21351/\" target=\"_blank\" rel=\"noopener\">深刻理解Python中的元类</a>）是用于创建类对象的类，类对象创建实例对象时一定会调用<code>__call__</code>方法，因此在调用<code>__call__</code>时候保证始终只创建一个实例即可，<code>type</code>是python中的一个元类。</p>\n<p>元类（metaclass）可以控制类的创建过程，它主要做三件事：</p>\n<ul>\n<li>拦截类的创建</li>\n<li>修改类的定义</li>\n<li>返回修改后的类</li>\n</ul>\n<p>使用元类实现单例模式的代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span><span class=\"params\">(type)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__call__</span><span class=\"params\">(cls, *args, **kwargs)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> hasattr(cls, <span class=\"string\">'_instance'</span>):</span><br><span class=\"line\">            cls._instance = super(Singleton, cls).__call__(*args, **kwargs)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cls._instance</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span><span class=\"params\">(metaclass=Singleton)</span>:</span>  </span><br><span class=\"line\">    a = <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 执行结果如下</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>one = MyClass()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>two = MyClass()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>one == two</span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>one <span class=\"keyword\">is</span> two</span><br><span class=\"line\"><span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>id(one), id(two)</span><br><span class=\"line\">(<span class=\"number\">4303862608</span>, <span class=\"number\">4303862608</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用装饰器\"><a href=\"#使用装饰器\" class=\"headerlink\" title=\"使用装饰器\"></a>使用装饰器</h3><p>装饰器（decorator）可以动态地修改一个类或函数的功能。这里，我们也可以使用装饰器来装饰某个类，使其只能生成一个实例，代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">singleton</span><span class=\"params\">(cls)</span>:</span></span><br><span class=\"line\">    instances = &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kwargs)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> cls <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> instances:</span><br><span class=\"line\">            instances[cls] = cls(*args, **kwargs)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instances[cls]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@singleton</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<p><strong>将装饰器写成类形式</strong><br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">single03</span><span class=\"params\">(object)</span>:</span>  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, cls)</span>:</span>  </span><br><span class=\"line\">            self._cls = cls  </span><br><span class=\"line\">            self._instances = <span class=\"keyword\">None</span>;  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__call__</span><span class=\"params\">(self, *args)</span>:</span>  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self._instances:  </span><br><span class=\"line\">                self._instances = self._cls(*args)  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> self._instances  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@single03  </span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span><span class=\"params\">(object)</span>:</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, name)</span>:</span>  </span><br><span class=\"line\">        self.name = name</span><br></pre></td></tr></table></figure></p>\n<p>在上面，我们定义了一个装饰器 singleton，它返回了一个内部函数 <code>warpper</code>，该函数会判断某个类是否在字典 instances 中，如果不存在，则会将 cls 作为 key，<code>cls(*args, **kw)</code> 作为 value 存到 instances 中，否则，直接返回 instances[cls]</p>\n<h3 id=\"使用模块\"><a href=\"#使用模块\" class=\"headerlink\" title=\"使用模块\"></a>使用模块</h3><p>Python 的模块就是天然的单例模式，因为模块在第一次导入时，会生成 .pyc 文件，当第二次导入时，就会直接加载 .pyc 文件，而不会再次执行模块代码。因此，我们只需把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了。如果我们真的想要一个单例类，可以考虑这样做：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># mysingleton.py</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">My_Singleton</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">foo</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">my_singleton = My_Singleton()</span><br></pre></td></tr></table></figure></p>\n<p>将上面的代码保存在文件 mysingleton.py 中，然后这样使用:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> mysingleton <span class=\"keyword\">import</span> my_singleton</span><br><span class=\"line\"></span><br><span class=\"line\">my_singleton.foo()</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"http://python.jobbole.com/87294/\" target=\"_blank\" rel=\"noopener\">http://python.jobbole.com/87294/</a></li>\n<li><a href=\"http://python.jobbole.com/87791/?utm_source=blog.jobbole.com&amp;utm_medium=relatedPosts\" target=\"_blank\" rel=\"noopener\">http://python.jobbole.com/87791/?utm_source=blog.jobbole.com&amp;utm_medium=relatedPosts</a></li>\n</ol>"},{"title":"Python3 向上取整ceil|向下取整floor|四舍五入round","date":"2018-03-09T06:21:35.000Z","_content":"```python\nimport math\n\n#向上取整\nprint(\"math.ceil---向上取整\")  \nprint(\"math.ceil(2.3) => \", math.ceil(2.3))  # 3\nprint(\"math.ceil(2.6) => \", math.ceil(2.6))  # 3\n\n#向下取整\nprint(\"\\nmath.floor---向下取整\")\nprint(\"math.floor(2.3) => \", math.floor(2.3)) # 2\nprint(\"math.floor(2.6) => \", math.floor(2.6)) # 2\n\n#四舍五入\nprint(\"\\nround---四舍五入\")\nprint(\"round(2.3) => \", round(2.3)) # 2\nprint(\"round(2.6) => \", round(2.6)) # 3\n\n```\n<!-- more -->\n```Bash\nmath.ceil---向上取整\nmath.ceil(2.3) =>  3\nmath.ceil(2.6) =>  3\n\nmath.floor---向下取整\nmath.floor(2.3) =>  2\nmath.floor(2.6) =>  2\n\nround---四舍五入\nround(2.3) =>  2\nround(2.6) =>  3\n\n```\n","source":"_posts/Python3-向上取整ceil-向下取整floor-四舍五入round.md","raw":"---\ntitle: Python3 向上取整ceil|向下取整floor|四舍五入round\ndate: 2018-03-09 14:21:35\ntags:\n  - Python3\ncategories:\n  - Python3 进阶\n---\n```python\nimport math\n\n#向上取整\nprint(\"math.ceil---向上取整\")  \nprint(\"math.ceil(2.3) => \", math.ceil(2.3))  # 3\nprint(\"math.ceil(2.6) => \", math.ceil(2.6))  # 3\n\n#向下取整\nprint(\"\\nmath.floor---向下取整\")\nprint(\"math.floor(2.3) => \", math.floor(2.3)) # 2\nprint(\"math.floor(2.6) => \", math.floor(2.6)) # 2\n\n#四舍五入\nprint(\"\\nround---四舍五入\")\nprint(\"round(2.3) => \", round(2.3)) # 2\nprint(\"round(2.6) => \", round(2.6)) # 3\n\n```\n<!-- more -->\n```Bash\nmath.ceil---向上取整\nmath.ceil(2.3) =>  3\nmath.ceil(2.6) =>  3\n\nmath.floor---向下取整\nmath.floor(2.3) =>  2\nmath.floor(2.6) =>  2\n\nround---四舍五入\nround(2.3) =>  2\nround(2.6) =>  3\n\n```\n","slug":"Python3-向上取整ceil-向下取整floor-四舍五入round","published":1,"updated":"2018-03-09T06:27:14.992Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozkx00278mot03aw0gag","content":"<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> math</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#向上取整</span></span><br><span class=\"line\">print(<span class=\"string\">\"math.ceil---向上取整\"</span>)  </span><br><span class=\"line\">print(<span class=\"string\">\"math.ceil(2.3) =&gt; \"</span>, math.ceil(<span class=\"number\">2.3</span>))  <span class=\"comment\"># 3</span></span><br><span class=\"line\">print(<span class=\"string\">\"math.ceil(2.6) =&gt; \"</span>, math.ceil(<span class=\"number\">2.6</span>))  <span class=\"comment\"># 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#向下取整</span></span><br><span class=\"line\">print(<span class=\"string\">\"\\nmath.floor---向下取整\"</span>)</span><br><span class=\"line\">print(<span class=\"string\">\"math.floor(2.3) =&gt; \"</span>, math.floor(<span class=\"number\">2.3</span>)) <span class=\"comment\"># 2</span></span><br><span class=\"line\">print(<span class=\"string\">\"math.floor(2.6) =&gt; \"</span>, math.floor(<span class=\"number\">2.6</span>)) <span class=\"comment\"># 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#四舍五入</span></span><br><span class=\"line\">print(<span class=\"string\">\"\\nround---四舍五入\"</span>)</span><br><span class=\"line\">print(<span class=\"string\">\"round(2.3) =&gt; \"</span>, round(<span class=\"number\">2.3</span>)) <span class=\"comment\"># 2</span></span><br><span class=\"line\">print(<span class=\"string\">\"round(2.6) =&gt; \"</span>, round(<span class=\"number\">2.6</span>)) <span class=\"comment\"># 3</span></span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">math.ceil---向上取整</span><br><span class=\"line\">math.ceil(2.3) =&gt;  3</span><br><span class=\"line\">math.ceil(2.6) =&gt;  3</span><br><span class=\"line\"></span><br><span class=\"line\">math.floor---向下取整</span><br><span class=\"line\">math.floor(2.3) =&gt;  2</span><br><span class=\"line\">math.floor(2.6) =&gt;  2</span><br><span class=\"line\"></span><br><span class=\"line\">round---四舍五入</span><br><span class=\"line\">round(2.3) =&gt;  2</span><br><span class=\"line\">round(2.6) =&gt;  3</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> math</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#向上取整</span></span><br><span class=\"line\">print(<span class=\"string\">\"math.ceil---向上取整\"</span>)  </span><br><span class=\"line\">print(<span class=\"string\">\"math.ceil(2.3) =&gt; \"</span>, math.ceil(<span class=\"number\">2.3</span>))  <span class=\"comment\"># 3</span></span><br><span class=\"line\">print(<span class=\"string\">\"math.ceil(2.6) =&gt; \"</span>, math.ceil(<span class=\"number\">2.6</span>))  <span class=\"comment\"># 3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#向下取整</span></span><br><span class=\"line\">print(<span class=\"string\">\"\\nmath.floor---向下取整\"</span>)</span><br><span class=\"line\">print(<span class=\"string\">\"math.floor(2.3) =&gt; \"</span>, math.floor(<span class=\"number\">2.3</span>)) <span class=\"comment\"># 2</span></span><br><span class=\"line\">print(<span class=\"string\">\"math.floor(2.6) =&gt; \"</span>, math.floor(<span class=\"number\">2.6</span>)) <span class=\"comment\"># 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#四舍五入</span></span><br><span class=\"line\">print(<span class=\"string\">\"\\nround---四舍五入\"</span>)</span><br><span class=\"line\">print(<span class=\"string\">\"round(2.3) =&gt; \"</span>, round(<span class=\"number\">2.3</span>)) <span class=\"comment\"># 2</span></span><br><span class=\"line\">print(<span class=\"string\">\"round(2.6) =&gt; \"</span>, round(<span class=\"number\">2.6</span>)) <span class=\"comment\"># 3</span></span><br></pre></td></tr></table></figure>","more":"<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">math.ceil---向上取整</span><br><span class=\"line\">math.ceil(2.3) =&gt;  3</span><br><span class=\"line\">math.ceil(2.6) =&gt;  3</span><br><span class=\"line\"></span><br><span class=\"line\">math.floor---向下取整</span><br><span class=\"line\">math.floor(2.3) =&gt;  2</span><br><span class=\"line\">math.floor(2.6) =&gt;  2</span><br><span class=\"line\"></span><br><span class=\"line\">round---四舍五入</span><br><span class=\"line\">round(2.3) =&gt;  2</span><br><span class=\"line\">round(2.6) =&gt;  3</span><br></pre></td></tr></table></figure>"},{"title":"Python3 回文字符串的判断","date":"2018-03-19T10:25:12.000Z","_content":"```python\ndef isPalindrome(str_):\n    if len(str_) < 2:\n        return True\n    if str_[0] != str_[-1]:\n        return False\n\n    return isPalindrome(str_[1:-1])\n```\n","source":"_posts/Python3-回文字符串的判断.md","raw":"---\ntitle: Python3 回文字符串的判断\ndate: 2018-03-19 18:25:12\ntags:\n  - Python3\n  - Algorithm\ncategories:\n  - Algorithm\n---\n```python\ndef isPalindrome(str_):\n    if len(str_) < 2:\n        return True\n    if str_[0] != str_[-1]:\n        return False\n\n    return isPalindrome(str_[1:-1])\n```\n","slug":"Python3-回文字符串的判断","published":1,"updated":"2018-03-19T10:33:22.228Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozkz002b8motlie8pwot","content":"<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(str_)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(str_) &lt; <span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> str_[<span class=\"number\">0</span>] != str_[<span class=\"number\">-1</span>]:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> isPalindrome(str_[<span class=\"number\">1</span>:<span class=\"number\">-1</span>])</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(str_)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(str_) &lt; <span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> str_[<span class=\"number\">0</span>] != str_[<span class=\"number\">-1</span>]:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> isPalindrome(str_[<span class=\"number\">1</span>:<span class=\"number\">-1</span>])</span><br></pre></td></tr></table></figure>\n"},{"title":"Python3 垃圾回收机制","date":"2018-03-05T13:38:25.000Z","_content":"Python中的垃圾回收GC(Garbage collection)是以引用计数为主，分代收集为辅。引用计数的缺陷是循环引用的问题。\n分代收集在一定程度上解决了循环引用的问题（可能描述不准确）。\n\n<!-- more -->\n## 引用计数\n\nPython语言默认采用的垃圾收集机制是『引用计数法 Reference Counting』，该算法最早George E. Collins在1960的时候首次提出，50年后的今天，该算法依然被很多编程语言使用，『引用计数法』的原理是：每个对象维护一个`ob_ref`字段，用来记录该对象当前被引用的次数，每当新的引用指向该对象时，它的引用计数ob_ref加1，每当该对象的引用失效时计数ob_ref减1，一旦对象的引用计数为0，该对象立即被回收，对象占用的内存空间将被释放。它的缺点是需要额外的空间维护引用计数，这个问题是其次的，不过最主要的问题是它不能解决对象的“循环引用”，因此，有很多语言比如Java并没有采用该算法做来垃圾的收集机制。\n\n导致引用计数+1的情况\n  1. 对象被创建，例如`a=23`\n  2. 对象被引用，例如`b=a`\n  3. 对象被作为参数，传入到一个函数中，例如`func(a)`\n  4. 对象作为一个元素，存储在容器中，例如`list1=[a,a]`\n导致引用计数-1的情况\n  1. 对象的别名被显式销毁，例如`del a`\n  2. 对象的别名被赋予新的对象，例如`a=24`\n  3. 一个对象离开它的作用域，例如f函数执行完毕时，func函数中的局部变量（全局变量不会）\n  4. 对象所在的容器被销毁，或从容器中删除对象\n\n## 标记清除\n\n『标记清除（Mark—Sweep）』算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。它分为两个阶段：第一阶段是标记阶段，GC会把所有的『活动对象』打上标记，第二阶段是把那些没有标记的对象『非活动对象』进行回收。那么GC又是如何判断哪些是活动对象哪些是非活动对象的呢？\n\n对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。\n\n![mark-sweepg](https://foofish.net/images/mark-sweep.svg)\n\n在上图中，我们把小黑圈视为全局变量，也就是把它作为root object，从小黑圈出发，对象1可直达，那么它将被标记，对象2、3可间接到达也会被标记，而4和5不可达，那么1、2、3就是活动对象，4和5是非活动对象会被GC回收。\n\n标记清除算法作为Python的辅助垃圾收集技术主要处理的是一些容器对象，比如list、dict、tuple，instance等，因为对于字符串、数值对象是不可能造成循环引用问题。Python使用一个双向链表将这些容器对象组织起来。不过，这种简单粗暴的标记清除算法也有明显的缺点：清除非活动的对象前它必须顺序扫描整个堆内存，哪怕只剩下小部分活动对象也要扫描所有对象。\n\n\n## 分代回收\n\n分代回收是一种以空间换时间的操作方式，Python将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代），他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发，把那些可以被回收的对象回收掉(包括循环引用的对象)，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。同时，`分代回收是建立在标记清除技术基础之上`。分代回收同样作为Python的辅助垃圾收集技术处理那些容器对象\n\n## Python中的GC阈值\n\n随着你的程序运行，Python解释器保持对新创建的对象，以及因为引用计数为零而被释放掉的对象的追踪。从理论上说，这两个值应该保持一致，因为程序新建的每个对象都应该最终被释放掉。\n\n当然，事实并非如此。因为循环引用的原因，并且因为你的程序使用了一些比其他对象存在时间更长的对象，从而被分配对象的计数值与被释放对象的计数值之间的差异在逐渐增长。一旦这个差异累计超过某个阈值，则Python的收集机制就启动了，并且触发上边所说到的零代算法，释放“浮动的垃圾”，并且将剩下的对象移动到一代列表。\n\n随着时间的推移，程序所使用的对象逐渐从零代列表移动到一代列表。而Python对于一代列表中对象的处理遵循同样的方法，一旦被分配计数值与被释放计数值累计到达一定阈值，Python会将剩下的活跃对象移动到二代列表。\n\n通过这种方法，你的代码所长期使用的对象，那些你的代码持续访问的活跃对象，会从零代链表转移到一代再转移到二代。通过不同的阈值设置，Python可以在不同的时间间隔处理这些对象。Python处理零代最为频繁，其次是一代然后才是二代。\n\n\n## gc模块\n[Garbage Collector interface](https://docs.python.org/2/library/gc.html)  \ngc模块提供一个接口给开发者设置垃圾回收的选项。上面说到，采用引用计数的方法管理内存的一个缺陷是循环引用，而gc模块的一个主要功能就是解决循环引用的问题。\n\n### 常用函数：\n\n  1. gc.set_debug(flags)  \n设置gc的debug日志，一般设置为gc.DEBUG_LEAK\n  2. gc.collect([generation])  \n显式进行垃圾回收，可以输入参数，0代表只检查第一代的对象，1代表检查一，二代的对象，2代表检查一，二，三代的对象，如果不传参数，执行一个full collection，也就是等于传2。  \n返回不可达（unreachable objects）对象的数目\n  3. gc.set_threshold(threshold0[, threshold1[, threshold2])  \n设置自动执行垃圾回收的频率。\n  4. gc.get_count()  \n获取当前自动执行垃圾回收的计数器，返回一个长度为3的列表\n\n### gc模块的自动垃圾回收机制\n\n必须要import gc模块，并且is_enable()=True才会启动自动垃圾回收。  \n这个机制的主要作用就是发现并处理不可达的垃圾对象。\n\n`垃圾回收=垃圾检查+垃圾回收`  \n\n在Python中，采用分代收集的方法。把对象分为三代，一开始，对象在创建的时候，放在一代中，如果在一次一代的垃圾检查中，该对象存活下来，就会被放到二代中，同理在一次二代的垃圾检查中，该对象存活下来，就会被放到三代中。\n\ngc模块里面会有一个长度为3的列表的计数器，可以通过`gc.get_count()`获取。  \n例如`(488,3,0)`，其中`488`是指距离上一次0代垃圾检查，Python分配内存的数目减去释放内存的数目，**注意是内存分配，而不是引用计数的增加**。例如：\n```Python\nprint gc.get_count()  # (590, 8, 0)\na = ClassA()\nprint gc.get_count()  # (591, 8, 0)\ndel a\nprint gc.get_count()  # (590, 8, 0)\n```\n`3`是指距离上一次1代垃圾检查，0代垃圾检查的次数，同理，`0`是指距离上一次2代垃圾检查，1代垃圾检查的次数。\n\ngc模快有一个自动垃圾回收的阀值，即通过`gc.get_threshold`函数获取到的长度为3的元组，例如`(700,10,10)`  \n每一次计数器的增加，gc模块就会检查增加后的计数是否达到阀值的数目，如果是，就会执行对应的代数的垃圾检查，然后重置计数器  \n例如，假设阀值是`(700,10,10)`：\n\n  * 当计数器从`(699,3,0)`增加到`(700,3,0)`，gc模块就会执行`gc.collect(0)`,即检查0代对象的垃圾，并重置计数器为`(0,4,0)`\n  * 当计数器从`(699,9,0)`增加到`(700,9,0)`，gc模块就会执行`gc.collect(1)`,即检查1、2代对象的垃圾，并重置计数器为`(0,0,1)`\n  * 当计数器从`(699,9,9)`增加到`(700,9,9)`，gc模块就会执行`gc.collect(2)`,即检查0、1、2代对象的垃圾，并重置计数器为`(0,0,0)`\n\n\n## 应用\n\n1. 项目中避免循环引用\n2. 引入gc模块，启动gc模块的自动清理循环引用的对象机制\n3. 由于分代收集，所以把需要长期使用的变量集中管理，并尽快移到二代以后，减少GC检查时的消耗\n4. gc模块唯一处理不了的是循环引用的类都有`__del__`方法，所以项目中要避免定义_`_del__`方法，如果一定要使用该方法，同时导致了循环引用，需要代码显式调用`gc.garbage`里面的对象的`__del__`来打破僵局\n\n\n## 参考\n1. http://python.jobbole.com/87843/\n2. https://www.cnblogs.com/pinganzi/p/6646742.html\n3. http://python.jobbole.com/87064/?utm_source=blog.jobbole.com&utm_medium=relatedPosts\n","source":"_posts/Python3-垃圾回收机制.md","raw":"---\ntitle: Python3 垃圾回收机制\ndate: 2018-03-05 21:38:25\ntags:\n  - Python3\ncategories:\n  - Python3 进阶\n---\nPython中的垃圾回收GC(Garbage collection)是以引用计数为主，分代收集为辅。引用计数的缺陷是循环引用的问题。\n分代收集在一定程度上解决了循环引用的问题（可能描述不准确）。\n\n<!-- more -->\n## 引用计数\n\nPython语言默认采用的垃圾收集机制是『引用计数法 Reference Counting』，该算法最早George E. Collins在1960的时候首次提出，50年后的今天，该算法依然被很多编程语言使用，『引用计数法』的原理是：每个对象维护一个`ob_ref`字段，用来记录该对象当前被引用的次数，每当新的引用指向该对象时，它的引用计数ob_ref加1，每当该对象的引用失效时计数ob_ref减1，一旦对象的引用计数为0，该对象立即被回收，对象占用的内存空间将被释放。它的缺点是需要额外的空间维护引用计数，这个问题是其次的，不过最主要的问题是它不能解决对象的“循环引用”，因此，有很多语言比如Java并没有采用该算法做来垃圾的收集机制。\n\n导致引用计数+1的情况\n  1. 对象被创建，例如`a=23`\n  2. 对象被引用，例如`b=a`\n  3. 对象被作为参数，传入到一个函数中，例如`func(a)`\n  4. 对象作为一个元素，存储在容器中，例如`list1=[a,a]`\n导致引用计数-1的情况\n  1. 对象的别名被显式销毁，例如`del a`\n  2. 对象的别名被赋予新的对象，例如`a=24`\n  3. 一个对象离开它的作用域，例如f函数执行完毕时，func函数中的局部变量（全局变量不会）\n  4. 对象所在的容器被销毁，或从容器中删除对象\n\n## 标记清除\n\n『标记清除（Mark—Sweep）』算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。它分为两个阶段：第一阶段是标记阶段，GC会把所有的『活动对象』打上标记，第二阶段是把那些没有标记的对象『非活动对象』进行回收。那么GC又是如何判断哪些是活动对象哪些是非活动对象的呢？\n\n对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。\n\n![mark-sweepg](https://foofish.net/images/mark-sweep.svg)\n\n在上图中，我们把小黑圈视为全局变量，也就是把它作为root object，从小黑圈出发，对象1可直达，那么它将被标记，对象2、3可间接到达也会被标记，而4和5不可达，那么1、2、3就是活动对象，4和5是非活动对象会被GC回收。\n\n标记清除算法作为Python的辅助垃圾收集技术主要处理的是一些容器对象，比如list、dict、tuple，instance等，因为对于字符串、数值对象是不可能造成循环引用问题。Python使用一个双向链表将这些容器对象组织起来。不过，这种简单粗暴的标记清除算法也有明显的缺点：清除非活动的对象前它必须顺序扫描整个堆内存，哪怕只剩下小部分活动对象也要扫描所有对象。\n\n\n## 分代回收\n\n分代回收是一种以空间换时间的操作方式，Python将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代），他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发，把那些可以被回收的对象回收掉(包括循环引用的对象)，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。同时，`分代回收是建立在标记清除技术基础之上`。分代回收同样作为Python的辅助垃圾收集技术处理那些容器对象\n\n## Python中的GC阈值\n\n随着你的程序运行，Python解释器保持对新创建的对象，以及因为引用计数为零而被释放掉的对象的追踪。从理论上说，这两个值应该保持一致，因为程序新建的每个对象都应该最终被释放掉。\n\n当然，事实并非如此。因为循环引用的原因，并且因为你的程序使用了一些比其他对象存在时间更长的对象，从而被分配对象的计数值与被释放对象的计数值之间的差异在逐渐增长。一旦这个差异累计超过某个阈值，则Python的收集机制就启动了，并且触发上边所说到的零代算法，释放“浮动的垃圾”，并且将剩下的对象移动到一代列表。\n\n随着时间的推移，程序所使用的对象逐渐从零代列表移动到一代列表。而Python对于一代列表中对象的处理遵循同样的方法，一旦被分配计数值与被释放计数值累计到达一定阈值，Python会将剩下的活跃对象移动到二代列表。\n\n通过这种方法，你的代码所长期使用的对象，那些你的代码持续访问的活跃对象，会从零代链表转移到一代再转移到二代。通过不同的阈值设置，Python可以在不同的时间间隔处理这些对象。Python处理零代最为频繁，其次是一代然后才是二代。\n\n\n## gc模块\n[Garbage Collector interface](https://docs.python.org/2/library/gc.html)  \ngc模块提供一个接口给开发者设置垃圾回收的选项。上面说到，采用引用计数的方法管理内存的一个缺陷是循环引用，而gc模块的一个主要功能就是解决循环引用的问题。\n\n### 常用函数：\n\n  1. gc.set_debug(flags)  \n设置gc的debug日志，一般设置为gc.DEBUG_LEAK\n  2. gc.collect([generation])  \n显式进行垃圾回收，可以输入参数，0代表只检查第一代的对象，1代表检查一，二代的对象，2代表检查一，二，三代的对象，如果不传参数，执行一个full collection，也就是等于传2。  \n返回不可达（unreachable objects）对象的数目\n  3. gc.set_threshold(threshold0[, threshold1[, threshold2])  \n设置自动执行垃圾回收的频率。\n  4. gc.get_count()  \n获取当前自动执行垃圾回收的计数器，返回一个长度为3的列表\n\n### gc模块的自动垃圾回收机制\n\n必须要import gc模块，并且is_enable()=True才会启动自动垃圾回收。  \n这个机制的主要作用就是发现并处理不可达的垃圾对象。\n\n`垃圾回收=垃圾检查+垃圾回收`  \n\n在Python中，采用分代收集的方法。把对象分为三代，一开始，对象在创建的时候，放在一代中，如果在一次一代的垃圾检查中，该对象存活下来，就会被放到二代中，同理在一次二代的垃圾检查中，该对象存活下来，就会被放到三代中。\n\ngc模块里面会有一个长度为3的列表的计数器，可以通过`gc.get_count()`获取。  \n例如`(488,3,0)`，其中`488`是指距离上一次0代垃圾检查，Python分配内存的数目减去释放内存的数目，**注意是内存分配，而不是引用计数的增加**。例如：\n```Python\nprint gc.get_count()  # (590, 8, 0)\na = ClassA()\nprint gc.get_count()  # (591, 8, 0)\ndel a\nprint gc.get_count()  # (590, 8, 0)\n```\n`3`是指距离上一次1代垃圾检查，0代垃圾检查的次数，同理，`0`是指距离上一次2代垃圾检查，1代垃圾检查的次数。\n\ngc模快有一个自动垃圾回收的阀值，即通过`gc.get_threshold`函数获取到的长度为3的元组，例如`(700,10,10)`  \n每一次计数器的增加，gc模块就会检查增加后的计数是否达到阀值的数目，如果是，就会执行对应的代数的垃圾检查，然后重置计数器  \n例如，假设阀值是`(700,10,10)`：\n\n  * 当计数器从`(699,3,0)`增加到`(700,3,0)`，gc模块就会执行`gc.collect(0)`,即检查0代对象的垃圾，并重置计数器为`(0,4,0)`\n  * 当计数器从`(699,9,0)`增加到`(700,9,0)`，gc模块就会执行`gc.collect(1)`,即检查1、2代对象的垃圾，并重置计数器为`(0,0,1)`\n  * 当计数器从`(699,9,9)`增加到`(700,9,9)`，gc模块就会执行`gc.collect(2)`,即检查0、1、2代对象的垃圾，并重置计数器为`(0,0,0)`\n\n\n## 应用\n\n1. 项目中避免循环引用\n2. 引入gc模块，启动gc模块的自动清理循环引用的对象机制\n3. 由于分代收集，所以把需要长期使用的变量集中管理，并尽快移到二代以后，减少GC检查时的消耗\n4. gc模块唯一处理不了的是循环引用的类都有`__del__`方法，所以项目中要避免定义_`_del__`方法，如果一定要使用该方法，同时导致了循环引用，需要代码显式调用`gc.garbage`里面的对象的`__del__`来打破僵局\n\n\n## 参考\n1. http://python.jobbole.com/87843/\n2. https://www.cnblogs.com/pinganzi/p/6646742.html\n3. http://python.jobbole.com/87064/?utm_source=blog.jobbole.com&utm_medium=relatedPosts\n","slug":"Python3-垃圾回收机制","published":1,"updated":"2018-03-05T16:51:20.605Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozl5002e8motohhds8x9","content":"<p>Python中的垃圾回收GC(Garbage collection)是以引用计数为主，分代收集为辅。引用计数的缺陷是循环引用的问题。<br>分代收集在一定程度上解决了循环引用的问题（可能描述不准确）。</p>\n<a id=\"more\"></a>\n<h2 id=\"引用计数\"><a href=\"#引用计数\" class=\"headerlink\" title=\"引用计数\"></a>引用计数</h2><p>Python语言默认采用的垃圾收集机制是『引用计数法 Reference Counting』，该算法最早George E. Collins在1960的时候首次提出，50年后的今天，该算法依然被很多编程语言使用，『引用计数法』的原理是：每个对象维护一个<code>ob_ref</code>字段，用来记录该对象当前被引用的次数，每当新的引用指向该对象时，它的引用计数ob_ref加1，每当该对象的引用失效时计数ob_ref减1，一旦对象的引用计数为0，该对象立即被回收，对象占用的内存空间将被释放。它的缺点是需要额外的空间维护引用计数，这个问题是其次的，不过最主要的问题是它不能解决对象的“循环引用”，因此，有很多语言比如Java并没有采用该算法做来垃圾的收集机制。</p>\n<p>导致引用计数+1的情况</p>\n<ol>\n<li>对象被创建，例如<code>a=23</code></li>\n<li>对象被引用，例如<code>b=a</code></li>\n<li>对象被作为参数，传入到一个函数中，例如<code>func(a)</code></li>\n<li>对象作为一个元素，存储在容器中，例如<code>list1=[a,a]</code><br>导致引用计数-1的情况</li>\n<li>对象的别名被显式销毁，例如<code>del a</code></li>\n<li>对象的别名被赋予新的对象，例如<code>a=24</code></li>\n<li>一个对象离开它的作用域，例如f函数执行完毕时，func函数中的局部变量（全局变量不会）</li>\n<li>对象所在的容器被销毁，或从容器中删除对象</li>\n</ol>\n<h2 id=\"标记清除\"><a href=\"#标记清除\" class=\"headerlink\" title=\"标记清除\"></a>标记清除</h2><p>『标记清除（Mark—Sweep）』算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。它分为两个阶段：第一阶段是标记阶段，GC会把所有的『活动对象』打上标记，第二阶段是把那些没有标记的对象『非活动对象』进行回收。那么GC又是如何判断哪些是活动对象哪些是非活动对象的呢？</p>\n<p>对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。</p>\n<p><img src=\"https://foofish.net/images/mark-sweep.svg\" alt=\"mark-sweepg\"></p>\n<p>在上图中，我们把小黑圈视为全局变量，也就是把它作为root object，从小黑圈出发，对象1可直达，那么它将被标记，对象2、3可间接到达也会被标记，而4和5不可达，那么1、2、3就是活动对象，4和5是非活动对象会被GC回收。</p>\n<p>标记清除算法作为Python的辅助垃圾收集技术主要处理的是一些容器对象，比如list、dict、tuple，instance等，因为对于字符串、数值对象是不可能造成循环引用问题。Python使用一个双向链表将这些容器对象组织起来。不过，这种简单粗暴的标记清除算法也有明显的缺点：清除非活动的对象前它必须顺序扫描整个堆内存，哪怕只剩下小部分活动对象也要扫描所有对象。</p>\n<h2 id=\"分代回收\"><a href=\"#分代回收\" class=\"headerlink\" title=\"分代回收\"></a>分代回收</h2><p>分代回收是一种以空间换时间的操作方式，Python将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代），他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发，把那些可以被回收的对象回收掉(包括循环引用的对象)，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。同时，<code>分代回收是建立在标记清除技术基础之上</code>。分代回收同样作为Python的辅助垃圾收集技术处理那些容器对象</p>\n<h2 id=\"Python中的GC阈值\"><a href=\"#Python中的GC阈值\" class=\"headerlink\" title=\"Python中的GC阈值\"></a>Python中的GC阈值</h2><p>随着你的程序运行，Python解释器保持对新创建的对象，以及因为引用计数为零而被释放掉的对象的追踪。从理论上说，这两个值应该保持一致，因为程序新建的每个对象都应该最终被释放掉。</p>\n<p>当然，事实并非如此。因为循环引用的原因，并且因为你的程序使用了一些比其他对象存在时间更长的对象，从而被分配对象的计数值与被释放对象的计数值之间的差异在逐渐增长。一旦这个差异累计超过某个阈值，则Python的收集机制就启动了，并且触发上边所说到的零代算法，释放“浮动的垃圾”，并且将剩下的对象移动到一代列表。</p>\n<p>随着时间的推移，程序所使用的对象逐渐从零代列表移动到一代列表。而Python对于一代列表中对象的处理遵循同样的方法，一旦被分配计数值与被释放计数值累计到达一定阈值，Python会将剩下的活跃对象移动到二代列表。</p>\n<p>通过这种方法，你的代码所长期使用的对象，那些你的代码持续访问的活跃对象，会从零代链表转移到一代再转移到二代。通过不同的阈值设置，Python可以在不同的时间间隔处理这些对象。Python处理零代最为频繁，其次是一代然后才是二代。</p>\n<h2 id=\"gc模块\"><a href=\"#gc模块\" class=\"headerlink\" title=\"gc模块\"></a>gc模块</h2><p><a href=\"https://docs.python.org/2/library/gc.html\" target=\"_blank\" rel=\"noopener\">Garbage Collector interface</a><br>gc模块提供一个接口给开发者设置垃圾回收的选项。上面说到，采用引用计数的方法管理内存的一个缺陷是循环引用，而gc模块的一个主要功能就是解决循环引用的问题。</p>\n<h3 id=\"常用函数：\"><a href=\"#常用函数：\" class=\"headerlink\" title=\"常用函数：\"></a>常用函数：</h3><ol>\n<li>gc.set_debug(flags)<br>设置gc的debug日志，一般设置为gc.DEBUG_LEAK</li>\n<li>gc.collect([generation])<br>显式进行垃圾回收，可以输入参数，0代表只检查第一代的对象，1代表检查一，二代的对象，2代表检查一，二，三代的对象，如果不传参数，执行一个full collection，也就是等于传2。<br>返回不可达（unreachable objects）对象的数目</li>\n<li>gc.set_threshold(threshold0[, threshold1[, threshold2])<br>设置自动执行垃圾回收的频率。</li>\n<li>gc.get_count()<br>获取当前自动执行垃圾回收的计数器，返回一个长度为3的列表</li>\n</ol>\n<h3 id=\"gc模块的自动垃圾回收机制\"><a href=\"#gc模块的自动垃圾回收机制\" class=\"headerlink\" title=\"gc模块的自动垃圾回收机制\"></a>gc模块的自动垃圾回收机制</h3><p>必须要import gc模块，并且is_enable()=True才会启动自动垃圾回收。<br>这个机制的主要作用就是发现并处理不可达的垃圾对象。</p>\n<p><code>垃圾回收=垃圾检查+垃圾回收</code>  </p>\n<p>在Python中，采用分代收集的方法。把对象分为三代，一开始，对象在创建的时候，放在一代中，如果在一次一代的垃圾检查中，该对象存活下来，就会被放到二代中，同理在一次二代的垃圾检查中，该对象存活下来，就会被放到三代中。</p>\n<p>gc模块里面会有一个长度为3的列表的计数器，可以通过<code>gc.get_count()</code>获取。<br>例如<code>(488,3,0)</code>，其中<code>488</code>是指距离上一次0代垃圾检查，Python分配内存的数目减去释放内存的数目，<strong>注意是内存分配，而不是引用计数的增加</strong>。例如：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">print</span> gc.get_count()  <span class=\"comment\"># (590, 8, 0)</span></span><br><span class=\"line\">a = ClassA()</span><br><span class=\"line\"><span class=\"keyword\">print</span> gc.get_count()  <span class=\"comment\"># (591, 8, 0)</span></span><br><span class=\"line\"><span class=\"keyword\">del</span> a</span><br><span class=\"line\"><span class=\"keyword\">print</span> gc.get_count()  <span class=\"comment\"># (590, 8, 0)</span></span><br></pre></td></tr></table></figure></p>\n<p><code>3</code>是指距离上一次1代垃圾检查，0代垃圾检查的次数，同理，<code>0</code>是指距离上一次2代垃圾检查，1代垃圾检查的次数。</p>\n<p>gc模快有一个自动垃圾回收的阀值，即通过<code>gc.get_threshold</code>函数获取到的长度为3的元组，例如<code>(700,10,10)</code><br>每一次计数器的增加，gc模块就会检查增加后的计数是否达到阀值的数目，如果是，就会执行对应的代数的垃圾检查，然后重置计数器<br>例如，假设阀值是<code>(700,10,10)</code>：</p>\n<ul>\n<li>当计数器从<code>(699,3,0)</code>增加到<code>(700,3,0)</code>，gc模块就会执行<code>gc.collect(0)</code>,即检查0代对象的垃圾，并重置计数器为<code>(0,4,0)</code></li>\n<li>当计数器从<code>(699,9,0)</code>增加到<code>(700,9,0)</code>，gc模块就会执行<code>gc.collect(1)</code>,即检查1、2代对象的垃圾，并重置计数器为<code>(0,0,1)</code></li>\n<li>当计数器从<code>(699,9,9)</code>增加到<code>(700,9,9)</code>，gc模块就会执行<code>gc.collect(2)</code>,即检查0、1、2代对象的垃圾，并重置计数器为<code>(0,0,0)</code></li>\n</ul>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><ol>\n<li>项目中避免循环引用</li>\n<li>引入gc模块，启动gc模块的自动清理循环引用的对象机制</li>\n<li>由于分代收集，所以把需要长期使用的变量集中管理，并尽快移到二代以后，减少GC检查时的消耗</li>\n<li>gc模块唯一处理不了的是循环引用的类都有<code>__del__</code>方法，所以项目中要避免定义_<code>_del__</code>方法，如果一定要使用该方法，同时导致了循环引用，需要代码显式调用<code>gc.garbage</code>里面的对象的<code>__del__</code>来打破僵局</li>\n</ol>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"http://python.jobbole.com/87843/\" target=\"_blank\" rel=\"noopener\">http://python.jobbole.com/87843/</a></li>\n<li><a href=\"https://www.cnblogs.com/pinganzi/p/6646742.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/pinganzi/p/6646742.html</a></li>\n<li><a href=\"http://python.jobbole.com/87064/?utm_source=blog.jobbole.com&amp;utm_medium=relatedPosts\" target=\"_blank\" rel=\"noopener\">http://python.jobbole.com/87064/?utm_source=blog.jobbole.com&amp;utm_medium=relatedPosts</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>Python中的垃圾回收GC(Garbage collection)是以引用计数为主，分代收集为辅。引用计数的缺陷是循环引用的问题。<br>分代收集在一定程度上解决了循环引用的问题（可能描述不准确）。</p>","more":"<h2 id=\"引用计数\"><a href=\"#引用计数\" class=\"headerlink\" title=\"引用计数\"></a>引用计数</h2><p>Python语言默认采用的垃圾收集机制是『引用计数法 Reference Counting』，该算法最早George E. Collins在1960的时候首次提出，50年后的今天，该算法依然被很多编程语言使用，『引用计数法』的原理是：每个对象维护一个<code>ob_ref</code>字段，用来记录该对象当前被引用的次数，每当新的引用指向该对象时，它的引用计数ob_ref加1，每当该对象的引用失效时计数ob_ref减1，一旦对象的引用计数为0，该对象立即被回收，对象占用的内存空间将被释放。它的缺点是需要额外的空间维护引用计数，这个问题是其次的，不过最主要的问题是它不能解决对象的“循环引用”，因此，有很多语言比如Java并没有采用该算法做来垃圾的收集机制。</p>\n<p>导致引用计数+1的情况</p>\n<ol>\n<li>对象被创建，例如<code>a=23</code></li>\n<li>对象被引用，例如<code>b=a</code></li>\n<li>对象被作为参数，传入到一个函数中，例如<code>func(a)</code></li>\n<li>对象作为一个元素，存储在容器中，例如<code>list1=[a,a]</code><br>导致引用计数-1的情况</li>\n<li>对象的别名被显式销毁，例如<code>del a</code></li>\n<li>对象的别名被赋予新的对象，例如<code>a=24</code></li>\n<li>一个对象离开它的作用域，例如f函数执行完毕时，func函数中的局部变量（全局变量不会）</li>\n<li>对象所在的容器被销毁，或从容器中删除对象</li>\n</ol>\n<h2 id=\"标记清除\"><a href=\"#标记清除\" class=\"headerlink\" title=\"标记清除\"></a>标记清除</h2><p>『标记清除（Mark—Sweep）』算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。它分为两个阶段：第一阶段是标记阶段，GC会把所有的『活动对象』打上标记，第二阶段是把那些没有标记的对象『非活动对象』进行回收。那么GC又是如何判断哪些是活动对象哪些是非活动对象的呢？</p>\n<p>对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。</p>\n<p><img src=\"https://foofish.net/images/mark-sweep.svg\" alt=\"mark-sweepg\"></p>\n<p>在上图中，我们把小黑圈视为全局变量，也就是把它作为root object，从小黑圈出发，对象1可直达，那么它将被标记，对象2、3可间接到达也会被标记，而4和5不可达，那么1、2、3就是活动对象，4和5是非活动对象会被GC回收。</p>\n<p>标记清除算法作为Python的辅助垃圾收集技术主要处理的是一些容器对象，比如list、dict、tuple，instance等，因为对于字符串、数值对象是不可能造成循环引用问题。Python使用一个双向链表将这些容器对象组织起来。不过，这种简单粗暴的标记清除算法也有明显的缺点：清除非活动的对象前它必须顺序扫描整个堆内存，哪怕只剩下小部分活动对象也要扫描所有对象。</p>\n<h2 id=\"分代回收\"><a href=\"#分代回收\" class=\"headerlink\" title=\"分代回收\"></a>分代回收</h2><p>分代回收是一种以空间换时间的操作方式，Python将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代），他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发，把那些可以被回收的对象回收掉(包括循环引用的对象)，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。同时，<code>分代回收是建立在标记清除技术基础之上</code>。分代回收同样作为Python的辅助垃圾收集技术处理那些容器对象</p>\n<h2 id=\"Python中的GC阈值\"><a href=\"#Python中的GC阈值\" class=\"headerlink\" title=\"Python中的GC阈值\"></a>Python中的GC阈值</h2><p>随着你的程序运行，Python解释器保持对新创建的对象，以及因为引用计数为零而被释放掉的对象的追踪。从理论上说，这两个值应该保持一致，因为程序新建的每个对象都应该最终被释放掉。</p>\n<p>当然，事实并非如此。因为循环引用的原因，并且因为你的程序使用了一些比其他对象存在时间更长的对象，从而被分配对象的计数值与被释放对象的计数值之间的差异在逐渐增长。一旦这个差异累计超过某个阈值，则Python的收集机制就启动了，并且触发上边所说到的零代算法，释放“浮动的垃圾”，并且将剩下的对象移动到一代列表。</p>\n<p>随着时间的推移，程序所使用的对象逐渐从零代列表移动到一代列表。而Python对于一代列表中对象的处理遵循同样的方法，一旦被分配计数值与被释放计数值累计到达一定阈值，Python会将剩下的活跃对象移动到二代列表。</p>\n<p>通过这种方法，你的代码所长期使用的对象，那些你的代码持续访问的活跃对象，会从零代链表转移到一代再转移到二代。通过不同的阈值设置，Python可以在不同的时间间隔处理这些对象。Python处理零代最为频繁，其次是一代然后才是二代。</p>\n<h2 id=\"gc模块\"><a href=\"#gc模块\" class=\"headerlink\" title=\"gc模块\"></a>gc模块</h2><p><a href=\"https://docs.python.org/2/library/gc.html\" target=\"_blank\" rel=\"noopener\">Garbage Collector interface</a><br>gc模块提供一个接口给开发者设置垃圾回收的选项。上面说到，采用引用计数的方法管理内存的一个缺陷是循环引用，而gc模块的一个主要功能就是解决循环引用的问题。</p>\n<h3 id=\"常用函数：\"><a href=\"#常用函数：\" class=\"headerlink\" title=\"常用函数：\"></a>常用函数：</h3><ol>\n<li>gc.set_debug(flags)<br>设置gc的debug日志，一般设置为gc.DEBUG_LEAK</li>\n<li>gc.collect([generation])<br>显式进行垃圾回收，可以输入参数，0代表只检查第一代的对象，1代表检查一，二代的对象，2代表检查一，二，三代的对象，如果不传参数，执行一个full collection，也就是等于传2。<br>返回不可达（unreachable objects）对象的数目</li>\n<li>gc.set_threshold(threshold0[, threshold1[, threshold2])<br>设置自动执行垃圾回收的频率。</li>\n<li>gc.get_count()<br>获取当前自动执行垃圾回收的计数器，返回一个长度为3的列表</li>\n</ol>\n<h3 id=\"gc模块的自动垃圾回收机制\"><a href=\"#gc模块的自动垃圾回收机制\" class=\"headerlink\" title=\"gc模块的自动垃圾回收机制\"></a>gc模块的自动垃圾回收机制</h3><p>必须要import gc模块，并且is_enable()=True才会启动自动垃圾回收。<br>这个机制的主要作用就是发现并处理不可达的垃圾对象。</p>\n<p><code>垃圾回收=垃圾检查+垃圾回收</code>  </p>\n<p>在Python中，采用分代收集的方法。把对象分为三代，一开始，对象在创建的时候，放在一代中，如果在一次一代的垃圾检查中，该对象存活下来，就会被放到二代中，同理在一次二代的垃圾检查中，该对象存活下来，就会被放到三代中。</p>\n<p>gc模块里面会有一个长度为3的列表的计数器，可以通过<code>gc.get_count()</code>获取。<br>例如<code>(488,3,0)</code>，其中<code>488</code>是指距离上一次0代垃圾检查，Python分配内存的数目减去释放内存的数目，<strong>注意是内存分配，而不是引用计数的增加</strong>。例如：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">print</span> gc.get_count()  <span class=\"comment\"># (590, 8, 0)</span></span><br><span class=\"line\">a = ClassA()</span><br><span class=\"line\"><span class=\"keyword\">print</span> gc.get_count()  <span class=\"comment\"># (591, 8, 0)</span></span><br><span class=\"line\"><span class=\"keyword\">del</span> a</span><br><span class=\"line\"><span class=\"keyword\">print</span> gc.get_count()  <span class=\"comment\"># (590, 8, 0)</span></span><br></pre></td></tr></table></figure></p>\n<p><code>3</code>是指距离上一次1代垃圾检查，0代垃圾检查的次数，同理，<code>0</code>是指距离上一次2代垃圾检查，1代垃圾检查的次数。</p>\n<p>gc模快有一个自动垃圾回收的阀值，即通过<code>gc.get_threshold</code>函数获取到的长度为3的元组，例如<code>(700,10,10)</code><br>每一次计数器的增加，gc模块就会检查增加后的计数是否达到阀值的数目，如果是，就会执行对应的代数的垃圾检查，然后重置计数器<br>例如，假设阀值是<code>(700,10,10)</code>：</p>\n<ul>\n<li>当计数器从<code>(699,3,0)</code>增加到<code>(700,3,0)</code>，gc模块就会执行<code>gc.collect(0)</code>,即检查0代对象的垃圾，并重置计数器为<code>(0,4,0)</code></li>\n<li>当计数器从<code>(699,9,0)</code>增加到<code>(700,9,0)</code>，gc模块就会执行<code>gc.collect(1)</code>,即检查1、2代对象的垃圾，并重置计数器为<code>(0,0,1)</code></li>\n<li>当计数器从<code>(699,9,9)</code>增加到<code>(700,9,9)</code>，gc模块就会执行<code>gc.collect(2)</code>,即检查0、1、2代对象的垃圾，并重置计数器为<code>(0,0,0)</code></li>\n</ul>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><ol>\n<li>项目中避免循环引用</li>\n<li>引入gc模块，启动gc模块的自动清理循环引用的对象机制</li>\n<li>由于分代收集，所以把需要长期使用的变量集中管理，并尽快移到二代以后，减少GC检查时的消耗</li>\n<li>gc模块唯一处理不了的是循环引用的类都有<code>__del__</code>方法，所以项目中要避免定义_<code>_del__</code>方法，如果一定要使用该方法，同时导致了循环引用，需要代码显式调用<code>gc.garbage</code>里面的对象的<code>__del__</code>来打破僵局</li>\n</ol>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"http://python.jobbole.com/87843/\" target=\"_blank\" rel=\"noopener\">http://python.jobbole.com/87843/</a></li>\n<li><a href=\"https://www.cnblogs.com/pinganzi/p/6646742.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/pinganzi/p/6646742.html</a></li>\n<li><a href=\"http://python.jobbole.com/87064/?utm_source=blog.jobbole.com&amp;utm_medium=relatedPosts\" target=\"_blank\" rel=\"noopener\">http://python.jobbole.com/87064/?utm_source=blog.jobbole.com&amp;utm_medium=relatedPosts</a></li>\n</ol>"},{"title":"Python3 基于链表技术实现栈","date":"2018-03-17T07:40:12.000Z","_content":"## 定义异常类\n实现栈结构之前，先考虑为操作失败的处理定义一个异常类。在这里通过继承已有的异常类定义自己的异常类。由于栈操作(如空栈弹出)时不满足需要可以看做参数值错误，采用下面的定义\n```Python\nclass StackUnderflow(ValueError):  # 栈下溢，空栈访问\n    pass\n```\n\n## 定义一个表结点类\n\n```python\nclass LNode:\n    def __init__(self, elem, next_=None):\n        self.elem = elem\n        self.next = next_\n```\n方法的第二个参数用名字`next_`，是为了避免与Python`标准函数next`重名\n\n<!-- more -->\n\n## 栈的链接表实现\n由于所有栈的操作都在线性表的一端进行，采用链接表技术，自然应该用表头一端作为栈顶，表尾作为栈底，是操作实现方便，效率也高。按照这种安排，容易定义出一个链接栈类。\n```python\nclass LStack:\n    def __init__(self):\n        self._top = None\n\n    def is_empty(self):\n        return self._top is None\n\n    def top(self):\n        if self._top is None:\n            raise StackUnderflow('in LStack.top()')\n        return self._top.elem\n\n    def push(self, elem):\n        self._top = LNode(elem, self._top)\n\n    def pop(self):\n        if self._top is None:\n            raise StackUnderflow('in LStack.pop()')\n        p = self._top\n        self._top = p.next\n        return p.elem\n\n\n\n```\n\n## 参考\n\n1. 《数据结构与算法Python语言描述》 --- 裘宗燕\n","source":"_posts/Python3-基于链表技术实现栈.md","raw":"---\ntitle: Python3 基于链表技术实现栈\ndate: 2018-03-17 15:40:12\ntags:\n  - Python3\n  - Algorithm\n  - Data Structures\ncategories:\n  - Data Structures\n---\n## 定义异常类\n实现栈结构之前，先考虑为操作失败的处理定义一个异常类。在这里通过继承已有的异常类定义自己的异常类。由于栈操作(如空栈弹出)时不满足需要可以看做参数值错误，采用下面的定义\n```Python\nclass StackUnderflow(ValueError):  # 栈下溢，空栈访问\n    pass\n```\n\n## 定义一个表结点类\n\n```python\nclass LNode:\n    def __init__(self, elem, next_=None):\n        self.elem = elem\n        self.next = next_\n```\n方法的第二个参数用名字`next_`，是为了避免与Python`标准函数next`重名\n\n<!-- more -->\n\n## 栈的链接表实现\n由于所有栈的操作都在线性表的一端进行，采用链接表技术，自然应该用表头一端作为栈顶，表尾作为栈底，是操作实现方便，效率也高。按照这种安排，容易定义出一个链接栈类。\n```python\nclass LStack:\n    def __init__(self):\n        self._top = None\n\n    def is_empty(self):\n        return self._top is None\n\n    def top(self):\n        if self._top is None:\n            raise StackUnderflow('in LStack.top()')\n        return self._top.elem\n\n    def push(self, elem):\n        self._top = LNode(elem, self._top)\n\n    def pop(self):\n        if self._top is None:\n            raise StackUnderflow('in LStack.pop()')\n        p = self._top\n        self._top = p.next\n        return p.elem\n\n\n\n```\n\n## 参考\n\n1. 《数据结构与算法Python语言描述》 --- 裘宗燕\n","slug":"Python3-基于链表技术实现栈","published":1,"updated":"2018-03-18T20:13:11.735Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozl7002i8mot3xjwbxqh","content":"<h2 id=\"定义异常类\"><a href=\"#定义异常类\" class=\"headerlink\" title=\"定义异常类\"></a>定义异常类</h2><p>实现栈结构之前，先考虑为操作失败的处理定义一个异常类。在这里通过继承已有的异常类定义自己的异常类。由于栈操作(如空栈弹出)时不满足需要可以看做参数值错误，采用下面的定义<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StackUnderflow</span><span class=\"params\">(ValueError)</span>:</span>  <span class=\"comment\"># 栈下溢，空栈访问</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"定义一个表结点类\"><a href=\"#定义一个表结点类\" class=\"headerlink\" title=\"定义一个表结点类\"></a>定义一个表结点类</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LNode</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, elem, next_=None)</span>:</span></span><br><span class=\"line\">        self.elem = elem</span><br><span class=\"line\">        self.next = next_</span><br></pre></td></tr></table></figure>\n<p>方法的第二个参数用名字<code>next_</code>，是为了避免与Python<code>标准函数next</code>重名</p>\n<a id=\"more\"></a>\n<h2 id=\"栈的链接表实现\"><a href=\"#栈的链接表实现\" class=\"headerlink\" title=\"栈的链接表实现\"></a>栈的链接表实现</h2><p>由于所有栈的操作都在线性表的一端进行，采用链接表技术，自然应该用表头一端作为栈顶，表尾作为栈底，是操作实现方便，效率也高。按照这种安排，容易定义出一个链接栈类。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LStack</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self._top = <span class=\"keyword\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_empty</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._top <span class=\"keyword\">is</span> <span class=\"keyword\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">top</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self._top <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> StackUnderflow(<span class=\"string\">'in LStack.top()'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._top.elem</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">push</span><span class=\"params\">(self, elem)</span>:</span></span><br><span class=\"line\">        self._top = LNode(elem, self._top)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pop</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self._top <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> StackUnderflow(<span class=\"string\">'in LStack.pop()'</span>)</span><br><span class=\"line\">        p = self._top</span><br><span class=\"line\">        self._top = p.next</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p.elem</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li>《数据结构与算法Python语言描述》 — 裘宗燕</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"定义异常类\"><a href=\"#定义异常类\" class=\"headerlink\" title=\"定义异常类\"></a>定义异常类</h2><p>实现栈结构之前，先考虑为操作失败的处理定义一个异常类。在这里通过继承已有的异常类定义自己的异常类。由于栈操作(如空栈弹出)时不满足需要可以看做参数值错误，采用下面的定义<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StackUnderflow</span><span class=\"params\">(ValueError)</span>:</span>  <span class=\"comment\"># 栈下溢，空栈访问</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"定义一个表结点类\"><a href=\"#定义一个表结点类\" class=\"headerlink\" title=\"定义一个表结点类\"></a>定义一个表结点类</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LNode</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, elem, next_=None)</span>:</span></span><br><span class=\"line\">        self.elem = elem</span><br><span class=\"line\">        self.next = next_</span><br></pre></td></tr></table></figure>\n<p>方法的第二个参数用名字<code>next_</code>，是为了避免与Python<code>标准函数next</code>重名</p>","more":"<h2 id=\"栈的链接表实现\"><a href=\"#栈的链接表实现\" class=\"headerlink\" title=\"栈的链接表实现\"></a>栈的链接表实现</h2><p>由于所有栈的操作都在线性表的一端进行，采用链接表技术，自然应该用表头一端作为栈顶，表尾作为栈底，是操作实现方便，效率也高。按照这种安排，容易定义出一个链接栈类。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LStack</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self._top = <span class=\"keyword\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_empty</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._top <span class=\"keyword\">is</span> <span class=\"keyword\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">top</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self._top <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> StackUnderflow(<span class=\"string\">'in LStack.top()'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._top.elem</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">push</span><span class=\"params\">(self, elem)</span>:</span></span><br><span class=\"line\">        self._top = LNode(elem, self._top)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pop</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self._top <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> StackUnderflow(<span class=\"string\">'in LStack.pop()'</span>)</span><br><span class=\"line\">        p = self._top</span><br><span class=\"line\">        self._top = p.next</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p.elem</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li>《数据结构与算法Python语言描述》 — 裘宗燕</li>\n</ol>"},{"title":"Python3 基于顺序表技术实现栈类","date":"2018-03-17T06:40:55.000Z","_content":"## 定义异常类\n实现栈结构之前，先考虑为操作失败的处理定义一个异常类。在这里通过继承已有的异常类定义自己的异常类。由于栈操作(如空栈弹出)时不满足需要可以看做参数值错误，采用下面的定义\n```Python\nclass StackUnderflow(ValueError):  # 栈下溢，空栈访问\n    pass\n```\n上面把异常`StackUnderflow`定义为`ValueError`子类，只简单定义了一个类名，类体部分只有一个`pass`语句，未定义任何新属性，因为不准备提供`ValueError`之外的新功能，只是想与其他`ValueError`异常有所区分，程序出错时能产生不同的错误信息。必要时可以定义专门的异常处理操作。自定义异常与python内置异常类似，同样通过`except`进行捕捉和处理，但只能通过`raise`语句引发。\n\n<!-- more -->\n## 栈类定义\n把list当做栈使用时，完全可以满足应用需要。但是，这样建立的对象实际上还是list，提供了list类型的所有操作。特别是提供了一大批栈结构原本不应该支持的操作，威胁栈的使用安全性(例如，栈要求未经弹出的元素应该存在，但表运行任意删除)。另外，这样的“栈”不是一个独立的类型，因此没有独立类型的所有重要性质。\n\n为了概念更清晰，实现更安全，操作名也更容易理解，，可以考虑使用顺序表定义一个栈类，使之成为一个独立的类型，把Python的list隐藏在类内部，作为其实现基础。\n\n```python\n\"\"\"\n基于顺序表实现栈类\n用list对象 _elems存储栈中的元素\n所有的栈操作都映射到list操作\n\"\"\"\nclass SStack(object):\n    def __init__(self):\n        self._elems = []\n\n    def is_empty(self):\n        return self._elems == []\n\n    def top(self):\n        if self._elems == []:\n            raise StackUnderflow('in SStack.top()')\n        return self._elems[-1]\n\n    def push(self, elem):\n        self._elems.append(elem)\n\n    def pop(self):\n        if self._elems == []:\n            raise StackUnderflow('in SStack.pop()')\n        return self._elems.pop()\n```\n\n## 参考\n\n1. 《数据结构与算法Python语言描述》 --- 裘宗燕\n","source":"_posts/Python3-基于顺序表技术实现栈类.md","raw":"---\ntitle: Python3 基于顺序表技术实现栈类\ndate: 2018-03-17 14:40:55\ntags:\n  - Python3\n  - Algorithm\n  - Data Structures\ncategories:\n  - Data Structures\n---\n## 定义异常类\n实现栈结构之前，先考虑为操作失败的处理定义一个异常类。在这里通过继承已有的异常类定义自己的异常类。由于栈操作(如空栈弹出)时不满足需要可以看做参数值错误，采用下面的定义\n```Python\nclass StackUnderflow(ValueError):  # 栈下溢，空栈访问\n    pass\n```\n上面把异常`StackUnderflow`定义为`ValueError`子类，只简单定义了一个类名，类体部分只有一个`pass`语句，未定义任何新属性，因为不准备提供`ValueError`之外的新功能，只是想与其他`ValueError`异常有所区分，程序出错时能产生不同的错误信息。必要时可以定义专门的异常处理操作。自定义异常与python内置异常类似，同样通过`except`进行捕捉和处理，但只能通过`raise`语句引发。\n\n<!-- more -->\n## 栈类定义\n把list当做栈使用时，完全可以满足应用需要。但是，这样建立的对象实际上还是list，提供了list类型的所有操作。特别是提供了一大批栈结构原本不应该支持的操作，威胁栈的使用安全性(例如，栈要求未经弹出的元素应该存在，但表运行任意删除)。另外，这样的“栈”不是一个独立的类型，因此没有独立类型的所有重要性质。\n\n为了概念更清晰，实现更安全，操作名也更容易理解，，可以考虑使用顺序表定义一个栈类，使之成为一个独立的类型，把Python的list隐藏在类内部，作为其实现基础。\n\n```python\n\"\"\"\n基于顺序表实现栈类\n用list对象 _elems存储栈中的元素\n所有的栈操作都映射到list操作\n\"\"\"\nclass SStack(object):\n    def __init__(self):\n        self._elems = []\n\n    def is_empty(self):\n        return self._elems == []\n\n    def top(self):\n        if self._elems == []:\n            raise StackUnderflow('in SStack.top()')\n        return self._elems[-1]\n\n    def push(self, elem):\n        self._elems.append(elem)\n\n    def pop(self):\n        if self._elems == []:\n            raise StackUnderflow('in SStack.pop()')\n        return self._elems.pop()\n```\n\n## 参考\n\n1. 《数据结构与算法Python语言描述》 --- 裘宗燕\n","slug":"Python3-基于顺序表技术实现栈类","published":1,"updated":"2018-03-17T07:12:09.223Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozl9002m8motoefx8src","content":"<h2 id=\"定义异常类\"><a href=\"#定义异常类\" class=\"headerlink\" title=\"定义异常类\"></a>定义异常类</h2><p>实现栈结构之前，先考虑为操作失败的处理定义一个异常类。在这里通过继承已有的异常类定义自己的异常类。由于栈操作(如空栈弹出)时不满足需要可以看做参数值错误，采用下面的定义<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StackUnderflow</span><span class=\"params\">(ValueError)</span>:</span>  <span class=\"comment\"># 栈下溢，空栈访问</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure></p>\n<p>上面把异常<code>StackUnderflow</code>定义为<code>ValueError</code>子类，只简单定义了一个类名，类体部分只有一个<code>pass</code>语句，未定义任何新属性，因为不准备提供<code>ValueError</code>之外的新功能，只是想与其他<code>ValueError</code>异常有所区分，程序出错时能产生不同的错误信息。必要时可以定义专门的异常处理操作。自定义异常与python内置异常类似，同样通过<code>except</code>进行捕捉和处理，但只能通过<code>raise</code>语句引发。</p>\n<a id=\"more\"></a>\n<h2 id=\"栈类定义\"><a href=\"#栈类定义\" class=\"headerlink\" title=\"栈类定义\"></a>栈类定义</h2><p>把list当做栈使用时，完全可以满足应用需要。但是，这样建立的对象实际上还是list，提供了list类型的所有操作。特别是提供了一大批栈结构原本不应该支持的操作，威胁栈的使用安全性(例如，栈要求未经弹出的元素应该存在，但表运行任意删除)。另外，这样的“栈”不是一个独立的类型，因此没有独立类型的所有重要性质。</p>\n<p>为了概念更清晰，实现更安全，操作名也更容易理解，，可以考虑使用顺序表定义一个栈类，使之成为一个独立的类型，把Python的list隐藏在类内部，作为其实现基础。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">基于顺序表实现栈类</span></span><br><span class=\"line\"><span class=\"string\">用list对象 _elems存储栈中的元素</span></span><br><span class=\"line\"><span class=\"string\">所有的栈操作都映射到list操作</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SStack</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self._elems = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_empty</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._elems == []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">top</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self._elems == []:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> StackUnderflow(<span class=\"string\">'in SStack.top()'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._elems[<span class=\"number\">-1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">push</span><span class=\"params\">(self, elem)</span>:</span></span><br><span class=\"line\">        self._elems.append(elem)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pop</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self._elems == []:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> StackUnderflow(<span class=\"string\">'in SStack.pop()'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._elems.pop()</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li>《数据结构与算法Python语言描述》 — 裘宗燕</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"定义异常类\"><a href=\"#定义异常类\" class=\"headerlink\" title=\"定义异常类\"></a>定义异常类</h2><p>实现栈结构之前，先考虑为操作失败的处理定义一个异常类。在这里通过继承已有的异常类定义自己的异常类。由于栈操作(如空栈弹出)时不满足需要可以看做参数值错误，采用下面的定义<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StackUnderflow</span><span class=\"params\">(ValueError)</span>:</span>  <span class=\"comment\"># 栈下溢，空栈访问</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure></p>\n<p>上面把异常<code>StackUnderflow</code>定义为<code>ValueError</code>子类，只简单定义了一个类名，类体部分只有一个<code>pass</code>语句，未定义任何新属性，因为不准备提供<code>ValueError</code>之外的新功能，只是想与其他<code>ValueError</code>异常有所区分，程序出错时能产生不同的错误信息。必要时可以定义专门的异常处理操作。自定义异常与python内置异常类似，同样通过<code>except</code>进行捕捉和处理，但只能通过<code>raise</code>语句引发。</p>","more":"<h2 id=\"栈类定义\"><a href=\"#栈类定义\" class=\"headerlink\" title=\"栈类定义\"></a>栈类定义</h2><p>把list当做栈使用时，完全可以满足应用需要。但是，这样建立的对象实际上还是list，提供了list类型的所有操作。特别是提供了一大批栈结构原本不应该支持的操作，威胁栈的使用安全性(例如，栈要求未经弹出的元素应该存在，但表运行任意删除)。另外，这样的“栈”不是一个独立的类型，因此没有独立类型的所有重要性质。</p>\n<p>为了概念更清晰，实现更安全，操作名也更容易理解，，可以考虑使用顺序表定义一个栈类，使之成为一个独立的类型，把Python的list隐藏在类内部，作为其实现基础。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">基于顺序表实现栈类</span></span><br><span class=\"line\"><span class=\"string\">用list对象 _elems存储栈中的元素</span></span><br><span class=\"line\"><span class=\"string\">所有的栈操作都映射到list操作</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SStack</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self._elems = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">is_empty</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._elems == []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">top</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self._elems == []:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> StackUnderflow(<span class=\"string\">'in SStack.top()'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._elems[<span class=\"number\">-1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">push</span><span class=\"params\">(self, elem)</span>:</span></span><br><span class=\"line\">        self._elems.append(elem)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pop</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self._elems == []:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> StackUnderflow(<span class=\"string\">'in SStack.pop()'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._elems.pop()</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li>《数据结构与算法Python语言描述》 — 裘宗燕</li>\n</ol>"},{"title":"Python3 子类的查看与类的对象判断","date":"2018-03-02T18:24:21.000Z","_content":"1. 如果想要查看一个类是不是另一个类的子类，可以使用內建的 `issubclass` 函数或者使用它的特殊特性`__base__`；\n\n2. 如果想要检查一个对象是不是一个类的实例，可以使用內建的 `isinstance` 函数或者使用它的特殊特性`__class__`;\n<!-- more -->\n\n```python\n# -*- coding: utf-8 -*-  \n__metaclass__ = type #确定使新式类  \n\n\nclass father():  \n    def init(self):  \n        print(\"father()已经创建\")  \n\nclass son(father):  \n    def init(self):  \n        print(\"son()已经创建\")  \n\n#下面测试issubclass()函数  \nprint(issubclass(father,son))  # output: False\nprint(issubclass(son,father))  # output: True\n\n#下面使用__bases__  \nprint(\"father.__bases__:\",father.__bases__)  # output: father.__bases__: (<class 'object'>,)  \nprint(\"son.__bases__:\",son.__bases__)        # output: son.__bases__: (<class '__main__.father'>,)  \n\n#下面测试isinstance()函数  \ns = son()  \nprint(isinstance(s,son))    # output: True\nprint(isinstance(s,father)) # output: True\nprint(isinstance(s,str))    # output: False\n\n#下面使用__class__  \nprint(\"s.__class__:\",s.__class__) # output: s.__class__: <class '__main__.son'>  \n```\n","source":"_posts/Python3-子类的查看与类的对象判断.md","raw":"---\ntitle: Python3 子类的查看与类的对象判断\ndate: 2018-03-03 02:24:21\ntags:\n  - Python3\ncategories:\n  - Python3 进阶\n---\n1. 如果想要查看一个类是不是另一个类的子类，可以使用內建的 `issubclass` 函数或者使用它的特殊特性`__base__`；\n\n2. 如果想要检查一个对象是不是一个类的实例，可以使用內建的 `isinstance` 函数或者使用它的特殊特性`__class__`;\n<!-- more -->\n\n```python\n# -*- coding: utf-8 -*-  \n__metaclass__ = type #确定使新式类  \n\n\nclass father():  \n    def init(self):  \n        print(\"father()已经创建\")  \n\nclass son(father):  \n    def init(self):  \n        print(\"son()已经创建\")  \n\n#下面测试issubclass()函数  \nprint(issubclass(father,son))  # output: False\nprint(issubclass(son,father))  # output: True\n\n#下面使用__bases__  \nprint(\"father.__bases__:\",father.__bases__)  # output: father.__bases__: (<class 'object'>,)  \nprint(\"son.__bases__:\",son.__bases__)        # output: son.__bases__: (<class '__main__.father'>,)  \n\n#下面测试isinstance()函数  \ns = son()  \nprint(isinstance(s,son))    # output: True\nprint(isinstance(s,father)) # output: True\nprint(isinstance(s,str))    # output: False\n\n#下面使用__class__  \nprint(\"s.__class__:\",s.__class__) # output: s.__class__: <class '__main__.son'>  \n```\n","slug":"Python3-子类的查看与类的对象判断","published":1,"updated":"2018-03-03T02:39:26.058Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozlb002q8mot9x1hrsjd","content":"<ol>\n<li><p>如果想要查看一个类是不是另一个类的子类，可以使用內建的 <code>issubclass</code> 函数或者使用它的特殊特性<code>__base__</code>；</p>\n</li>\n<li><p>如果想要检查一个对象是不是一个类的实例，可以使用內建的 <code>isinstance</code> 函数或者使用它的特殊特性<code>__class__</code>;</p>\n<a id=\"more\"></a>\n</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-  </span></span><br><span class=\"line\">__metaclass__ = type <span class=\"comment\">#确定使新式类  </span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">father</span><span class=\"params\">()</span>:</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">init</span><span class=\"params\">(self)</span>:</span>  </span><br><span class=\"line\">        print(<span class=\"string\">\"father()已经创建\"</span>)  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">son</span><span class=\"params\">(father)</span>:</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">init</span><span class=\"params\">(self)</span>:</span>  </span><br><span class=\"line\">        print(<span class=\"string\">\"son()已经创建\"</span>)  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#下面测试issubclass()函数  </span></span><br><span class=\"line\">print(issubclass(father,son))  <span class=\"comment\"># output: False</span></span><br><span class=\"line\">print(issubclass(son,father))  <span class=\"comment\"># output: True</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#下面使用__bases__  </span></span><br><span class=\"line\">print(<span class=\"string\">\"father.__bases__:\"</span>,father.__bases__)  <span class=\"comment\"># output: father.__bases__: (&lt;class 'object'&gt;,)  </span></span><br><span class=\"line\">print(<span class=\"string\">\"son.__bases__:\"</span>,son.__bases__)        <span class=\"comment\"># output: son.__bases__: (&lt;class '__main__.father'&gt;,)  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#下面测试isinstance()函数  </span></span><br><span class=\"line\">s = son()  </span><br><span class=\"line\">print(isinstance(s,son))    <span class=\"comment\"># output: True</span></span><br><span class=\"line\">print(isinstance(s,father)) <span class=\"comment\"># output: True</span></span><br><span class=\"line\">print(isinstance(s,str))    <span class=\"comment\"># output: False</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#下面使用__class__  </span></span><br><span class=\"line\">print(<span class=\"string\">\"s.__class__:\"</span>,s.__class__) <span class=\"comment\"># output: s.__class__: &lt;class '__main__.son'&gt;</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<ol>\n<li><p>如果想要查看一个类是不是另一个类的子类，可以使用內建的 <code>issubclass</code> 函数或者使用它的特殊特性<code>__base__</code>；</p>\n</li>\n<li><p>如果想要检查一个对象是不是一个类的实例，可以使用內建的 <code>isinstance</code> 函数或者使用它的特殊特性<code>__class__</code>;</p>","more":"</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-  </span></span><br><span class=\"line\">__metaclass__ = type <span class=\"comment\">#确定使新式类  </span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">father</span><span class=\"params\">()</span>:</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">init</span><span class=\"params\">(self)</span>:</span>  </span><br><span class=\"line\">        print(<span class=\"string\">\"father()已经创建\"</span>)  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">son</span><span class=\"params\">(father)</span>:</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">init</span><span class=\"params\">(self)</span>:</span>  </span><br><span class=\"line\">        print(<span class=\"string\">\"son()已经创建\"</span>)  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#下面测试issubclass()函数  </span></span><br><span class=\"line\">print(issubclass(father,son))  <span class=\"comment\"># output: False</span></span><br><span class=\"line\">print(issubclass(son,father))  <span class=\"comment\"># output: True</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#下面使用__bases__  </span></span><br><span class=\"line\">print(<span class=\"string\">\"father.__bases__:\"</span>,father.__bases__)  <span class=\"comment\"># output: father.__bases__: (&lt;class 'object'&gt;,)  </span></span><br><span class=\"line\">print(<span class=\"string\">\"son.__bases__:\"</span>,son.__bases__)        <span class=\"comment\"># output: son.__bases__: (&lt;class '__main__.father'&gt;,)  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#下面测试isinstance()函数  </span></span><br><span class=\"line\">s = son()  </span><br><span class=\"line\">print(isinstance(s,son))    <span class=\"comment\"># output: True</span></span><br><span class=\"line\">print(isinstance(s,father)) <span class=\"comment\"># output: True</span></span><br><span class=\"line\">print(isinstance(s,str))    <span class=\"comment\"># output: False</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#下面使用__class__  </span></span><br><span class=\"line\">print(<span class=\"string\">\"s.__class__:\"</span>,s.__class__) <span class=\"comment\"># output: s.__class__: &lt;class '__main__.son'&gt;</span></span><br></pre></td></tr></table></figure>"},{"title":"Python3 实现二分查找","date":"2018-03-09T06:32:16.000Z","_content":"\n二分查找,给出一个已经排好序的列表,`注意是已经排好序的`,查找指定元素在列表中的位置\n```Python\nimport math\n\ndef binary_search(my_list, item):\n    \"\"\"从list中查找item\"\"\"\n    low = 0\n    high = len(my_list) - 1\n\n    while low <= high:\n        mid = math.floor((low + high)/2)\n        guess = my_list[mid]\n        if guess > item:\n            high = mid - 1\n        elif guess < item:\n            low = mid + 1\n        else:\n            return mid\n    return None\n\nmy_list = [1,3,5,7,9]\nitem = 1\nprint(binary_search(my_list, item))\n\n```\n","source":"_posts/Python3-实现二分查找.md","raw":"---\ntitle: Python3 实现二分查找\ndate: 2018-03-09 14:32:16\ntags:\n  - Python3\n  - Algorithm\ncategories:\n  - Algorithm\n---\n\n二分查找,给出一个已经排好序的列表,`注意是已经排好序的`,查找指定元素在列表中的位置\n```Python\nimport math\n\ndef binary_search(my_list, item):\n    \"\"\"从list中查找item\"\"\"\n    low = 0\n    high = len(my_list) - 1\n\n    while low <= high:\n        mid = math.floor((low + high)/2)\n        guess = my_list[mid]\n        if guess > item:\n            high = mid - 1\n        elif guess < item:\n            low = mid + 1\n        else:\n            return mid\n    return None\n\nmy_list = [1,3,5,7,9]\nitem = 1\nprint(binary_search(my_list, item))\n\n```\n","slug":"Python3-实现二分查找","published":1,"updated":"2018-03-09T07:26:37.282Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozld002u8mot7n9mdngz","content":"<p>二分查找,给出一个已经排好序的列表,<code>注意是已经排好序的</code>,查找指定元素在列表中的位置<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> math</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">binary_search</span><span class=\"params\">(my_list, item)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"从list中查找item\"\"\"</span></span><br><span class=\"line\">    low = <span class=\"number\">0</span></span><br><span class=\"line\">    high = len(my_list) - <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> low &lt;= high:</span><br><span class=\"line\">        mid = math.floor((low + high)/<span class=\"number\">2</span>)</span><br><span class=\"line\">        guess = my_list[mid]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> guess &gt; item:</span><br><span class=\"line\">            high = mid - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> guess &lt; item:</span><br><span class=\"line\">            low = mid + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\">my_list = [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">9</span>]</span><br><span class=\"line\">item = <span class=\"number\">1</span></span><br><span class=\"line\">print(binary_search(my_list, item))</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>二分查找,给出一个已经排好序的列表,<code>注意是已经排好序的</code>,查找指定元素在列表中的位置<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> math</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">binary_search</span><span class=\"params\">(my_list, item)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"从list中查找item\"\"\"</span></span><br><span class=\"line\">    low = <span class=\"number\">0</span></span><br><span class=\"line\">    high = len(my_list) - <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> low &lt;= high:</span><br><span class=\"line\">        mid = math.floor((low + high)/<span class=\"number\">2</span>)</span><br><span class=\"line\">        guess = my_list[mid]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> guess &gt; item:</span><br><span class=\"line\">            high = mid - <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> guess &lt; item:</span><br><span class=\"line\">            low = mid + <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\">my_list = [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">9</span>]</span><br><span class=\"line\">item = <span class=\"number\">1</span></span><br><span class=\"line\">print(binary_search(my_list, item))</span><br></pre></td></tr></table></figure></p>\n"},{"title":"Python3 实现二叉树前、中、后序遍历及按层遍历","date":"2018-03-15T15:57:26.000Z","_content":"假设有这么一个二叉树如下：\n![二叉树.png](https://upload-images.jianshu.io/upload_images/2952111-707a1e95da262138.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n前序遍历结果：1, 2, 4, 5, 8, 9, 11, 3, 6, 7, 10\n中序遍历结果：4, 2, 8, 5, 11, 9, 1, 6, 3, 10, 7\n后序遍历结果：4, 8, 11, 9, 5, 2, 6, 10, 7, 3, 1\n\n## 二叉树的类实现\n```python\nclass Node(object):\n    def __init__(self, value=None, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\nif __name__ == \"__main__\":\n    tree = Node(1, Node(2, Node(4),\n                           Node(5, Node(8),\n                                   Node(9, left=Node(11)))),\n                   Node(3, Node(6),\n                           Node(7, left=Node(10))))\n```\n<!-- more -->\n## 深度优先遍历\n### 递归法\n\n```python\n# 前序遍历（递归）\ndef pre_deep_func(root):\n    if root is None:\n        return\n    print(root.value, end = ' ')  # print 放到下一行 就是中序遍历，放到最后 就是后序遍历\n    pre_deep_func(root.left)\n    pre_deep_func(root.right)\n\n```\n\n### 非递归法\n#### 前序遍历\n根据已有的认识，此函数需要一个栈，保存树尚未访问过的部分信息。对于前序遍历也会有不同的实现方法，下面考虑一种方法，即：\n1. 由于采取先序遍历，遇到结点就应该访问，下一步就应该沿着树的坐分支下行\n2. 但结点的右分支（右子树）还没有访问，因此需要记录，将右子结点入栈。\n3. 遇到空树时回溯，取出栈中保存的一个右分支，像一颗二叉树一样遍历它。\n\n\n```python\n## 方法一 常规打印\ndef preorder_nonrec(root):\n    s = []\n    while s or root:\n        while root:  # 沿左分支下行\n            print(root.value, end = ' ')  # 先处理根数据\n            s.append(root.right)          # 右分支入栈\n            root = root.left\n        root = s.pop()                    #  遇到空树，回溯\n\n## 方法二 通过生成器函数遍历\ndef preorder_elements(root):\n    s = []\n    while s or root:\n        while root:\n            s.append(root.right)\n            yield root.value\n            root = root.left\n        root = s.pop()\n\n## 方法三\n# 前序遍历（根左右）:模拟压栈过程\n# 入栈之前读（根、左），这样出栈时再读右（也是右结点子节点们的根）\ndef pre_deep_func2(root):\n    a = []\n    while a or root:\n        while root:\n            print(root.value, end = ' ')\n            a.append(root)  ## 根入栈\n            root = root.left\n        h = a.pop()\n        root = h.right\n\n```\n\n非递归算法的一个价值是把算法过程完整的暴露出来，便于进行细致的分析。\n时间复杂度：在非递归的算法中，因为在执行的过程中访问每个结点一次，一部分子树(所有右子树，方法一、二)被压入和弹出各一次(栈操作是O(1)时间)，所以整个遍历过程需要的时间复杂度为O(n)。\n空间复杂度：这里的关键因素是遍历中栈可能达到的最大深度（栈中元素的最大深度个数），而栈的最大深度由被遍历的二叉树的高度决定。由于二叉树的高度可能达到O(n)，所以在最坏情况下，算法的空间复杂度为O(n)，n个结点的二叉树的平均高度为O(log n)，所以非递归前序遍历的平均空间复杂度为O(log n)。\n在一些情况下，修改实现方法也可能降低空间的开销。对于上面函数，修改其定义，只把非空的右子树进栈，在很多情况下能减小一些空间开销。\n\n其他非递归的遍历算法，包括中序遍历和后续遍历算法以及层次遍历算法，都可以直接了当的修改成迭代器。但是递归算法不可以。\n\n#### 中序遍历\n```python\n# 中序遍历（左根右）:模拟压栈过程\n# 出栈之后读（左、根），这样出栈后指针变更再读右\ndef mid_deep_func2(root):\n    a = []\n    while a or root:\n        while root:\n            a.append(root)\n            root = root.left\n        h = a.pop()\n        print h.value\n        root = h.right\n```\n\n#### 后序遍历\n```python\n# 后序遍历（左右根）:模拟逆序(根右左)存入数组b，然后再数组b逆序输出\n# (根右左)与(根左右)类似，入栈a前读（根、右），出栈后指针变更再读左\n## 方法 1\ndef after_deep_func2(root):\n    a = []\n    b = []\n    while a or root:\n        while root:\n            b.append(root.value)\n            a.append(root.left)\n            root = root.right\n        root = a.pop()\n    print(b[::-1])\n\n## 方法2\ndef after_deep_func2(root):\n    a = []\n    b = []\n    while a or root:\n        while root:\n            b.append(root.value)\n            a.append(root)\n            root = root.right\n        h = a.pop()\n        root = h.left\n    print b[::-1]\n```\n\n## 广度优先遍历\n```python\ndef level_func(root):\n    a = []\n    a.append(root)\n    while a:\n        head = a.pop(0)\n        print head.value\n        if head.left:\n            a.append(head.left)\n        if head.right:\n            a.append(head.right)\n\n```\n\n\n\n## 参考\n\n1. http://blog.csdn.net/su92chen/article/details/70242822\n2. 《数据结构与算法Python语言描述》 --- 裘宗燕\n","source":"_posts/Python3-实现二叉树前、中、后序遍历及按层遍历.md","raw":"---\ntitle: Python3 实现二叉树前、中、后序遍历及按层遍历\ndate: 2018-03-15 23:57:26\ntags:\n  - Python3\n  - Algorithm\n  - Data Structures\ncategories:\n  - Data Structures\n---\n假设有这么一个二叉树如下：\n![二叉树.png](https://upload-images.jianshu.io/upload_images/2952111-707a1e95da262138.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n前序遍历结果：1, 2, 4, 5, 8, 9, 11, 3, 6, 7, 10\n中序遍历结果：4, 2, 8, 5, 11, 9, 1, 6, 3, 10, 7\n后序遍历结果：4, 8, 11, 9, 5, 2, 6, 10, 7, 3, 1\n\n## 二叉树的类实现\n```python\nclass Node(object):\n    def __init__(self, value=None, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n\nif __name__ == \"__main__\":\n    tree = Node(1, Node(2, Node(4),\n                           Node(5, Node(8),\n                                   Node(9, left=Node(11)))),\n                   Node(3, Node(6),\n                           Node(7, left=Node(10))))\n```\n<!-- more -->\n## 深度优先遍历\n### 递归法\n\n```python\n# 前序遍历（递归）\ndef pre_deep_func(root):\n    if root is None:\n        return\n    print(root.value, end = ' ')  # print 放到下一行 就是中序遍历，放到最后 就是后序遍历\n    pre_deep_func(root.left)\n    pre_deep_func(root.right)\n\n```\n\n### 非递归法\n#### 前序遍历\n根据已有的认识，此函数需要一个栈，保存树尚未访问过的部分信息。对于前序遍历也会有不同的实现方法，下面考虑一种方法，即：\n1. 由于采取先序遍历，遇到结点就应该访问，下一步就应该沿着树的坐分支下行\n2. 但结点的右分支（右子树）还没有访问，因此需要记录，将右子结点入栈。\n3. 遇到空树时回溯，取出栈中保存的一个右分支，像一颗二叉树一样遍历它。\n\n\n```python\n## 方法一 常规打印\ndef preorder_nonrec(root):\n    s = []\n    while s or root:\n        while root:  # 沿左分支下行\n            print(root.value, end = ' ')  # 先处理根数据\n            s.append(root.right)          # 右分支入栈\n            root = root.left\n        root = s.pop()                    #  遇到空树，回溯\n\n## 方法二 通过生成器函数遍历\ndef preorder_elements(root):\n    s = []\n    while s or root:\n        while root:\n            s.append(root.right)\n            yield root.value\n            root = root.left\n        root = s.pop()\n\n## 方法三\n# 前序遍历（根左右）:模拟压栈过程\n# 入栈之前读（根、左），这样出栈时再读右（也是右结点子节点们的根）\ndef pre_deep_func2(root):\n    a = []\n    while a or root:\n        while root:\n            print(root.value, end = ' ')\n            a.append(root)  ## 根入栈\n            root = root.left\n        h = a.pop()\n        root = h.right\n\n```\n\n非递归算法的一个价值是把算法过程完整的暴露出来，便于进行细致的分析。\n时间复杂度：在非递归的算法中，因为在执行的过程中访问每个结点一次，一部分子树(所有右子树，方法一、二)被压入和弹出各一次(栈操作是O(1)时间)，所以整个遍历过程需要的时间复杂度为O(n)。\n空间复杂度：这里的关键因素是遍历中栈可能达到的最大深度（栈中元素的最大深度个数），而栈的最大深度由被遍历的二叉树的高度决定。由于二叉树的高度可能达到O(n)，所以在最坏情况下，算法的空间复杂度为O(n)，n个结点的二叉树的平均高度为O(log n)，所以非递归前序遍历的平均空间复杂度为O(log n)。\n在一些情况下，修改实现方法也可能降低空间的开销。对于上面函数，修改其定义，只把非空的右子树进栈，在很多情况下能减小一些空间开销。\n\n其他非递归的遍历算法，包括中序遍历和后续遍历算法以及层次遍历算法，都可以直接了当的修改成迭代器。但是递归算法不可以。\n\n#### 中序遍历\n```python\n# 中序遍历（左根右）:模拟压栈过程\n# 出栈之后读（左、根），这样出栈后指针变更再读右\ndef mid_deep_func2(root):\n    a = []\n    while a or root:\n        while root:\n            a.append(root)\n            root = root.left\n        h = a.pop()\n        print h.value\n        root = h.right\n```\n\n#### 后序遍历\n```python\n# 后序遍历（左右根）:模拟逆序(根右左)存入数组b，然后再数组b逆序输出\n# (根右左)与(根左右)类似，入栈a前读（根、右），出栈后指针变更再读左\n## 方法 1\ndef after_deep_func2(root):\n    a = []\n    b = []\n    while a or root:\n        while root:\n            b.append(root.value)\n            a.append(root.left)\n            root = root.right\n        root = a.pop()\n    print(b[::-1])\n\n## 方法2\ndef after_deep_func2(root):\n    a = []\n    b = []\n    while a or root:\n        while root:\n            b.append(root.value)\n            a.append(root)\n            root = root.right\n        h = a.pop()\n        root = h.left\n    print b[::-1]\n```\n\n## 广度优先遍历\n```python\ndef level_func(root):\n    a = []\n    a.append(root)\n    while a:\n        head = a.pop(0)\n        print head.value\n        if head.left:\n            a.append(head.left)\n        if head.right:\n            a.append(head.right)\n\n```\n\n\n\n## 参考\n\n1. http://blog.csdn.net/su92chen/article/details/70242822\n2. 《数据结构与算法Python语言描述》 --- 裘宗燕\n","slug":"Python3-实现二叉树前、中、后序遍历及按层遍历","published":1,"updated":"2018-03-18T20:12:31.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozlg002y8mot4wgat9yu","content":"<p>假设有这么一个二叉树如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/2952111-707a1e95da262138.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"二叉树.png\"></p>\n<p>前序遍历结果：1, 2, 4, 5, 8, 9, 11, 3, 6, 7, 10<br>中序遍历结果：4, 2, 8, 5, 11, 9, 1, 6, 3, 10, 7<br>后序遍历结果：4, 8, 11, 9, 5, 2, 6, 10, 7, 3, 1</p>\n<h2 id=\"二叉树的类实现\"><a href=\"#二叉树的类实现\" class=\"headerlink\" title=\"二叉树的类实现\"></a>二叉树的类实现</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, value=None, left=None, right=None)</span>:</span></span><br><span class=\"line\">        self.value = value</span><br><span class=\"line\">        self.left = left</span><br><span class=\"line\">        self.right = right</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    tree = Node(<span class=\"number\">1</span>, Node(<span class=\"number\">2</span>, Node(<span class=\"number\">4</span>),</span><br><span class=\"line\">                           Node(<span class=\"number\">5</span>, Node(<span class=\"number\">8</span>),</span><br><span class=\"line\">                                   Node(<span class=\"number\">9</span>, left=Node(<span class=\"number\">11</span>)))),</span><br><span class=\"line\">                   Node(<span class=\"number\">3</span>, Node(<span class=\"number\">6</span>),</span><br><span class=\"line\">                           Node(<span class=\"number\">7</span>, left=Node(<span class=\"number\">10</span>))))</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h2 id=\"深度优先遍历\"><a href=\"#深度优先遍历\" class=\"headerlink\" title=\"深度优先遍历\"></a>深度优先遍历</h2><h3 id=\"递归法\"><a href=\"#递归法\" class=\"headerlink\" title=\"递归法\"></a>递归法</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 前序遍历（递归）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pre_deep_func</span><span class=\"params\">(root)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> root <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    print(root.value, end = <span class=\"string\">' '</span>)  <span class=\"comment\"># print 放到下一行 就是中序遍历，放到最后 就是后序遍历</span></span><br><span class=\"line\">    pre_deep_func(root.left)</span><br><span class=\"line\">    pre_deep_func(root.right)</span><br></pre></td></tr></table></figure>\n<h3 id=\"非递归法\"><a href=\"#非递归法\" class=\"headerlink\" title=\"非递归法\"></a>非递归法</h3><h4 id=\"前序遍历\"><a href=\"#前序遍历\" class=\"headerlink\" title=\"前序遍历\"></a>前序遍历</h4><p>根据已有的认识，此函数需要一个栈，保存树尚未访问过的部分信息。对于前序遍历也会有不同的实现方法，下面考虑一种方法，即：</p>\n<ol>\n<li>由于采取先序遍历，遇到结点就应该访问，下一步就应该沿着树的坐分支下行</li>\n<li>但结点的右分支（右子树）还没有访问，因此需要记录，将右子结点入栈。</li>\n<li>遇到空树时回溯，取出栈中保存的一个右分支，像一颗二叉树一样遍历它。</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## 方法一 常规打印</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">preorder_nonrec</span><span class=\"params\">(root)</span>:</span></span><br><span class=\"line\">    s = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> s <span class=\"keyword\">or</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> root:  <span class=\"comment\"># 沿左分支下行</span></span><br><span class=\"line\">            print(root.value, end = <span class=\"string\">' '</span>)  <span class=\"comment\"># 先处理根数据</span></span><br><span class=\"line\">            s.append(root.right)          <span class=\"comment\"># 右分支入栈</span></span><br><span class=\"line\">            root = root.left</span><br><span class=\"line\">        root = s.pop()                    <span class=\"comment\">#  遇到空树，回溯</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 方法二 通过生成器函数遍历</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">preorder_elements</span><span class=\"params\">(root)</span>:</span></span><br><span class=\"line\">    s = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> s <span class=\"keyword\">or</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> root:</span><br><span class=\"line\">            s.append(root.right)</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> root.value</span><br><span class=\"line\">            root = root.left</span><br><span class=\"line\">        root = s.pop()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 方法三</span></span><br><span class=\"line\"><span class=\"comment\"># 前序遍历（根左右）:模拟压栈过程</span></span><br><span class=\"line\"><span class=\"comment\"># 入栈之前读（根、左），这样出栈时再读右（也是右结点子节点们的根）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pre_deep_func2</span><span class=\"params\">(root)</span>:</span></span><br><span class=\"line\">    a = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> a <span class=\"keyword\">or</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> root:</span><br><span class=\"line\">            print(root.value, end = <span class=\"string\">' '</span>)</span><br><span class=\"line\">            a.append(root)  <span class=\"comment\">## 根入栈</span></span><br><span class=\"line\">            root = root.left</span><br><span class=\"line\">        h = a.pop()</span><br><span class=\"line\">        root = h.right</span><br></pre></td></tr></table></figure>\n<p>非递归算法的一个价值是把算法过程完整的暴露出来，便于进行细致的分析。<br>时间复杂度：在非递归的算法中，因为在执行的过程中访问每个结点一次，一部分子树(所有右子树，方法一、二)被压入和弹出各一次(栈操作是O(1)时间)，所以整个遍历过程需要的时间复杂度为O(n)。<br>空间复杂度：这里的关键因素是遍历中栈可能达到的最大深度（栈中元素的最大深度个数），而栈的最大深度由被遍历的二叉树的高度决定。由于二叉树的高度可能达到O(n)，所以在最坏情况下，算法的空间复杂度为O(n)，n个结点的二叉树的平均高度为O(log n)，所以非递归前序遍历的平均空间复杂度为O(log n)。<br>在一些情况下，修改实现方法也可能降低空间的开销。对于上面函数，修改其定义，只把非空的右子树进栈，在很多情况下能减小一些空间开销。</p>\n<p>其他非递归的遍历算法，包括中序遍历和后续遍历算法以及层次遍历算法，都可以直接了当的修改成迭代器。但是递归算法不可以。</p>\n<h4 id=\"中序遍历\"><a href=\"#中序遍历\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 中序遍历（左根右）:模拟压栈过程</span></span><br><span class=\"line\"><span class=\"comment\"># 出栈之后读（左、根），这样出栈后指针变更再读右</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mid_deep_func2</span><span class=\"params\">(root)</span>:</span></span><br><span class=\"line\">    a = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> a <span class=\"keyword\">or</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> root:</span><br><span class=\"line\">            a.append(root)</span><br><span class=\"line\">            root = root.left</span><br><span class=\"line\">        h = a.pop()</span><br><span class=\"line\">        <span class=\"keyword\">print</span> h.value</span><br><span class=\"line\">        root = h.right</span><br></pre></td></tr></table></figure>\n<h4 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 后序遍历（左右根）:模拟逆序(根右左)存入数组b，然后再数组b逆序输出</span></span><br><span class=\"line\"><span class=\"comment\"># (根右左)与(根左右)类似，入栈a前读（根、右），出栈后指针变更再读左</span></span><br><span class=\"line\"><span class=\"comment\">## 方法 1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">after_deep_func2</span><span class=\"params\">(root)</span>:</span></span><br><span class=\"line\">    a = []</span><br><span class=\"line\">    b = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> a <span class=\"keyword\">or</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> root:</span><br><span class=\"line\">            b.append(root.value)</span><br><span class=\"line\">            a.append(root.left)</span><br><span class=\"line\">            root = root.right</span><br><span class=\"line\">        root = a.pop()</span><br><span class=\"line\">    print(b[::<span class=\"number\">-1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 方法2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">after_deep_func2</span><span class=\"params\">(root)</span>:</span></span><br><span class=\"line\">    a = []</span><br><span class=\"line\">    b = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> a <span class=\"keyword\">or</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> root:</span><br><span class=\"line\">            b.append(root.value)</span><br><span class=\"line\">            a.append(root)</span><br><span class=\"line\">            root = root.right</span><br><span class=\"line\">        h = a.pop()</span><br><span class=\"line\">        root = h.left</span><br><span class=\"line\">    <span class=\"keyword\">print</span> b[::<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<h2 id=\"广度优先遍历\"><a href=\"#广度优先遍历\" class=\"headerlink\" title=\"广度优先遍历\"></a>广度优先遍历</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">level_func</span><span class=\"params\">(root)</span>:</span></span><br><span class=\"line\">    a = []</span><br><span class=\"line\">    a.append(root)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> a:</span><br><span class=\"line\">        head = a.pop(<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">print</span> head.value</span><br><span class=\"line\">        <span class=\"keyword\">if</span> head.left:</span><br><span class=\"line\">            a.append(head.left)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> head.right:</span><br><span class=\"line\">            a.append(head.right)</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"http://blog.csdn.net/su92chen/article/details/70242822\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/su92chen/article/details/70242822</a></li>\n<li>《数据结构与算法Python语言描述》 — 裘宗燕</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>假设有这么一个二叉树如下：<br><img src=\"https://upload-images.jianshu.io/upload_images/2952111-707a1e95da262138.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"二叉树.png\"></p>\n<p>前序遍历结果：1, 2, 4, 5, 8, 9, 11, 3, 6, 7, 10<br>中序遍历结果：4, 2, 8, 5, 11, 9, 1, 6, 3, 10, 7<br>后序遍历结果：4, 8, 11, 9, 5, 2, 6, 10, 7, 3, 1</p>\n<h2 id=\"二叉树的类实现\"><a href=\"#二叉树的类实现\" class=\"headerlink\" title=\"二叉树的类实现\"></a>二叉树的类实现</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, value=None, left=None, right=None)</span>:</span></span><br><span class=\"line\">        self.value = value</span><br><span class=\"line\">        self.left = left</span><br><span class=\"line\">        self.right = right</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    tree = Node(<span class=\"number\">1</span>, Node(<span class=\"number\">2</span>, Node(<span class=\"number\">4</span>),</span><br><span class=\"line\">                           Node(<span class=\"number\">5</span>, Node(<span class=\"number\">8</span>),</span><br><span class=\"line\">                                   Node(<span class=\"number\">9</span>, left=Node(<span class=\"number\">11</span>)))),</span><br><span class=\"line\">                   Node(<span class=\"number\">3</span>, Node(<span class=\"number\">6</span>),</span><br><span class=\"line\">                           Node(<span class=\"number\">7</span>, left=Node(<span class=\"number\">10</span>))))</span><br></pre></td></tr></table></figure>","more":"<h2 id=\"深度优先遍历\"><a href=\"#深度优先遍历\" class=\"headerlink\" title=\"深度优先遍历\"></a>深度优先遍历</h2><h3 id=\"递归法\"><a href=\"#递归法\" class=\"headerlink\" title=\"递归法\"></a>递归法</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 前序遍历（递归）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pre_deep_func</span><span class=\"params\">(root)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> root <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    print(root.value, end = <span class=\"string\">' '</span>)  <span class=\"comment\"># print 放到下一行 就是中序遍历，放到最后 就是后序遍历</span></span><br><span class=\"line\">    pre_deep_func(root.left)</span><br><span class=\"line\">    pre_deep_func(root.right)</span><br></pre></td></tr></table></figure>\n<h3 id=\"非递归法\"><a href=\"#非递归法\" class=\"headerlink\" title=\"非递归法\"></a>非递归法</h3><h4 id=\"前序遍历\"><a href=\"#前序遍历\" class=\"headerlink\" title=\"前序遍历\"></a>前序遍历</h4><p>根据已有的认识，此函数需要一个栈，保存树尚未访问过的部分信息。对于前序遍历也会有不同的实现方法，下面考虑一种方法，即：</p>\n<ol>\n<li>由于采取先序遍历，遇到结点就应该访问，下一步就应该沿着树的坐分支下行</li>\n<li>但结点的右分支（右子树）还没有访问，因此需要记录，将右子结点入栈。</li>\n<li>遇到空树时回溯，取出栈中保存的一个右分支，像一颗二叉树一样遍历它。</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">## 方法一 常规打印</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">preorder_nonrec</span><span class=\"params\">(root)</span>:</span></span><br><span class=\"line\">    s = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> s <span class=\"keyword\">or</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> root:  <span class=\"comment\"># 沿左分支下行</span></span><br><span class=\"line\">            print(root.value, end = <span class=\"string\">' '</span>)  <span class=\"comment\"># 先处理根数据</span></span><br><span class=\"line\">            s.append(root.right)          <span class=\"comment\"># 右分支入栈</span></span><br><span class=\"line\">            root = root.left</span><br><span class=\"line\">        root = s.pop()                    <span class=\"comment\">#  遇到空树，回溯</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 方法二 通过生成器函数遍历</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">preorder_elements</span><span class=\"params\">(root)</span>:</span></span><br><span class=\"line\">    s = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> s <span class=\"keyword\">or</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> root:</span><br><span class=\"line\">            s.append(root.right)</span><br><span class=\"line\">            <span class=\"keyword\">yield</span> root.value</span><br><span class=\"line\">            root = root.left</span><br><span class=\"line\">        root = s.pop()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 方法三</span></span><br><span class=\"line\"><span class=\"comment\"># 前序遍历（根左右）:模拟压栈过程</span></span><br><span class=\"line\"><span class=\"comment\"># 入栈之前读（根、左），这样出栈时再读右（也是右结点子节点们的根）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pre_deep_func2</span><span class=\"params\">(root)</span>:</span></span><br><span class=\"line\">    a = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> a <span class=\"keyword\">or</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> root:</span><br><span class=\"line\">            print(root.value, end = <span class=\"string\">' '</span>)</span><br><span class=\"line\">            a.append(root)  <span class=\"comment\">## 根入栈</span></span><br><span class=\"line\">            root = root.left</span><br><span class=\"line\">        h = a.pop()</span><br><span class=\"line\">        root = h.right</span><br></pre></td></tr></table></figure>\n<p>非递归算法的一个价值是把算法过程完整的暴露出来，便于进行细致的分析。<br>时间复杂度：在非递归的算法中，因为在执行的过程中访问每个结点一次，一部分子树(所有右子树，方法一、二)被压入和弹出各一次(栈操作是O(1)时间)，所以整个遍历过程需要的时间复杂度为O(n)。<br>空间复杂度：这里的关键因素是遍历中栈可能达到的最大深度（栈中元素的最大深度个数），而栈的最大深度由被遍历的二叉树的高度决定。由于二叉树的高度可能达到O(n)，所以在最坏情况下，算法的空间复杂度为O(n)，n个结点的二叉树的平均高度为O(log n)，所以非递归前序遍历的平均空间复杂度为O(log n)。<br>在一些情况下，修改实现方法也可能降低空间的开销。对于上面函数，修改其定义，只把非空的右子树进栈，在很多情况下能减小一些空间开销。</p>\n<p>其他非递归的遍历算法，包括中序遍历和后续遍历算法以及层次遍历算法，都可以直接了当的修改成迭代器。但是递归算法不可以。</p>\n<h4 id=\"中序遍历\"><a href=\"#中序遍历\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 中序遍历（左根右）:模拟压栈过程</span></span><br><span class=\"line\"><span class=\"comment\"># 出栈之后读（左、根），这样出栈后指针变更再读右</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mid_deep_func2</span><span class=\"params\">(root)</span>:</span></span><br><span class=\"line\">    a = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> a <span class=\"keyword\">or</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> root:</span><br><span class=\"line\">            a.append(root)</span><br><span class=\"line\">            root = root.left</span><br><span class=\"line\">        h = a.pop()</span><br><span class=\"line\">        <span class=\"keyword\">print</span> h.value</span><br><span class=\"line\">        root = h.right</span><br></pre></td></tr></table></figure>\n<h4 id=\"后序遍历\"><a href=\"#后序遍历\" class=\"headerlink\" title=\"后序遍历\"></a>后序遍历</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 后序遍历（左右根）:模拟逆序(根右左)存入数组b，然后再数组b逆序输出</span></span><br><span class=\"line\"><span class=\"comment\"># (根右左)与(根左右)类似，入栈a前读（根、右），出栈后指针变更再读左</span></span><br><span class=\"line\"><span class=\"comment\">## 方法 1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">after_deep_func2</span><span class=\"params\">(root)</span>:</span></span><br><span class=\"line\">    a = []</span><br><span class=\"line\">    b = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> a <span class=\"keyword\">or</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> root:</span><br><span class=\"line\">            b.append(root.value)</span><br><span class=\"line\">            a.append(root.left)</span><br><span class=\"line\">            root = root.right</span><br><span class=\"line\">        root = a.pop()</span><br><span class=\"line\">    print(b[::<span class=\"number\">-1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 方法2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">after_deep_func2</span><span class=\"params\">(root)</span>:</span></span><br><span class=\"line\">    a = []</span><br><span class=\"line\">    b = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> a <span class=\"keyword\">or</span> root:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> root:</span><br><span class=\"line\">            b.append(root.value)</span><br><span class=\"line\">            a.append(root)</span><br><span class=\"line\">            root = root.right</span><br><span class=\"line\">        h = a.pop()</span><br><span class=\"line\">        root = h.left</span><br><span class=\"line\">    <span class=\"keyword\">print</span> b[::<span class=\"number\">-1</span>]</span><br></pre></td></tr></table></figure>\n<h2 id=\"广度优先遍历\"><a href=\"#广度优先遍历\" class=\"headerlink\" title=\"广度优先遍历\"></a>广度优先遍历</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">level_func</span><span class=\"params\">(root)</span>:</span></span><br><span class=\"line\">    a = []</span><br><span class=\"line\">    a.append(root)</span><br><span class=\"line\">    <span class=\"keyword\">while</span> a:</span><br><span class=\"line\">        head = a.pop(<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">print</span> head.value</span><br><span class=\"line\">        <span class=\"keyword\">if</span> head.left:</span><br><span class=\"line\">            a.append(head.left)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> head.right:</span><br><span class=\"line\">            a.append(head.right)</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"http://blog.csdn.net/su92chen/article/details/70242822\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/su92chen/article/details/70242822</a></li>\n<li>《数据结构与算法Python语言描述》 — 裘宗燕</li>\n</ol>"},{"title":"Python3 实现遍历目录与子目录，并抓取.py文件","date":"2018-03-12T08:54:54.000Z","_content":"\n```bash\ntree test\n.\n├── subtest1\n│   ├── subsubdir\n│   │   └── sub.py\n│   └── test1.py\n├── subtest2\n│   └── test2.py\n└── subtest3\n    └── test3.py\n```\n```python\n# 1. for-in dir/subdir to get the filesname  \n# 2. splitext filename to filter  \n\nimport os  \n\ndef getFiles(dir, suffix):  \n\n    res = []  \n    for root, directory, files in os.walk(dir):  \n        for filename in files:  \n            name, suf = os.path.splitext(filename)  \n            if suf == suffix:  \n                res.append(os.path.join(root, filename))  \n    return res  \n\nfor file in getFiles(\"./\", '.py'):  \n    print(file)\n# output:\n# ./walkdir.py\n# ./subtest2/test2.py\n# ./subtest3/test3.py\n# ./subtest1/test1.py\n# ./subtest1/subsubdir/sub.py\n\n```\n","source":"_posts/Python3-实现遍历目录与子目录，并抓取-py文件.md","raw":"---\ntitle: Python3 实现遍历目录与子目录，并抓取.py文件\ndate: 2018-03-12 16:54:54\ntags:\n  - Python3\ncategories:\n  - Python3 进阶\n---\n\n```bash\ntree test\n.\n├── subtest1\n│   ├── subsubdir\n│   │   └── sub.py\n│   └── test1.py\n├── subtest2\n│   └── test2.py\n└── subtest3\n    └── test3.py\n```\n```python\n# 1. for-in dir/subdir to get the filesname  \n# 2. splitext filename to filter  \n\nimport os  \n\ndef getFiles(dir, suffix):  \n\n    res = []  \n    for root, directory, files in os.walk(dir):  \n        for filename in files:  \n            name, suf = os.path.splitext(filename)  \n            if suf == suffix:  \n                res.append(os.path.join(root, filename))  \n    return res  \n\nfor file in getFiles(\"./\", '.py'):  \n    print(file)\n# output:\n# ./walkdir.py\n# ./subtest2/test2.py\n# ./subtest3/test3.py\n# ./subtest1/test1.py\n# ./subtest1/subsubdir/sub.py\n\n```\n","slug":"Python3-实现遍历目录与子目录，并抓取-py文件","published":1,"updated":"2018-03-12T09:04:15.759Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozlh00328motwclnq96n","content":"<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tree <span class=\"built_in\">test</span></span><br><span class=\"line\">.</span><br><span class=\"line\">├── subtest1</span><br><span class=\"line\">│   ├── subsubdir</span><br><span class=\"line\">│   │   └── sub.py</span><br><span class=\"line\">│   └── test1.py</span><br><span class=\"line\">├── subtest2</span><br><span class=\"line\">│   └── test2.py</span><br><span class=\"line\">└── subtest3</span><br><span class=\"line\">    └── test3.py</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. for-in dir/subdir to get the filesname  </span></span><br><span class=\"line\"><span class=\"comment\"># 2. splitext filename to filter  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> os  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getFiles</span><span class=\"params\">(dir, suffix)</span>:</span>  </span><br><span class=\"line\"></span><br><span class=\"line\">    res = []  </span><br><span class=\"line\">    <span class=\"keyword\">for</span> root, directory, files <span class=\"keyword\">in</span> os.walk(dir):  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> filename <span class=\"keyword\">in</span> files:  </span><br><span class=\"line\">            name, suf = os.path.splitext(filename)  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> suf == suffix:  </span><br><span class=\"line\">                res.append(os.path.join(root, filename))  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> res  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> file <span class=\"keyword\">in</span> getFiles(<span class=\"string\">\"./\"</span>, <span class=\"string\">'.py'</span>):  </span><br><span class=\"line\">    print(file)</span><br><span class=\"line\"><span class=\"comment\"># output:</span></span><br><span class=\"line\"><span class=\"comment\"># ./walkdir.py</span></span><br><span class=\"line\"><span class=\"comment\"># ./subtest2/test2.py</span></span><br><span class=\"line\"><span class=\"comment\"># ./subtest3/test3.py</span></span><br><span class=\"line\"><span class=\"comment\"># ./subtest1/test1.py</span></span><br><span class=\"line\"><span class=\"comment\"># ./subtest1/subsubdir/sub.py</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tree <span class=\"built_in\">test</span></span><br><span class=\"line\">.</span><br><span class=\"line\">├── subtest1</span><br><span class=\"line\">│   ├── subsubdir</span><br><span class=\"line\">│   │   └── sub.py</span><br><span class=\"line\">│   └── test1.py</span><br><span class=\"line\">├── subtest2</span><br><span class=\"line\">│   └── test2.py</span><br><span class=\"line\">└── subtest3</span><br><span class=\"line\">    └── test3.py</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 1. for-in dir/subdir to get the filesname  </span></span><br><span class=\"line\"><span class=\"comment\"># 2. splitext filename to filter  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> os  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getFiles</span><span class=\"params\">(dir, suffix)</span>:</span>  </span><br><span class=\"line\"></span><br><span class=\"line\">    res = []  </span><br><span class=\"line\">    <span class=\"keyword\">for</span> root, directory, files <span class=\"keyword\">in</span> os.walk(dir):  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> filename <span class=\"keyword\">in</span> files:  </span><br><span class=\"line\">            name, suf = os.path.splitext(filename)  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> suf == suffix:  </span><br><span class=\"line\">                res.append(os.path.join(root, filename))  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> res  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> file <span class=\"keyword\">in</span> getFiles(<span class=\"string\">\"./\"</span>, <span class=\"string\">'.py'</span>):  </span><br><span class=\"line\">    print(file)</span><br><span class=\"line\"><span class=\"comment\"># output:</span></span><br><span class=\"line\"><span class=\"comment\"># ./walkdir.py</span></span><br><span class=\"line\"><span class=\"comment\"># ./subtest2/test2.py</span></span><br><span class=\"line\"><span class=\"comment\"># ./subtest3/test3.py</span></span><br><span class=\"line\"><span class=\"comment\"># ./subtest1/test1.py</span></span><br><span class=\"line\"><span class=\"comment\"># ./subtest1/subsubdir/sub.py</span></span><br></pre></td></tr></table></figure>\n"},{"title":"Python3 实现常见的各种排序方法","date":"2018-03-09T07:56:09.000Z","_content":"\n## 快速排序\n快速排序的思路：\n1. 先从数列中取出一个数作为基准数。\n2. 分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边(假定从小到大排序)。\n3. 再对左右区间重复第二步，直到各区间只有一个数\n\n```Python\ndef quicksort(array):\n    \"\"\"快速排序\"\"\"\n    if len(array) < 2:  # 基线条件：为空或者只有一个元素的数组是有序的\n        return array\n    else:\n        pivot = array[0]  # 递归条件,基准值\n        less = [i for i in array[1:] if i <= pivot]  # 所有小于基准值的元素组成的子数组\n        greater = [i for i in array[1:] if i > pivot]  # 所有大于基准值的元素组成的子数组\n        return quicksort(less) + [pivot] + quicksort(greater)\n\nprint(quicksort([1,2,7,4,2,9,3]))\n```\n<!-- more -->\n![快速排序](http://upload-images.jianshu.io/upload_images/2952111-d52e0c914f7272a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![20170801013540271.gif](http://upload-images.jianshu.io/upload_images/2952111-03cf1024e51c6dee.gif?imageMogr2/auto-orient/strip)\n\n## 冒泡排序\n\n冒泡排序原理即：从数组下标为0的位置开始，比较下标位置为0和1的数据，如果0号位置的大，则交换位置，如果1号位置大，则什么也不做，然后右移一个位置，比较1号和2号的数据，和刚才的一样，如果1号的大，则交换位置，以此类推直至最后一个位置结束，到此数组中最大的元素就被排到了最后，之后再根据之前的步骤开始排前面的数据，直至全部数据都排序完成。\n\n就是传说中的大的沉到底原则，适用于小量数据\n\n冒泡排序思路: 每一趟只能将一个数归位, 如果有n个数进行排序,只需将n-1个数归位, 也就是说要进行n-1趟操作(已经归位的数不用再比较)\n\n缺点: 冒泡排序解决了桶排序浪费空间的问题, 但是冒泡排序的效率特别低\n![冒泡排序](http://upload-images.jianshu.io/upload_images/2952111-020fcd7b86279da7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```Python\ndef bubbleSort(relist):\n    \"\"\"冒泡排序\"\"\"\n    len_ = len(relist)\n    for i in range(len_ - 1):  # 这个循环负责设置冒泡排序进行的次数\n        for j in range(0,len_-i-1):\n            if relist[j] > relist[j+1]:\n                relist[j+1], relist[j] = relist[j], relist[j+1]\n    return relist\n\nprint(bubbleSort([1,5,2,6,9,3]))\n```\n![冒泡排序](http://upload-images.jianshu.io/upload_images/2952111-e421e0f31170cb93.gif?imageMogr2/auto-orient/strip)\n\n由上图看出最大的数一直沉到底部\n\n\n## 选择排序\n\n选择排序基本原理：\n1. 第1趟，在待排序记录r1 ~ r[n]中选出最小的记录，将它与r1交换；\n2. 第2趟，在待排序记录r2 ~ r[n]中选出最小的记录，将它与r2交换；\n3. 以此类推，第i趟在待排序记录r[i] ~ r[n]中选出最小的记录，将它与r[i]交换，使有序序列不断增长直到全部排序完毕。\n\n```Python\n# 方法一\ndef selectSort(relist):\n    len_ = len(relist)\n    for i in range(len_):\n        min_index = i\n        for j in range(i+1,len_):  # 这个循环会找到值比第i个索引所代表值小的索引\n            if relist[j] < relist[min_index]:\n                min_index = j\n        relist[i] ,relist[min_index] = relist[min_index], relist[i]  # 互换两个索引位置\n    return relist\n\nprint selectSort([1,5,2,6,9,3])\n\n# 方法二\ndef findSmallest(arr):\n    smallest = arr[0]\n    smallest_index = 0\n    for i in range(1, len(arr)):\n        if arr[i] < smallest:\n            smallest = arr[i]\n            smallest_index = i\n    return smallest_index\n\ndef selectionSort(arr):\n    newArr = []\n    for i in range(len(arr)):\n        smallest = findSmallest(arr)\n        newArr.append(arr.pop(smallest))\n    return newArr\n\nprint(selectionSort([5,3,7,2,1,8]))\n```\n\n![选择排序](http://upload-images.jianshu.io/upload_images/2952111-3b59aac6b772ddf0.gif?imageMogr2/auto-orient/strip)\n\n\n## 归并排序\n\n`所谓归并是指将若干个已排好序的部分合并成一个有序的部分。`\n\n假设我们有一个没有排好序的序列(14,12,15,13,11,16)，那么首先我们使用分割的办法将这个序列分割成一个个已经排好序的子序列。然后再利用归并的方法将一个个的子序列合并成排序好的序列。分割和归并的过程可以看下面的图例。这样通过先递归的分解数列，再合并数列就完成了归并排序。\n\n![MergeSort.jpg](https://upload-images.jianshu.io/upload_images/2952111-b7ca2aad908df253.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```Python\nimport math\ndef merge(left, right):\n    result = []\n    while left and right:\n        result.append(left.pop(0) if left[0] <= right[0] else right.pop(0))\n    while left:\n        result.append(left.pop(0))\n    while right:\n        result.append(right.pop(0))\n\n    return result\n\ndef mergeSort(relist):\n    if len(relist) <= 1:\n        return relist\n    mid_index = math.floor(len(relist)/2)\n    left = mergeSort(relist[:mid_index])  # 递归拆解的过程\n    right = mergeSort(relist[mid_index:])\n    return merge(left, right)  # 合并的过程\n\nprint(mergeSort([1,5,2,6,9,3]))\n\n```\n![归并排序](https://upload-images.jianshu.io/upload_images/2952111-8ee3d2a2a81eab80.gif?imageMogr2/auto-orient/strip)\n\n\n## 堆排序\n\n1. 创建最大堆:将堆所有数据重新排序，使其成为最大堆\n2. 最大堆调整:作用是保持最大堆的性质，是创建最大堆的核心子程序\n3. 堆排序:移除位在第一个数据的根节点，并做最大堆调整的递归运算\n\n![堆排序.png](https://upload-images.jianshu.io/upload_images/2952111-5903c9ca1e9a0473.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```Python\n# code from -http://blog.csdn.net/minxihou/article/details/51850001\nimport random\n\ndef MAX_Heapify(heap,HeapSize,root):#在堆中做结构调整使得父节点的值大于子节点\n\n    left = 2*root + 1\n    right = left + 1\n    larger = root\n    if left < HeapSize and heap[larger] < heap[left]:\n        larger = left\n    if right < HeapSize and heap[larger] < heap[right]:\n        larger = right\n    if larger != root:#如果做了堆调整则larger的值等于左节点或者右节点的，这个时候做对调值操作\n        heap[larger],heap[root] = heap[root],heap[larger]\n        MAX_Heapify(heap, HeapSize, larger)\n\ndef Build_MAX_Heap(heap):#构造一个堆，将堆中所有数据重新排序\n    HeapSize = len(heap)#将堆的长度当独拿出来方便\n    for i in range((HeapSize -2)//2,-1,-1):#从后往前出数\n        MAX_Heapify(heap,HeapSize,i)\n\ndef HeapSort(heap):#将根节点取出与最后一位做对调，对前面len-1个节点继续进行对调整过程。\n    Build_MAX_Heap(heap)\n    for i in range(len(heap)-1,-1,-1):\n        heap[0],heap[i] = heap[i],heap[0]\n        MAX_Heapify(heap, i, 0)\n    return heap\n\nif __name__ == '__main__':\n    a = [30,50,57,77,62,78,94,80,84]\n    print(a)\n    HeapSort(a)\n    print(a)\n    b = [random.randint(1,1000) for i in range(1000)]\n    #print b\n    HeapSort(b)\n    print(b)\n\n\n```\n![堆排序.gif](https://upload-images.jianshu.io/upload_images/2952111-d80509464c38434d.gif?imageMogr2/auto-orient/strip)\n\n## 复杂度\n\n\n| 排序法 | 最差时间 | 平均时间复杂度 |稳定度|空间复杂度|\n| :--- | :------- | :------ |:------ |:------ |\n| 冒泡排序 | O(n^2) | O(n^2) |稳定|O(1)|\n| 快速排序 | O(n^2) | O(n*log n) |不稳定|O(log2n)~O(n)|\n| 选择排序 | O(n^2) | O(n^2) |不稳定|O(1)|\n| 二叉树排序 | O(n^2) | O(n*log n) |不一定|O(n)|\n| 插入排序 | O(n^2) | O(n^2) |稳定|O(1)|\n| 堆排序 | O(n*log n) | O(n*log n) |不稳定|O(1)|\n| 希尔排序 | O      | O           |不稳定|O(1)|\n| 归并排序 | O(n*log n)| O(n*log n) |稳定|?|\n\n## 参考\n1. http://blog.csdn.net/mrlevo520/article/details/77829204\n2. http://blog.csdn.net/minxihou/article/details/51850001\n","source":"_posts/Python3-实现常见的各种排序方法.md","raw":"---\ntitle: Python3 实现常见的各种排序方法\ndate: 2018-03-09 15:56:09\ntags:\n  - Python3\n  - Algorithm\n  - Data Structures\ncategories:\n  - Algorithm\n---\n\n## 快速排序\n快速排序的思路：\n1. 先从数列中取出一个数作为基准数。\n2. 分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边(假定从小到大排序)。\n3. 再对左右区间重复第二步，直到各区间只有一个数\n\n```Python\ndef quicksort(array):\n    \"\"\"快速排序\"\"\"\n    if len(array) < 2:  # 基线条件：为空或者只有一个元素的数组是有序的\n        return array\n    else:\n        pivot = array[0]  # 递归条件,基准值\n        less = [i for i in array[1:] if i <= pivot]  # 所有小于基准值的元素组成的子数组\n        greater = [i for i in array[1:] if i > pivot]  # 所有大于基准值的元素组成的子数组\n        return quicksort(less) + [pivot] + quicksort(greater)\n\nprint(quicksort([1,2,7,4,2,9,3]))\n```\n<!-- more -->\n![快速排序](http://upload-images.jianshu.io/upload_images/2952111-d52e0c914f7272a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![20170801013540271.gif](http://upload-images.jianshu.io/upload_images/2952111-03cf1024e51c6dee.gif?imageMogr2/auto-orient/strip)\n\n## 冒泡排序\n\n冒泡排序原理即：从数组下标为0的位置开始，比较下标位置为0和1的数据，如果0号位置的大，则交换位置，如果1号位置大，则什么也不做，然后右移一个位置，比较1号和2号的数据，和刚才的一样，如果1号的大，则交换位置，以此类推直至最后一个位置结束，到此数组中最大的元素就被排到了最后，之后再根据之前的步骤开始排前面的数据，直至全部数据都排序完成。\n\n就是传说中的大的沉到底原则，适用于小量数据\n\n冒泡排序思路: 每一趟只能将一个数归位, 如果有n个数进行排序,只需将n-1个数归位, 也就是说要进行n-1趟操作(已经归位的数不用再比较)\n\n缺点: 冒泡排序解决了桶排序浪费空间的问题, 但是冒泡排序的效率特别低\n![冒泡排序](http://upload-images.jianshu.io/upload_images/2952111-020fcd7b86279da7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```Python\ndef bubbleSort(relist):\n    \"\"\"冒泡排序\"\"\"\n    len_ = len(relist)\n    for i in range(len_ - 1):  # 这个循环负责设置冒泡排序进行的次数\n        for j in range(0,len_-i-1):\n            if relist[j] > relist[j+1]:\n                relist[j+1], relist[j] = relist[j], relist[j+1]\n    return relist\n\nprint(bubbleSort([1,5,2,6,9,3]))\n```\n![冒泡排序](http://upload-images.jianshu.io/upload_images/2952111-e421e0f31170cb93.gif?imageMogr2/auto-orient/strip)\n\n由上图看出最大的数一直沉到底部\n\n\n## 选择排序\n\n选择排序基本原理：\n1. 第1趟，在待排序记录r1 ~ r[n]中选出最小的记录，将它与r1交换；\n2. 第2趟，在待排序记录r2 ~ r[n]中选出最小的记录，将它与r2交换；\n3. 以此类推，第i趟在待排序记录r[i] ~ r[n]中选出最小的记录，将它与r[i]交换，使有序序列不断增长直到全部排序完毕。\n\n```Python\n# 方法一\ndef selectSort(relist):\n    len_ = len(relist)\n    for i in range(len_):\n        min_index = i\n        for j in range(i+1,len_):  # 这个循环会找到值比第i个索引所代表值小的索引\n            if relist[j] < relist[min_index]:\n                min_index = j\n        relist[i] ,relist[min_index] = relist[min_index], relist[i]  # 互换两个索引位置\n    return relist\n\nprint selectSort([1,5,2,6,9,3])\n\n# 方法二\ndef findSmallest(arr):\n    smallest = arr[0]\n    smallest_index = 0\n    for i in range(1, len(arr)):\n        if arr[i] < smallest:\n            smallest = arr[i]\n            smallest_index = i\n    return smallest_index\n\ndef selectionSort(arr):\n    newArr = []\n    for i in range(len(arr)):\n        smallest = findSmallest(arr)\n        newArr.append(arr.pop(smallest))\n    return newArr\n\nprint(selectionSort([5,3,7,2,1,8]))\n```\n\n![选择排序](http://upload-images.jianshu.io/upload_images/2952111-3b59aac6b772ddf0.gif?imageMogr2/auto-orient/strip)\n\n\n## 归并排序\n\n`所谓归并是指将若干个已排好序的部分合并成一个有序的部分。`\n\n假设我们有一个没有排好序的序列(14,12,15,13,11,16)，那么首先我们使用分割的办法将这个序列分割成一个个已经排好序的子序列。然后再利用归并的方法将一个个的子序列合并成排序好的序列。分割和归并的过程可以看下面的图例。这样通过先递归的分解数列，再合并数列就完成了归并排序。\n\n![MergeSort.jpg](https://upload-images.jianshu.io/upload_images/2952111-b7ca2aad908df253.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```Python\nimport math\ndef merge(left, right):\n    result = []\n    while left and right:\n        result.append(left.pop(0) if left[0] <= right[0] else right.pop(0))\n    while left:\n        result.append(left.pop(0))\n    while right:\n        result.append(right.pop(0))\n\n    return result\n\ndef mergeSort(relist):\n    if len(relist) <= 1:\n        return relist\n    mid_index = math.floor(len(relist)/2)\n    left = mergeSort(relist[:mid_index])  # 递归拆解的过程\n    right = mergeSort(relist[mid_index:])\n    return merge(left, right)  # 合并的过程\n\nprint(mergeSort([1,5,2,6,9,3]))\n\n```\n![归并排序](https://upload-images.jianshu.io/upload_images/2952111-8ee3d2a2a81eab80.gif?imageMogr2/auto-orient/strip)\n\n\n## 堆排序\n\n1. 创建最大堆:将堆所有数据重新排序，使其成为最大堆\n2. 最大堆调整:作用是保持最大堆的性质，是创建最大堆的核心子程序\n3. 堆排序:移除位在第一个数据的根节点，并做最大堆调整的递归运算\n\n![堆排序.png](https://upload-images.jianshu.io/upload_images/2952111-5903c9ca1e9a0473.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```Python\n# code from -http://blog.csdn.net/minxihou/article/details/51850001\nimport random\n\ndef MAX_Heapify(heap,HeapSize,root):#在堆中做结构调整使得父节点的值大于子节点\n\n    left = 2*root + 1\n    right = left + 1\n    larger = root\n    if left < HeapSize and heap[larger] < heap[left]:\n        larger = left\n    if right < HeapSize and heap[larger] < heap[right]:\n        larger = right\n    if larger != root:#如果做了堆调整则larger的值等于左节点或者右节点的，这个时候做对调值操作\n        heap[larger],heap[root] = heap[root],heap[larger]\n        MAX_Heapify(heap, HeapSize, larger)\n\ndef Build_MAX_Heap(heap):#构造一个堆，将堆中所有数据重新排序\n    HeapSize = len(heap)#将堆的长度当独拿出来方便\n    for i in range((HeapSize -2)//2,-1,-1):#从后往前出数\n        MAX_Heapify(heap,HeapSize,i)\n\ndef HeapSort(heap):#将根节点取出与最后一位做对调，对前面len-1个节点继续进行对调整过程。\n    Build_MAX_Heap(heap)\n    for i in range(len(heap)-1,-1,-1):\n        heap[0],heap[i] = heap[i],heap[0]\n        MAX_Heapify(heap, i, 0)\n    return heap\n\nif __name__ == '__main__':\n    a = [30,50,57,77,62,78,94,80,84]\n    print(a)\n    HeapSort(a)\n    print(a)\n    b = [random.randint(1,1000) for i in range(1000)]\n    #print b\n    HeapSort(b)\n    print(b)\n\n\n```\n![堆排序.gif](https://upload-images.jianshu.io/upload_images/2952111-d80509464c38434d.gif?imageMogr2/auto-orient/strip)\n\n## 复杂度\n\n\n| 排序法 | 最差时间 | 平均时间复杂度 |稳定度|空间复杂度|\n| :--- | :------- | :------ |:------ |:------ |\n| 冒泡排序 | O(n^2) | O(n^2) |稳定|O(1)|\n| 快速排序 | O(n^2) | O(n*log n) |不稳定|O(log2n)~O(n)|\n| 选择排序 | O(n^2) | O(n^2) |不稳定|O(1)|\n| 二叉树排序 | O(n^2) | O(n*log n) |不一定|O(n)|\n| 插入排序 | O(n^2) | O(n^2) |稳定|O(1)|\n| 堆排序 | O(n*log n) | O(n*log n) |不稳定|O(1)|\n| 希尔排序 | O      | O           |不稳定|O(1)|\n| 归并排序 | O(n*log n)| O(n*log n) |稳定|?|\n\n## 参考\n1. http://blog.csdn.net/mrlevo520/article/details/77829204\n2. http://blog.csdn.net/minxihou/article/details/51850001\n","slug":"Python3-实现常见的各种排序方法","published":1,"updated":"2018-03-19T14:16:30.068Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozlj00358mot3kjfp6vz","content":"<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><p>快速排序的思路：</p>\n<ol>\n<li>先从数列中取出一个数作为基准数。</li>\n<li>分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边(假定从小到大排序)。</li>\n<li>再对左右区间重复第二步，直到各区间只有一个数</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">quicksort</span><span class=\"params\">(array)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"快速排序\"\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(array) &lt; <span class=\"number\">2</span>:  <span class=\"comment\"># 基线条件：为空或者只有一个元素的数组是有序的</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> array</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        pivot = array[<span class=\"number\">0</span>]  <span class=\"comment\"># 递归条件,基准值</span></span><br><span class=\"line\">        less = [i <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> array[<span class=\"number\">1</span>:] <span class=\"keyword\">if</span> i &lt;= pivot]  <span class=\"comment\"># 所有小于基准值的元素组成的子数组</span></span><br><span class=\"line\">        greater = [i <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> array[<span class=\"number\">1</span>:] <span class=\"keyword\">if</span> i &gt; pivot]  <span class=\"comment\"># 所有大于基准值的元素组成的子数组</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> quicksort(less) + [pivot] + quicksort(greater)</span><br><span class=\"line\"></span><br><span class=\"line\">print(quicksort([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">7</span>,<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">9</span>,<span class=\"number\">3</span>]))</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-d52e0c914f7272a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"快速排序\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-03cf1024e51c6dee.gif?imageMogr2/auto-orient/strip\" alt=\"20170801013540271.gif\"></p>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><p>冒泡排序原理即：从数组下标为0的位置开始，比较下标位置为0和1的数据，如果0号位置的大，则交换位置，如果1号位置大，则什么也不做，然后右移一个位置，比较1号和2号的数据，和刚才的一样，如果1号的大，则交换位置，以此类推直至最后一个位置结束，到此数组中最大的元素就被排到了最后，之后再根据之前的步骤开始排前面的数据，直至全部数据都排序完成。</p>\n<p>就是传说中的大的沉到底原则，适用于小量数据</p>\n<p>冒泡排序思路: 每一趟只能将一个数归位, 如果有n个数进行排序,只需将n-1个数归位, 也就是说要进行n-1趟操作(已经归位的数不用再比较)</p>\n<p>缺点: 冒泡排序解决了桶排序浪费空间的问题, 但是冒泡排序的效率特别低<br><img src=\"http://upload-images.jianshu.io/upload_images/2952111-020fcd7b86279da7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"冒泡排序\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bubbleSort</span><span class=\"params\">(relist)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"冒泡排序\"\"\"</span></span><br><span class=\"line\">    len_ = len(relist)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len_ - <span class=\"number\">1</span>):  <span class=\"comment\"># 这个循环负责设置冒泡排序进行的次数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>,len_-i<span class=\"number\">-1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> relist[j] &gt; relist[j+<span class=\"number\">1</span>]:</span><br><span class=\"line\">                relist[j+<span class=\"number\">1</span>], relist[j] = relist[j], relist[j+<span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> relist</span><br><span class=\"line\"></span><br><span class=\"line\">print(bubbleSort([<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">2</span>,<span class=\"number\">6</span>,<span class=\"number\">9</span>,<span class=\"number\">3</span>]))</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-e421e0f31170cb93.gif?imageMogr2/auto-orient/strip\" alt=\"冒泡排序\"></p>\n<p>由上图看出最大的数一直沉到底部</p>\n<h2 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h2><p>选择排序基本原理：</p>\n<ol>\n<li>第1趟，在待排序记录r1 ~ r[n]中选出最小的记录，将它与r1交换；</li>\n<li>第2趟，在待排序记录r2 ~ r[n]中选出最小的记录，将它与r2交换；</li>\n<li>以此类推，第i趟在待排序记录r[i] ~ r[n]中选出最小的记录，将它与r[i]交换，使有序序列不断增长直到全部排序完毕。</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 方法一</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">selectSort</span><span class=\"params\">(relist)</span>:</span></span><br><span class=\"line\">    len_ = len(relist)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len_):</span><br><span class=\"line\">        min_index = i</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i+<span class=\"number\">1</span>,len_):  <span class=\"comment\"># 这个循环会找到值比第i个索引所代表值小的索引</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> relist[j] &lt; relist[min_index]:</span><br><span class=\"line\">                min_index = j</span><br><span class=\"line\">        relist[i] ,relist[min_index] = relist[min_index], relist[i]  <span class=\"comment\"># 互换两个索引位置</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> relist</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">print</span> selectSort([<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">2</span>,<span class=\"number\">6</span>,<span class=\"number\">9</span>,<span class=\"number\">3</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方法二</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findSmallest</span><span class=\"params\">(arr)</span>:</span></span><br><span class=\"line\">    smallest = arr[<span class=\"number\">0</span>]</span><br><span class=\"line\">    smallest_index = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(arr)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> arr[i] &lt; smallest:</span><br><span class=\"line\">            smallest = arr[i]</span><br><span class=\"line\">            smallest_index = i</span><br><span class=\"line\">    <span class=\"keyword\">return</span> smallest_index</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">selectionSort</span><span class=\"params\">(arr)</span>:</span></span><br><span class=\"line\">    newArr = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(arr)):</span><br><span class=\"line\">        smallest = findSmallest(arr)</span><br><span class=\"line\">        newArr.append(arr.pop(smallest))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newArr</span><br><span class=\"line\"></span><br><span class=\"line\">print(selectionSort([<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">7</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">8</span>]))</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-3b59aac6b772ddf0.gif?imageMogr2/auto-orient/strip\" alt=\"选择排序\"></p>\n<h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><p><code>所谓归并是指将若干个已排好序的部分合并成一个有序的部分。</code></p>\n<p>假设我们有一个没有排好序的序列(14,12,15,13,11,16)，那么首先我们使用分割的办法将这个序列分割成一个个已经排好序的子序列。然后再利用归并的方法将一个个的子序列合并成排序好的序列。分割和归并的过程可以看下面的图例。这样通过先递归的分解数列，再合并数列就完成了归并排序。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2952111-b7ca2aad908df253.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"MergeSort.jpg\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> math</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge</span><span class=\"params\">(left, right)</span>:</span></span><br><span class=\"line\">    result = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> left <span class=\"keyword\">and</span> right:</span><br><span class=\"line\">        result.append(left.pop(<span class=\"number\">0</span>) <span class=\"keyword\">if</span> left[<span class=\"number\">0</span>] &lt;= right[<span class=\"number\">0</span>] <span class=\"keyword\">else</span> right.pop(<span class=\"number\">0</span>))</span><br><span class=\"line\">    <span class=\"keyword\">while</span> left:</span><br><span class=\"line\">        result.append(left.pop(<span class=\"number\">0</span>))</span><br><span class=\"line\">    <span class=\"keyword\">while</span> right:</span><br><span class=\"line\">        result.append(right.pop(<span class=\"number\">0</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergeSort</span><span class=\"params\">(relist)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(relist) &lt;= <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> relist</span><br><span class=\"line\">    mid_index = math.floor(len(relist)/<span class=\"number\">2</span>)</span><br><span class=\"line\">    left = mergeSort(relist[:mid_index])  <span class=\"comment\"># 递归拆解的过程</span></span><br><span class=\"line\">    right = mergeSort(relist[mid_index:])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> merge(left, right)  <span class=\"comment\"># 合并的过程</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(mergeSort([<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">2</span>,<span class=\"number\">6</span>,<span class=\"number\">9</span>,<span class=\"number\">3</span>]))</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2952111-8ee3d2a2a81eab80.gif?imageMogr2/auto-orient/strip\" alt=\"归并排序\"></p>\n<h2 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h2><ol>\n<li>创建最大堆:将堆所有数据重新排序，使其成为最大堆</li>\n<li>最大堆调整:作用是保持最大堆的性质，是创建最大堆的核心子程序</li>\n<li>堆排序:移除位在第一个数据的根节点，并做最大堆调整的递归运算</li>\n</ol>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2952111-5903c9ca1e9a0473.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"堆排序.png\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># code from -http://blog.csdn.net/minxihou/article/details/51850001</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> random</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">MAX_Heapify</span><span class=\"params\">(heap,HeapSize,root)</span>:</span><span class=\"comment\">#在堆中做结构调整使得父节点的值大于子节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    left = <span class=\"number\">2</span>*root + <span class=\"number\">1</span></span><br><span class=\"line\">    right = left + <span class=\"number\">1</span></span><br><span class=\"line\">    larger = root</span><br><span class=\"line\">    <span class=\"keyword\">if</span> left &lt; HeapSize <span class=\"keyword\">and</span> heap[larger] &lt; heap[left]:</span><br><span class=\"line\">        larger = left</span><br><span class=\"line\">    <span class=\"keyword\">if</span> right &lt; HeapSize <span class=\"keyword\">and</span> heap[larger] &lt; heap[right]:</span><br><span class=\"line\">        larger = right</span><br><span class=\"line\">    <span class=\"keyword\">if</span> larger != root:<span class=\"comment\">#如果做了堆调整则larger的值等于左节点或者右节点的，这个时候做对调值操作</span></span><br><span class=\"line\">        heap[larger],heap[root] = heap[root],heap[larger]</span><br><span class=\"line\">        MAX_Heapify(heap, HeapSize, larger)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">Build_MAX_Heap</span><span class=\"params\">(heap)</span>:</span><span class=\"comment\">#构造一个堆，将堆中所有数据重新排序</span></span><br><span class=\"line\">    HeapSize = len(heap)<span class=\"comment\">#将堆的长度当独拿出来方便</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range((HeapSize <span class=\"number\">-2</span>)//<span class=\"number\">2</span>,<span class=\"number\">-1</span>,<span class=\"number\">-1</span>):<span class=\"comment\">#从后往前出数</span></span><br><span class=\"line\">        MAX_Heapify(heap,HeapSize,i)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">HeapSort</span><span class=\"params\">(heap)</span>:</span><span class=\"comment\">#将根节点取出与最后一位做对调，对前面len-1个节点继续进行对调整过程。</span></span><br><span class=\"line\">    Build_MAX_Heap(heap)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(heap)<span class=\"number\">-1</span>,<span class=\"number\">-1</span>,<span class=\"number\">-1</span>):</span><br><span class=\"line\">        heap[<span class=\"number\">0</span>],heap[i] = heap[i],heap[<span class=\"number\">0</span>]</span><br><span class=\"line\">        MAX_Heapify(heap, i, <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> heap</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    a = [<span class=\"number\">30</span>,<span class=\"number\">50</span>,<span class=\"number\">57</span>,<span class=\"number\">77</span>,<span class=\"number\">62</span>,<span class=\"number\">78</span>,<span class=\"number\">94</span>,<span class=\"number\">80</span>,<span class=\"number\">84</span>]</span><br><span class=\"line\">    print(a)</span><br><span class=\"line\">    HeapSort(a)</span><br><span class=\"line\">    print(a)</span><br><span class=\"line\">    b = [random.randint(<span class=\"number\">1</span>,<span class=\"number\">1000</span>) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1000</span>)]</span><br><span class=\"line\">    <span class=\"comment\">#print b</span></span><br><span class=\"line\">    HeapSort(b)</span><br><span class=\"line\">    print(b)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2952111-d80509464c38434d.gif?imageMogr2/auto-orient/strip\" alt=\"堆排序.gif\"></p>\n<h2 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">排序法</th>\n<th style=\"text-align:left\">最差时间</th>\n<th style=\"text-align:left\">平均时间复杂度</th>\n<th style=\"text-align:left\">稳定度</th>\n<th style=\"text-align:left\">空间复杂度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">冒泡排序</td>\n<td style=\"text-align:left\">O(n^2)</td>\n<td style=\"text-align:left\">O(n^2)</td>\n<td style=\"text-align:left\">稳定</td>\n<td style=\"text-align:left\">O(1)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">快速排序</td>\n<td style=\"text-align:left\">O(n^2)</td>\n<td style=\"text-align:left\">O(n*log n)</td>\n<td style=\"text-align:left\">不稳定</td>\n<td style=\"text-align:left\">O(log2n)~O(n)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">选择排序</td>\n<td style=\"text-align:left\">O(n^2)</td>\n<td style=\"text-align:left\">O(n^2)</td>\n<td style=\"text-align:left\">不稳定</td>\n<td style=\"text-align:left\">O(1)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">二叉树排序</td>\n<td style=\"text-align:left\">O(n^2)</td>\n<td style=\"text-align:left\">O(n*log n)</td>\n<td style=\"text-align:left\">不一定</td>\n<td style=\"text-align:left\">O(n)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">插入排序</td>\n<td style=\"text-align:left\">O(n^2)</td>\n<td style=\"text-align:left\">O(n^2)</td>\n<td style=\"text-align:left\">稳定</td>\n<td style=\"text-align:left\">O(1)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">堆排序</td>\n<td style=\"text-align:left\">O(n*log n)</td>\n<td style=\"text-align:left\">O(n*log n)</td>\n<td style=\"text-align:left\">不稳定</td>\n<td style=\"text-align:left\">O(1)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">希尔排序</td>\n<td style=\"text-align:left\">O</td>\n<td style=\"text-align:left\">O</td>\n<td style=\"text-align:left\">不稳定</td>\n<td style=\"text-align:left\">O(1)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">归并排序</td>\n<td style=\"text-align:left\">O(n*log n)</td>\n<td style=\"text-align:left\">O(n*log n)</td>\n<td style=\"text-align:left\">稳定</td>\n<td style=\"text-align:left\">?</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"http://blog.csdn.net/mrlevo520/article/details/77829204\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/mrlevo520/article/details/77829204</a></li>\n<li><a href=\"http://blog.csdn.net/minxihou/article/details/51850001\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/minxihou/article/details/51850001</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><p>快速排序的思路：</p>\n<ol>\n<li>先从数列中取出一个数作为基准数。</li>\n<li>分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边(假定从小到大排序)。</li>\n<li>再对左右区间重复第二步，直到各区间只有一个数</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">quicksort</span><span class=\"params\">(array)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"快速排序\"\"\"</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(array) &lt; <span class=\"number\">2</span>:  <span class=\"comment\"># 基线条件：为空或者只有一个元素的数组是有序的</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> array</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        pivot = array[<span class=\"number\">0</span>]  <span class=\"comment\"># 递归条件,基准值</span></span><br><span class=\"line\">        less = [i <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> array[<span class=\"number\">1</span>:] <span class=\"keyword\">if</span> i &lt;= pivot]  <span class=\"comment\"># 所有小于基准值的元素组成的子数组</span></span><br><span class=\"line\">        greater = [i <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> array[<span class=\"number\">1</span>:] <span class=\"keyword\">if</span> i &gt; pivot]  <span class=\"comment\"># 所有大于基准值的元素组成的子数组</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> quicksort(less) + [pivot] + quicksort(greater)</span><br><span class=\"line\"></span><br><span class=\"line\">print(quicksort([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">7</span>,<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">9</span>,<span class=\"number\">3</span>]))</span><br></pre></td></tr></table></figure>","more":"<p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-d52e0c914f7272a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"快速排序\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-03cf1024e51c6dee.gif?imageMogr2/auto-orient/strip\" alt=\"20170801013540271.gif\"></p>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><p>冒泡排序原理即：从数组下标为0的位置开始，比较下标位置为0和1的数据，如果0号位置的大，则交换位置，如果1号位置大，则什么也不做，然后右移一个位置，比较1号和2号的数据，和刚才的一样，如果1号的大，则交换位置，以此类推直至最后一个位置结束，到此数组中最大的元素就被排到了最后，之后再根据之前的步骤开始排前面的数据，直至全部数据都排序完成。</p>\n<p>就是传说中的大的沉到底原则，适用于小量数据</p>\n<p>冒泡排序思路: 每一趟只能将一个数归位, 如果有n个数进行排序,只需将n-1个数归位, 也就是说要进行n-1趟操作(已经归位的数不用再比较)</p>\n<p>缺点: 冒泡排序解决了桶排序浪费空间的问题, 但是冒泡排序的效率特别低<br><img src=\"http://upload-images.jianshu.io/upload_images/2952111-020fcd7b86279da7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"冒泡排序\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bubbleSort</span><span class=\"params\">(relist)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"冒泡排序\"\"\"</span></span><br><span class=\"line\">    len_ = len(relist)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len_ - <span class=\"number\">1</span>):  <span class=\"comment\"># 这个循环负责设置冒泡排序进行的次数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>,len_-i<span class=\"number\">-1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> relist[j] &gt; relist[j+<span class=\"number\">1</span>]:</span><br><span class=\"line\">                relist[j+<span class=\"number\">1</span>], relist[j] = relist[j], relist[j+<span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> relist</span><br><span class=\"line\"></span><br><span class=\"line\">print(bubbleSort([<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">2</span>,<span class=\"number\">6</span>,<span class=\"number\">9</span>,<span class=\"number\">3</span>]))</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-e421e0f31170cb93.gif?imageMogr2/auto-orient/strip\" alt=\"冒泡排序\"></p>\n<p>由上图看出最大的数一直沉到底部</p>\n<h2 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h2><p>选择排序基本原理：</p>\n<ol>\n<li>第1趟，在待排序记录r1 ~ r[n]中选出最小的记录，将它与r1交换；</li>\n<li>第2趟，在待排序记录r2 ~ r[n]中选出最小的记录，将它与r2交换；</li>\n<li>以此类推，第i趟在待排序记录r[i] ~ r[n]中选出最小的记录，将它与r[i]交换，使有序序列不断增长直到全部排序完毕。</li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 方法一</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">selectSort</span><span class=\"params\">(relist)</span>:</span></span><br><span class=\"line\">    len_ = len(relist)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len_):</span><br><span class=\"line\">        min_index = i</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i+<span class=\"number\">1</span>,len_):  <span class=\"comment\"># 这个循环会找到值比第i个索引所代表值小的索引</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> relist[j] &lt; relist[min_index]:</span><br><span class=\"line\">                min_index = j</span><br><span class=\"line\">        relist[i] ,relist[min_index] = relist[min_index], relist[i]  <span class=\"comment\"># 互换两个索引位置</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> relist</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">print</span> selectSort([<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">2</span>,<span class=\"number\">6</span>,<span class=\"number\">9</span>,<span class=\"number\">3</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方法二</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">findSmallest</span><span class=\"params\">(arr)</span>:</span></span><br><span class=\"line\">    smallest = arr[<span class=\"number\">0</span>]</span><br><span class=\"line\">    smallest_index = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(arr)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> arr[i] &lt; smallest:</span><br><span class=\"line\">            smallest = arr[i]</span><br><span class=\"line\">            smallest_index = i</span><br><span class=\"line\">    <span class=\"keyword\">return</span> smallest_index</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">selectionSort</span><span class=\"params\">(arr)</span>:</span></span><br><span class=\"line\">    newArr = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(arr)):</span><br><span class=\"line\">        smallest = findSmallest(arr)</span><br><span class=\"line\">        newArr.append(arr.pop(smallest))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newArr</span><br><span class=\"line\"></span><br><span class=\"line\">print(selectionSort([<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">7</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">8</span>]))</span><br></pre></td></tr></table></figure>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-3b59aac6b772ddf0.gif?imageMogr2/auto-orient/strip\" alt=\"选择排序\"></p>\n<h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><p><code>所谓归并是指将若干个已排好序的部分合并成一个有序的部分。</code></p>\n<p>假设我们有一个没有排好序的序列(14,12,15,13,11,16)，那么首先我们使用分割的办法将这个序列分割成一个个已经排好序的子序列。然后再利用归并的方法将一个个的子序列合并成排序好的序列。分割和归并的过程可以看下面的图例。这样通过先递归的分解数列，再合并数列就完成了归并排序。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2952111-b7ca2aad908df253.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"MergeSort.jpg\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> math</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge</span><span class=\"params\">(left, right)</span>:</span></span><br><span class=\"line\">    result = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> left <span class=\"keyword\">and</span> right:</span><br><span class=\"line\">        result.append(left.pop(<span class=\"number\">0</span>) <span class=\"keyword\">if</span> left[<span class=\"number\">0</span>] &lt;= right[<span class=\"number\">0</span>] <span class=\"keyword\">else</span> right.pop(<span class=\"number\">0</span>))</span><br><span class=\"line\">    <span class=\"keyword\">while</span> left:</span><br><span class=\"line\">        result.append(left.pop(<span class=\"number\">0</span>))</span><br><span class=\"line\">    <span class=\"keyword\">while</span> right:</span><br><span class=\"line\">        result.append(right.pop(<span class=\"number\">0</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mergeSort</span><span class=\"params\">(relist)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(relist) &lt;= <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> relist</span><br><span class=\"line\">    mid_index = math.floor(len(relist)/<span class=\"number\">2</span>)</span><br><span class=\"line\">    left = mergeSort(relist[:mid_index])  <span class=\"comment\"># 递归拆解的过程</span></span><br><span class=\"line\">    right = mergeSort(relist[mid_index:])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> merge(left, right)  <span class=\"comment\"># 合并的过程</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(mergeSort([<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">2</span>,<span class=\"number\">6</span>,<span class=\"number\">9</span>,<span class=\"number\">3</span>]))</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2952111-8ee3d2a2a81eab80.gif?imageMogr2/auto-orient/strip\" alt=\"归并排序\"></p>\n<h2 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h2><ol>\n<li>创建最大堆:将堆所有数据重新排序，使其成为最大堆</li>\n<li>最大堆调整:作用是保持最大堆的性质，是创建最大堆的核心子程序</li>\n<li>堆排序:移除位在第一个数据的根节点，并做最大堆调整的递归运算</li>\n</ol>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2952111-5903c9ca1e9a0473.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"堆排序.png\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># code from -http://blog.csdn.net/minxihou/article/details/51850001</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> random</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">MAX_Heapify</span><span class=\"params\">(heap,HeapSize,root)</span>:</span><span class=\"comment\">#在堆中做结构调整使得父节点的值大于子节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">    left = <span class=\"number\">2</span>*root + <span class=\"number\">1</span></span><br><span class=\"line\">    right = left + <span class=\"number\">1</span></span><br><span class=\"line\">    larger = root</span><br><span class=\"line\">    <span class=\"keyword\">if</span> left &lt; HeapSize <span class=\"keyword\">and</span> heap[larger] &lt; heap[left]:</span><br><span class=\"line\">        larger = left</span><br><span class=\"line\">    <span class=\"keyword\">if</span> right &lt; HeapSize <span class=\"keyword\">and</span> heap[larger] &lt; heap[right]:</span><br><span class=\"line\">        larger = right</span><br><span class=\"line\">    <span class=\"keyword\">if</span> larger != root:<span class=\"comment\">#如果做了堆调整则larger的值等于左节点或者右节点的，这个时候做对调值操作</span></span><br><span class=\"line\">        heap[larger],heap[root] = heap[root],heap[larger]</span><br><span class=\"line\">        MAX_Heapify(heap, HeapSize, larger)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">Build_MAX_Heap</span><span class=\"params\">(heap)</span>:</span><span class=\"comment\">#构造一个堆，将堆中所有数据重新排序</span></span><br><span class=\"line\">    HeapSize = len(heap)<span class=\"comment\">#将堆的长度当独拿出来方便</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range((HeapSize <span class=\"number\">-2</span>)//<span class=\"number\">2</span>,<span class=\"number\">-1</span>,<span class=\"number\">-1</span>):<span class=\"comment\">#从后往前出数</span></span><br><span class=\"line\">        MAX_Heapify(heap,HeapSize,i)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">HeapSort</span><span class=\"params\">(heap)</span>:</span><span class=\"comment\">#将根节点取出与最后一位做对调，对前面len-1个节点继续进行对调整过程。</span></span><br><span class=\"line\">    Build_MAX_Heap(heap)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(heap)<span class=\"number\">-1</span>,<span class=\"number\">-1</span>,<span class=\"number\">-1</span>):</span><br><span class=\"line\">        heap[<span class=\"number\">0</span>],heap[i] = heap[i],heap[<span class=\"number\">0</span>]</span><br><span class=\"line\">        MAX_Heapify(heap, i, <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> heap</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    a = [<span class=\"number\">30</span>,<span class=\"number\">50</span>,<span class=\"number\">57</span>,<span class=\"number\">77</span>,<span class=\"number\">62</span>,<span class=\"number\">78</span>,<span class=\"number\">94</span>,<span class=\"number\">80</span>,<span class=\"number\">84</span>]</span><br><span class=\"line\">    print(a)</span><br><span class=\"line\">    HeapSort(a)</span><br><span class=\"line\">    print(a)</span><br><span class=\"line\">    b = [random.randint(<span class=\"number\">1</span>,<span class=\"number\">1000</span>) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1000</span>)]</span><br><span class=\"line\">    <span class=\"comment\">#print b</span></span><br><span class=\"line\">    HeapSort(b)</span><br><span class=\"line\">    print(b)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2952111-d80509464c38434d.gif?imageMogr2/auto-orient/strip\" alt=\"堆排序.gif\"></p>\n<h2 id=\"复杂度\"><a href=\"#复杂度\" class=\"headerlink\" title=\"复杂度\"></a>复杂度</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">排序法</th>\n<th style=\"text-align:left\">最差时间</th>\n<th style=\"text-align:left\">平均时间复杂度</th>\n<th style=\"text-align:left\">稳定度</th>\n<th style=\"text-align:left\">空间复杂度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">冒泡排序</td>\n<td style=\"text-align:left\">O(n^2)</td>\n<td style=\"text-align:left\">O(n^2)</td>\n<td style=\"text-align:left\">稳定</td>\n<td style=\"text-align:left\">O(1)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">快速排序</td>\n<td style=\"text-align:left\">O(n^2)</td>\n<td style=\"text-align:left\">O(n*log n)</td>\n<td style=\"text-align:left\">不稳定</td>\n<td style=\"text-align:left\">O(log2n)~O(n)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">选择排序</td>\n<td style=\"text-align:left\">O(n^2)</td>\n<td style=\"text-align:left\">O(n^2)</td>\n<td style=\"text-align:left\">不稳定</td>\n<td style=\"text-align:left\">O(1)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">二叉树排序</td>\n<td style=\"text-align:left\">O(n^2)</td>\n<td style=\"text-align:left\">O(n*log n)</td>\n<td style=\"text-align:left\">不一定</td>\n<td style=\"text-align:left\">O(n)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">插入排序</td>\n<td style=\"text-align:left\">O(n^2)</td>\n<td style=\"text-align:left\">O(n^2)</td>\n<td style=\"text-align:left\">稳定</td>\n<td style=\"text-align:left\">O(1)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">堆排序</td>\n<td style=\"text-align:left\">O(n*log n)</td>\n<td style=\"text-align:left\">O(n*log n)</td>\n<td style=\"text-align:left\">不稳定</td>\n<td style=\"text-align:left\">O(1)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">希尔排序</td>\n<td style=\"text-align:left\">O</td>\n<td style=\"text-align:left\">O</td>\n<td style=\"text-align:left\">不稳定</td>\n<td style=\"text-align:left\">O(1)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">归并排序</td>\n<td style=\"text-align:left\">O(n*log n)</td>\n<td style=\"text-align:left\">O(n*log n)</td>\n<td style=\"text-align:left\">稳定</td>\n<td style=\"text-align:left\">?</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"http://blog.csdn.net/mrlevo520/article/details/77829204\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/mrlevo520/article/details/77829204</a></li>\n<li><a href=\"http://blog.csdn.net/minxihou/article/details/51850001\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/minxihou/article/details/51850001</a></li>\n</ol>"},{"title":"Python3 对象操作的时间复杂度总结","date":"2018-03-29T11:27:04.000Z","_content":"## 列表 list\n列表是以数组（Array）实现的。最大的开销发生在超过当前分配大小的增长，这种情况下所有元素都需要移动；或者是在起始位置附近插入或者删除元素，这种情况下所有在该位置后面的元素都需要移动，这种情况可以考虑使用双向队列来解决。\n\n| Operation                                                    | Average Case | [Amortized Worst Case](http://en.wikipedia.org/wiki/Amortized_analysis) |\n| ------------------------------------------------------------ | ------------ | ------------------------------------------------------------ |\n| Copy                                                         | O(n)         | O(n)                                                         |\n| Append[1]                                                    | O(1)         | O(1)                                                         |\n| Pop last                                                     | O(1)         | O(1)                                                         |\n| Pop intermediate                                             | O(k)         | O(k)                                                         |\n| Insert                                                       | O(n)         | O(n)                                                         |\n| Get Item                                                     | O(1)         | O(1)                                                         |\n| Set Item                                                     | O(1)         | O(1)                                                         |\n| Delete Item                                                  | O(n)         | O(n)                                                         |\n| Iteration                                                    | O(n)         | O(n)                                                         |\n| Get Slice                                                    | O(k)         | O(k)                                                         |\n| Del Slice                                                    | O(n)         | O(n)                                                         |\n| Set Slice                                                    | O(k+n)       | O(k+n)                                                       |\n| Extend[1]                                                    | O(k)         | O(k)                                                         |\n| [Sort](http://svn.python.org/projects/python/trunk/Objects/listsort.txt) | O(n log n)   | O(n log n)                                                   |\n| Multiply                                                     | O(nk)        | O(nk)                                                        |\n| x in s                                                       | O(n)         |                                                              |\n| min(s), max(s)                                               | O(n)         |                                                              |\n| Get Length                                                   | O(1)         | O(1)                                                         |\n\n<!-- more -->\n## 双向队列 collections.deque\n\ndeque是以双向链表的形式实现的。双向队列的两端都是可达的，但从查找队列中间的元素较为缓慢，增删元素就更慢了。\n\n|  **操作**  | **平均情况** | **最坏情况** |\n| :--------: | :----------: | :----------: |\n|    复制    |     O(n)     |     O(n)     |\n|   append   |     O(1)     |     O(1)     |\n| appendleft |     O(1)     |     O(1)     |\n|    pop     |     O(1)     |     O(1)     |\n|  popleft   |     O(1)     |     O(1)     |\n|   extend   |     O(k)     |     O(k)     |\n| extendleft |     O(k)     |     O(k)     |\n|   rotate   |     O(k)     |     O(k)     |\n|   remove   |     O(n)     |     O(n)     |\n\n\n## 集合 set\n| **Operation**                     | **Average case**                                             | **Worst Case**                                | **notes**                                  |\n| --------------------------------- | ------------------------------------------------------------ | --------------------------------------------- | ------------------------------------------ |\n| x in s                            | O(1)                                                         | O(n)                                          |                                            |\n| Union s\\|t                        | [O(len(s)+len(t))](https://wiki.python.org/moin/TimeComplexity_%28SetCode%29) |                                               |                                            |\n| Intersection s&t                  | O(min(len(s), len(t))                                        | O(len(s) * len(t))                            | replace \"min\" with \"max\" if t is not a set |\n| Multiple intersection s1&s2&..&sn |                                                              | (n-1)*O(l) where l is max(len(s1),..,len(sn)) |                                            |\n| Difference s-t                    | O(len(s))                                                    |                                               |                                            |\n| s.difference_update(t)            | O(len(t))                                                    |                                               |                                            |\n| Symmetric Difference s^t          | O(len(s))                                                    | O(len(s) * len(t))                            |                                            |\n| s.symmetric_difference_update(t)  | O(len(t))                                                    | O(len(t) * len(s))                            |                                            |\n\n## 字典 dict\n字典的平均情况基于以下假设：\n1. 对象的散列函数足够撸棒（robust），不会发生冲突。\n2. 字典的键是从所有可能的键的集合中随机选择的。\n\n| **Operation** | **Average Case** | **Amortized Worst Case** |\n| ------------- | ---------------- | ------------------------ |\n| Copy[2]       | O(n)             | O(n)                     |\n| Get Item      | O(1)             | O(n)                     |\n| Set Item[1]   | O(1)             | O(n)                     |\n| Delete Item   | O(1)             | O(n)                     |\n| Iteration[2]  | O(n)             | O(n)                     |\n\n\n## 参考\n1. https://wiki.python.org/moin/TimeComplexity\n","source":"_posts/Python3-对象操作的时间复杂度总结.md","raw":"---\ntitle: Python3 对象操作的时间复杂度总结\ndate: 2018-03-29 19:27:04\ntags:\n  - Python3\n  - Algorithm\ncategories:\n  - Python3 进阶\n---\n## 列表 list\n列表是以数组（Array）实现的。最大的开销发生在超过当前分配大小的增长，这种情况下所有元素都需要移动；或者是在起始位置附近插入或者删除元素，这种情况下所有在该位置后面的元素都需要移动，这种情况可以考虑使用双向队列来解决。\n\n| Operation                                                    | Average Case | [Amortized Worst Case](http://en.wikipedia.org/wiki/Amortized_analysis) |\n| ------------------------------------------------------------ | ------------ | ------------------------------------------------------------ |\n| Copy                                                         | O(n)         | O(n)                                                         |\n| Append[1]                                                    | O(1)         | O(1)                                                         |\n| Pop last                                                     | O(1)         | O(1)                                                         |\n| Pop intermediate                                             | O(k)         | O(k)                                                         |\n| Insert                                                       | O(n)         | O(n)                                                         |\n| Get Item                                                     | O(1)         | O(1)                                                         |\n| Set Item                                                     | O(1)         | O(1)                                                         |\n| Delete Item                                                  | O(n)         | O(n)                                                         |\n| Iteration                                                    | O(n)         | O(n)                                                         |\n| Get Slice                                                    | O(k)         | O(k)                                                         |\n| Del Slice                                                    | O(n)         | O(n)                                                         |\n| Set Slice                                                    | O(k+n)       | O(k+n)                                                       |\n| Extend[1]                                                    | O(k)         | O(k)                                                         |\n| [Sort](http://svn.python.org/projects/python/trunk/Objects/listsort.txt) | O(n log n)   | O(n log n)                                                   |\n| Multiply                                                     | O(nk)        | O(nk)                                                        |\n| x in s                                                       | O(n)         |                                                              |\n| min(s), max(s)                                               | O(n)         |                                                              |\n| Get Length                                                   | O(1)         | O(1)                                                         |\n\n<!-- more -->\n## 双向队列 collections.deque\n\ndeque是以双向链表的形式实现的。双向队列的两端都是可达的，但从查找队列中间的元素较为缓慢，增删元素就更慢了。\n\n|  **操作**  | **平均情况** | **最坏情况** |\n| :--------: | :----------: | :----------: |\n|    复制    |     O(n)     |     O(n)     |\n|   append   |     O(1)     |     O(1)     |\n| appendleft |     O(1)     |     O(1)     |\n|    pop     |     O(1)     |     O(1)     |\n|  popleft   |     O(1)     |     O(1)     |\n|   extend   |     O(k)     |     O(k)     |\n| extendleft |     O(k)     |     O(k)     |\n|   rotate   |     O(k)     |     O(k)     |\n|   remove   |     O(n)     |     O(n)     |\n\n\n## 集合 set\n| **Operation**                     | **Average case**                                             | **Worst Case**                                | **notes**                                  |\n| --------------------------------- | ------------------------------------------------------------ | --------------------------------------------- | ------------------------------------------ |\n| x in s                            | O(1)                                                         | O(n)                                          |                                            |\n| Union s\\|t                        | [O(len(s)+len(t))](https://wiki.python.org/moin/TimeComplexity_%28SetCode%29) |                                               |                                            |\n| Intersection s&t                  | O(min(len(s), len(t))                                        | O(len(s) * len(t))                            | replace \"min\" with \"max\" if t is not a set |\n| Multiple intersection s1&s2&..&sn |                                                              | (n-1)*O(l) where l is max(len(s1),..,len(sn)) |                                            |\n| Difference s-t                    | O(len(s))                                                    |                                               |                                            |\n| s.difference_update(t)            | O(len(t))                                                    |                                               |                                            |\n| Symmetric Difference s^t          | O(len(s))                                                    | O(len(s) * len(t))                            |                                            |\n| s.symmetric_difference_update(t)  | O(len(t))                                                    | O(len(t) * len(s))                            |                                            |\n\n## 字典 dict\n字典的平均情况基于以下假设：\n1. 对象的散列函数足够撸棒（robust），不会发生冲突。\n2. 字典的键是从所有可能的键的集合中随机选择的。\n\n| **Operation** | **Average Case** | **Amortized Worst Case** |\n| ------------- | ---------------- | ------------------------ |\n| Copy[2]       | O(n)             | O(n)                     |\n| Get Item      | O(1)             | O(n)                     |\n| Set Item[1]   | O(1)             | O(n)                     |\n| Delete Item   | O(1)             | O(n)                     |\n| Iteration[2]  | O(n)             | O(n)                     |\n\n\n## 参考\n1. https://wiki.python.org/moin/TimeComplexity\n","slug":"Python3-对象操作的时间复杂度总结","published":1,"updated":"2018-03-29T12:11:59.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozlm003a8motw5c5aydo","content":"<h2 id=\"列表-list\"><a href=\"#列表-list\" class=\"headerlink\" title=\"列表 list\"></a>列表 list</h2><p>列表是以数组（Array）实现的。最大的开销发生在超过当前分配大小的增长，这种情况下所有元素都需要移动；或者是在起始位置附近插入或者删除元素，这种情况下所有在该位置后面的元素都需要移动，这种情况可以考虑使用双向队列来解决。</p>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Average Case</th>\n<th><a href=\"http://en.wikipedia.org/wiki/Amortized_analysis\" target=\"_blank\" rel=\"noopener\">Amortized Worst Case</a></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Copy</td>\n<td>O(n)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>Append[1]</td>\n<td>O(1)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>Pop last</td>\n<td>O(1)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>Pop intermediate</td>\n<td>O(k)</td>\n<td>O(k)</td>\n</tr>\n<tr>\n<td>Insert</td>\n<td>O(n)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>Get Item</td>\n<td>O(1)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>Set Item</td>\n<td>O(1)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>Delete Item</td>\n<td>O(n)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>Iteration</td>\n<td>O(n)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>Get Slice</td>\n<td>O(k)</td>\n<td>O(k)</td>\n</tr>\n<tr>\n<td>Del Slice</td>\n<td>O(n)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>Set Slice</td>\n<td>O(k+n)</td>\n<td>O(k+n)</td>\n</tr>\n<tr>\n<td>Extend[1]</td>\n<td>O(k)</td>\n<td>O(k)</td>\n</tr>\n<tr>\n<td><a href=\"http://svn.python.org/projects/python/trunk/Objects/listsort.txt\" target=\"_blank\" rel=\"noopener\">Sort</a></td>\n<td>O(n log n)</td>\n<td>O(n log n)</td>\n</tr>\n<tr>\n<td>Multiply</td>\n<td>O(nk)</td>\n<td>O(nk)</td>\n</tr>\n<tr>\n<td>x in s</td>\n<td>O(n)</td>\n<td></td>\n</tr>\n<tr>\n<td>min(s), max(s)</td>\n<td>O(n)</td>\n<td></td>\n</tr>\n<tr>\n<td>Get Length</td>\n<td>O(1)</td>\n<td>O(1)</td>\n</tr>\n</tbody>\n</table>\n<a id=\"more\"></a>\n<h2 id=\"双向队列-collections-deque\"><a href=\"#双向队列-collections-deque\" class=\"headerlink\" title=\"双向队列 collections.deque\"></a>双向队列 collections.deque</h2><p>deque是以双向链表的形式实现的。双向队列的两端都是可达的，但从查找队列中间的元素较为缓慢，增删元素就更慢了。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><strong>操作</strong></th>\n<th style=\"text-align:center\"><strong>平均情况</strong></th>\n<th style=\"text-align:center\"><strong>最坏情况</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">复制</td>\n<td style=\"text-align:center\">O(n)</td>\n<td style=\"text-align:center\">O(n)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">append</td>\n<td style=\"text-align:center\">O(1)</td>\n<td style=\"text-align:center\">O(1)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">appendleft</td>\n<td style=\"text-align:center\">O(1)</td>\n<td style=\"text-align:center\">O(1)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">pop</td>\n<td style=\"text-align:center\">O(1)</td>\n<td style=\"text-align:center\">O(1)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">popleft</td>\n<td style=\"text-align:center\">O(1)</td>\n<td style=\"text-align:center\">O(1)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">extend</td>\n<td style=\"text-align:center\">O(k)</td>\n<td style=\"text-align:center\">O(k)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">extendleft</td>\n<td style=\"text-align:center\">O(k)</td>\n<td style=\"text-align:center\">O(k)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">rotate</td>\n<td style=\"text-align:center\">O(k)</td>\n<td style=\"text-align:center\">O(k)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">remove</td>\n<td style=\"text-align:center\">O(n)</td>\n<td style=\"text-align:center\">O(n)</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"集合-set\"><a href=\"#集合-set\" class=\"headerlink\" title=\"集合 set\"></a>集合 set</h2><table>\n<thead>\n<tr>\n<th><strong>Operation</strong></th>\n<th><strong>Average case</strong></th>\n<th><strong>Worst Case</strong></th>\n<th><strong>notes</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>x in s</td>\n<td>O(1)</td>\n<td>O(n)</td>\n<td></td>\n</tr>\n<tr>\n<td>Union s\\</td>\n<td>t</td>\n<td><a href=\"https://wiki.python.org/moin/TimeComplexity_%28SetCode%29\" target=\"_blank\" rel=\"noopener\">O(len(s)+len(t))</a></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Intersection s&amp;t</td>\n<td>O(min(len(s), len(t))</td>\n<td>O(len(s) * len(t))</td>\n<td>replace “min” with “max” if t is not a set</td>\n</tr>\n<tr>\n<td>Multiple intersection s1&amp;s2&amp;..&amp;sn</td>\n<td></td>\n<td>(n-1)*O(l) where l is max(len(s1),..,len(sn))</td>\n<td></td>\n</tr>\n<tr>\n<td>Difference s-t</td>\n<td>O(len(s))</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>s.difference_update(t)</td>\n<td>O(len(t))</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Symmetric Difference s^t</td>\n<td>O(len(s))</td>\n<td>O(len(s) * len(t))</td>\n<td></td>\n</tr>\n<tr>\n<td>s.symmetric_difference_update(t)</td>\n<td>O(len(t))</td>\n<td>O(len(t) * len(s))</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"字典-dict\"><a href=\"#字典-dict\" class=\"headerlink\" title=\"字典 dict\"></a>字典 dict</h2><p>字典的平均情况基于以下假设：</p>\n<ol>\n<li>对象的散列函数足够撸棒（robust），不会发生冲突。</li>\n<li>字典的键是从所有可能的键的集合中随机选择的。</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th><strong>Operation</strong></th>\n<th><strong>Average Case</strong></th>\n<th><strong>Amortized Worst Case</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Copy[2]</td>\n<td>O(n)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>Get Item</td>\n<td>O(1)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>Set Item[1]</td>\n<td>O(1)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>Delete Item</td>\n<td>O(1)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>Iteration[2]</td>\n<td>O(n)</td>\n<td>O(n)</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://wiki.python.org/moin/TimeComplexity\" target=\"_blank\" rel=\"noopener\">https://wiki.python.org/moin/TimeComplexity</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"列表-list\"><a href=\"#列表-list\" class=\"headerlink\" title=\"列表 list\"></a>列表 list</h2><p>列表是以数组（Array）实现的。最大的开销发生在超过当前分配大小的增长，这种情况下所有元素都需要移动；或者是在起始位置附近插入或者删除元素，这种情况下所有在该位置后面的元素都需要移动，这种情况可以考虑使用双向队列来解决。</p>\n<table>\n<thead>\n<tr>\n<th>Operation</th>\n<th>Average Case</th>\n<th><a href=\"http://en.wikipedia.org/wiki/Amortized_analysis\" target=\"_blank\" rel=\"noopener\">Amortized Worst Case</a></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Copy</td>\n<td>O(n)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>Append[1]</td>\n<td>O(1)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>Pop last</td>\n<td>O(1)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>Pop intermediate</td>\n<td>O(k)</td>\n<td>O(k)</td>\n</tr>\n<tr>\n<td>Insert</td>\n<td>O(n)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>Get Item</td>\n<td>O(1)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>Set Item</td>\n<td>O(1)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>Delete Item</td>\n<td>O(n)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>Iteration</td>\n<td>O(n)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>Get Slice</td>\n<td>O(k)</td>\n<td>O(k)</td>\n</tr>\n<tr>\n<td>Del Slice</td>\n<td>O(n)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>Set Slice</td>\n<td>O(k+n)</td>\n<td>O(k+n)</td>\n</tr>\n<tr>\n<td>Extend[1]</td>\n<td>O(k)</td>\n<td>O(k)</td>\n</tr>\n<tr>\n<td><a href=\"http://svn.python.org/projects/python/trunk/Objects/listsort.txt\" target=\"_blank\" rel=\"noopener\">Sort</a></td>\n<td>O(n log n)</td>\n<td>O(n log n)</td>\n</tr>\n<tr>\n<td>Multiply</td>\n<td>O(nk)</td>\n<td>O(nk)</td>\n</tr>\n<tr>\n<td>x in s</td>\n<td>O(n)</td>\n<td></td>\n</tr>\n<tr>\n<td>min(s), max(s)</td>\n<td>O(n)</td>\n<td></td>\n</tr>\n<tr>\n<td>Get Length</td>\n<td>O(1)</td>\n<td>O(1)</td>\n</tr>\n</tbody>\n</table>","more":"<h2 id=\"双向队列-collections-deque\"><a href=\"#双向队列-collections-deque\" class=\"headerlink\" title=\"双向队列 collections.deque\"></a>双向队列 collections.deque</h2><p>deque是以双向链表的形式实现的。双向队列的两端都是可达的，但从查找队列中间的元素较为缓慢，增删元素就更慢了。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><strong>操作</strong></th>\n<th style=\"text-align:center\"><strong>平均情况</strong></th>\n<th style=\"text-align:center\"><strong>最坏情况</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">复制</td>\n<td style=\"text-align:center\">O(n)</td>\n<td style=\"text-align:center\">O(n)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">append</td>\n<td style=\"text-align:center\">O(1)</td>\n<td style=\"text-align:center\">O(1)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">appendleft</td>\n<td style=\"text-align:center\">O(1)</td>\n<td style=\"text-align:center\">O(1)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">pop</td>\n<td style=\"text-align:center\">O(1)</td>\n<td style=\"text-align:center\">O(1)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">popleft</td>\n<td style=\"text-align:center\">O(1)</td>\n<td style=\"text-align:center\">O(1)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">extend</td>\n<td style=\"text-align:center\">O(k)</td>\n<td style=\"text-align:center\">O(k)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">extendleft</td>\n<td style=\"text-align:center\">O(k)</td>\n<td style=\"text-align:center\">O(k)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">rotate</td>\n<td style=\"text-align:center\">O(k)</td>\n<td style=\"text-align:center\">O(k)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">remove</td>\n<td style=\"text-align:center\">O(n)</td>\n<td style=\"text-align:center\">O(n)</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"集合-set\"><a href=\"#集合-set\" class=\"headerlink\" title=\"集合 set\"></a>集合 set</h2><table>\n<thead>\n<tr>\n<th><strong>Operation</strong></th>\n<th><strong>Average case</strong></th>\n<th><strong>Worst Case</strong></th>\n<th><strong>notes</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>x in s</td>\n<td>O(1)</td>\n<td>O(n)</td>\n<td></td>\n</tr>\n<tr>\n<td>Union s\\</td>\n<td>t</td>\n<td><a href=\"https://wiki.python.org/moin/TimeComplexity_%28SetCode%29\" target=\"_blank\" rel=\"noopener\">O(len(s)+len(t))</a></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Intersection s&amp;t</td>\n<td>O(min(len(s), len(t))</td>\n<td>O(len(s) * len(t))</td>\n<td>replace “min” with “max” if t is not a set</td>\n</tr>\n<tr>\n<td>Multiple intersection s1&amp;s2&amp;..&amp;sn</td>\n<td></td>\n<td>(n-1)*O(l) where l is max(len(s1),..,len(sn))</td>\n<td></td>\n</tr>\n<tr>\n<td>Difference s-t</td>\n<td>O(len(s))</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>s.difference_update(t)</td>\n<td>O(len(t))</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>Symmetric Difference s^t</td>\n<td>O(len(s))</td>\n<td>O(len(s) * len(t))</td>\n<td></td>\n</tr>\n<tr>\n<td>s.symmetric_difference_update(t)</td>\n<td>O(len(t))</td>\n<td>O(len(t) * len(s))</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"字典-dict\"><a href=\"#字典-dict\" class=\"headerlink\" title=\"字典 dict\"></a>字典 dict</h2><p>字典的平均情况基于以下假设：</p>\n<ol>\n<li>对象的散列函数足够撸棒（robust），不会发生冲突。</li>\n<li>字典的键是从所有可能的键的集合中随机选择的。</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th><strong>Operation</strong></th>\n<th><strong>Average Case</strong></th>\n<th><strong>Amortized Worst Case</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Copy[2]</td>\n<td>O(n)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>Get Item</td>\n<td>O(1)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>Set Item[1]</td>\n<td>O(1)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>Delete Item</td>\n<td>O(1)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>Iteration[2]</td>\n<td>O(n)</td>\n<td>O(n)</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://wiki.python.org/moin/TimeComplexity\" target=\"_blank\" rel=\"noopener\">https://wiki.python.org/moin/TimeComplexity</a></li>\n</ol>"},{"title":"Python3 将两个排好序的列表合并成一个有序列表","date":"2018-03-11T16:11:27.000Z","_content":"```Python\ndef merge_list(a, b):\n    if not a:\n        return b\n    if not b:\n        return a\n    a_index = b_index = 0\n    ret = []\n    while a_index < len(a) and b_index < len(b):\n        if a[a_index] <= b[b_index]:\n            ret.append(a[a_index])\n            a_index += 1\n        else:\n            ret.append(b[b_index])\n            b_index += 1\n    if a_index < len(a):\n        ret.extend(a[a_index:])\n    if b_index < len(b):\n        ret.extend(b[b_index:])\n    return ret\n\n\nif __name__ == '__main__':\n    a = [1, 2, 3, 5, 7, 9]\n    b = [1, 2, 2, 4, 5, 6, 8, 10]\n    print(merge_list(a, b))\n\n```\n","source":"_posts/Python3-将两个排好序的列表合并成一个有序列表.md","raw":"---\ntitle: Python3 将两个排好序的列表合并成一个有序列表\ndate: 2018-03-12 00:11:27\ntags:\n  - Python3\n  - Algorithm\ncategories:\n  - Algorithm\n---\n```Python\ndef merge_list(a, b):\n    if not a:\n        return b\n    if not b:\n        return a\n    a_index = b_index = 0\n    ret = []\n    while a_index < len(a) and b_index < len(b):\n        if a[a_index] <= b[b_index]:\n            ret.append(a[a_index])\n            a_index += 1\n        else:\n            ret.append(b[b_index])\n            b_index += 1\n    if a_index < len(a):\n        ret.extend(a[a_index:])\n    if b_index < len(b):\n        ret.extend(b[b_index:])\n    return ret\n\n\nif __name__ == '__main__':\n    a = [1, 2, 3, 5, 7, 9]\n    b = [1, 2, 2, 4, 5, 6, 8, 10]\n    print(merge_list(a, b))\n\n```\n","slug":"Python3-将两个排好序的列表合并成一个有序列表","published":1,"updated":"2018-03-11T17:59:27.116Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozlo003d8motzvwpzpyr","content":"<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge_list</span><span class=\"params\">(a, b)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> a:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> b</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> b:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a</span><br><span class=\"line\">    a_index = b_index = <span class=\"number\">0</span></span><br><span class=\"line\">    ret = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> a_index &lt; len(a) <span class=\"keyword\">and</span> b_index &lt; len(b):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> a[a_index] &lt;= b[b_index]:</span><br><span class=\"line\">            ret.append(a[a_index])</span><br><span class=\"line\">            a_index += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            ret.append(b[b_index])</span><br><span class=\"line\">            b_index += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> a_index &lt; len(a):</span><br><span class=\"line\">        ret.extend(a[a_index:])</span><br><span class=\"line\">    <span class=\"keyword\">if</span> b_index &lt; len(b):</span><br><span class=\"line\">        ret.extend(b[b_index:])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>]</span><br><span class=\"line\">    b = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">10</span>]</span><br><span class=\"line\">    print(merge_list(a, b))</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">merge_list</span><span class=\"params\">(a, b)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> a:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> b</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> b:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a</span><br><span class=\"line\">    a_index = b_index = <span class=\"number\">0</span></span><br><span class=\"line\">    ret = []</span><br><span class=\"line\">    <span class=\"keyword\">while</span> a_index &lt; len(a) <span class=\"keyword\">and</span> b_index &lt; len(b):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> a[a_index] &lt;= b[b_index]:</span><br><span class=\"line\">            ret.append(a[a_index])</span><br><span class=\"line\">            a_index += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            ret.append(b[b_index])</span><br><span class=\"line\">            b_index += <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> a_index &lt; len(a):</span><br><span class=\"line\">        ret.extend(a[a_index:])</span><br><span class=\"line\">    <span class=\"keyword\">if</span> b_index &lt; len(b):</span><br><span class=\"line\">        ret.extend(b[b_index:])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ret</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>]</span><br><span class=\"line\">    b = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">10</span>]</span><br><span class=\"line\">    print(merge_list(a, b))</span><br></pre></td></tr></table></figure>\n"},{"title":"Python3 拷贝对象(深拷贝deepcopy和浅拷贝copy)","date":"2018-03-03T04:10:54.000Z","_content":"\n1. copy.copy 浅拷贝 `只拷贝父对象`，不会拷贝对象的内部的子对象。\n2. copy.deepcopy 深拷贝 `拷贝对象及其子对象`\n---\n![屏幕截图3.jpg](http://upload-images.jianshu.io/upload_images/2952111-17e1f4233f95285d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n<!-- more -->\n```python\n# -*-coding:utf-8 -*-\nimport copy\na = [1, 2, 3, 4, ['a', 'b']] #原始对象\n\nb = a #赋值，传对象的引用\nc = copy.copy(a) #对象拷贝，浅拷贝\nd = copy.deepcopy(a) #对象拷贝，深拷贝\n\na.append(5) #修改对象a\na[4].append('c') #修改对象a中的['a', 'b']数组对象\n\nprint 'a = ', a\nprint 'b = ', b\nprint 'c = ', c\nprint 'd = ', d\n输出结果：\na =  [1, 2, 3, 4, ['a', 'b', 'c'], 5]\nb =  [1, 2, 3, 4, ['a', 'b', 'c'], 5]\nc =  [1, 2, 3, 4, ['a', 'b', 'c']]\nd =  [1, 2, 3, 4, ['a', 'b']]\n```\n","source":"_posts/Python3-拷贝对象-深拷贝deepcopy和浅拷贝copy.md","raw":"---\ntitle: Python3 拷贝对象(深拷贝deepcopy和浅拷贝copy)\ndate: 2018-03-03 12:10:54\ntags:\n  - Python3\ncategories:\n  - Python3 进阶\n  - Python3 拷贝对象\n---\n\n1. copy.copy 浅拷贝 `只拷贝父对象`，不会拷贝对象的内部的子对象。\n2. copy.deepcopy 深拷贝 `拷贝对象及其子对象`\n---\n![屏幕截图3.jpg](http://upload-images.jianshu.io/upload_images/2952111-17e1f4233f95285d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n<!-- more -->\n```python\n# -*-coding:utf-8 -*-\nimport copy\na = [1, 2, 3, 4, ['a', 'b']] #原始对象\n\nb = a #赋值，传对象的引用\nc = copy.copy(a) #对象拷贝，浅拷贝\nd = copy.deepcopy(a) #对象拷贝，深拷贝\n\na.append(5) #修改对象a\na[4].append('c') #修改对象a中的['a', 'b']数组对象\n\nprint 'a = ', a\nprint 'b = ', b\nprint 'c = ', c\nprint 'd = ', d\n输出结果：\na =  [1, 2, 3, 4, ['a', 'b', 'c'], 5]\nb =  [1, 2, 3, 4, ['a', 'b', 'c'], 5]\nc =  [1, 2, 3, 4, ['a', 'b', 'c']]\nd =  [1, 2, 3, 4, ['a', 'b']]\n```\n","slug":"Python3-拷贝对象-深拷贝deepcopy和浅拷贝copy","published":1,"updated":"2018-03-03T04:14:09.659Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozlp003h8mottwz5gpp0","content":"<ol>\n<li>copy.copy 浅拷贝 <code>只拷贝父对象</code>，不会拷贝对象的内部的子对象。</li>\n<li>copy.deepcopy 深拷贝 <code>拷贝对象及其子对象</code></li>\n</ol>\n<hr>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-17e1f4233f95285d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕截图3.jpg\"></p>\n<a id=\"more\"></a>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*-coding:utf-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> copy</span><br><span class=\"line\">a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>]] <span class=\"comment\">#原始对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">b = a <span class=\"comment\">#赋值，传对象的引用</span></span><br><span class=\"line\">c = copy.copy(a) <span class=\"comment\">#对象拷贝，浅拷贝</span></span><br><span class=\"line\">d = copy.deepcopy(a) <span class=\"comment\">#对象拷贝，深拷贝</span></span><br><span class=\"line\"></span><br><span class=\"line\">a.append(<span class=\"number\">5</span>) <span class=\"comment\">#修改对象a</span></span><br><span class=\"line\">a[<span class=\"number\">4</span>].append(<span class=\"string\">'c'</span>) <span class=\"comment\">#修改对象a中的['a', 'b']数组对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">'a = '</span>, a</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">'b = '</span>, b</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">'c = '</span>, c</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">'d = '</span>, d</span><br><span class=\"line\">输出结果：</span><br><span class=\"line\">a =  [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>], <span class=\"number\">5</span>]</span><br><span class=\"line\">b =  [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>], <span class=\"number\">5</span>]</span><br><span class=\"line\">c =  [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>]]</span><br><span class=\"line\">d =  [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>]]</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<ol>\n<li>copy.copy 浅拷贝 <code>只拷贝父对象</code>，不会拷贝对象的内部的子对象。</li>\n<li>copy.deepcopy 深拷贝 <code>拷贝对象及其子对象</code></li>\n</ol>\n<hr>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-17e1f4233f95285d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"屏幕截图3.jpg\"></p>","more":"<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*-coding:utf-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> copy</span><br><span class=\"line\">a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>]] <span class=\"comment\">#原始对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">b = a <span class=\"comment\">#赋值，传对象的引用</span></span><br><span class=\"line\">c = copy.copy(a) <span class=\"comment\">#对象拷贝，浅拷贝</span></span><br><span class=\"line\">d = copy.deepcopy(a) <span class=\"comment\">#对象拷贝，深拷贝</span></span><br><span class=\"line\"></span><br><span class=\"line\">a.append(<span class=\"number\">5</span>) <span class=\"comment\">#修改对象a</span></span><br><span class=\"line\">a[<span class=\"number\">4</span>].append(<span class=\"string\">'c'</span>) <span class=\"comment\">#修改对象a中的['a', 'b']数组对象</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">'a = '</span>, a</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">'b = '</span>, b</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">'c = '</span>, c</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">'d = '</span>, d</span><br><span class=\"line\">输出结果：</span><br><span class=\"line\">a =  [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>], <span class=\"number\">5</span>]</span><br><span class=\"line\">b =  [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>], <span class=\"number\">5</span>]</span><br><span class=\"line\">c =  [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>]]</span><br><span class=\"line\">d =  [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>]]</span><br></pre></td></tr></table></figure>"},{"title":"Python3 真假值对照表","date":"2018-03-03T05:14:45.000Z","_content":"\n| 类型              | False                       |True   |\n| :-----:           | :-----:                    | :-----:   |\n|布尔               |False(与0等价)                |True(与1等价)   |\n|数值                | 0, &nbsp;&nbsp;0.0         |非零的数值   |\n|字符串              | '',&nbsp;&nbsp;\"\"(空字符串)  |非空字符串   |\n|容器   |[],&nbsp;&nbsp;(),&nbsp;&nbsp;{},&nbsp;&nbsp;set() |至少有一个元素的容器对象|\n|None          |None|非None对象|\n","source":"_posts/Python3-真假值对照表.md","raw":"---\ntitle: Python3 真假值对照表\ndate: 2018-03-03 13:14:45\ntags:\n  - Python3\ncategories:\n  - Python3 进阶\n  - Python3 True or False\n---\n\n| 类型              | False                       |True   |\n| :-----:           | :-----:                    | :-----:   |\n|布尔               |False(与0等价)                |True(与1等价)   |\n|数值                | 0, &nbsp;&nbsp;0.0         |非零的数值   |\n|字符串              | '',&nbsp;&nbsp;\"\"(空字符串)  |非空字符串   |\n|容器   |[],&nbsp;&nbsp;(),&nbsp;&nbsp;{},&nbsp;&nbsp;set() |至少有一个元素的容器对象|\n|None          |None|非None对象|\n","slug":"Python3-真假值对照表","published":1,"updated":"2018-03-03T05:21:56.663Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozlr003l8mot1kcygkuq","content":"<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">类型</th>\n<th style=\"text-align:center\">False</th>\n<th style=\"text-align:center\">True</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">布尔</td>\n<td style=\"text-align:center\">False(与0等价)</td>\n<td style=\"text-align:center\">True(与1等价)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">数值</td>\n<td style=\"text-align:center\">0, &nbsp;&nbsp;0.0</td>\n<td style=\"text-align:center\">非零的数值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">字符串</td>\n<td style=\"text-align:center\">‘’,&nbsp;&nbsp;””(空字符串)</td>\n<td style=\"text-align:center\">非空字符串</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">容器</td>\n<td style=\"text-align:center\">[],&nbsp;&nbsp;(),&nbsp;&nbsp;{},&nbsp;&nbsp;set()</td>\n<td style=\"text-align:center\">至少有一个元素的容器对象</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">None</td>\n<td style=\"text-align:center\">None</td>\n<td style=\"text-align:center\">非None对象</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">类型</th>\n<th style=\"text-align:center\">False</th>\n<th style=\"text-align:center\">True</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">布尔</td>\n<td style=\"text-align:center\">False(与0等价)</td>\n<td style=\"text-align:center\">True(与1等价)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">数值</td>\n<td style=\"text-align:center\">0, &nbsp;&nbsp;0.0</td>\n<td style=\"text-align:center\">非零的数值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">字符串</td>\n<td style=\"text-align:center\">‘’,&nbsp;&nbsp;””(空字符串)</td>\n<td style=\"text-align:center\">非空字符串</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">容器</td>\n<td style=\"text-align:center\">[],&nbsp;&nbsp;(),&nbsp;&nbsp;{},&nbsp;&nbsp;set()</td>\n<td style=\"text-align:center\">至少有一个元素的容器对象</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">None</td>\n<td style=\"text-align:center\">None</td>\n<td style=\"text-align:center\">非None对象</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"Python3 类变量和实例变量","date":"2018-03-01T05:21:38.000Z","_content":"### 写在前面\n首先来一张图\n![classvariable.png](http://upload-images.jianshu.io/upload_images/2952111-07f6d669392b20c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n### 类变量和实例变量\n\n在Python Tutorial中对于类变量和实例变量是这样描述的：\n>Generally speaking, instance variables are for data unique to each instance and class variables are for attributes and methods shared by all instances of the class:\n\n```python\nclass Dog:\n    kind = 'canine'         # class variable shared by all instances\n    def __init__(self, name):\n        self.name = name    # instance variable unique to each instance\n```\n\n类`Dog`中，类属性`kind`为所有实例所共享；实例属性`name`为每个`Dog`的实例独有。\n<!-- more -->\n\n#### 类变量：\n\n> ​\t是可在类的所有实例之间共享的值（也就是说，它们不是单独分配给每个实例的）。例如下例中，num_of_instance 就是类变量，用于跟踪存在着多少个Test 的实例。\n\n#### 实例变量：\n\n> 实例化之后，每个实例单独拥有的变量。\n\n\n```python\nclass Test(object):  \n    num_of_instance = 0  \n    def __init__(self, name):  \n        self.name = name  \n        Test.num_of_instance += 1  \n\nif __name__ == '__main__':  \n    print Test.num_of_instance   # 0\n    t1 = Test('jack')  \n    print Test.num_of_instance   # 1\n    t2 = Test('lucy')  \n    print t1.name , t1.num_of_instance  # jack 2\n    print t2.name , t2.num_of_instance  # lucy 2\n```\n\n> 补充的例子\n\n```python\nclass Person:\n    name=\"aaa\"\n\np1=Person()\np2=Person()\np1.name=\"bbb\"\nprint p1.name  # bbb\nprint p2.name  # aaa\nprint Person.name  # aaa\n```\n\n这里`p1.name=\"bbb\"`是实例调用了类变量,属于函数传参的问题,`p1.name`一开始是指向的类变量`name=\"aaa\"`,但是在实例的作用域里把类变量的引用改变了,就变成了一个实例变量,self.name不再引用Person的类变量name了.\n\n可以看看下面的例子:\n\n```python\nclass Person:\n    name=[]\n\np1=Person()\np2=Person()\np1.name.append(1)\nprint p1.name  # [1]\nprint p2.name  # [1]\nprint Person.name  # [1]\n```\n\n### 类对象和实例对象\n\n#### 类对象\n`Python`中一切皆对象；类定义完成后，会在当前作用域中定义一个以类名为名字，指向类对象的名字。如\n```python    \nclass Dog:\n    pass\n```\n会在当前作用域定义名字`Dog`，指向类对象`Dog`。\n\n**类对象支持的操作**：  \n总的来说，类对象仅支持两个操作：\n\n  1. 实例化；使用`instance_name = class_name()`的方式实例化，实例化操作创建该类的实例。\n  2. 属性引用；使用`class_name.attr_name`的方式引用类属性。\n\n#### 实例对象\n\n**实例对象是类对象实例化的产物，实例对象仅支持一个操作**:\n\n  1. 属性引用；与类对象属性引用的方式相同，使用`instance_name.attr_name`的方式。\n\n按照严格的面向对象思想，所有属性都应该是实例的，类属性不应该存在。那么在`Python`中，由于类属性绑定就不应该存在，类定义中就只剩下函数定义了。\n\n在[Python tutorial](https://docs.python.org/3/tutorial/classes.html#class-definition-syntax)关于类定义也这么说：\n\n> In practice, the statements inside a class definition will usually be function definitions, but other statements are allowed, and sometimes useful.\n\n实践中，类定义中的语句通常是函数定义，但是其他语句也是允许的，有时也是有用的。\n\n这里说的其他语句，就是指类属性的绑定语句。\n\n\n### 属性绑定\n\n在定义类时，通常我们说的定义属性，其实是分为两个方面的：\n\n  1. 类属性绑定\n  2. 实例属性绑定\n\n用**绑定**这个词更加确切；不管是类对象还是实例对象，属性都是依托对象而存在的。\n\n我们说的属性绑定，首先需要一个可变对象，才能执行绑定操作，使用\n\n    objname.attr = attr_value\n\n的方式，为对象`objname`绑定属性`attr`。\n\n这分两种情况：\n\n  1. 若属性`attr`已经存在，绑定操作会将属性名指向新的对象；\n  2. 若不存在，则为该对象添加新的属性，后面就可以引用新增属性。\n\n#### 类属性绑定\n\n`Python`作为动态语言，类对象和实例对象都可以在运行时绑定任意属性。因此，类属性的绑定发生在两个地方：\n\n  1. 类定义时；\n  2. 运行时任意阶段。\n\n下面这个例子说明了类属性绑定发生的时期：\n```python\nclass Dog:\n    kind = 'canine'\n\nDog.country = 'China'\nprint(Dog.kind, ' - ', Dog.country) # output: canine - China\ndel Dog.kind\nprint(Dog.kind, ' - ', Dog.country)\n# AttributeError: type object 'Dog' has no attribute 'kind'\n```\n在类定义中，类属性的绑定并没有使用`objname.attr = attr_value`的方式，这是一个特例，其实是等同于后面使用类名绑定属性的方式。  \n因为是动态语言，所以可以在运行时增加属性，删除属性。\n\n#### 实例属性绑定\n\n与类属性绑定相同，实例属性绑定也发生在两个地方：\n\n  1. 类定义时；\n  2. 运行时任意阶段。\n\n示例：\n```python\nclass Dog:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\ndog = Dog('Lily', 3)\ndog.fur_color = 'red'\nprint('%s is %s years old, it has %s fur' % (dog.name, dog.age, dog.fur_color))\n# Output: Lily is 3 years old, it has red fur\n```\n`Python`类实例有两个特殊之处：\n\n  1. `__init__`在实例化时执行\n  2. `Python`实例调用方法时，会将实例对象作为第一个参数传递\n\n因此，`__init__`方法中的`self`就是实例对象本身，这里是`dog`，语句\n```python\nself.name = name\nself.age = age\n```\n以及后面的语句\n```python\ndog.fur_color = 'red'\n```\n为实例`dog`增加三个属性`name`, `age`, `fur_color`。\n\n### 属性引用\n\n#### 类属属性引用\n\n类属性的引用，肯定是需要类对象的，属性分为两种：\n\n  1. 数据属性\n  2. 函数属性\n\n数据属性引用很简单，示例：\n```python    \nclass Dog:\n    kind = 'canine'\n\nDog.country = 'China'\nprint(Dog.kind, ' - ', Dog.country) # output: canine - China\n```\n通常很少有引用类函数属性的需求，示例：\n```python\nclass Dog:\n    kind = 'canine'\n    def tell_kind():\n        print(Dog.kind)\n\nDog.tell_kind() # Output: canine\n```\n函数`tell_kind`在引用`kind`需要使用`Dog.kind`而不是直接使用`kind`，涉及到作用域，这一点在我的另一篇文章中有介绍：[Python进阶 - 命名空间与作用域](http://www.cnblogs.com/crazyrunning/p/6914080.html)\n\n\n#### 实例属性引用\n\n使用实例对象引用属性稍微复杂一些，因为实例对象可引用类属性以及实例属性。但是实例对象引用属性时遵循以下规则：\n\n  1. 总是先到实例对象中查找属性，再到类属性中查找属性；\n  2. 属性绑定语句总是为实例对象创建新属性，属性存在时，更新属性指向的对象。\n\n##### 数据属性引用\n\n示例1：\n```Python\nclass Dog:\n\n    kind = 'canine'\n    country = 'China'\n\n    def __init__(self, name, age, country):\n        self.name = name\n        self.age = age\n        self.country = country\n\ndog = Dog('Lily', 3, 'Britain')\nprint(dog.name, dog.age, dog.kind, dog.country)\n# output: Lily 3 canine Britain\n\n```\n类对象`Dog`与实例对象`dog`均有属性`country`，按照规则，`dog.country`会引用到实例对象的属性；但实例对象`dog`没有属性`kind`，按照规则会引用类对象的属性。\n\n示例2：\n```python\nclass Dog:\n\n    kind = 'canine'\n    country = 'China'\n\n    def __init__(self, name, age, country):\n        self.name = name\n        self.age = age\n        self.country = country\n\ndog = Dog('Lily', 3, 'Britain')\nprint(dog.name, dog.age, dog.kind, dog.country) # Lily 3 canine Britain\nprint(dog.__dict__) # {'name': 'Lily', 'age': 3, 'country': 'Britain'}\n\ndog.kind = 'feline'\nprint(dog.name, dog.age, dog.kind, dog.country) # Lily 3 feline Britain\nprint(dog.__dict__)  # {'name': 'Lily', 'age': 3, 'country': 'Britain', 'kind': 'feline'}\nprint(Dog.kind) # canine 没有改变类属性的指向\n\n```\n\n示例3，可变类属性引用：\n\n```python\n\nclass Dog:\n\n    tricks = []\n\n    def __init__(self, name):\n        self.name = name\n\n    def add_trick(self, trick):\n        # self.tricks.append(trick)\n        Dog.tricks.append(trick)\n\nd = Dog('Fido')\ne = Dog('Buddy')\nd.add_trick('roll over')\ne.add_trick('play dead')\nprint(d.tricks) # ['roll over', 'play dead']\n```\n\n语句`self.tricks.append(trick)`并不是属性绑定语句，因此还是在类属性上修改可变对象。\n\n##### 方法属性引用\n\n与数据成员不同，类函数属性在实例对象中会变成方法属性。先看一个示例：\n\n```Python\nclass MethodTest:\n\n    def inner_test(self):\n        print('in class')\n\ndef outer_test():\n    print('out of class')\n\nmt = MethodTest()\nmt.outer_test = outer_test\n\nprint(type(MethodTest.inner_test))  # <class 'function'> 类函数\nprint(type(mt.inner_test))          #<class 'method'> 类方法\nprint(type(mt.outer_test))          #<class 'function'> 类函数\n\n```\n可以看到，类函数属性在实例对象中变成了方法属性，但是并不是实例对象中所有的函数都是方法。\n\nPython tutorial中这样介绍方法对象：\n\n>When an instance attribute is referenced that isn’t a data attribute, its class is searched. If the name denotes a valid class attribute that is a function object, a method object is created by packing (pointers to) the instance object and the function object just found together in an abstract object: this is the method object. When the method object is called with an argument list, a new argument list is constructed from the instance object and the argument list, and the function object is called with this new argument list.\n\n引用非数据属性的实例属性时，会搜索它对应的类。如果名字是一个有效的函数对象，Python会将实例对象连同函数对象打包到一个抽象的对象中并且依据这个对象创建方法对象：这就是被调用的方法对象。当使用参数列表调用方法对象时，会使用实例对象以及原有参数列表构建新的参数列表，并且使用新的参数列表调用函数对象。\n\n那么，实例对象只有在引用方法属性时，才会将自身作为第一个参数传递；调用实例对象的普通函数，则不会。  \n所以可以使用如下方式直接调用方法与函数：\n\n```python\nmt.inner_test()\nmt.outer_test()\n```\n除了方法与函数的区别，其引用与数据属性都是一样的\n\n### 最佳实践\n\n虽然`Python`作为动态语言，支持在运行时绑定属性，但是从面向对象的角度来看，还是在定义类的时候将属性确定下来。\n\n\n\n\n\n\n\n\n参考:\n1. http://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block\n2. https://www.cnblogs.com/crazyrunning/p/6945183.html\n","source":"_posts/Python3-类变量和实例变量.md","raw":"---\ntitle: Python3 类变量和实例变量\ndate: 2018-03-01 13:21:38\ntags:\n  - Python3\ncategories:\n  - Python3 进阶\n  - 类变量 和 实例变量\n---\n### 写在前面\n首先来一张图\n![classvariable.png](http://upload-images.jianshu.io/upload_images/2952111-07f6d669392b20c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n### 类变量和实例变量\n\n在Python Tutorial中对于类变量和实例变量是这样描述的：\n>Generally speaking, instance variables are for data unique to each instance and class variables are for attributes and methods shared by all instances of the class:\n\n```python\nclass Dog:\n    kind = 'canine'         # class variable shared by all instances\n    def __init__(self, name):\n        self.name = name    # instance variable unique to each instance\n```\n\n类`Dog`中，类属性`kind`为所有实例所共享；实例属性`name`为每个`Dog`的实例独有。\n<!-- more -->\n\n#### 类变量：\n\n> ​\t是可在类的所有实例之间共享的值（也就是说，它们不是单独分配给每个实例的）。例如下例中，num_of_instance 就是类变量，用于跟踪存在着多少个Test 的实例。\n\n#### 实例变量：\n\n> 实例化之后，每个实例单独拥有的变量。\n\n\n```python\nclass Test(object):  \n    num_of_instance = 0  \n    def __init__(self, name):  \n        self.name = name  \n        Test.num_of_instance += 1  \n\nif __name__ == '__main__':  \n    print Test.num_of_instance   # 0\n    t1 = Test('jack')  \n    print Test.num_of_instance   # 1\n    t2 = Test('lucy')  \n    print t1.name , t1.num_of_instance  # jack 2\n    print t2.name , t2.num_of_instance  # lucy 2\n```\n\n> 补充的例子\n\n```python\nclass Person:\n    name=\"aaa\"\n\np1=Person()\np2=Person()\np1.name=\"bbb\"\nprint p1.name  # bbb\nprint p2.name  # aaa\nprint Person.name  # aaa\n```\n\n这里`p1.name=\"bbb\"`是实例调用了类变量,属于函数传参的问题,`p1.name`一开始是指向的类变量`name=\"aaa\"`,但是在实例的作用域里把类变量的引用改变了,就变成了一个实例变量,self.name不再引用Person的类变量name了.\n\n可以看看下面的例子:\n\n```python\nclass Person:\n    name=[]\n\np1=Person()\np2=Person()\np1.name.append(1)\nprint p1.name  # [1]\nprint p2.name  # [1]\nprint Person.name  # [1]\n```\n\n### 类对象和实例对象\n\n#### 类对象\n`Python`中一切皆对象；类定义完成后，会在当前作用域中定义一个以类名为名字，指向类对象的名字。如\n```python    \nclass Dog:\n    pass\n```\n会在当前作用域定义名字`Dog`，指向类对象`Dog`。\n\n**类对象支持的操作**：  \n总的来说，类对象仅支持两个操作：\n\n  1. 实例化；使用`instance_name = class_name()`的方式实例化，实例化操作创建该类的实例。\n  2. 属性引用；使用`class_name.attr_name`的方式引用类属性。\n\n#### 实例对象\n\n**实例对象是类对象实例化的产物，实例对象仅支持一个操作**:\n\n  1. 属性引用；与类对象属性引用的方式相同，使用`instance_name.attr_name`的方式。\n\n按照严格的面向对象思想，所有属性都应该是实例的，类属性不应该存在。那么在`Python`中，由于类属性绑定就不应该存在，类定义中就只剩下函数定义了。\n\n在[Python tutorial](https://docs.python.org/3/tutorial/classes.html#class-definition-syntax)关于类定义也这么说：\n\n> In practice, the statements inside a class definition will usually be function definitions, but other statements are allowed, and sometimes useful.\n\n实践中，类定义中的语句通常是函数定义，但是其他语句也是允许的，有时也是有用的。\n\n这里说的其他语句，就是指类属性的绑定语句。\n\n\n### 属性绑定\n\n在定义类时，通常我们说的定义属性，其实是分为两个方面的：\n\n  1. 类属性绑定\n  2. 实例属性绑定\n\n用**绑定**这个词更加确切；不管是类对象还是实例对象，属性都是依托对象而存在的。\n\n我们说的属性绑定，首先需要一个可变对象，才能执行绑定操作，使用\n\n    objname.attr = attr_value\n\n的方式，为对象`objname`绑定属性`attr`。\n\n这分两种情况：\n\n  1. 若属性`attr`已经存在，绑定操作会将属性名指向新的对象；\n  2. 若不存在，则为该对象添加新的属性，后面就可以引用新增属性。\n\n#### 类属性绑定\n\n`Python`作为动态语言，类对象和实例对象都可以在运行时绑定任意属性。因此，类属性的绑定发生在两个地方：\n\n  1. 类定义时；\n  2. 运行时任意阶段。\n\n下面这个例子说明了类属性绑定发生的时期：\n```python\nclass Dog:\n    kind = 'canine'\n\nDog.country = 'China'\nprint(Dog.kind, ' - ', Dog.country) # output: canine - China\ndel Dog.kind\nprint(Dog.kind, ' - ', Dog.country)\n# AttributeError: type object 'Dog' has no attribute 'kind'\n```\n在类定义中，类属性的绑定并没有使用`objname.attr = attr_value`的方式，这是一个特例，其实是等同于后面使用类名绑定属性的方式。  \n因为是动态语言，所以可以在运行时增加属性，删除属性。\n\n#### 实例属性绑定\n\n与类属性绑定相同，实例属性绑定也发生在两个地方：\n\n  1. 类定义时；\n  2. 运行时任意阶段。\n\n示例：\n```python\nclass Dog:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\ndog = Dog('Lily', 3)\ndog.fur_color = 'red'\nprint('%s is %s years old, it has %s fur' % (dog.name, dog.age, dog.fur_color))\n# Output: Lily is 3 years old, it has red fur\n```\n`Python`类实例有两个特殊之处：\n\n  1. `__init__`在实例化时执行\n  2. `Python`实例调用方法时，会将实例对象作为第一个参数传递\n\n因此，`__init__`方法中的`self`就是实例对象本身，这里是`dog`，语句\n```python\nself.name = name\nself.age = age\n```\n以及后面的语句\n```python\ndog.fur_color = 'red'\n```\n为实例`dog`增加三个属性`name`, `age`, `fur_color`。\n\n### 属性引用\n\n#### 类属属性引用\n\n类属性的引用，肯定是需要类对象的，属性分为两种：\n\n  1. 数据属性\n  2. 函数属性\n\n数据属性引用很简单，示例：\n```python    \nclass Dog:\n    kind = 'canine'\n\nDog.country = 'China'\nprint(Dog.kind, ' - ', Dog.country) # output: canine - China\n```\n通常很少有引用类函数属性的需求，示例：\n```python\nclass Dog:\n    kind = 'canine'\n    def tell_kind():\n        print(Dog.kind)\n\nDog.tell_kind() # Output: canine\n```\n函数`tell_kind`在引用`kind`需要使用`Dog.kind`而不是直接使用`kind`，涉及到作用域，这一点在我的另一篇文章中有介绍：[Python进阶 - 命名空间与作用域](http://www.cnblogs.com/crazyrunning/p/6914080.html)\n\n\n#### 实例属性引用\n\n使用实例对象引用属性稍微复杂一些，因为实例对象可引用类属性以及实例属性。但是实例对象引用属性时遵循以下规则：\n\n  1. 总是先到实例对象中查找属性，再到类属性中查找属性；\n  2. 属性绑定语句总是为实例对象创建新属性，属性存在时，更新属性指向的对象。\n\n##### 数据属性引用\n\n示例1：\n```Python\nclass Dog:\n\n    kind = 'canine'\n    country = 'China'\n\n    def __init__(self, name, age, country):\n        self.name = name\n        self.age = age\n        self.country = country\n\ndog = Dog('Lily', 3, 'Britain')\nprint(dog.name, dog.age, dog.kind, dog.country)\n# output: Lily 3 canine Britain\n\n```\n类对象`Dog`与实例对象`dog`均有属性`country`，按照规则，`dog.country`会引用到实例对象的属性；但实例对象`dog`没有属性`kind`，按照规则会引用类对象的属性。\n\n示例2：\n```python\nclass Dog:\n\n    kind = 'canine'\n    country = 'China'\n\n    def __init__(self, name, age, country):\n        self.name = name\n        self.age = age\n        self.country = country\n\ndog = Dog('Lily', 3, 'Britain')\nprint(dog.name, dog.age, dog.kind, dog.country) # Lily 3 canine Britain\nprint(dog.__dict__) # {'name': 'Lily', 'age': 3, 'country': 'Britain'}\n\ndog.kind = 'feline'\nprint(dog.name, dog.age, dog.kind, dog.country) # Lily 3 feline Britain\nprint(dog.__dict__)  # {'name': 'Lily', 'age': 3, 'country': 'Britain', 'kind': 'feline'}\nprint(Dog.kind) # canine 没有改变类属性的指向\n\n```\n\n示例3，可变类属性引用：\n\n```python\n\nclass Dog:\n\n    tricks = []\n\n    def __init__(self, name):\n        self.name = name\n\n    def add_trick(self, trick):\n        # self.tricks.append(trick)\n        Dog.tricks.append(trick)\n\nd = Dog('Fido')\ne = Dog('Buddy')\nd.add_trick('roll over')\ne.add_trick('play dead')\nprint(d.tricks) # ['roll over', 'play dead']\n```\n\n语句`self.tricks.append(trick)`并不是属性绑定语句，因此还是在类属性上修改可变对象。\n\n##### 方法属性引用\n\n与数据成员不同，类函数属性在实例对象中会变成方法属性。先看一个示例：\n\n```Python\nclass MethodTest:\n\n    def inner_test(self):\n        print('in class')\n\ndef outer_test():\n    print('out of class')\n\nmt = MethodTest()\nmt.outer_test = outer_test\n\nprint(type(MethodTest.inner_test))  # <class 'function'> 类函数\nprint(type(mt.inner_test))          #<class 'method'> 类方法\nprint(type(mt.outer_test))          #<class 'function'> 类函数\n\n```\n可以看到，类函数属性在实例对象中变成了方法属性，但是并不是实例对象中所有的函数都是方法。\n\nPython tutorial中这样介绍方法对象：\n\n>When an instance attribute is referenced that isn’t a data attribute, its class is searched. If the name denotes a valid class attribute that is a function object, a method object is created by packing (pointers to) the instance object and the function object just found together in an abstract object: this is the method object. When the method object is called with an argument list, a new argument list is constructed from the instance object and the argument list, and the function object is called with this new argument list.\n\n引用非数据属性的实例属性时，会搜索它对应的类。如果名字是一个有效的函数对象，Python会将实例对象连同函数对象打包到一个抽象的对象中并且依据这个对象创建方法对象：这就是被调用的方法对象。当使用参数列表调用方法对象时，会使用实例对象以及原有参数列表构建新的参数列表，并且使用新的参数列表调用函数对象。\n\n那么，实例对象只有在引用方法属性时，才会将自身作为第一个参数传递；调用实例对象的普通函数，则不会。  \n所以可以使用如下方式直接调用方法与函数：\n\n```python\nmt.inner_test()\nmt.outer_test()\n```\n除了方法与函数的区别，其引用与数据属性都是一样的\n\n### 最佳实践\n\n虽然`Python`作为动态语言，支持在运行时绑定属性，但是从面向对象的角度来看，还是在定义类的时候将属性确定下来。\n\n\n\n\n\n\n\n\n参考:\n1. http://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block\n2. https://www.cnblogs.com/crazyrunning/p/6945183.html\n","slug":"Python3-类变量和实例变量","published":1,"updated":"2018-03-01T08:05:39.909Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozlt003p8motflgws4wq","content":"<h3 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h3><p>首先来一张图<br><img src=\"http://upload-images.jianshu.io/upload_images/2952111-07f6d669392b20c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"classvariable.png\"></p>\n<h3 id=\"类变量和实例变量\"><a href=\"#类变量和实例变量\" class=\"headerlink\" title=\"类变量和实例变量\"></a>类变量和实例变量</h3><p>在Python Tutorial中对于类变量和实例变量是这样描述的：</p>\n<blockquote>\n<p>Generally speaking, instance variables are for data unique to each instance and class variables are for attributes and methods shared by all instances of the class:</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span>:</span></span><br><span class=\"line\">    kind = <span class=\"string\">'canine'</span>         <span class=\"comment\"># class variable shared by all instances</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, name)</span>:</span></span><br><span class=\"line\">        self.name = name    <span class=\"comment\"># instance variable unique to each instance</span></span><br></pre></td></tr></table></figure>\n<p>类<code>Dog</code>中，类属性<code>kind</code>为所有实例所共享；实例属性<code>name</code>为每个<code>Dog</code>的实例独有。<br><a id=\"more\"></a></p>\n<h4 id=\"类变量：\"><a href=\"#类变量：\" class=\"headerlink\" title=\"类变量：\"></a>类变量：</h4><blockquote>\n<p>​    是可在类的所有实例之间共享的值（也就是说，它们不是单独分配给每个实例的）。例如下例中，num_of_instance 就是类变量，用于跟踪存在着多少个Test 的实例。</p>\n</blockquote>\n<h4 id=\"实例变量：\"><a href=\"#实例变量：\" class=\"headerlink\" title=\"实例变量：\"></a>实例变量：</h4><blockquote>\n<p>实例化之后，每个实例单独拥有的变量。</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span><span class=\"params\">(object)</span>:</span>  </span><br><span class=\"line\">    num_of_instance = <span class=\"number\">0</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, name)</span>:</span>  </span><br><span class=\"line\">        self.name = name  </span><br><span class=\"line\">        Test.num_of_instance += <span class=\"number\">1</span>  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:  </span><br><span class=\"line\">    <span class=\"keyword\">print</span> Test.num_of_instance   <span class=\"comment\"># 0</span></span><br><span class=\"line\">    t1 = Test(<span class=\"string\">'jack'</span>)  </span><br><span class=\"line\">    <span class=\"keyword\">print</span> Test.num_of_instance   <span class=\"comment\"># 1</span></span><br><span class=\"line\">    t2 = Test(<span class=\"string\">'lucy'</span>)  </span><br><span class=\"line\">    <span class=\"keyword\">print</span> t1.name , t1.num_of_instance  <span class=\"comment\"># jack 2</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> t2.name , t2.num_of_instance  <span class=\"comment\"># lucy 2</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>补充的例子</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>:</span></span><br><span class=\"line\">    name=<span class=\"string\">\"aaa\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">p1=Person()</span><br><span class=\"line\">p2=Person()</span><br><span class=\"line\">p1.name=<span class=\"string\">\"bbb\"</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> p1.name  <span class=\"comment\"># bbb</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> p2.name  <span class=\"comment\"># aaa</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> Person.name  <span class=\"comment\"># aaa</span></span><br></pre></td></tr></table></figure>\n<p>这里<code>p1.name=&quot;bbb&quot;</code>是实例调用了类变量,属于函数传参的问题,<code>p1.name</code>一开始是指向的类变量<code>name=&quot;aaa&quot;</code>,但是在实例的作用域里把类变量的引用改变了,就变成了一个实例变量,self.name不再引用Person的类变量name了.</p>\n<p>可以看看下面的例子:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>:</span></span><br><span class=\"line\">    name=[]</span><br><span class=\"line\"></span><br><span class=\"line\">p1=Person()</span><br><span class=\"line\">p2=Person()</span><br><span class=\"line\">p1.name.append(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">print</span> p1.name  <span class=\"comment\"># [1]</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> p2.name  <span class=\"comment\"># [1]</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> Person.name  <span class=\"comment\"># [1]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"类对象和实例对象\"><a href=\"#类对象和实例对象\" class=\"headerlink\" title=\"类对象和实例对象\"></a>类对象和实例对象</h3><h4 id=\"类对象\"><a href=\"#类对象\" class=\"headerlink\" title=\"类对象\"></a>类对象</h4><p><code>Python</code>中一切皆对象；类定义完成后，会在当前作用域中定义一个以类名为名字，指向类对象的名字。如<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure></p>\n<p>会在当前作用域定义名字<code>Dog</code>，指向类对象<code>Dog</code>。</p>\n<p><strong>类对象支持的操作</strong>：<br>总的来说，类对象仅支持两个操作：</p>\n<ol>\n<li>实例化；使用<code>instance_name = class_name()</code>的方式实例化，实例化操作创建该类的实例。</li>\n<li>属性引用；使用<code>class_name.attr_name</code>的方式引用类属性。</li>\n</ol>\n<h4 id=\"实例对象\"><a href=\"#实例对象\" class=\"headerlink\" title=\"实例对象\"></a>实例对象</h4><p><strong>实例对象是类对象实例化的产物，实例对象仅支持一个操作</strong>:</p>\n<ol>\n<li>属性引用；与类对象属性引用的方式相同，使用<code>instance_name.attr_name</code>的方式。</li>\n</ol>\n<p>按照严格的面向对象思想，所有属性都应该是实例的，类属性不应该存在。那么在<code>Python</code>中，由于类属性绑定就不应该存在，类定义中就只剩下函数定义了。</p>\n<p>在<a href=\"https://docs.python.org/3/tutorial/classes.html#class-definition-syntax\" target=\"_blank\" rel=\"noopener\">Python tutorial</a>关于类定义也这么说：</p>\n<blockquote>\n<p>In practice, the statements inside a class definition will usually be function definitions, but other statements are allowed, and sometimes useful.</p>\n</blockquote>\n<p>实践中，类定义中的语句通常是函数定义，但是其他语句也是允许的，有时也是有用的。</p>\n<p>这里说的其他语句，就是指类属性的绑定语句。</p>\n<h3 id=\"属性绑定\"><a href=\"#属性绑定\" class=\"headerlink\" title=\"属性绑定\"></a>属性绑定</h3><p>在定义类时，通常我们说的定义属性，其实是分为两个方面的：</p>\n<ol>\n<li>类属性绑定</li>\n<li>实例属性绑定</li>\n</ol>\n<p>用<strong>绑定</strong>这个词更加确切；不管是类对象还是实例对象，属性都是依托对象而存在的。</p>\n<p>我们说的属性绑定，首先需要一个可变对象，才能执行绑定操作，使用</p>\n<pre><code>objname.attr = attr_value\n</code></pre><p>的方式，为对象<code>objname</code>绑定属性<code>attr</code>。</p>\n<p>这分两种情况：</p>\n<ol>\n<li>若属性<code>attr</code>已经存在，绑定操作会将属性名指向新的对象；</li>\n<li>若不存在，则为该对象添加新的属性，后面就可以引用新增属性。</li>\n</ol>\n<h4 id=\"类属性绑定\"><a href=\"#类属性绑定\" class=\"headerlink\" title=\"类属性绑定\"></a>类属性绑定</h4><p><code>Python</code>作为动态语言，类对象和实例对象都可以在运行时绑定任意属性。因此，类属性的绑定发生在两个地方：</p>\n<ol>\n<li>类定义时；</li>\n<li>运行时任意阶段。</li>\n</ol>\n<p>下面这个例子说明了类属性绑定发生的时期：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span>:</span></span><br><span class=\"line\">    kind = <span class=\"string\">'canine'</span></span><br><span class=\"line\"></span><br><span class=\"line\">Dog.country = <span class=\"string\">'China'</span></span><br><span class=\"line\">print(Dog.kind, <span class=\"string\">' - '</span>, Dog.country) <span class=\"comment\"># output: canine - China</span></span><br><span class=\"line\"><span class=\"keyword\">del</span> Dog.kind</span><br><span class=\"line\">print(Dog.kind, <span class=\"string\">' - '</span>, Dog.country)</span><br><span class=\"line\"><span class=\"comment\"># AttributeError: type object 'Dog' has no attribute 'kind'</span></span><br></pre></td></tr></table></figure></p>\n<p>在类定义中，类属性的绑定并没有使用<code>objname.attr = attr_value</code>的方式，这是一个特例，其实是等同于后面使用类名绑定属性的方式。<br>因为是动态语言，所以可以在运行时增加属性，删除属性。</p>\n<h4 id=\"实例属性绑定\"><a href=\"#实例属性绑定\" class=\"headerlink\" title=\"实例属性绑定\"></a>实例属性绑定</h4><p>与类属性绑定相同，实例属性绑定也发生在两个地方：</p>\n<ol>\n<li>类定义时；</li>\n<li>运行时任意阶段。</li>\n</ol>\n<p>示例：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, name, age)</span>:</span></span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\">        self.age = age</span><br><span class=\"line\"></span><br><span class=\"line\">dog = Dog(<span class=\"string\">'Lily'</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">dog.fur_color = <span class=\"string\">'red'</span></span><br><span class=\"line\">print(<span class=\"string\">'%s is %s years old, it has %s fur'</span> % (dog.name, dog.age, dog.fur_color))</span><br><span class=\"line\"><span class=\"comment\"># Output: Lily is 3 years old, it has red fur</span></span><br></pre></td></tr></table></figure></p>\n<p><code>Python</code>类实例有两个特殊之处：</p>\n<ol>\n<li><code>__init__</code>在实例化时执行</li>\n<li><code>Python</code>实例调用方法时，会将实例对象作为第一个参数传递</li>\n</ol>\n<p>因此，<code>__init__</code>方法中的<code>self</code>就是实例对象本身，这里是<code>dog</code>，语句<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.name = name</span><br><span class=\"line\">self.age = age</span><br></pre></td></tr></table></figure></p>\n<p>以及后面的语句<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dog.fur_color = <span class=\"string\">'red'</span></span><br></pre></td></tr></table></figure></p>\n<p>为实例<code>dog</code>增加三个属性<code>name</code>, <code>age</code>, <code>fur_color</code>。</p>\n<h3 id=\"属性引用\"><a href=\"#属性引用\" class=\"headerlink\" title=\"属性引用\"></a>属性引用</h3><h4 id=\"类属属性引用\"><a href=\"#类属属性引用\" class=\"headerlink\" title=\"类属属性引用\"></a>类属属性引用</h4><p>类属性的引用，肯定是需要类对象的，属性分为两种：</p>\n<ol>\n<li>数据属性</li>\n<li>函数属性</li>\n</ol>\n<p>数据属性引用很简单，示例：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span>:</span></span><br><span class=\"line\">    kind = <span class=\"string\">'canine'</span></span><br><span class=\"line\"></span><br><span class=\"line\">Dog.country = <span class=\"string\">'China'</span></span><br><span class=\"line\">print(Dog.kind, <span class=\"string\">' - '</span>, Dog.country) <span class=\"comment\"># output: canine - China</span></span><br></pre></td></tr></table></figure></p>\n<p>通常很少有引用类函数属性的需求，示例：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span>:</span></span><br><span class=\"line\">    kind = <span class=\"string\">'canine'</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">tell_kind</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">        print(Dog.kind)</span><br><span class=\"line\"></span><br><span class=\"line\">Dog.tell_kind() <span class=\"comment\"># Output: canine</span></span><br></pre></td></tr></table></figure></p>\n<p>函数<code>tell_kind</code>在引用<code>kind</code>需要使用<code>Dog.kind</code>而不是直接使用<code>kind</code>，涉及到作用域，这一点在我的另一篇文章中有介绍：<a href=\"http://www.cnblogs.com/crazyrunning/p/6914080.html\" target=\"_blank\" rel=\"noopener\">Python进阶 - 命名空间与作用域</a></p>\n<h4 id=\"实例属性引用\"><a href=\"#实例属性引用\" class=\"headerlink\" title=\"实例属性引用\"></a>实例属性引用</h4><p>使用实例对象引用属性稍微复杂一些，因为实例对象可引用类属性以及实例属性。但是实例对象引用属性时遵循以下规则：</p>\n<ol>\n<li>总是先到实例对象中查找属性，再到类属性中查找属性；</li>\n<li>属性绑定语句总是为实例对象创建新属性，属性存在时，更新属性指向的对象。</li>\n</ol>\n<h5 id=\"数据属性引用\"><a href=\"#数据属性引用\" class=\"headerlink\" title=\"数据属性引用\"></a>数据属性引用</h5><p>示例1：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    kind = <span class=\"string\">'canine'</span></span><br><span class=\"line\">    country = <span class=\"string\">'China'</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, name, age, country)</span>:</span></span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\">        self.age = age</span><br><span class=\"line\">        self.country = country</span><br><span class=\"line\"></span><br><span class=\"line\">dog = Dog(<span class=\"string\">'Lily'</span>, <span class=\"number\">3</span>, <span class=\"string\">'Britain'</span>)</span><br><span class=\"line\">print(dog.name, dog.age, dog.kind, dog.country)</span><br><span class=\"line\"><span class=\"comment\"># output: Lily 3 canine Britain</span></span><br></pre></td></tr></table></figure></p>\n<p>类对象<code>Dog</code>与实例对象<code>dog</code>均有属性<code>country</code>，按照规则，<code>dog.country</code>会引用到实例对象的属性；但实例对象<code>dog</code>没有属性<code>kind</code>，按照规则会引用类对象的属性。</p>\n<p>示例2：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    kind = <span class=\"string\">'canine'</span></span><br><span class=\"line\">    country = <span class=\"string\">'China'</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, name, age, country)</span>:</span></span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\">        self.age = age</span><br><span class=\"line\">        self.country = country</span><br><span class=\"line\"></span><br><span class=\"line\">dog = Dog(<span class=\"string\">'Lily'</span>, <span class=\"number\">3</span>, <span class=\"string\">'Britain'</span>)</span><br><span class=\"line\">print(dog.name, dog.age, dog.kind, dog.country) <span class=\"comment\"># Lily 3 canine Britain</span></span><br><span class=\"line\">print(dog.__dict__) <span class=\"comment\"># &#123;'name': 'Lily', 'age': 3, 'country': 'Britain'&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">dog.kind = <span class=\"string\">'feline'</span></span><br><span class=\"line\">print(dog.name, dog.age, dog.kind, dog.country) <span class=\"comment\"># Lily 3 feline Britain</span></span><br><span class=\"line\">print(dog.__dict__)  <span class=\"comment\"># &#123;'name': 'Lily', 'age': 3, 'country': 'Britain', 'kind': 'feline'&#125;</span></span><br><span class=\"line\">print(Dog.kind) <span class=\"comment\"># canine 没有改变类属性的指向</span></span><br></pre></td></tr></table></figure></p>\n<p>示例3，可变类属性引用：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    tricks = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, name)</span>:</span></span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_trick</span><span class=\"params\">(self, trick)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># self.tricks.append(trick)</span></span><br><span class=\"line\">        Dog.tricks.append(trick)</span><br><span class=\"line\"></span><br><span class=\"line\">d = Dog(<span class=\"string\">'Fido'</span>)</span><br><span class=\"line\">e = Dog(<span class=\"string\">'Buddy'</span>)</span><br><span class=\"line\">d.add_trick(<span class=\"string\">'roll over'</span>)</span><br><span class=\"line\">e.add_trick(<span class=\"string\">'play dead'</span>)</span><br><span class=\"line\">print(d.tricks) <span class=\"comment\"># ['roll over', 'play dead']</span></span><br></pre></td></tr></table></figure>\n<p>语句<code>self.tricks.append(trick)</code>并不是属性绑定语句，因此还是在类属性上修改可变对象。</p>\n<h5 id=\"方法属性引用\"><a href=\"#方法属性引用\" class=\"headerlink\" title=\"方法属性引用\"></a>方法属性引用</h5><p>与数据成员不同，类函数属性在实例对象中会变成方法属性。先看一个示例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MethodTest</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inner_test</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'in class'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">outer_test</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'out of class'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">mt = MethodTest()</span><br><span class=\"line\">mt.outer_test = outer_test</span><br><span class=\"line\"></span><br><span class=\"line\">print(type(MethodTest.inner_test))  <span class=\"comment\"># &lt;class 'function'&gt; 类函数</span></span><br><span class=\"line\">print(type(mt.inner_test))          <span class=\"comment\">#&lt;class 'method'&gt; 类方法</span></span><br><span class=\"line\">print(type(mt.outer_test))          <span class=\"comment\">#&lt;class 'function'&gt; 类函数</span></span><br></pre></td></tr></table></figure>\n<p>可以看到，类函数属性在实例对象中变成了方法属性，但是并不是实例对象中所有的函数都是方法。</p>\n<p>Python tutorial中这样介绍方法对象：</p>\n<blockquote>\n<p>When an instance attribute is referenced that isn’t a data attribute, its class is searched. If the name denotes a valid class attribute that is a function object, a method object is created by packing (pointers to) the instance object and the function object just found together in an abstract object: this is the method object. When the method object is called with an argument list, a new argument list is constructed from the instance object and the argument list, and the function object is called with this new argument list.</p>\n</blockquote>\n<p>引用非数据属性的实例属性时，会搜索它对应的类。如果名字是一个有效的函数对象，Python会将实例对象连同函数对象打包到一个抽象的对象中并且依据这个对象创建方法对象：这就是被调用的方法对象。当使用参数列表调用方法对象时，会使用实例对象以及原有参数列表构建新的参数列表，并且使用新的参数列表调用函数对象。</p>\n<p>那么，实例对象只有在引用方法属性时，才会将自身作为第一个参数传递；调用实例对象的普通函数，则不会。<br>所以可以使用如下方式直接调用方法与函数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mt.inner_test()</span><br><span class=\"line\">mt.outer_test()</span><br></pre></td></tr></table></figure>\n<p>除了方法与函数的区别，其引用与数据属性都是一样的</p>\n<h3 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><p>虽然<code>Python</code>作为动态语言，支持在运行时绑定属性，但是从面向对象的角度来看，还是在定义类的时候将属性确定下来。</p>\n<p>参考:</p>\n<ol>\n<li><a href=\"http://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block\" target=\"_blank\" rel=\"noopener\">http://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block</a></li>\n<li><a href=\"https://www.cnblogs.com/crazyrunning/p/6945183.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/crazyrunning/p/6945183.html</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h3><p>首先来一张图<br><img src=\"http://upload-images.jianshu.io/upload_images/2952111-07f6d669392b20c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"classvariable.png\"></p>\n<h3 id=\"类变量和实例变量\"><a href=\"#类变量和实例变量\" class=\"headerlink\" title=\"类变量和实例变量\"></a>类变量和实例变量</h3><p>在Python Tutorial中对于类变量和实例变量是这样描述的：</p>\n<blockquote>\n<p>Generally speaking, instance variables are for data unique to each instance and class variables are for attributes and methods shared by all instances of the class:</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span>:</span></span><br><span class=\"line\">    kind = <span class=\"string\">'canine'</span>         <span class=\"comment\"># class variable shared by all instances</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, name)</span>:</span></span><br><span class=\"line\">        self.name = name    <span class=\"comment\"># instance variable unique to each instance</span></span><br></pre></td></tr></table></figure>\n<p>类<code>Dog</code>中，类属性<code>kind</code>为所有实例所共享；实例属性<code>name</code>为每个<code>Dog</code>的实例独有。<br>","more":"</p>\n<h4 id=\"类变量：\"><a href=\"#类变量：\" class=\"headerlink\" title=\"类变量：\"></a>类变量：</h4><blockquote>\n<p>​    是可在类的所有实例之间共享的值（也就是说，它们不是单独分配给每个实例的）。例如下例中，num_of_instance 就是类变量，用于跟踪存在着多少个Test 的实例。</p>\n</blockquote>\n<h4 id=\"实例变量：\"><a href=\"#实例变量：\" class=\"headerlink\" title=\"实例变量：\"></a>实例变量：</h4><blockquote>\n<p>实例化之后，每个实例单独拥有的变量。</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span><span class=\"params\">(object)</span>:</span>  </span><br><span class=\"line\">    num_of_instance = <span class=\"number\">0</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, name)</span>:</span>  </span><br><span class=\"line\">        self.name = name  </span><br><span class=\"line\">        Test.num_of_instance += <span class=\"number\">1</span>  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:  </span><br><span class=\"line\">    <span class=\"keyword\">print</span> Test.num_of_instance   <span class=\"comment\"># 0</span></span><br><span class=\"line\">    t1 = Test(<span class=\"string\">'jack'</span>)  </span><br><span class=\"line\">    <span class=\"keyword\">print</span> Test.num_of_instance   <span class=\"comment\"># 1</span></span><br><span class=\"line\">    t2 = Test(<span class=\"string\">'lucy'</span>)  </span><br><span class=\"line\">    <span class=\"keyword\">print</span> t1.name , t1.num_of_instance  <span class=\"comment\"># jack 2</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> t2.name , t2.num_of_instance  <span class=\"comment\"># lucy 2</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>补充的例子</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>:</span></span><br><span class=\"line\">    name=<span class=\"string\">\"aaa\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">p1=Person()</span><br><span class=\"line\">p2=Person()</span><br><span class=\"line\">p1.name=<span class=\"string\">\"bbb\"</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> p1.name  <span class=\"comment\"># bbb</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> p2.name  <span class=\"comment\"># aaa</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> Person.name  <span class=\"comment\"># aaa</span></span><br></pre></td></tr></table></figure>\n<p>这里<code>p1.name=&quot;bbb&quot;</code>是实例调用了类变量,属于函数传参的问题,<code>p1.name</code>一开始是指向的类变量<code>name=&quot;aaa&quot;</code>,但是在实例的作用域里把类变量的引用改变了,就变成了一个实例变量,self.name不再引用Person的类变量name了.</p>\n<p>可以看看下面的例子:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>:</span></span><br><span class=\"line\">    name=[]</span><br><span class=\"line\"></span><br><span class=\"line\">p1=Person()</span><br><span class=\"line\">p2=Person()</span><br><span class=\"line\">p1.name.append(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">print</span> p1.name  <span class=\"comment\"># [1]</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> p2.name  <span class=\"comment\"># [1]</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> Person.name  <span class=\"comment\"># [1]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"类对象和实例对象\"><a href=\"#类对象和实例对象\" class=\"headerlink\" title=\"类对象和实例对象\"></a>类对象和实例对象</h3><h4 id=\"类对象\"><a href=\"#类对象\" class=\"headerlink\" title=\"类对象\"></a>类对象</h4><p><code>Python</code>中一切皆对象；类定义完成后，会在当前作用域中定义一个以类名为名字，指向类对象的名字。如<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure></p>\n<p>会在当前作用域定义名字<code>Dog</code>，指向类对象<code>Dog</code>。</p>\n<p><strong>类对象支持的操作</strong>：<br>总的来说，类对象仅支持两个操作：</p>\n<ol>\n<li>实例化；使用<code>instance_name = class_name()</code>的方式实例化，实例化操作创建该类的实例。</li>\n<li>属性引用；使用<code>class_name.attr_name</code>的方式引用类属性。</li>\n</ol>\n<h4 id=\"实例对象\"><a href=\"#实例对象\" class=\"headerlink\" title=\"实例对象\"></a>实例对象</h4><p><strong>实例对象是类对象实例化的产物，实例对象仅支持一个操作</strong>:</p>\n<ol>\n<li>属性引用；与类对象属性引用的方式相同，使用<code>instance_name.attr_name</code>的方式。</li>\n</ol>\n<p>按照严格的面向对象思想，所有属性都应该是实例的，类属性不应该存在。那么在<code>Python</code>中，由于类属性绑定就不应该存在，类定义中就只剩下函数定义了。</p>\n<p>在<a href=\"https://docs.python.org/3/tutorial/classes.html#class-definition-syntax\" target=\"_blank\" rel=\"noopener\">Python tutorial</a>关于类定义也这么说：</p>\n<blockquote>\n<p>In practice, the statements inside a class definition will usually be function definitions, but other statements are allowed, and sometimes useful.</p>\n</blockquote>\n<p>实践中，类定义中的语句通常是函数定义，但是其他语句也是允许的，有时也是有用的。</p>\n<p>这里说的其他语句，就是指类属性的绑定语句。</p>\n<h3 id=\"属性绑定\"><a href=\"#属性绑定\" class=\"headerlink\" title=\"属性绑定\"></a>属性绑定</h3><p>在定义类时，通常我们说的定义属性，其实是分为两个方面的：</p>\n<ol>\n<li>类属性绑定</li>\n<li>实例属性绑定</li>\n</ol>\n<p>用<strong>绑定</strong>这个词更加确切；不管是类对象还是实例对象，属性都是依托对象而存在的。</p>\n<p>我们说的属性绑定，首先需要一个可变对象，才能执行绑定操作，使用</p>\n<pre><code>objname.attr = attr_value\n</code></pre><p>的方式，为对象<code>objname</code>绑定属性<code>attr</code>。</p>\n<p>这分两种情况：</p>\n<ol>\n<li>若属性<code>attr</code>已经存在，绑定操作会将属性名指向新的对象；</li>\n<li>若不存在，则为该对象添加新的属性，后面就可以引用新增属性。</li>\n</ol>\n<h4 id=\"类属性绑定\"><a href=\"#类属性绑定\" class=\"headerlink\" title=\"类属性绑定\"></a>类属性绑定</h4><p><code>Python</code>作为动态语言，类对象和实例对象都可以在运行时绑定任意属性。因此，类属性的绑定发生在两个地方：</p>\n<ol>\n<li>类定义时；</li>\n<li>运行时任意阶段。</li>\n</ol>\n<p>下面这个例子说明了类属性绑定发生的时期：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span>:</span></span><br><span class=\"line\">    kind = <span class=\"string\">'canine'</span></span><br><span class=\"line\"></span><br><span class=\"line\">Dog.country = <span class=\"string\">'China'</span></span><br><span class=\"line\">print(Dog.kind, <span class=\"string\">' - '</span>, Dog.country) <span class=\"comment\"># output: canine - China</span></span><br><span class=\"line\"><span class=\"keyword\">del</span> Dog.kind</span><br><span class=\"line\">print(Dog.kind, <span class=\"string\">' - '</span>, Dog.country)</span><br><span class=\"line\"><span class=\"comment\"># AttributeError: type object 'Dog' has no attribute 'kind'</span></span><br></pre></td></tr></table></figure></p>\n<p>在类定义中，类属性的绑定并没有使用<code>objname.attr = attr_value</code>的方式，这是一个特例，其实是等同于后面使用类名绑定属性的方式。<br>因为是动态语言，所以可以在运行时增加属性，删除属性。</p>\n<h4 id=\"实例属性绑定\"><a href=\"#实例属性绑定\" class=\"headerlink\" title=\"实例属性绑定\"></a>实例属性绑定</h4><p>与类属性绑定相同，实例属性绑定也发生在两个地方：</p>\n<ol>\n<li>类定义时；</li>\n<li>运行时任意阶段。</li>\n</ol>\n<p>示例：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, name, age)</span>:</span></span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\">        self.age = age</span><br><span class=\"line\"></span><br><span class=\"line\">dog = Dog(<span class=\"string\">'Lily'</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">dog.fur_color = <span class=\"string\">'red'</span></span><br><span class=\"line\">print(<span class=\"string\">'%s is %s years old, it has %s fur'</span> % (dog.name, dog.age, dog.fur_color))</span><br><span class=\"line\"><span class=\"comment\"># Output: Lily is 3 years old, it has red fur</span></span><br></pre></td></tr></table></figure></p>\n<p><code>Python</code>类实例有两个特殊之处：</p>\n<ol>\n<li><code>__init__</code>在实例化时执行</li>\n<li><code>Python</code>实例调用方法时，会将实例对象作为第一个参数传递</li>\n</ol>\n<p>因此，<code>__init__</code>方法中的<code>self</code>就是实例对象本身，这里是<code>dog</code>，语句<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.name = name</span><br><span class=\"line\">self.age = age</span><br></pre></td></tr></table></figure></p>\n<p>以及后面的语句<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dog.fur_color = <span class=\"string\">'red'</span></span><br></pre></td></tr></table></figure></p>\n<p>为实例<code>dog</code>增加三个属性<code>name</code>, <code>age</code>, <code>fur_color</code>。</p>\n<h3 id=\"属性引用\"><a href=\"#属性引用\" class=\"headerlink\" title=\"属性引用\"></a>属性引用</h3><h4 id=\"类属属性引用\"><a href=\"#类属属性引用\" class=\"headerlink\" title=\"类属属性引用\"></a>类属属性引用</h4><p>类属性的引用，肯定是需要类对象的，属性分为两种：</p>\n<ol>\n<li>数据属性</li>\n<li>函数属性</li>\n</ol>\n<p>数据属性引用很简单，示例：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span>:</span></span><br><span class=\"line\">    kind = <span class=\"string\">'canine'</span></span><br><span class=\"line\"></span><br><span class=\"line\">Dog.country = <span class=\"string\">'China'</span></span><br><span class=\"line\">print(Dog.kind, <span class=\"string\">' - '</span>, Dog.country) <span class=\"comment\"># output: canine - China</span></span><br></pre></td></tr></table></figure></p>\n<p>通常很少有引用类函数属性的需求，示例：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span>:</span></span><br><span class=\"line\">    kind = <span class=\"string\">'canine'</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">tell_kind</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">        print(Dog.kind)</span><br><span class=\"line\"></span><br><span class=\"line\">Dog.tell_kind() <span class=\"comment\"># Output: canine</span></span><br></pre></td></tr></table></figure></p>\n<p>函数<code>tell_kind</code>在引用<code>kind</code>需要使用<code>Dog.kind</code>而不是直接使用<code>kind</code>，涉及到作用域，这一点在我的另一篇文章中有介绍：<a href=\"http://www.cnblogs.com/crazyrunning/p/6914080.html\" target=\"_blank\" rel=\"noopener\">Python进阶 - 命名空间与作用域</a></p>\n<h4 id=\"实例属性引用\"><a href=\"#实例属性引用\" class=\"headerlink\" title=\"实例属性引用\"></a>实例属性引用</h4><p>使用实例对象引用属性稍微复杂一些，因为实例对象可引用类属性以及实例属性。但是实例对象引用属性时遵循以下规则：</p>\n<ol>\n<li>总是先到实例对象中查找属性，再到类属性中查找属性；</li>\n<li>属性绑定语句总是为实例对象创建新属性，属性存在时，更新属性指向的对象。</li>\n</ol>\n<h5 id=\"数据属性引用\"><a href=\"#数据属性引用\" class=\"headerlink\" title=\"数据属性引用\"></a>数据属性引用</h5><p>示例1：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    kind = <span class=\"string\">'canine'</span></span><br><span class=\"line\">    country = <span class=\"string\">'China'</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, name, age, country)</span>:</span></span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\">        self.age = age</span><br><span class=\"line\">        self.country = country</span><br><span class=\"line\"></span><br><span class=\"line\">dog = Dog(<span class=\"string\">'Lily'</span>, <span class=\"number\">3</span>, <span class=\"string\">'Britain'</span>)</span><br><span class=\"line\">print(dog.name, dog.age, dog.kind, dog.country)</span><br><span class=\"line\"><span class=\"comment\"># output: Lily 3 canine Britain</span></span><br></pre></td></tr></table></figure></p>\n<p>类对象<code>Dog</code>与实例对象<code>dog</code>均有属性<code>country</code>，按照规则，<code>dog.country</code>会引用到实例对象的属性；但实例对象<code>dog</code>没有属性<code>kind</code>，按照规则会引用类对象的属性。</p>\n<p>示例2：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    kind = <span class=\"string\">'canine'</span></span><br><span class=\"line\">    country = <span class=\"string\">'China'</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, name, age, country)</span>:</span></span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\">        self.age = age</span><br><span class=\"line\">        self.country = country</span><br><span class=\"line\"></span><br><span class=\"line\">dog = Dog(<span class=\"string\">'Lily'</span>, <span class=\"number\">3</span>, <span class=\"string\">'Britain'</span>)</span><br><span class=\"line\">print(dog.name, dog.age, dog.kind, dog.country) <span class=\"comment\"># Lily 3 canine Britain</span></span><br><span class=\"line\">print(dog.__dict__) <span class=\"comment\"># &#123;'name': 'Lily', 'age': 3, 'country': 'Britain'&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">dog.kind = <span class=\"string\">'feline'</span></span><br><span class=\"line\">print(dog.name, dog.age, dog.kind, dog.country) <span class=\"comment\"># Lily 3 feline Britain</span></span><br><span class=\"line\">print(dog.__dict__)  <span class=\"comment\"># &#123;'name': 'Lily', 'age': 3, 'country': 'Britain', 'kind': 'feline'&#125;</span></span><br><span class=\"line\">print(Dog.kind) <span class=\"comment\"># canine 没有改变类属性的指向</span></span><br></pre></td></tr></table></figure></p>\n<p>示例3，可变类属性引用：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    tricks = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, name)</span>:</span></span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_trick</span><span class=\"params\">(self, trick)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\"># self.tricks.append(trick)</span></span><br><span class=\"line\">        Dog.tricks.append(trick)</span><br><span class=\"line\"></span><br><span class=\"line\">d = Dog(<span class=\"string\">'Fido'</span>)</span><br><span class=\"line\">e = Dog(<span class=\"string\">'Buddy'</span>)</span><br><span class=\"line\">d.add_trick(<span class=\"string\">'roll over'</span>)</span><br><span class=\"line\">e.add_trick(<span class=\"string\">'play dead'</span>)</span><br><span class=\"line\">print(d.tricks) <span class=\"comment\"># ['roll over', 'play dead']</span></span><br></pre></td></tr></table></figure>\n<p>语句<code>self.tricks.append(trick)</code>并不是属性绑定语句，因此还是在类属性上修改可变对象。</p>\n<h5 id=\"方法属性引用\"><a href=\"#方法属性引用\" class=\"headerlink\" title=\"方法属性引用\"></a>方法属性引用</h5><p>与数据成员不同，类函数属性在实例对象中会变成方法属性。先看一个示例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MethodTest</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inner_test</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'in class'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">outer_test</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">'out of class'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">mt = MethodTest()</span><br><span class=\"line\">mt.outer_test = outer_test</span><br><span class=\"line\"></span><br><span class=\"line\">print(type(MethodTest.inner_test))  <span class=\"comment\"># &lt;class 'function'&gt; 类函数</span></span><br><span class=\"line\">print(type(mt.inner_test))          <span class=\"comment\">#&lt;class 'method'&gt; 类方法</span></span><br><span class=\"line\">print(type(mt.outer_test))          <span class=\"comment\">#&lt;class 'function'&gt; 类函数</span></span><br></pre></td></tr></table></figure>\n<p>可以看到，类函数属性在实例对象中变成了方法属性，但是并不是实例对象中所有的函数都是方法。</p>\n<p>Python tutorial中这样介绍方法对象：</p>\n<blockquote>\n<p>When an instance attribute is referenced that isn’t a data attribute, its class is searched. If the name denotes a valid class attribute that is a function object, a method object is created by packing (pointers to) the instance object and the function object just found together in an abstract object: this is the method object. When the method object is called with an argument list, a new argument list is constructed from the instance object and the argument list, and the function object is called with this new argument list.</p>\n</blockquote>\n<p>引用非数据属性的实例属性时，会搜索它对应的类。如果名字是一个有效的函数对象，Python会将实例对象连同函数对象打包到一个抽象的对象中并且依据这个对象创建方法对象：这就是被调用的方法对象。当使用参数列表调用方法对象时，会使用实例对象以及原有参数列表构建新的参数列表，并且使用新的参数列表调用函数对象。</p>\n<p>那么，实例对象只有在引用方法属性时，才会将自身作为第一个参数传递；调用实例对象的普通函数，则不会。<br>所以可以使用如下方式直接调用方法与函数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mt.inner_test()</span><br><span class=\"line\">mt.outer_test()</span><br></pre></td></tr></table></figure>\n<p>除了方法与函数的区别，其引用与数据属性都是一样的</p>\n<h3 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><p>虽然<code>Python</code>作为动态语言，支持在运行时绑定属性，但是从面向对象的角度来看，还是在定义类的时候将属性确定下来。</p>\n<p>参考:</p>\n<ol>\n<li><a href=\"http://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block\" target=\"_blank\" rel=\"noopener\">http://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block</a></li>\n<li><a href=\"https://www.cnblogs.com/crazyrunning/p/6945183.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/crazyrunning/p/6945183.html</a></li>\n</ol>"},{"title":"Python3 自省","date":"2018-03-01T08:19:37.000Z","_content":"\n自省是python彪悍的特性之一.\n\n自省（introspection）是一种自我检查行为。在计算机编程中，自省是指这种能力：检查某些事物以确定它是什么、它知道什么以及它能做什么。自省向程序员提供了极大的灵活性和控制力.\n\n<!-- more -->\n\n自省就是面向对象的语言所写的程序在运行时,所能知道对象的类型.简单一句就是运行时能够获得对象的类型.比如type(),dir(),getattr(),hasattr(),isinstance().\n\n```python\na = [1,2,3]\nb = {'a':1,'b':2,'c':3}\nc = True\nprint type(a),type(b),type(c) # <type 'list'> <type 'dict'> <type 'bool'>\nprint isinstance(a,list)  # True\n```\n\n\n未完待续\n\n参考：\n1. http://python.jobbole.com/82110/\n2. http://blog.csdn.net/IAlexanderI/article/details/78768378\n","source":"_posts/Python3-自省.md","raw":"---\ntitle: Python3 自省\ndate: 2018-03-01 16:19:37\ntags:\n  - Python3\ncategories:\n  - Python3 进阶\n  - Python3 自省\n---\n\n自省是python彪悍的特性之一.\n\n自省（introspection）是一种自我检查行为。在计算机编程中，自省是指这种能力：检查某些事物以确定它是什么、它知道什么以及它能做什么。自省向程序员提供了极大的灵活性和控制力.\n\n<!-- more -->\n\n自省就是面向对象的语言所写的程序在运行时,所能知道对象的类型.简单一句就是运行时能够获得对象的类型.比如type(),dir(),getattr(),hasattr(),isinstance().\n\n```python\na = [1,2,3]\nb = {'a':1,'b':2,'c':3}\nc = True\nprint type(a),type(b),type(c) # <type 'list'> <type 'dict'> <type 'bool'>\nprint isinstance(a,list)  # True\n```\n\n\n未完待续\n\n参考：\n1. http://python.jobbole.com/82110/\n2. http://blog.csdn.net/IAlexanderI/article/details/78768378\n","slug":"Python3-自省","published":1,"updated":"2018-03-02T17:23:56.828Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozlv003t8motpkxkvdig","content":"<p>自省是python彪悍的特性之一.</p>\n<p>自省（introspection）是一种自我检查行为。在计算机编程中，自省是指这种能力：检查某些事物以确定它是什么、它知道什么以及它能做什么。自省向程序员提供了极大的灵活性和控制力.</p>\n<a id=\"more\"></a>\n<p>自省就是面向对象的语言所写的程序在运行时,所能知道对象的类型.简单一句就是运行时能够获得对象的类型.比如type(),dir(),getattr(),hasattr(),isinstance().</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">b = &#123;<span class=\"string\">'a'</span>:<span class=\"number\">1</span>,<span class=\"string\">'b'</span>:<span class=\"number\">2</span>,<span class=\"string\">'c'</span>:<span class=\"number\">3</span>&#125;</span><br><span class=\"line\">c = <span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> type(a),type(b),type(c) <span class=\"comment\"># &lt;type 'list'&gt; &lt;type 'dict'&gt; &lt;type 'bool'&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> isinstance(a,list)  <span class=\"comment\"># True</span></span><br></pre></td></tr></table></figure>\n<p>未完待续</p>\n<p>参考：</p>\n<ol>\n<li><a href=\"http://python.jobbole.com/82110/\" target=\"_blank\" rel=\"noopener\">http://python.jobbole.com/82110/</a></li>\n<li><a href=\"http://blog.csdn.net/IAlexanderI/article/details/78768378\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/IAlexanderI/article/details/78768378</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>自省是python彪悍的特性之一.</p>\n<p>自省（introspection）是一种自我检查行为。在计算机编程中，自省是指这种能力：检查某些事物以确定它是什么、它知道什么以及它能做什么。自省向程序员提供了极大的灵活性和控制力.</p>","more":"<p>自省就是面向对象的语言所写的程序在运行时,所能知道对象的类型.简单一句就是运行时能够获得对象的类型.比如type(),dir(),getattr(),hasattr(),isinstance().</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">b = &#123;<span class=\"string\">'a'</span>:<span class=\"number\">1</span>,<span class=\"string\">'b'</span>:<span class=\"number\">2</span>,<span class=\"string\">'c'</span>:<span class=\"number\">3</span>&#125;</span><br><span class=\"line\">c = <span class=\"keyword\">True</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> type(a),type(b),type(c) <span class=\"comment\"># &lt;type 'list'&gt; &lt;type 'dict'&gt; &lt;type 'bool'&gt;</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> isinstance(a,list)  <span class=\"comment\"># True</span></span><br></pre></td></tr></table></figure>\n<p>未完待续</p>\n<p>参考：</p>\n<ol>\n<li><a href=\"http://python.jobbole.com/82110/\" target=\"_blank\" rel=\"noopener\">http://python.jobbole.com/82110/</a></li>\n<li><a href=\"http://blog.csdn.net/IAlexanderI/article/details/78768378\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/IAlexanderI/article/details/78768378</a></li>\n</ol>"},{"title":"Python3 解包和压包","date":"2018-04-06T15:31:01.000Z","_content":"\nPython中的解包可以这样理解：一个可迭代对象是一个整体，想把可迭代对象中每个元素当成一个个个体剥离出来，这个过程就是解包。下面将举例说明。\n\n\n## **可迭代对象每个元素赋值给一个变量**\n```python\n# 列表\n>>> name, age, date = ['Bob', 20, '2018-1-1']\n>>> name\n'Bob'\n>>> age\n20\n>>> date\n'2018-1-1'\n\n>>> a, b, c = enumerate(['a', 'b', 'c'])\n>>> a\n(0, 'a')\n\n# 元组\n>>> a, b, c = ('a', 'b', 'c')\n>>> a\n'a'\n\n# 字典\n>>> a, b, c = {'a':1, 'b':2, 'c':3}\n>>> a\n'a'\n\n>>> a, b, c = {'a':1, 'b':2, 'c':3}.items()\n>>> a\n('a', 1)\n\n>>> a, b, c = {'a':1, 'b':2, 'c':3}.values()\n>>> a\n1\n\n# 字符串\n>>> a, b, c = 'abc'\n>>> a\n'a'\n\n# 生成器\n>>> a, b, c = (x + 1 for x in range(3))\n>>> b\n2\n```\n<!-- more -->\n\n## **星号\"*\"的使用---解包**\n\n比如我们要计算平均分，去除最高分和最低分，除了用切片，还可以用解包的方式获得中间的数值\n```python\n>>> small, *new, big = sorted([93,12,33,55,99])\n>>> new\n[33, 55, 93]\n```\n\n## **压包与解包**\n```python\na = ['a', 'b', 'c']\nb = [1, 2, 3]\nfor i, j in zip(a, b):\n    print(i+j)\n\n# 输出\n1\n3\n5\n```\n分析以上代码：\n1. zip函数将a, b压包程一个可迭代对象\n2. 对可迭代对象的每一个元素（('a', 1)）进行解包（i, j = ('a', 1)）\n3. 接下来可以分别调用i, j变量进行计算\n\n再举一个例子：\n```python\nl = [\n    ('Bob', '1991', '60'),\n    ('Bill', '1992', '65'),\n    ('Mike', '1993', '70')\n]\nfor name, *args in l:\n    print(name, args)\n\nBob ['1991', '60']\nBill ['1992', '65']\nMike ['1993', '70']\n```\n\n## **\"_\"的用法**\n当一些变量不用时，用`_`表示是更好的写法，可以让读代码的人知道这个元素是不要的\n```python\n>>> p = ('Bob', 20, 50, (11,20,2000))\n>>> name, *_, (*_, year) = p\n>>> name\n'Bob'\n>>> year\n2000\n```\n\n## **多变量同时赋值**\n```python\n>>> a, b = 1, 2\n>>> a = 1, 2\n>>> a\n(1, 2)\n```\n下面用法都会报错\n```python\n*a = 1, 3\na,b,c = 1,2\n```\n`但是这种写法是可以的`\n```python\n>>> *a, = 1,2\n>>> a\n[1,2]\n```\n\n## **“*”之可变参数**\n函数定义时，我们使用*的可变参数，其实也是压包解包过程\n```python\ndef func(*args):\n    print(args)\n\n>>> func(1,2,3,4)\n(1, 2, 3, 4)\n```\n参数用*num表示，num变量就可以当成元组调用了。\n其实这个过程相当于*num, = 1,2,5,6\n\n\n## **“*”之关键字参数**\n```python\ndef func(**kw):\n    print(kw)\n\n>>> func(name = 'Bob', age = 10, weight = 60)\n{'name' = 'Bob', 'age' = 10, 'weight' = 60}\n```\n\n键值对传入**kw，kw就可以表示相应字典。\n\n`**`的用法只在函数定义中使用，`不能这样使用`\n```python\na, **b = {'name' = 'Bob', 'age' = 10, 'weight' = 60}\n```\n\n## **可变参数与关键字参数的细节问题**\n### 函数传入实参时，可变参数`*`之前的参数不能指定参数名\n```python\ndef func(a, *b):\n    print(a)\n    print(b)\n\n>>> func(a=1, 2,3,4)\nFile \"<ipython-input-17-978eea76866e>\", line 1\n  func(a=1, 2,3,4)\n           ^\nSyntaxError: positional argument follows keyword argument\nfunc(1,2,3,4)\n1\n(2,3,4)\n```\n\n### 函数传入实参时，可变参数`*`之后的参数必须指定参数名，否则就会被归到可变参数之中\n```python\ndef func(a, *b, c = None):\n    print(a)\n    print(b)\n    print(c)\n\n>>> func(1,2,3,4)\n1\n(2,3,4)\nNone\n\n>>> func(1,2,3,c=4)\n1\n(2,3)\n4\n```\n如果一个函数想要使用时必须明确指定参数名，可以将所有参数都放在可变参数之后，而可变参数不用管它就可以，也不用命名，如下:\n```python\ndef func(*, a, b):\n    print(a)\n    print(b)\n\n>>> func(a = 1, b = 2)\n1\n2\n```\n可变参数的这两条特性，可以用于将 只需要按照位置赋值的参数 和 需要明确指定参数名的参数区分开来\n### 关键字参数都只能作为最后一个参数，前面的参数按照位置赋值还是名称赋值都可以\n```python\ndef func(a, *b, c, **d):\n    print(a)\n    print(b)\n    print(c)\n    print(d)\n\n>>> func(1,2,3,c=4,m=5,n=6)\n1\n(2,3)\n4\n{'m': 5, 'n':6}\n```\n\n### `可变参数与关键词参数共同使用以表示任意参数`\n下面是这一点在装饰器当中的使用\n\n```python\ndef mydecorator(func):\n    def wrapper(*args, **kw):\n        print('i am using a decorator')\n        return func(*args, **kw)\n    return wrapper\n\n@mydecorator\ndef myfun(a, b):\n    print(a)\n    print(b)\n\n>>> myfun(1, b = 2)\ni am using a decorator\n1\n2\n```\nwrapper函数使用`*args`, `**kw`作为参数，则被修饰的myfun函数需要的参数无论是什么样的，传入wrapper都不会报错，这保证了装饰器可以修饰各种各样函数的灵活性。毕竟我们一般在函数中传入参数时，要么所有参数名都写，要么前面几个不写，后面的会写，这样使用`*args`, `**kw`完全没有问题。\n\n## 解包作为参数传入函数中\n首先定义一个函数\n```python\ndef myfun(a, b):\n    print(a + b)\n```\n列表|元组的解包\n```python\n>>> n = [1,2]\n>>> myfun(*n)\n3\n```\n字典的解包\n```python\n>>> mydict = {'a':1, 'b':2}\n>>> myfun(**mydict)\n3\n>>> myfun(*mydict)\n'ab'\n```\n\n一个简单的应用\n```python\n>>> Bob = {'name': 'Bob', 'age':20}\n>>> \"{name}'s age is {age}\".format(**Bob)\n\"Bob's age is 20\"\n```\n## 多返回值函数\n下面过程也涉及到了解包\n```python\ndef myfun(a, b):\n    print a+1, b+1\n\n>>> m,n = myfun(1,2)\n>>> m\n2\n>>> n\n3\n```\n其本身是一个元组\n```python\n>>> p = myfun(1, 2)\n>>> p\n(2, 3)\n```\n","source":"_posts/Python3-解包和压包.md","raw":"---\ntitle: Python3 解包和压包\ndate: 2018-04-06 23:31:01\ntags:\n  - Python3\ncategories:\n  - Python3 进阶\n---\n\nPython中的解包可以这样理解：一个可迭代对象是一个整体，想把可迭代对象中每个元素当成一个个个体剥离出来，这个过程就是解包。下面将举例说明。\n\n\n## **可迭代对象每个元素赋值给一个变量**\n```python\n# 列表\n>>> name, age, date = ['Bob', 20, '2018-1-1']\n>>> name\n'Bob'\n>>> age\n20\n>>> date\n'2018-1-1'\n\n>>> a, b, c = enumerate(['a', 'b', 'c'])\n>>> a\n(0, 'a')\n\n# 元组\n>>> a, b, c = ('a', 'b', 'c')\n>>> a\n'a'\n\n# 字典\n>>> a, b, c = {'a':1, 'b':2, 'c':3}\n>>> a\n'a'\n\n>>> a, b, c = {'a':1, 'b':2, 'c':3}.items()\n>>> a\n('a', 1)\n\n>>> a, b, c = {'a':1, 'b':2, 'c':3}.values()\n>>> a\n1\n\n# 字符串\n>>> a, b, c = 'abc'\n>>> a\n'a'\n\n# 生成器\n>>> a, b, c = (x + 1 for x in range(3))\n>>> b\n2\n```\n<!-- more -->\n\n## **星号\"*\"的使用---解包**\n\n比如我们要计算平均分，去除最高分和最低分，除了用切片，还可以用解包的方式获得中间的数值\n```python\n>>> small, *new, big = sorted([93,12,33,55,99])\n>>> new\n[33, 55, 93]\n```\n\n## **压包与解包**\n```python\na = ['a', 'b', 'c']\nb = [1, 2, 3]\nfor i, j in zip(a, b):\n    print(i+j)\n\n# 输出\n1\n3\n5\n```\n分析以上代码：\n1. zip函数将a, b压包程一个可迭代对象\n2. 对可迭代对象的每一个元素（('a', 1)）进行解包（i, j = ('a', 1)）\n3. 接下来可以分别调用i, j变量进行计算\n\n再举一个例子：\n```python\nl = [\n    ('Bob', '1991', '60'),\n    ('Bill', '1992', '65'),\n    ('Mike', '1993', '70')\n]\nfor name, *args in l:\n    print(name, args)\n\nBob ['1991', '60']\nBill ['1992', '65']\nMike ['1993', '70']\n```\n\n## **\"_\"的用法**\n当一些变量不用时，用`_`表示是更好的写法，可以让读代码的人知道这个元素是不要的\n```python\n>>> p = ('Bob', 20, 50, (11,20,2000))\n>>> name, *_, (*_, year) = p\n>>> name\n'Bob'\n>>> year\n2000\n```\n\n## **多变量同时赋值**\n```python\n>>> a, b = 1, 2\n>>> a = 1, 2\n>>> a\n(1, 2)\n```\n下面用法都会报错\n```python\n*a = 1, 3\na,b,c = 1,2\n```\n`但是这种写法是可以的`\n```python\n>>> *a, = 1,2\n>>> a\n[1,2]\n```\n\n## **“*”之可变参数**\n函数定义时，我们使用*的可变参数，其实也是压包解包过程\n```python\ndef func(*args):\n    print(args)\n\n>>> func(1,2,3,4)\n(1, 2, 3, 4)\n```\n参数用*num表示，num变量就可以当成元组调用了。\n其实这个过程相当于*num, = 1,2,5,6\n\n\n## **“*”之关键字参数**\n```python\ndef func(**kw):\n    print(kw)\n\n>>> func(name = 'Bob', age = 10, weight = 60)\n{'name' = 'Bob', 'age' = 10, 'weight' = 60}\n```\n\n键值对传入**kw，kw就可以表示相应字典。\n\n`**`的用法只在函数定义中使用，`不能这样使用`\n```python\na, **b = {'name' = 'Bob', 'age' = 10, 'weight' = 60}\n```\n\n## **可变参数与关键字参数的细节问题**\n### 函数传入实参时，可变参数`*`之前的参数不能指定参数名\n```python\ndef func(a, *b):\n    print(a)\n    print(b)\n\n>>> func(a=1, 2,3,4)\nFile \"<ipython-input-17-978eea76866e>\", line 1\n  func(a=1, 2,3,4)\n           ^\nSyntaxError: positional argument follows keyword argument\nfunc(1,2,3,4)\n1\n(2,3,4)\n```\n\n### 函数传入实参时，可变参数`*`之后的参数必须指定参数名，否则就会被归到可变参数之中\n```python\ndef func(a, *b, c = None):\n    print(a)\n    print(b)\n    print(c)\n\n>>> func(1,2,3,4)\n1\n(2,3,4)\nNone\n\n>>> func(1,2,3,c=4)\n1\n(2,3)\n4\n```\n如果一个函数想要使用时必须明确指定参数名，可以将所有参数都放在可变参数之后，而可变参数不用管它就可以，也不用命名，如下:\n```python\ndef func(*, a, b):\n    print(a)\n    print(b)\n\n>>> func(a = 1, b = 2)\n1\n2\n```\n可变参数的这两条特性，可以用于将 只需要按照位置赋值的参数 和 需要明确指定参数名的参数区分开来\n### 关键字参数都只能作为最后一个参数，前面的参数按照位置赋值还是名称赋值都可以\n```python\ndef func(a, *b, c, **d):\n    print(a)\n    print(b)\n    print(c)\n    print(d)\n\n>>> func(1,2,3,c=4,m=5,n=6)\n1\n(2,3)\n4\n{'m': 5, 'n':6}\n```\n\n### `可变参数与关键词参数共同使用以表示任意参数`\n下面是这一点在装饰器当中的使用\n\n```python\ndef mydecorator(func):\n    def wrapper(*args, **kw):\n        print('i am using a decorator')\n        return func(*args, **kw)\n    return wrapper\n\n@mydecorator\ndef myfun(a, b):\n    print(a)\n    print(b)\n\n>>> myfun(1, b = 2)\ni am using a decorator\n1\n2\n```\nwrapper函数使用`*args`, `**kw`作为参数，则被修饰的myfun函数需要的参数无论是什么样的，传入wrapper都不会报错，这保证了装饰器可以修饰各种各样函数的灵活性。毕竟我们一般在函数中传入参数时，要么所有参数名都写，要么前面几个不写，后面的会写，这样使用`*args`, `**kw`完全没有问题。\n\n## 解包作为参数传入函数中\n首先定义一个函数\n```python\ndef myfun(a, b):\n    print(a + b)\n```\n列表|元组的解包\n```python\n>>> n = [1,2]\n>>> myfun(*n)\n3\n```\n字典的解包\n```python\n>>> mydict = {'a':1, 'b':2}\n>>> myfun(**mydict)\n3\n>>> myfun(*mydict)\n'ab'\n```\n\n一个简单的应用\n```python\n>>> Bob = {'name': 'Bob', 'age':20}\n>>> \"{name}'s age is {age}\".format(**Bob)\n\"Bob's age is 20\"\n```\n## 多返回值函数\n下面过程也涉及到了解包\n```python\ndef myfun(a, b):\n    print a+1, b+1\n\n>>> m,n = myfun(1,2)\n>>> m\n2\n>>> n\n3\n```\n其本身是一个元组\n```python\n>>> p = myfun(1, 2)\n>>> p\n(2, 3)\n```\n","slug":"Python3-解包和压包","published":1,"updated":"2018-04-06T17:14:14.402Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozlz003x8motswhhziq2","content":"<p>Python中的解包可以这样理解：一个可迭代对象是一个整体，想把可迭代对象中每个元素当成一个个个体剥离出来，这个过程就是解包。下面将举例说明。</p>\n<h2 id=\"可迭代对象每个元素赋值给一个变量\"><a href=\"#可迭代对象每个元素赋值给一个变量\" class=\"headerlink\" title=\"可迭代对象每个元素赋值给一个变量\"></a><strong>可迭代对象每个元素赋值给一个变量</strong></h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列表</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name, age, date = [<span class=\"string\">'Bob'</span>, <span class=\"number\">20</span>, <span class=\"string\">'2018-1-1'</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name</span><br><span class=\"line\"><span class=\"string\">'Bob'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>age</span><br><span class=\"line\"><span class=\"number\">20</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>date</span><br><span class=\"line\"><span class=\"string\">'2018-1-1'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a, b, c = enumerate([<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a</span><br><span class=\"line\">(<span class=\"number\">0</span>, <span class=\"string\">'a'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 元组</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a, b, c = (<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a</span><br><span class=\"line\"><span class=\"string\">'a'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 字典</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a, b, c = &#123;<span class=\"string\">'a'</span>:<span class=\"number\">1</span>, <span class=\"string\">'b'</span>:<span class=\"number\">2</span>, <span class=\"string\">'c'</span>:<span class=\"number\">3</span>&#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a</span><br><span class=\"line\"><span class=\"string\">'a'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a, b, c = &#123;<span class=\"string\">'a'</span>:<span class=\"number\">1</span>, <span class=\"string\">'b'</span>:<span class=\"number\">2</span>, <span class=\"string\">'c'</span>:<span class=\"number\">3</span>&#125;.items()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a</span><br><span class=\"line\">(<span class=\"string\">'a'</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a, b, c = &#123;<span class=\"string\">'a'</span>:<span class=\"number\">1</span>, <span class=\"string\">'b'</span>:<span class=\"number\">2</span>, <span class=\"string\">'c'</span>:<span class=\"number\">3</span>&#125;.values()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 字符串</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a, b, c = <span class=\"string\">'abc'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a</span><br><span class=\"line\"><span class=\"string\">'a'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 生成器</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a, b, c = (x + <span class=\"number\">1</span> <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"number\">3</span>))</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b</span><br><span class=\"line\"><span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h2 id=\"星号”-”的使用—解包\"><a href=\"#星号”-”的使用—解包\" class=\"headerlink\" title=\"星号”*”的使用—解包\"></a><strong>星号”*”的使用—解包</strong></h2><p>比如我们要计算平均分，去除最高分和最低分，除了用切片，还可以用解包的方式获得中间的数值<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>small, *new, big = sorted([<span class=\"number\">93</span>,<span class=\"number\">12</span>,<span class=\"number\">33</span>,<span class=\"number\">55</span>,<span class=\"number\">99</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>new</span><br><span class=\"line\">[<span class=\"number\">33</span>, <span class=\"number\">55</span>, <span class=\"number\">93</span>]</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"压包与解包\"><a href=\"#压包与解包\" class=\"headerlink\" title=\"压包与解包\"></a><strong>压包与解包</strong></h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>]</span><br><span class=\"line\">b = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">for</span> i, j <span class=\"keyword\">in</span> zip(a, b):</span><br><span class=\"line\">    print(i+j)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n<p>分析以上代码：</p>\n<ol>\n<li>zip函数将a, b压包程一个可迭代对象</li>\n<li>对可迭代对象的每一个元素（(‘a’, 1)）进行解包（i, j = (‘a’, 1)）</li>\n<li>接下来可以分别调用i, j变量进行计算</li>\n</ol>\n<p>再举一个例子：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">l = [</span><br><span class=\"line\">    (<span class=\"string\">'Bob'</span>, <span class=\"string\">'1991'</span>, <span class=\"string\">'60'</span>),</span><br><span class=\"line\">    (<span class=\"string\">'Bill'</span>, <span class=\"string\">'1992'</span>, <span class=\"string\">'65'</span>),</span><br><span class=\"line\">    (<span class=\"string\">'Mike'</span>, <span class=\"string\">'1993'</span>, <span class=\"string\">'70'</span>)</span><br><span class=\"line\">]</span><br><span class=\"line\"><span class=\"keyword\">for</span> name, *args <span class=\"keyword\">in</span> l:</span><br><span class=\"line\">    print(name, args)</span><br><span class=\"line\"></span><br><span class=\"line\">Bob [<span class=\"string\">'1991'</span>, <span class=\"string\">'60'</span>]</span><br><span class=\"line\">Bill [<span class=\"string\">'1992'</span>, <span class=\"string\">'65'</span>]</span><br><span class=\"line\">Mike [<span class=\"string\">'1993'</span>, <span class=\"string\">'70'</span>]</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"“-”的用法\"><a href=\"#“-”的用法\" class=\"headerlink\" title=\"“_”的用法\"></a><strong>“_”的用法</strong></h2><p>当一些变量不用时，用<code>_</code>表示是更好的写法，可以让读代码的人知道这个元素是不要的<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>p = (<span class=\"string\">'Bob'</span>, <span class=\"number\">20</span>, <span class=\"number\">50</span>, (<span class=\"number\">11</span>,<span class=\"number\">20</span>,<span class=\"number\">2000</span>))</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name, *_, (*_, year) = p</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name</span><br><span class=\"line\"><span class=\"string\">'Bob'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>year</span><br><span class=\"line\"><span class=\"number\">2000</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"多变量同时赋值\"><a href=\"#多变量同时赋值\" class=\"headerlink\" title=\"多变量同时赋值\"></a><strong>多变量同时赋值</strong></h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a, b = <span class=\"number\">1</span>, <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a = <span class=\"number\">1</span>, <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a</span><br><span class=\"line\">(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<p>下面用法都会报错<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*a = <span class=\"number\">1</span>, <span class=\"number\">3</span></span><br><span class=\"line\">a,b,c = <span class=\"number\">1</span>,<span class=\"number\">2</span></span><br></pre></td></tr></table></figure></p>\n<p><code>但是这种写法是可以的</code><br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>*a, = <span class=\"number\">1</span>,<span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>]</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"“-”之可变参数\"><a href=\"#“-”之可变参数\" class=\"headerlink\" title=\"“*”之可变参数\"></a><strong>“*”之可变参数</strong></h2><p>函数定义时，我们使用*的可变参数，其实也是压包解包过程<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func</span><span class=\"params\">(*args)</span>:</span></span><br><span class=\"line\">    print(args)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>func(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\">(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure></p>\n<p>参数用<em>num表示，num变量就可以当成元组调用了。<br>其实这个过程相当于</em>num, = 1,2,5,6</p>\n<h2 id=\"“-”之关键字参数\"><a href=\"#“-”之关键字参数\" class=\"headerlink\" title=\"“*”之关键字参数\"></a><strong>“*”之关键字参数</strong></h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func</span><span class=\"params\">(**kw)</span>:</span></span><br><span class=\"line\">    print(kw)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>func(name = <span class=\"string\">'Bob'</span>, age = <span class=\"number\">10</span>, weight = <span class=\"number\">60</span>)</span><br><span class=\"line\">&#123;<span class=\"string\">'name'</span> = <span class=\"string\">'Bob'</span>, <span class=\"string\">'age'</span> = <span class=\"number\">10</span>, <span class=\"string\">'weight'</span> = <span class=\"number\">60</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>键值对传入**kw，kw就可以表示相应字典。</p>\n<p><code>**</code>的用法只在函数定义中使用，<code>不能这样使用</code><br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a, **b = &#123;<span class=\"string\">'name'</span> = <span class=\"string\">'Bob'</span>, <span class=\"string\">'age'</span> = <span class=\"number\">10</span>, <span class=\"string\">'weight'</span> = <span class=\"number\">60</span>&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"可变参数与关键字参数的细节问题\"><a href=\"#可变参数与关键字参数的细节问题\" class=\"headerlink\" title=\"可变参数与关键字参数的细节问题\"></a><strong>可变参数与关键字参数的细节问题</strong></h2><h3 id=\"函数传入实参时，可变参数-之前的参数不能指定参数名\"><a href=\"#函数传入实参时，可变参数-之前的参数不能指定参数名\" class=\"headerlink\" title=\"函数传入实参时，可变参数*之前的参数不能指定参数名\"></a>函数传入实参时，可变参数<code>*</code>之前的参数不能指定参数名</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func</span><span class=\"params\">(a, *b)</span>:</span></span><br><span class=\"line\">    print(a)</span><br><span class=\"line\">    print(b)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>func(a=<span class=\"number\">1</span>, <span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\">File <span class=\"string\">\"&lt;ipython-input-17-978eea76866e&gt;\"</span>, line <span class=\"number\">1</span></span><br><span class=\"line\">  func(a=<span class=\"number\">1</span>, <span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\">           ^</span><br><span class=\"line\">SyntaxError: positional argument follows keyword argument</span><br><span class=\"line\">func(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\">(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"函数传入实参时，可变参数-之后的参数必须指定参数名，否则就会被归到可变参数之中\"><a href=\"#函数传入实参时，可变参数-之后的参数必须指定参数名，否则就会被归到可变参数之中\" class=\"headerlink\" title=\"函数传入实参时，可变参数*之后的参数必须指定参数名，否则就会被归到可变参数之中\"></a>函数传入实参时，可变参数<code>*</code>之后的参数必须指定参数名，否则就会被归到可变参数之中</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func</span><span class=\"params\">(a, *b, c = None)</span>:</span></span><br><span class=\"line\">    print(a)</span><br><span class=\"line\">    print(b)</span><br><span class=\"line\">    print(c)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>func(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\">(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"keyword\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>func(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,c=<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\">(<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n<p>如果一个函数想要使用时必须明确指定参数名，可以将所有参数都放在可变参数之后，而可变参数不用管它就可以，也不用命名，如下:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func</span><span class=\"params\">(*, a, b)</span>:</span></span><br><span class=\"line\">    print(a)</span><br><span class=\"line\">    print(b)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>func(a = <span class=\"number\">1</span>, b = <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br></pre></td></tr></table></figure></p>\n<p>可变参数的这两条特性，可以用于将 只需要按照位置赋值的参数 和 需要明确指定参数名的参数区分开来</p>\n<h3 id=\"关键字参数都只能作为最后一个参数，前面的参数按照位置赋值还是名称赋值都可以\"><a href=\"#关键字参数都只能作为最后一个参数，前面的参数按照位置赋值还是名称赋值都可以\" class=\"headerlink\" title=\"关键字参数都只能作为最后一个参数，前面的参数按照位置赋值还是名称赋值都可以\"></a>关键字参数都只能作为最后一个参数，前面的参数按照位置赋值还是名称赋值都可以</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func</span><span class=\"params\">(a, *b, c, **d)</span>:</span></span><br><span class=\"line\">    print(a)</span><br><span class=\"line\">    print(b)</span><br><span class=\"line\">    print(c)</span><br><span class=\"line\">    print(d)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>func(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,c=<span class=\"number\">4</span>,m=<span class=\"number\">5</span>,n=<span class=\"number\">6</span>)</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\">(<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\">&#123;<span class=\"string\">'m'</span>: <span class=\"number\">5</span>, <span class=\"string\">'n'</span>:<span class=\"number\">6</span>&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"可变参数与关键词参数共同使用以表示任意参数\"><a href=\"#可变参数与关键词参数共同使用以表示任意参数\" class=\"headerlink\" title=\"可变参数与关键词参数共同使用以表示任意参数\"></a><code>可变参数与关键词参数共同使用以表示任意参数</code></h3><p>下面是这一点在装饰器当中的使用</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mydecorator</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kw)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'i am using a decorator'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> func(*args, **kw)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@mydecorator</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">myfun</span><span class=\"params\">(a, b)</span>:</span></span><br><span class=\"line\">    print(a)</span><br><span class=\"line\">    print(b)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>myfun(<span class=\"number\">1</span>, b = <span class=\"number\">2</span>)</span><br><span class=\"line\">i am using a decorator</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<p>wrapper函数使用<code>*args</code>, <code>**kw</code>作为参数，则被修饰的myfun函数需要的参数无论是什么样的，传入wrapper都不会报错，这保证了装饰器可以修饰各种各样函数的灵活性。毕竟我们一般在函数中传入参数时，要么所有参数名都写，要么前面几个不写，后面的会写，这样使用<code>*args</code>, <code>**kw</code>完全没有问题。</p>\n<h2 id=\"解包作为参数传入函数中\"><a href=\"#解包作为参数传入函数中\" class=\"headerlink\" title=\"解包作为参数传入函数中\"></a>解包作为参数传入函数中</h2><p>首先定义一个函数<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">myfun</span><span class=\"params\">(a, b)</span>:</span></span><br><span class=\"line\">    print(a + b)</span><br></pre></td></tr></table></figure></p>\n<p>列表|元组的解包<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>n = [<span class=\"number\">1</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>myfun(*n)</span><br><span class=\"line\"><span class=\"number\">3</span></span><br></pre></td></tr></table></figure></p>\n<p>字典的解包<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>mydict = &#123;<span class=\"string\">'a'</span>:<span class=\"number\">1</span>, <span class=\"string\">'b'</span>:<span class=\"number\">2</span>&#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>myfun(**mydict)</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>myfun(*mydict)</span><br><span class=\"line\"><span class=\"string\">'ab'</span></span><br></pre></td></tr></table></figure></p>\n<p>一个简单的应用<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>Bob = &#123;<span class=\"string\">'name'</span>: <span class=\"string\">'Bob'</span>, <span class=\"string\">'age'</span>:<span class=\"number\">20</span>&#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">\"&#123;name&#125;'s age is &#123;age&#125;\"</span>.format(**Bob)</span><br><span class=\"line\"><span class=\"string\">\"Bob's age is 20\"</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"多返回值函数\"><a href=\"#多返回值函数\" class=\"headerlink\" title=\"多返回值函数\"></a>多返回值函数</h2><p>下面过程也涉及到了解包<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">myfun</span><span class=\"params\">(a, b)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> a+<span class=\"number\">1</span>, b+<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m,n = myfun(<span class=\"number\">1</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m</span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>n</span><br><span class=\"line\"><span class=\"number\">3</span></span><br></pre></td></tr></table></figure></p>\n<p>其本身是一个元组<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>p = myfun(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>p</span><br><span class=\"line\">(<span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>Python中的解包可以这样理解：一个可迭代对象是一个整体，想把可迭代对象中每个元素当成一个个个体剥离出来，这个过程就是解包。下面将举例说明。</p>\n<h2 id=\"可迭代对象每个元素赋值给一个变量\"><a href=\"#可迭代对象每个元素赋值给一个变量\" class=\"headerlink\" title=\"可迭代对象每个元素赋值给一个变量\"></a><strong>可迭代对象每个元素赋值给一个变量</strong></h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列表</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name, age, date = [<span class=\"string\">'Bob'</span>, <span class=\"number\">20</span>, <span class=\"string\">'2018-1-1'</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name</span><br><span class=\"line\"><span class=\"string\">'Bob'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>age</span><br><span class=\"line\"><span class=\"number\">20</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>date</span><br><span class=\"line\"><span class=\"string\">'2018-1-1'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a, b, c = enumerate([<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a</span><br><span class=\"line\">(<span class=\"number\">0</span>, <span class=\"string\">'a'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 元组</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a, b, c = (<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a</span><br><span class=\"line\"><span class=\"string\">'a'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 字典</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a, b, c = &#123;<span class=\"string\">'a'</span>:<span class=\"number\">1</span>, <span class=\"string\">'b'</span>:<span class=\"number\">2</span>, <span class=\"string\">'c'</span>:<span class=\"number\">3</span>&#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a</span><br><span class=\"line\"><span class=\"string\">'a'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a, b, c = &#123;<span class=\"string\">'a'</span>:<span class=\"number\">1</span>, <span class=\"string\">'b'</span>:<span class=\"number\">2</span>, <span class=\"string\">'c'</span>:<span class=\"number\">3</span>&#125;.items()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a</span><br><span class=\"line\">(<span class=\"string\">'a'</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a, b, c = &#123;<span class=\"string\">'a'</span>:<span class=\"number\">1</span>, <span class=\"string\">'b'</span>:<span class=\"number\">2</span>, <span class=\"string\">'c'</span>:<span class=\"number\">3</span>&#125;.values()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 字符串</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a, b, c = <span class=\"string\">'abc'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a</span><br><span class=\"line\"><span class=\"string\">'a'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 生成器</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a, b, c = (x + <span class=\"number\">1</span> <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"number\">3</span>))</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b</span><br><span class=\"line\"><span class=\"number\">2</span></span><br></pre></td></tr></table></figure>","more":"<h2 id=\"星号”-”的使用—解包\"><a href=\"#星号”-”的使用—解包\" class=\"headerlink\" title=\"星号”*”的使用—解包\"></a><strong>星号”*”的使用—解包</strong></h2><p>比如我们要计算平均分，去除最高分和最低分，除了用切片，还可以用解包的方式获得中间的数值<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>small, *new, big = sorted([<span class=\"number\">93</span>,<span class=\"number\">12</span>,<span class=\"number\">33</span>,<span class=\"number\">55</span>,<span class=\"number\">99</span>])</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>new</span><br><span class=\"line\">[<span class=\"number\">33</span>, <span class=\"number\">55</span>, <span class=\"number\">93</span>]</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"压包与解包\"><a href=\"#压包与解包\" class=\"headerlink\" title=\"压包与解包\"></a><strong>压包与解包</strong></h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = [<span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'c'</span>]</span><br><span class=\"line\">b = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"keyword\">for</span> i, j <span class=\"keyword\">in</span> zip(a, b):</span><br><span class=\"line\">    print(i+j)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n<p>分析以上代码：</p>\n<ol>\n<li>zip函数将a, b压包程一个可迭代对象</li>\n<li>对可迭代对象的每一个元素（(‘a’, 1)）进行解包（i, j = (‘a’, 1)）</li>\n<li>接下来可以分别调用i, j变量进行计算</li>\n</ol>\n<p>再举一个例子：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">l = [</span><br><span class=\"line\">    (<span class=\"string\">'Bob'</span>, <span class=\"string\">'1991'</span>, <span class=\"string\">'60'</span>),</span><br><span class=\"line\">    (<span class=\"string\">'Bill'</span>, <span class=\"string\">'1992'</span>, <span class=\"string\">'65'</span>),</span><br><span class=\"line\">    (<span class=\"string\">'Mike'</span>, <span class=\"string\">'1993'</span>, <span class=\"string\">'70'</span>)</span><br><span class=\"line\">]</span><br><span class=\"line\"><span class=\"keyword\">for</span> name, *args <span class=\"keyword\">in</span> l:</span><br><span class=\"line\">    print(name, args)</span><br><span class=\"line\"></span><br><span class=\"line\">Bob [<span class=\"string\">'1991'</span>, <span class=\"string\">'60'</span>]</span><br><span class=\"line\">Bill [<span class=\"string\">'1992'</span>, <span class=\"string\">'65'</span>]</span><br><span class=\"line\">Mike [<span class=\"string\">'1993'</span>, <span class=\"string\">'70'</span>]</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"“-”的用法\"><a href=\"#“-”的用法\" class=\"headerlink\" title=\"“_”的用法\"></a><strong>“_”的用法</strong></h2><p>当一些变量不用时，用<code>_</code>表示是更好的写法，可以让读代码的人知道这个元素是不要的<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>p = (<span class=\"string\">'Bob'</span>, <span class=\"number\">20</span>, <span class=\"number\">50</span>, (<span class=\"number\">11</span>,<span class=\"number\">20</span>,<span class=\"number\">2000</span>))</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name, *_, (*_, year) = p</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>name</span><br><span class=\"line\"><span class=\"string\">'Bob'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>year</span><br><span class=\"line\"><span class=\"number\">2000</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"多变量同时赋值\"><a href=\"#多变量同时赋值\" class=\"headerlink\" title=\"多变量同时赋值\"></a><strong>多变量同时赋值</strong></h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a, b = <span class=\"number\">1</span>, <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a = <span class=\"number\">1</span>, <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a</span><br><span class=\"line\">(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<p>下面用法都会报错<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*a = <span class=\"number\">1</span>, <span class=\"number\">3</span></span><br><span class=\"line\">a,b,c = <span class=\"number\">1</span>,<span class=\"number\">2</span></span><br></pre></td></tr></table></figure></p>\n<p><code>但是这种写法是可以的</code><br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>*a, = <span class=\"number\">1</span>,<span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>]</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"“-”之可变参数\"><a href=\"#“-”之可变参数\" class=\"headerlink\" title=\"“*”之可变参数\"></a><strong>“*”之可变参数</strong></h2><p>函数定义时，我们使用*的可变参数，其实也是压包解包过程<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func</span><span class=\"params\">(*args)</span>:</span></span><br><span class=\"line\">    print(args)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>func(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\">(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure></p>\n<p>参数用<em>num表示，num变量就可以当成元组调用了。<br>其实这个过程相当于</em>num, = 1,2,5,6</p>\n<h2 id=\"“-”之关键字参数\"><a href=\"#“-”之关键字参数\" class=\"headerlink\" title=\"“*”之关键字参数\"></a><strong>“*”之关键字参数</strong></h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func</span><span class=\"params\">(**kw)</span>:</span></span><br><span class=\"line\">    print(kw)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>func(name = <span class=\"string\">'Bob'</span>, age = <span class=\"number\">10</span>, weight = <span class=\"number\">60</span>)</span><br><span class=\"line\">&#123;<span class=\"string\">'name'</span> = <span class=\"string\">'Bob'</span>, <span class=\"string\">'age'</span> = <span class=\"number\">10</span>, <span class=\"string\">'weight'</span> = <span class=\"number\">60</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>键值对传入**kw，kw就可以表示相应字典。</p>\n<p><code>**</code>的用法只在函数定义中使用，<code>不能这样使用</code><br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a, **b = &#123;<span class=\"string\">'name'</span> = <span class=\"string\">'Bob'</span>, <span class=\"string\">'age'</span> = <span class=\"number\">10</span>, <span class=\"string\">'weight'</span> = <span class=\"number\">60</span>&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"可变参数与关键字参数的细节问题\"><a href=\"#可变参数与关键字参数的细节问题\" class=\"headerlink\" title=\"可变参数与关键字参数的细节问题\"></a><strong>可变参数与关键字参数的细节问题</strong></h2><h3 id=\"函数传入实参时，可变参数-之前的参数不能指定参数名\"><a href=\"#函数传入实参时，可变参数-之前的参数不能指定参数名\" class=\"headerlink\" title=\"函数传入实参时，可变参数*之前的参数不能指定参数名\"></a>函数传入实参时，可变参数<code>*</code>之前的参数不能指定参数名</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func</span><span class=\"params\">(a, *b)</span>:</span></span><br><span class=\"line\">    print(a)</span><br><span class=\"line\">    print(b)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>func(a=<span class=\"number\">1</span>, <span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\">File <span class=\"string\">\"&lt;ipython-input-17-978eea76866e&gt;\"</span>, line <span class=\"number\">1</span></span><br><span class=\"line\">  func(a=<span class=\"number\">1</span>, <span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\">           ^</span><br><span class=\"line\">SyntaxError: positional argument follows keyword argument</span><br><span class=\"line\">func(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\">(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"函数传入实参时，可变参数-之后的参数必须指定参数名，否则就会被归到可变参数之中\"><a href=\"#函数传入实参时，可变参数-之后的参数必须指定参数名，否则就会被归到可变参数之中\" class=\"headerlink\" title=\"函数传入实参时，可变参数*之后的参数必须指定参数名，否则就会被归到可变参数之中\"></a>函数传入实参时，可变参数<code>*</code>之后的参数必须指定参数名，否则就会被归到可变参数之中</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func</span><span class=\"params\">(a, *b, c = None)</span>:</span></span><br><span class=\"line\">    print(a)</span><br><span class=\"line\">    print(b)</span><br><span class=\"line\">    print(c)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>func(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\">(<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"keyword\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>func(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,c=<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\">(<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n<p>如果一个函数想要使用时必须明确指定参数名，可以将所有参数都放在可变参数之后，而可变参数不用管它就可以，也不用命名，如下:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func</span><span class=\"params\">(*, a, b)</span>:</span></span><br><span class=\"line\">    print(a)</span><br><span class=\"line\">    print(b)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>func(a = <span class=\"number\">1</span>, b = <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br></pre></td></tr></table></figure></p>\n<p>可变参数的这两条特性，可以用于将 只需要按照位置赋值的参数 和 需要明确指定参数名的参数区分开来</p>\n<h3 id=\"关键字参数都只能作为最后一个参数，前面的参数按照位置赋值还是名称赋值都可以\"><a href=\"#关键字参数都只能作为最后一个参数，前面的参数按照位置赋值还是名称赋值都可以\" class=\"headerlink\" title=\"关键字参数都只能作为最后一个参数，前面的参数按照位置赋值还是名称赋值都可以\"></a>关键字参数都只能作为最后一个参数，前面的参数按照位置赋值还是名称赋值都可以</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func</span><span class=\"params\">(a, *b, c, **d)</span>:</span></span><br><span class=\"line\">    print(a)</span><br><span class=\"line\">    print(b)</span><br><span class=\"line\">    print(c)</span><br><span class=\"line\">    print(d)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>func(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,c=<span class=\"number\">4</span>,m=<span class=\"number\">5</span>,n=<span class=\"number\">6</span>)</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\">(<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\">&#123;<span class=\"string\">'m'</span>: <span class=\"number\">5</span>, <span class=\"string\">'n'</span>:<span class=\"number\">6</span>&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"可变参数与关键词参数共同使用以表示任意参数\"><a href=\"#可变参数与关键词参数共同使用以表示任意参数\" class=\"headerlink\" title=\"可变参数与关键词参数共同使用以表示任意参数\"></a><code>可变参数与关键词参数共同使用以表示任意参数</code></h3><p>下面是这一点在装饰器当中的使用</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">mydecorator</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kw)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'i am using a decorator'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> func(*args, **kw)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@mydecorator</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">myfun</span><span class=\"params\">(a, b)</span>:</span></span><br><span class=\"line\">    print(a)</span><br><span class=\"line\">    print(b)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>myfun(<span class=\"number\">1</span>, b = <span class=\"number\">2</span>)</span><br><span class=\"line\">i am using a decorator</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<p>wrapper函数使用<code>*args</code>, <code>**kw</code>作为参数，则被修饰的myfun函数需要的参数无论是什么样的，传入wrapper都不会报错，这保证了装饰器可以修饰各种各样函数的灵活性。毕竟我们一般在函数中传入参数时，要么所有参数名都写，要么前面几个不写，后面的会写，这样使用<code>*args</code>, <code>**kw</code>完全没有问题。</p>\n<h2 id=\"解包作为参数传入函数中\"><a href=\"#解包作为参数传入函数中\" class=\"headerlink\" title=\"解包作为参数传入函数中\"></a>解包作为参数传入函数中</h2><p>首先定义一个函数<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">myfun</span><span class=\"params\">(a, b)</span>:</span></span><br><span class=\"line\">    print(a + b)</span><br></pre></td></tr></table></figure></p>\n<p>列表|元组的解包<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>n = [<span class=\"number\">1</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>myfun(*n)</span><br><span class=\"line\"><span class=\"number\">3</span></span><br></pre></td></tr></table></figure></p>\n<p>字典的解包<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>mydict = &#123;<span class=\"string\">'a'</span>:<span class=\"number\">1</span>, <span class=\"string\">'b'</span>:<span class=\"number\">2</span>&#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>myfun(**mydict)</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>myfun(*mydict)</span><br><span class=\"line\"><span class=\"string\">'ab'</span></span><br></pre></td></tr></table></figure></p>\n<p>一个简单的应用<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>Bob = &#123;<span class=\"string\">'name'</span>: <span class=\"string\">'Bob'</span>, <span class=\"string\">'age'</span>:<span class=\"number\">20</span>&#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"string\">\"&#123;name&#125;'s age is &#123;age&#125;\"</span>.format(**Bob)</span><br><span class=\"line\"><span class=\"string\">\"Bob's age is 20\"</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"多返回值函数\"><a href=\"#多返回值函数\" class=\"headerlink\" title=\"多返回值函数\"></a>多返回值函数</h2><p>下面过程也涉及到了解包<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">myfun</span><span class=\"params\">(a, b)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> a+<span class=\"number\">1</span>, b+<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m,n = myfun(<span class=\"number\">1</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>m</span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>n</span><br><span class=\"line\"><span class=\"number\">3</span></span><br></pre></td></tr></table></figure></p>\n<p>其本身是一个元组<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>p = myfun(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>p</span><br><span class=\"line\">(<span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure></p>"},{"title":"Python3 让字典保持有序","date":"2018-03-06T04:02:36.000Z","_content":"\n## 背景\n想创建一个字典，同时当对字典做迭代或序列化操作时，也能控制其中元素的顺序。\n\n## 解决方案\n\n要控制字典中元素的顺序，可以使用`collections模块`中的`OrderDict类`。当对字典做迭代时，他会严格按照元素初始添加的顺序执行。例如：\n```Python\nfrom collections import OrderedDict\n\nd = OrderedDict()\nd['foo'] = 1\nd['bar'] = 2\nd['spam'] = 3\nd['qrok'] = 4\n\nfor key in d:\n    print(key, d[key])\n\n# output:\n# foo 1\n# bar 2\n# spam 3\n# qrok 4\n```\n<!-- more -->\n当想创建一个映射结构以便稍后对其做序列化或编码成另一种格式时，OrderedDict就显得特别有用。例如，如果想在进行json编码时精确控制各个字段的顺序，那么只要首先在OrderedDict中构建数据就可以了。\n\n```Python\n>>> import json\n>>> json.dumps(d)\n'{\"foo\":1,\"bar\":2,\"spam\":3,\"qrok\":4}'\n>>>\n```\n\n## 讨论\n\nOrderedDict内部维护了一个双向链表，他会根据元素加入的顺序来排列键的位置。第一个加入的元素被放置的链表的末尾。接下来对已存在的键做重新赋值不会改变键的顺序。\n\n注意OrderedDict的大小是普通字典的两倍多，这是由于它额外创建的链表所致。因此，如果打算构建一个涉及大量OrderedDict实例的数据结构（例如从CSV文件中读取100000行内容到OrderedDict列表中），那么需要认真对应用做需求分析，从而判断使用OrderedDict所带来的好处是否能够超越额外的内存开销带来的缺点。\n\n\n\n\n\n\n\n\na\n","source":"_posts/Python3-让字典保持有序.md","raw":"---\ntitle: Python3 让字典保持有序\ndate: 2018-03-06 12:02:36\ntags:\n  - Python3\ncategories:\n  - Python3 进阶\n  - Python3 字典\n---\n\n## 背景\n想创建一个字典，同时当对字典做迭代或序列化操作时，也能控制其中元素的顺序。\n\n## 解决方案\n\n要控制字典中元素的顺序，可以使用`collections模块`中的`OrderDict类`。当对字典做迭代时，他会严格按照元素初始添加的顺序执行。例如：\n```Python\nfrom collections import OrderedDict\n\nd = OrderedDict()\nd['foo'] = 1\nd['bar'] = 2\nd['spam'] = 3\nd['qrok'] = 4\n\nfor key in d:\n    print(key, d[key])\n\n# output:\n# foo 1\n# bar 2\n# spam 3\n# qrok 4\n```\n<!-- more -->\n当想创建一个映射结构以便稍后对其做序列化或编码成另一种格式时，OrderedDict就显得特别有用。例如，如果想在进行json编码时精确控制各个字段的顺序，那么只要首先在OrderedDict中构建数据就可以了。\n\n```Python\n>>> import json\n>>> json.dumps(d)\n'{\"foo\":1,\"bar\":2,\"spam\":3,\"qrok\":4}'\n>>>\n```\n\n## 讨论\n\nOrderedDict内部维护了一个双向链表，他会根据元素加入的顺序来排列键的位置。第一个加入的元素被放置的链表的末尾。接下来对已存在的键做重新赋值不会改变键的顺序。\n\n注意OrderedDict的大小是普通字典的两倍多，这是由于它额外创建的链表所致。因此，如果打算构建一个涉及大量OrderedDict实例的数据结构（例如从CSV文件中读取100000行内容到OrderedDict列表中），那么需要认真对应用做需求分析，从而判断使用OrderedDict所带来的好处是否能够超越额外的内存开销带来的缺点。\n\n\n\n\n\n\n\n\na\n","slug":"Python3-让字典保持有序","published":1,"updated":"2018-03-06T04:55:57.785Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozm000418motvcq8ftjk","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>想创建一个字典，同时当对字典做迭代或序列化操作时，也能控制其中元素的顺序。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>要控制字典中元素的顺序，可以使用<code>collections模块</code>中的<code>OrderDict类</code>。当对字典做迭代时，他会严格按照元素初始添加的顺序执行。例如：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> OrderedDict</span><br><span class=\"line\"></span><br><span class=\"line\">d = OrderedDict()</span><br><span class=\"line\">d[<span class=\"string\">'foo'</span>] = <span class=\"number\">1</span></span><br><span class=\"line\">d[<span class=\"string\">'bar'</span>] = <span class=\"number\">2</span></span><br><span class=\"line\">d[<span class=\"string\">'spam'</span>] = <span class=\"number\">3</span></span><br><span class=\"line\">d[<span class=\"string\">'qrok'</span>] = <span class=\"number\">4</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> key <span class=\"keyword\">in</span> d:</span><br><span class=\"line\">    print(key, d[key])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># output:</span></span><br><span class=\"line\"><span class=\"comment\"># foo 1</span></span><br><span class=\"line\"><span class=\"comment\"># bar 2</span></span><br><span class=\"line\"><span class=\"comment\"># spam 3</span></span><br><span class=\"line\"><span class=\"comment\"># qrok 4</span></span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>当想创建一个映射结构以便稍后对其做序列化或编码成另一种格式时，OrderedDict就显得特别有用。例如，如果想在进行json编码时精确控制各个字段的顺序，那么只要首先在OrderedDict中构建数据就可以了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> json</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>json.dumps(d)</span><br><span class=\"line\"><span class=\"string\">'&#123;\"foo\":1,\"bar\":2,\"spam\":3,\"qrok\":4&#125;'</span></span><br><span class=\"line\">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"讨论\"><a href=\"#讨论\" class=\"headerlink\" title=\"讨论\"></a>讨论</h2><p>OrderedDict内部维护了一个双向链表，他会根据元素加入的顺序来排列键的位置。第一个加入的元素被放置的链表的末尾。接下来对已存在的键做重新赋值不会改变键的顺序。</p>\n<p>注意OrderedDict的大小是普通字典的两倍多，这是由于它额外创建的链表所致。因此，如果打算构建一个涉及大量OrderedDict实例的数据结构（例如从CSV文件中读取100000行内容到OrderedDict列表中），那么需要认真对应用做需求分析，从而判断使用OrderedDict所带来的好处是否能够超越额外的内存开销带来的缺点。</p>\n<p>a</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>想创建一个字典，同时当对字典做迭代或序列化操作时，也能控制其中元素的顺序。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>要控制字典中元素的顺序，可以使用<code>collections模块</code>中的<code>OrderDict类</code>。当对字典做迭代时，他会严格按照元素初始添加的顺序执行。例如：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> OrderedDict</span><br><span class=\"line\"></span><br><span class=\"line\">d = OrderedDict()</span><br><span class=\"line\">d[<span class=\"string\">'foo'</span>] = <span class=\"number\">1</span></span><br><span class=\"line\">d[<span class=\"string\">'bar'</span>] = <span class=\"number\">2</span></span><br><span class=\"line\">d[<span class=\"string\">'spam'</span>] = <span class=\"number\">3</span></span><br><span class=\"line\">d[<span class=\"string\">'qrok'</span>] = <span class=\"number\">4</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> key <span class=\"keyword\">in</span> d:</span><br><span class=\"line\">    print(key, d[key])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># output:</span></span><br><span class=\"line\"><span class=\"comment\"># foo 1</span></span><br><span class=\"line\"><span class=\"comment\"># bar 2</span></span><br><span class=\"line\"><span class=\"comment\"># spam 3</span></span><br><span class=\"line\"><span class=\"comment\"># qrok 4</span></span><br></pre></td></tr></table></figure></p>","more":"<p>当想创建一个映射结构以便稍后对其做序列化或编码成另一种格式时，OrderedDict就显得特别有用。例如，如果想在进行json编码时精确控制各个字段的顺序，那么只要首先在OrderedDict中构建数据就可以了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> json</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>json.dumps(d)</span><br><span class=\"line\"><span class=\"string\">'&#123;\"foo\":1,\"bar\":2,\"spam\":3,\"qrok\":4&#125;'</span></span><br><span class=\"line\">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"讨论\"><a href=\"#讨论\" class=\"headerlink\" title=\"讨论\"></a>讨论</h2><p>OrderedDict内部维护了一个双向链表，他会根据元素加入的顺序来排列键的位置。第一个加入的元素被放置的链表的末尾。接下来对已存在的键做重新赋值不会改变键的顺序。</p>\n<p>注意OrderedDict的大小是普通字典的两倍多，这是由于它额外创建的链表所致。因此，如果打算构建一个涉及大量OrderedDict实例的数据结构（例如从CSV文件中读取100000行内容到OrderedDict列表中），那么需要认真对应用做需求分析，从而判断使用OrderedDict所带来的好处是否能够超越额外的内存开销带来的缺点。</p>\n<p>a</p>"},{"title":"Python3 闭包","date":"2018-03-06T06:04:56.000Z","_content":"闭包是指延伸了作用域的函数，其中包含函数定义体中引用、但是不在定义体中定义的非全局变量。\n闭包(closure)是函数式编程的重要的语法结构。闭包也是一种组织代码的结构，它同样提高了代码的可重复使用性。\n\n当一个内嵌函数引用其外部作用域的变量,我们就会得到一个闭包. 总结一下,创建一个闭包必须满足以下几点:\n\n  1. 必须有一个内嵌函数\n  2. 内嵌函数必须引用外部函数中的变量\n  3. 外部函数的返回值必须是内嵌函数\n\n闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，这样调用函数时虽然定义作用域不可用了，但仍能使用那些绑定。\n<!-- more -->\n\n闭包的概念难以掌握，最好通过示例理解。\n\n假如有个名为avg的函数，他的作用是计算不断增加的系列值得平均数。起初，avg是这样使用的：\n```Python\n>>> avg(10)\n10.0\n>>> avg(11)\n10.5\n>>> avg(12)\n11.0\n\n```\n初学者可能会用类来实现，如示例1\n```python\n# 示例1\nclass Averager(object):\n    \"\"\"docstring for Average.\"\"\"\n    def __init__(self):\n        self.series = []\n\n    def __call__(self, new_value):\n        self.series.append(new_value)\n        total = sum(self.series)\n        return total/len(self.series)\n\n```\nAverage的实例是可调用对象：\n```python\n>>> avg = Averager()\n>>> avg(10)\n10.0\n>>> avg(11)\n10.5\n>>> avg(12)\n11.0\n```\n\n下面使用函数式实现，如示例2：\n```python\n# 示例2\ndef make_averager():\n    series = []\n\n    def averager(new_value):\n        series.append(new_value)\n        total = sum(series)\n        return total/len(series)\n\n    return averager\n\n```\n调用make_averager时，返回一个averager函数对象。每次调用averager时，他会把参数添加到系列值中，然后计算当前平均值，如下所示：\n```python\n>>> avg = make_averager()\n>>> avg(10)\n10.0\n>>> avg(11)\n10.5\n>>> avg(12)\n11.0\n```\n\n注意，以上两个示例有共通之处：调用Averager()或make_averager()得到一个可调用对象avg，他会更新历史值，然后计算当前均值。示例1中，avg是Averager的实例；实例2中是内部函数averager。不管怎样，我们都只需要调用avg(n),把n放入系列值中，然后重新计算均值。\n\nAverager()类的实例avg在哪里存储历史值很明显：self.series实例属性；但是第二个示例中的avg函数在哪里寻找series呢？\n\n注意，series是make_averager函数的局部变量，因为那个函数的定义体中初始化了series：series = []。可是，调用avg(10)时，make_averager函数已经返回了，而他的本地作用域也一去不复返了。\n\n在averager函数中，series是自由变量。这是一个技术术语，指未在本地作用域中绑定的变量，如图：\n\n![闭包](http://upload-images.jianshu.io/upload_images/2952111-039ebc44d7803bbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**averager的闭包延伸到那个函数的作用域之外，包含自由变量series的绑定**\n\n我们可以审查返回的averager对象，发现Python在`__code__`属性（表示编译后的函数定义体）中保存局部变量和自由变量的名称，如下所示\n\n```Python\n# 审查make_averager创建的函数\n>>> avg.__code__.co_varnames\n('new_value', 'total')\n>>> avg.__code__.co_freevars\n('series',)\n```\n\nseries绑定在返回的avg函数的`__closure__`属性中。`avg.__closure__`中各个元素对应于`avg.__code__.co_freevars`中的一个名称。这些元素是cell对象，有个`cell_content`属性，保存着真正的值。这些属性的值如示例所示：\n```python\n>>> avg.__code__.co_freevars\n('series',)\n>>> avg.__closure__\n(<cell at 0x108b89828: list object at 0x108ae96c8>,)\n>>> avg.__closure__[0].cell_contents\n[10,11,12]\n```\n综上，闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，这样调用函数时虽然定义作用域不可用了，但仍能使用那些绑定。\n\n注意，只有嵌套在其他函数中的函数才可能需要处理不在全局作用域中的外部变量。\n","source":"_posts/Python3-闭包.md","raw":"---\ntitle: Python3 闭包\ndate: 2018-03-06 14:04:56\ntags:\n  - Python3\ncategories:\n  - Python3 进阶\n  - Python3 闭包\n---\n闭包是指延伸了作用域的函数，其中包含函数定义体中引用、但是不在定义体中定义的非全局变量。\n闭包(closure)是函数式编程的重要的语法结构。闭包也是一种组织代码的结构，它同样提高了代码的可重复使用性。\n\n当一个内嵌函数引用其外部作用域的变量,我们就会得到一个闭包. 总结一下,创建一个闭包必须满足以下几点:\n\n  1. 必须有一个内嵌函数\n  2. 内嵌函数必须引用外部函数中的变量\n  3. 外部函数的返回值必须是内嵌函数\n\n闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，这样调用函数时虽然定义作用域不可用了，但仍能使用那些绑定。\n<!-- more -->\n\n闭包的概念难以掌握，最好通过示例理解。\n\n假如有个名为avg的函数，他的作用是计算不断增加的系列值得平均数。起初，avg是这样使用的：\n```Python\n>>> avg(10)\n10.0\n>>> avg(11)\n10.5\n>>> avg(12)\n11.0\n\n```\n初学者可能会用类来实现，如示例1\n```python\n# 示例1\nclass Averager(object):\n    \"\"\"docstring for Average.\"\"\"\n    def __init__(self):\n        self.series = []\n\n    def __call__(self, new_value):\n        self.series.append(new_value)\n        total = sum(self.series)\n        return total/len(self.series)\n\n```\nAverage的实例是可调用对象：\n```python\n>>> avg = Averager()\n>>> avg(10)\n10.0\n>>> avg(11)\n10.5\n>>> avg(12)\n11.0\n```\n\n下面使用函数式实现，如示例2：\n```python\n# 示例2\ndef make_averager():\n    series = []\n\n    def averager(new_value):\n        series.append(new_value)\n        total = sum(series)\n        return total/len(series)\n\n    return averager\n\n```\n调用make_averager时，返回一个averager函数对象。每次调用averager时，他会把参数添加到系列值中，然后计算当前平均值，如下所示：\n```python\n>>> avg = make_averager()\n>>> avg(10)\n10.0\n>>> avg(11)\n10.5\n>>> avg(12)\n11.0\n```\n\n注意，以上两个示例有共通之处：调用Averager()或make_averager()得到一个可调用对象avg，他会更新历史值，然后计算当前均值。示例1中，avg是Averager的实例；实例2中是内部函数averager。不管怎样，我们都只需要调用avg(n),把n放入系列值中，然后重新计算均值。\n\nAverager()类的实例avg在哪里存储历史值很明显：self.series实例属性；但是第二个示例中的avg函数在哪里寻找series呢？\n\n注意，series是make_averager函数的局部变量，因为那个函数的定义体中初始化了series：series = []。可是，调用avg(10)时，make_averager函数已经返回了，而他的本地作用域也一去不复返了。\n\n在averager函数中，series是自由变量。这是一个技术术语，指未在本地作用域中绑定的变量，如图：\n\n![闭包](http://upload-images.jianshu.io/upload_images/2952111-039ebc44d7803bbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n**averager的闭包延伸到那个函数的作用域之外，包含自由变量series的绑定**\n\n我们可以审查返回的averager对象，发现Python在`__code__`属性（表示编译后的函数定义体）中保存局部变量和自由变量的名称，如下所示\n\n```Python\n# 审查make_averager创建的函数\n>>> avg.__code__.co_varnames\n('new_value', 'total')\n>>> avg.__code__.co_freevars\n('series',)\n```\n\nseries绑定在返回的avg函数的`__closure__`属性中。`avg.__closure__`中各个元素对应于`avg.__code__.co_freevars`中的一个名称。这些元素是cell对象，有个`cell_content`属性，保存着真正的值。这些属性的值如示例所示：\n```python\n>>> avg.__code__.co_freevars\n('series',)\n>>> avg.__closure__\n(<cell at 0x108b89828: list object at 0x108ae96c8>,)\n>>> avg.__closure__[0].cell_contents\n[10,11,12]\n```\n综上，闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，这样调用函数时虽然定义作用域不可用了，但仍能使用那些绑定。\n\n注意，只有嵌套在其他函数中的函数才可能需要处理不在全局作用域中的外部变量。\n","slug":"Python3-闭包","published":1,"updated":"2018-03-06T06:56:44.733Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozm200448mot342vlmrx","content":"<p>闭包是指延伸了作用域的函数，其中包含函数定义体中引用、但是不在定义体中定义的非全局变量。<br>闭包(closure)是函数式编程的重要的语法结构。闭包也是一种组织代码的结构，它同样提高了代码的可重复使用性。</p>\n<p>当一个内嵌函数引用其外部作用域的变量,我们就会得到一个闭包. 总结一下,创建一个闭包必须满足以下几点:</p>\n<ol>\n<li>必须有一个内嵌函数</li>\n<li>内嵌函数必须引用外部函数中的变量</li>\n<li>外部函数的返回值必须是内嵌函数</li>\n</ol>\n<p>闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，这样调用函数时虽然定义作用域不可用了，但仍能使用那些绑定。<br><a id=\"more\"></a></p>\n<p>闭包的概念难以掌握，最好通过示例理解。</p>\n<p>假如有个名为avg的函数，他的作用是计算不断增加的系列值得平均数。起初，avg是这样使用的：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>avg(<span class=\"number\">10</span>)</span><br><span class=\"line\"><span class=\"number\">10.0</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>avg(<span class=\"number\">11</span>)</span><br><span class=\"line\"><span class=\"number\">10.5</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>avg(<span class=\"number\">12</span>)</span><br><span class=\"line\"><span class=\"number\">11.0</span></span><br></pre></td></tr></table></figure></p>\n<p>初学者可能会用类来实现，如示例1<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 示例1</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Averager</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"docstring for Average.\"\"\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.series = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__call__</span><span class=\"params\">(self, new_value)</span>:</span></span><br><span class=\"line\">        self.series.append(new_value)</span><br><span class=\"line\">        total = sum(self.series)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> total/len(self.series)</span><br></pre></td></tr></table></figure></p>\n<p>Average的实例是可调用对象：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>avg = Averager()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>avg(<span class=\"number\">10</span>)</span><br><span class=\"line\"><span class=\"number\">10.0</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>avg(<span class=\"number\">11</span>)</span><br><span class=\"line\"><span class=\"number\">10.5</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>avg(<span class=\"number\">12</span>)</span><br><span class=\"line\"><span class=\"number\">11.0</span></span><br></pre></td></tr></table></figure></p>\n<p>下面使用函数式实现，如示例2：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 示例2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">make_averager</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    series = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">averager</span><span class=\"params\">(new_value)</span>:</span></span><br><span class=\"line\">        series.append(new_value)</span><br><span class=\"line\">        total = sum(series)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> total/len(series)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> averager</span><br></pre></td></tr></table></figure></p>\n<p>调用make_averager时，返回一个averager函数对象。每次调用averager时，他会把参数添加到系列值中，然后计算当前平均值，如下所示：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>avg = make_averager()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>avg(<span class=\"number\">10</span>)</span><br><span class=\"line\"><span class=\"number\">10.0</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>avg(<span class=\"number\">11</span>)</span><br><span class=\"line\"><span class=\"number\">10.5</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>avg(<span class=\"number\">12</span>)</span><br><span class=\"line\"><span class=\"number\">11.0</span></span><br></pre></td></tr></table></figure></p>\n<p>注意，以上两个示例有共通之处：调用Averager()或make_averager()得到一个可调用对象avg，他会更新历史值，然后计算当前均值。示例1中，avg是Averager的实例；实例2中是内部函数averager。不管怎样，我们都只需要调用avg(n),把n放入系列值中，然后重新计算均值。</p>\n<p>Averager()类的实例avg在哪里存储历史值很明显：self.series实例属性；但是第二个示例中的avg函数在哪里寻找series呢？</p>\n<p>注意，series是make_averager函数的局部变量，因为那个函数的定义体中初始化了series：series = []。可是，调用avg(10)时，make_averager函数已经返回了，而他的本地作用域也一去不复返了。</p>\n<p>在averager函数中，series是自由变量。这是一个技术术语，指未在本地作用域中绑定的变量，如图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-039ebc44d7803bbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"闭包\"></p>\n<p><strong>averager的闭包延伸到那个函数的作用域之外，包含自由变量series的绑定</strong></p>\n<p>我们可以审查返回的averager对象，发现Python在<code>__code__</code>属性（表示编译后的函数定义体）中保存局部变量和自由变量的名称，如下所示</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 审查make_averager创建的函数</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>avg.__code__.co_varnames</span><br><span class=\"line\">(<span class=\"string\">'new_value'</span>, <span class=\"string\">'total'</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>avg.__code__.co_freevars</span><br><span class=\"line\">(<span class=\"string\">'series'</span>,)</span><br></pre></td></tr></table></figure>\n<p>series绑定在返回的avg函数的<code>__closure__</code>属性中。<code>avg.__closure__</code>中各个元素对应于<code>avg.__code__.co_freevars</code>中的一个名称。这些元素是cell对象，有个<code>cell_content</code>属性，保存着真正的值。这些属性的值如示例所示：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>avg.__code__.co_freevars</span><br><span class=\"line\">(<span class=\"string\">'series'</span>,)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>avg.__closure__</span><br><span class=\"line\">(&lt;cell at <span class=\"number\">0x108b89828</span>: list object at <span class=\"number\">0x108ae96c8</span>&gt;,)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>avg.__closure__[<span class=\"number\">0</span>].cell_contents</span><br><span class=\"line\">[<span class=\"number\">10</span>,<span class=\"number\">11</span>,<span class=\"number\">12</span>]</span><br></pre></td></tr></table></figure></p>\n<p>综上，闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，这样调用函数时虽然定义作用域不可用了，但仍能使用那些绑定。</p>\n<p>注意，只有嵌套在其他函数中的函数才可能需要处理不在全局作用域中的外部变量。</p>\n","site":{"data":{}},"excerpt":"<p>闭包是指延伸了作用域的函数，其中包含函数定义体中引用、但是不在定义体中定义的非全局变量。<br>闭包(closure)是函数式编程的重要的语法结构。闭包也是一种组织代码的结构，它同样提高了代码的可重复使用性。</p>\n<p>当一个内嵌函数引用其外部作用域的变量,我们就会得到一个闭包. 总结一下,创建一个闭包必须满足以下几点:</p>\n<ol>\n<li>必须有一个内嵌函数</li>\n<li>内嵌函数必须引用外部函数中的变量</li>\n<li>外部函数的返回值必须是内嵌函数</li>\n</ol>\n<p>闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，这样调用函数时虽然定义作用域不可用了，但仍能使用那些绑定。<br>","more":"</p>\n<p>闭包的概念难以掌握，最好通过示例理解。</p>\n<p>假如有个名为avg的函数，他的作用是计算不断增加的系列值得平均数。起初，avg是这样使用的：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>avg(<span class=\"number\">10</span>)</span><br><span class=\"line\"><span class=\"number\">10.0</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>avg(<span class=\"number\">11</span>)</span><br><span class=\"line\"><span class=\"number\">10.5</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>avg(<span class=\"number\">12</span>)</span><br><span class=\"line\"><span class=\"number\">11.0</span></span><br></pre></td></tr></table></figure></p>\n<p>初学者可能会用类来实现，如示例1<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 示例1</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Averager</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"docstring for Average.\"\"\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.series = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__call__</span><span class=\"params\">(self, new_value)</span>:</span></span><br><span class=\"line\">        self.series.append(new_value)</span><br><span class=\"line\">        total = sum(self.series)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> total/len(self.series)</span><br></pre></td></tr></table></figure></p>\n<p>Average的实例是可调用对象：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>avg = Averager()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>avg(<span class=\"number\">10</span>)</span><br><span class=\"line\"><span class=\"number\">10.0</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>avg(<span class=\"number\">11</span>)</span><br><span class=\"line\"><span class=\"number\">10.5</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>avg(<span class=\"number\">12</span>)</span><br><span class=\"line\"><span class=\"number\">11.0</span></span><br></pre></td></tr></table></figure></p>\n<p>下面使用函数式实现，如示例2：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 示例2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">make_averager</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    series = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">averager</span><span class=\"params\">(new_value)</span>:</span></span><br><span class=\"line\">        series.append(new_value)</span><br><span class=\"line\">        total = sum(series)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> total/len(series)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> averager</span><br></pre></td></tr></table></figure></p>\n<p>调用make_averager时，返回一个averager函数对象。每次调用averager时，他会把参数添加到系列值中，然后计算当前平均值，如下所示：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>avg = make_averager()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>avg(<span class=\"number\">10</span>)</span><br><span class=\"line\"><span class=\"number\">10.0</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>avg(<span class=\"number\">11</span>)</span><br><span class=\"line\"><span class=\"number\">10.5</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>avg(<span class=\"number\">12</span>)</span><br><span class=\"line\"><span class=\"number\">11.0</span></span><br></pre></td></tr></table></figure></p>\n<p>注意，以上两个示例有共通之处：调用Averager()或make_averager()得到一个可调用对象avg，他会更新历史值，然后计算当前均值。示例1中，avg是Averager的实例；实例2中是内部函数averager。不管怎样，我们都只需要调用avg(n),把n放入系列值中，然后重新计算均值。</p>\n<p>Averager()类的实例avg在哪里存储历史值很明显：self.series实例属性；但是第二个示例中的avg函数在哪里寻找series呢？</p>\n<p>注意，series是make_averager函数的局部变量，因为那个函数的定义体中初始化了series：series = []。可是，调用avg(10)时，make_averager函数已经返回了，而他的本地作用域也一去不复返了。</p>\n<p>在averager函数中，series是自由变量。这是一个技术术语，指未在本地作用域中绑定的变量，如图：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-039ebc44d7803bbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"闭包\"></p>\n<p><strong>averager的闭包延伸到那个函数的作用域之外，包含自由变量series的绑定</strong></p>\n<p>我们可以审查返回的averager对象，发现Python在<code>__code__</code>属性（表示编译后的函数定义体）中保存局部变量和自由变量的名称，如下所示</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 审查make_averager创建的函数</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>avg.__code__.co_varnames</span><br><span class=\"line\">(<span class=\"string\">'new_value'</span>, <span class=\"string\">'total'</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>avg.__code__.co_freevars</span><br><span class=\"line\">(<span class=\"string\">'series'</span>,)</span><br></pre></td></tr></table></figure>\n<p>series绑定在返回的avg函数的<code>__closure__</code>属性中。<code>avg.__closure__</code>中各个元素对应于<code>avg.__code__.co_freevars</code>中的一个名称。这些元素是cell对象，有个<code>cell_content</code>属性，保存着真正的值。这些属性的值如示例所示：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>avg.__code__.co_freevars</span><br><span class=\"line\">(<span class=\"string\">'series'</span>,)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>avg.__closure__</span><br><span class=\"line\">(&lt;cell at <span class=\"number\">0x108b89828</span>: list object at <span class=\"number\">0x108ae96c8</span>&gt;,)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>avg.__closure__[<span class=\"number\">0</span>].cell_contents</span><br><span class=\"line\">[<span class=\"number\">10</span>,<span class=\"number\">11</span>,<span class=\"number\">12</span>]</span><br></pre></td></tr></table></figure></p>\n<p>综上，闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，这样调用函数时虽然定义作用域不可用了，但仍能使用那些绑定。</p>\n<p>注意，只有嵌套在其他函数中的函数才可能需要处理不在全局作用域中的外部变量。</p>"},{"title":"Python3 鸭子类型","date":"2018-03-02T17:52:21.000Z","_content":"\n## 来源和解释\nDuck typing 这个概念来源于美国印第安纳州的诗人詹姆斯·惠特科姆·莱利（James Whitcomb Riley,1849-1916）的诗句：\n\n>\" When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.\"\n\n中文：\n\n>“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”\n\n“鸭子类型”的语言是这么推断的：一只鸟走起来像鸭子、游起泳来像鸭子、叫起来也像鸭子，那它就可以被当做鸭子。也就是说，它不关注对象的类型，而是关注对象具有的行为(方法)。\n<!-- more -->\n\n鸭子类型是程序设计中的一种类型推断风格，这种风格适用于动态语言(比如PHP、Python、Ruby、Typescript、Perl、Objective-C、Lua、Julia、JavaScript、Java、Groovy、C#等)和某些静态语言(比如Golang,一般来说，静态类型语言在编译时便已确定了变量的类型，但是Golang的实现是：在编译时推断变量的类型)，支持\"鸭子类型\"的语言的解释器/编译器将会在解析(Parse)或编译时，推断对象的类型。\n\n`在鸭子类型中，关注的不是对象的类型本身，而是它是如何使用的。` 例如，在不使用鸭子类型的语言中，我们可以编写一个函数，它接受一个类型为鸭的对象，并调用它的走和叫方法。在使用鸭子类型的语言中，这样的一个函数可以接受一个任意类型的对象，并调用它的走和叫方法。如果这些需要被调用的方法不存在，那么将引发一个运行时错误。任何拥有这样的正确的走和叫方法的对象都可被函数接受的这种行为引出了以上表述，这种决定类型的方式因此得名。\n\n`鸭子类型通常得益于不测试方法和函数中参数的类型，而是依赖文档、清晰的代码和测试来确保正确使用。`从静态类型语言转向动态类型语言的用户通常试图添加一些静态的（在运行之前的）类型检查，从而影响了鸭子类型的益处和可伸缩性，并约束了语言的动态特性。\n\n\n## 不足\n\"鸭子类型\"没有任何静态检查，如类型检查、属性检查、方法签名检查等。\n\n“鸭子类型”语言的程序可能会在运行时因为不具备某种特定的方法而抛出异常：如果一只小狗(对象)想加入合唱团(以对象会不会嘎嘎嘎叫的方法为检验标准)，也学鸭子那么嘎嘎嘎叫，好吧，它加入了，可是加入之后，却不会像鸭子那样走路，那么，迟早要出问题的。\n\n再举个例子：一只小老鼠被猫盯上了，情急之下，它学了狗叫，猫撤了之后，小老鼠的妈妈不无感叹的对它说：看吧，我让你学的这门儿外语多么重要啊。这虽然是个段子，但是，由于猫在思考时，使用了 \"鸭子测试\"，它以为会叫的就是狗，会对自己产生威胁，所以撤退了，也正是因为这个错误的判断，它误失了一次进食机会。\n\n## 静态类型语言和动态类型语言的区别\n\n静态类型语言在编译时便已确定变量的类型，而动态类型语言的变量类型要到程序运行的时候，待变量被赋予某个值之后，才会具有某种类型。  \n\n`静态类型语言的优点`首先是在编译时就能发现类型不匹配的错误，编辑器可以帮助我们提前避免程序在运行期间有可能发生的一些错误。其次，如果在程序中明确地规定了数据类型，编译器还可以针对这些信息对程序进行一些优化工作，提高程序执行速度。  \n\n`静态类型语言的缺点`首先是迫使程序员依照强契约来编写程序，为每个变量规定数据类型，归根结底只是辅助我们编写可靠性高程序的一种手段，而不是编写程序的目的，毕竟大部分人编写程序的目的是为了完成需求交付生产。其次，类型的声明也会增加更多的代码，在程序编写过程中，这些细节会让程序员的精力从思考业务逻辑上分散开来。  \n\n`动态类型语言的优点`是编写的代码数量更少，看起来也更加简洁，程序员可以把精力更多地放在业务逻辑上面。虽然不区分类型在某些情况下会让程序变得难以理解，但整体而言，代码量越少，越专注于逻辑表达，对阅读程序是越有帮助的。  \n`动态类型语言的缺点`是无法保证变量的类型，从而在程序的运行期有可能发生跟类型相关的错误。\n\n**动态类型语言对变量类型的宽容给实际编码带来了很大的灵活性。由于无需进行类型检测，我们可以尝试调用任何对象的任意方法，而无需去考虑它原本是否被设计为拥有该方法。**\n\n## 面向接口编程\n\n动态类型语言的面向对象设计中，鸭子类型的概念至关重要。利用鸭子类型的思想，我们不必借助`超类型`的帮助，就能轻松地在动态类型语言中实现一个原则：“面向接口编程，而不是面向实现编程”。\n例如,\n1. 一个对象若有push和pop方法，并且这些方法提供了正确的实现，它就可以被当作栈来使用。\n2. 一个对象如果有length属性，也可以依照下标来存取属性（最好还要拥有slice和splice等方法），这个对象就可以被当作数组来使用。\n3. 比如在python中，有很多file-like的东西，比如StringIO,GzipFile,socket。它们有很多相同的方法，我们把它们当作文件使用。\n4. 又比如list.extend()方法中,我们并不关心它的参数是不是list,只要它是可迭代的,所以它的参数可以是list/tuple/dict/字符串/生成器等.\n\n鸭子类型在动态语言中经常使用，非常灵活，使得python不想java那样专门去弄一大堆的设计模式。\n\n\n在静态类型语言中，要实现“面向接口编程”并不是一件容易的事情，往往要通过抽象类或者接口等将对象进行`向上转型`。当对象的真正类型被隐藏在它的超类型身后，这些对象才能在`类型检查系统`的“监视”之下互相被替换使用。只有当对象能够被互相替换使用，才能体现出对象多态性的价值。\n\n## Python中的多态\n\n**Python中的鸭子类型允许我们使用任何提供所需方法的对象，而不需要迫使它成为一个子类。**  \n由于python属于动态语言，当你定义了一个基类和基类中的方法，并编写几个继承该基类的子类时，由于python在定义变量时不指定变量的类型，而是由解释器根据变量内容推断变量类型的（也就是说变量的类型取决于所关联的对象），这就使得python的多态不像是c++或java中那样---定义一个基类类型变量而隐藏了具体子类的细节。\n\n请看下面的例子和说明：\n```python\nclass AudioFile:\n    def __init__(self, filename):\n        if not filename.endswith(self.ext):\n            raise Exception(\"Invalid file format\")\n        self.filename = filename\n\nclass MP3File(AudioFile):\n    ext = \"mp3\"\n    def play(self):\n        print(\"Playing {} as mp3\".format(self.filename))\n\nclass WavFile(AudioFile):\n    ext = \"wav\"\n    def play(self):\n        print(\"Playing {} as wav\".format(self.filename))\n\nclass OggFile(AudioFile):\n    ext = \"ogg\"\n    def play(self):\n        print(\"Playing {} as ogg\".format(self.filename))\n\nclass FlacFile:\n    \"\"\"\n    Though FlacFile class doesn't inherit AudioFile class,\n    it also has the same interface as three subclass of AudioFile.\n\n    It is called duck typing.\n    \"\"\"\n    def __init__(self, filename):\n        if not filename.endswith(\".flac\"):\n            raise Exception(\"Invalid file format\")\n        self.filename = filename\n\n    def play(self):\n        print(\"Playing {} as flac\".format(self.filename))\n\n\n```\n>Though FlacFile class doesn't inherit AudioFile class,\n>it also has the same interface as three subclass of AudioFile.\n>It is called duck typing.\n\n上面的代码中，`MP3File`、`WavFile`、`OggFile`三个类型继承了`AudioFile`这一积累，而`FlacFile`没有扩展`AudioFile`，但是可以在python中使用完全相同的接口与之交互。  \n\n因为任何提供正确接口的对象都可以在python中交替使用，它减少了多态的一般`超类`的需求。继承仍然可以用来共享代码，但是如果所有被共享的都是公共接口，鸭子类型就是所有所需的。这减少了继承的需要，同时也减少了多重继承的需要；通常，当多重继承似乎是一个有效方案的时候，我们只需要使用鸭子类型去模拟多个超类之一（定义和那个超类一样的接口和实现）就可以了。\n\n>作者：JasonDing\n>链接：https://www.jianshu.com/p/650485b78d11\n>來源：简书\n>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n## 参考\n1. https://baike.baidu.com/item/鸭子类型/10845665?fr=aladdin\n2. https://www.jianshu.com/p/650485b78d11\n","source":"_posts/Python3-鸭子类型.md","raw":"---\ntitle: Python3 鸭子类型\ndate: 2018-03-03 01:52:21\ntags:\n  - Python3\ncategories:\n  - Python3 进阶\n  - Python3 鸭子类型\n---\n\n## 来源和解释\nDuck typing 这个概念来源于美国印第安纳州的诗人詹姆斯·惠特科姆·莱利（James Whitcomb Riley,1849-1916）的诗句：\n\n>\" When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.\"\n\n中文：\n\n>“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”\n\n“鸭子类型”的语言是这么推断的：一只鸟走起来像鸭子、游起泳来像鸭子、叫起来也像鸭子，那它就可以被当做鸭子。也就是说，它不关注对象的类型，而是关注对象具有的行为(方法)。\n<!-- more -->\n\n鸭子类型是程序设计中的一种类型推断风格，这种风格适用于动态语言(比如PHP、Python、Ruby、Typescript、Perl、Objective-C、Lua、Julia、JavaScript、Java、Groovy、C#等)和某些静态语言(比如Golang,一般来说，静态类型语言在编译时便已确定了变量的类型，但是Golang的实现是：在编译时推断变量的类型)，支持\"鸭子类型\"的语言的解释器/编译器将会在解析(Parse)或编译时，推断对象的类型。\n\n`在鸭子类型中，关注的不是对象的类型本身，而是它是如何使用的。` 例如，在不使用鸭子类型的语言中，我们可以编写一个函数，它接受一个类型为鸭的对象，并调用它的走和叫方法。在使用鸭子类型的语言中，这样的一个函数可以接受一个任意类型的对象，并调用它的走和叫方法。如果这些需要被调用的方法不存在，那么将引发一个运行时错误。任何拥有这样的正确的走和叫方法的对象都可被函数接受的这种行为引出了以上表述，这种决定类型的方式因此得名。\n\n`鸭子类型通常得益于不测试方法和函数中参数的类型，而是依赖文档、清晰的代码和测试来确保正确使用。`从静态类型语言转向动态类型语言的用户通常试图添加一些静态的（在运行之前的）类型检查，从而影响了鸭子类型的益处和可伸缩性，并约束了语言的动态特性。\n\n\n## 不足\n\"鸭子类型\"没有任何静态检查，如类型检查、属性检查、方法签名检查等。\n\n“鸭子类型”语言的程序可能会在运行时因为不具备某种特定的方法而抛出异常：如果一只小狗(对象)想加入合唱团(以对象会不会嘎嘎嘎叫的方法为检验标准)，也学鸭子那么嘎嘎嘎叫，好吧，它加入了，可是加入之后，却不会像鸭子那样走路，那么，迟早要出问题的。\n\n再举个例子：一只小老鼠被猫盯上了，情急之下，它学了狗叫，猫撤了之后，小老鼠的妈妈不无感叹的对它说：看吧，我让你学的这门儿外语多么重要啊。这虽然是个段子，但是，由于猫在思考时，使用了 \"鸭子测试\"，它以为会叫的就是狗，会对自己产生威胁，所以撤退了，也正是因为这个错误的判断，它误失了一次进食机会。\n\n## 静态类型语言和动态类型语言的区别\n\n静态类型语言在编译时便已确定变量的类型，而动态类型语言的变量类型要到程序运行的时候，待变量被赋予某个值之后，才会具有某种类型。  \n\n`静态类型语言的优点`首先是在编译时就能发现类型不匹配的错误，编辑器可以帮助我们提前避免程序在运行期间有可能发生的一些错误。其次，如果在程序中明确地规定了数据类型，编译器还可以针对这些信息对程序进行一些优化工作，提高程序执行速度。  \n\n`静态类型语言的缺点`首先是迫使程序员依照强契约来编写程序，为每个变量规定数据类型，归根结底只是辅助我们编写可靠性高程序的一种手段，而不是编写程序的目的，毕竟大部分人编写程序的目的是为了完成需求交付生产。其次，类型的声明也会增加更多的代码，在程序编写过程中，这些细节会让程序员的精力从思考业务逻辑上分散开来。  \n\n`动态类型语言的优点`是编写的代码数量更少，看起来也更加简洁，程序员可以把精力更多地放在业务逻辑上面。虽然不区分类型在某些情况下会让程序变得难以理解，但整体而言，代码量越少，越专注于逻辑表达，对阅读程序是越有帮助的。  \n`动态类型语言的缺点`是无法保证变量的类型，从而在程序的运行期有可能发生跟类型相关的错误。\n\n**动态类型语言对变量类型的宽容给实际编码带来了很大的灵活性。由于无需进行类型检测，我们可以尝试调用任何对象的任意方法，而无需去考虑它原本是否被设计为拥有该方法。**\n\n## 面向接口编程\n\n动态类型语言的面向对象设计中，鸭子类型的概念至关重要。利用鸭子类型的思想，我们不必借助`超类型`的帮助，就能轻松地在动态类型语言中实现一个原则：“面向接口编程，而不是面向实现编程”。\n例如,\n1. 一个对象若有push和pop方法，并且这些方法提供了正确的实现，它就可以被当作栈来使用。\n2. 一个对象如果有length属性，也可以依照下标来存取属性（最好还要拥有slice和splice等方法），这个对象就可以被当作数组来使用。\n3. 比如在python中，有很多file-like的东西，比如StringIO,GzipFile,socket。它们有很多相同的方法，我们把它们当作文件使用。\n4. 又比如list.extend()方法中,我们并不关心它的参数是不是list,只要它是可迭代的,所以它的参数可以是list/tuple/dict/字符串/生成器等.\n\n鸭子类型在动态语言中经常使用，非常灵活，使得python不想java那样专门去弄一大堆的设计模式。\n\n\n在静态类型语言中，要实现“面向接口编程”并不是一件容易的事情，往往要通过抽象类或者接口等将对象进行`向上转型`。当对象的真正类型被隐藏在它的超类型身后，这些对象才能在`类型检查系统`的“监视”之下互相被替换使用。只有当对象能够被互相替换使用，才能体现出对象多态性的价值。\n\n## Python中的多态\n\n**Python中的鸭子类型允许我们使用任何提供所需方法的对象，而不需要迫使它成为一个子类。**  \n由于python属于动态语言，当你定义了一个基类和基类中的方法，并编写几个继承该基类的子类时，由于python在定义变量时不指定变量的类型，而是由解释器根据变量内容推断变量类型的（也就是说变量的类型取决于所关联的对象），这就使得python的多态不像是c++或java中那样---定义一个基类类型变量而隐藏了具体子类的细节。\n\n请看下面的例子和说明：\n```python\nclass AudioFile:\n    def __init__(self, filename):\n        if not filename.endswith(self.ext):\n            raise Exception(\"Invalid file format\")\n        self.filename = filename\n\nclass MP3File(AudioFile):\n    ext = \"mp3\"\n    def play(self):\n        print(\"Playing {} as mp3\".format(self.filename))\n\nclass WavFile(AudioFile):\n    ext = \"wav\"\n    def play(self):\n        print(\"Playing {} as wav\".format(self.filename))\n\nclass OggFile(AudioFile):\n    ext = \"ogg\"\n    def play(self):\n        print(\"Playing {} as ogg\".format(self.filename))\n\nclass FlacFile:\n    \"\"\"\n    Though FlacFile class doesn't inherit AudioFile class,\n    it also has the same interface as three subclass of AudioFile.\n\n    It is called duck typing.\n    \"\"\"\n    def __init__(self, filename):\n        if not filename.endswith(\".flac\"):\n            raise Exception(\"Invalid file format\")\n        self.filename = filename\n\n    def play(self):\n        print(\"Playing {} as flac\".format(self.filename))\n\n\n```\n>Though FlacFile class doesn't inherit AudioFile class,\n>it also has the same interface as three subclass of AudioFile.\n>It is called duck typing.\n\n上面的代码中，`MP3File`、`WavFile`、`OggFile`三个类型继承了`AudioFile`这一积累，而`FlacFile`没有扩展`AudioFile`，但是可以在python中使用完全相同的接口与之交互。  \n\n因为任何提供正确接口的对象都可以在python中交替使用，它减少了多态的一般`超类`的需求。继承仍然可以用来共享代码，但是如果所有被共享的都是公共接口，鸭子类型就是所有所需的。这减少了继承的需要，同时也减少了多重继承的需要；通常，当多重继承似乎是一个有效方案的时候，我们只需要使用鸭子类型去模拟多个超类之一（定义和那个超类一样的接口和实现）就可以了。\n\n>作者：JasonDing\n>链接：https://www.jianshu.com/p/650485b78d11\n>來源：简书\n>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n\n## 参考\n1. https://baike.baidu.com/item/鸭子类型/10845665?fr=aladdin\n2. https://www.jianshu.com/p/650485b78d11\n","slug":"Python3-鸭子类型","published":1,"updated":"2018-03-03T05:40:54.624Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozm300498moty3gibzpi","content":"<h2 id=\"来源和解释\"><a href=\"#来源和解释\" class=\"headerlink\" title=\"来源和解释\"></a>来源和解释</h2><p>Duck typing 这个概念来源于美国印第安纳州的诗人詹姆斯·惠特科姆·莱利（James Whitcomb Riley,1849-1916）的诗句：</p>\n<blockquote>\n<p>“ When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.”</p>\n</blockquote>\n<p>中文：</p>\n<blockquote>\n<p>“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”</p>\n</blockquote>\n<p>“鸭子类型”的语言是这么推断的：一只鸟走起来像鸭子、游起泳来像鸭子、叫起来也像鸭子，那它就可以被当做鸭子。也就是说，它不关注对象的类型，而是关注对象具有的行为(方法)。<br><a id=\"more\"></a></p>\n<p>鸭子类型是程序设计中的一种类型推断风格，这种风格适用于动态语言(比如PHP、Python、Ruby、Typescript、Perl、Objective-C、Lua、Julia、JavaScript、Java、Groovy、C#等)和某些静态语言(比如Golang,一般来说，静态类型语言在编译时便已确定了变量的类型，但是Golang的实现是：在编译时推断变量的类型)，支持”鸭子类型”的语言的解释器/编译器将会在解析(Parse)或编译时，推断对象的类型。</p>\n<p><code>在鸭子类型中，关注的不是对象的类型本身，而是它是如何使用的。</code> 例如，在不使用鸭子类型的语言中，我们可以编写一个函数，它接受一个类型为鸭的对象，并调用它的走和叫方法。在使用鸭子类型的语言中，这样的一个函数可以接受一个任意类型的对象，并调用它的走和叫方法。如果这些需要被调用的方法不存在，那么将引发一个运行时错误。任何拥有这样的正确的走和叫方法的对象都可被函数接受的这种行为引出了以上表述，这种决定类型的方式因此得名。</p>\n<p><code>鸭子类型通常得益于不测试方法和函数中参数的类型，而是依赖文档、清晰的代码和测试来确保正确使用。</code>从静态类型语言转向动态类型语言的用户通常试图添加一些静态的（在运行之前的）类型检查，从而影响了鸭子类型的益处和可伸缩性，并约束了语言的动态特性。</p>\n<h2 id=\"不足\"><a href=\"#不足\" class=\"headerlink\" title=\"不足\"></a>不足</h2><p>“鸭子类型”没有任何静态检查，如类型检查、属性检查、方法签名检查等。</p>\n<p>“鸭子类型”语言的程序可能会在运行时因为不具备某种特定的方法而抛出异常：如果一只小狗(对象)想加入合唱团(以对象会不会嘎嘎嘎叫的方法为检验标准)，也学鸭子那么嘎嘎嘎叫，好吧，它加入了，可是加入之后，却不会像鸭子那样走路，那么，迟早要出问题的。</p>\n<p>再举个例子：一只小老鼠被猫盯上了，情急之下，它学了狗叫，猫撤了之后，小老鼠的妈妈不无感叹的对它说：看吧，我让你学的这门儿外语多么重要啊。这虽然是个段子，但是，由于猫在思考时，使用了 “鸭子测试”，它以为会叫的就是狗，会对自己产生威胁，所以撤退了，也正是因为这个错误的判断，它误失了一次进食机会。</p>\n<h2 id=\"静态类型语言和动态类型语言的区别\"><a href=\"#静态类型语言和动态类型语言的区别\" class=\"headerlink\" title=\"静态类型语言和动态类型语言的区别\"></a>静态类型语言和动态类型语言的区别</h2><p>静态类型语言在编译时便已确定变量的类型，而动态类型语言的变量类型要到程序运行的时候，待变量被赋予某个值之后，才会具有某种类型。  </p>\n<p><code>静态类型语言的优点</code>首先是在编译时就能发现类型不匹配的错误，编辑器可以帮助我们提前避免程序在运行期间有可能发生的一些错误。其次，如果在程序中明确地规定了数据类型，编译器还可以针对这些信息对程序进行一些优化工作，提高程序执行速度。  </p>\n<p><code>静态类型语言的缺点</code>首先是迫使程序员依照强契约来编写程序，为每个变量规定数据类型，归根结底只是辅助我们编写可靠性高程序的一种手段，而不是编写程序的目的，毕竟大部分人编写程序的目的是为了完成需求交付生产。其次，类型的声明也会增加更多的代码，在程序编写过程中，这些细节会让程序员的精力从思考业务逻辑上分散开来。  </p>\n<p><code>动态类型语言的优点</code>是编写的代码数量更少，看起来也更加简洁，程序员可以把精力更多地放在业务逻辑上面。虽然不区分类型在某些情况下会让程序变得难以理解，但整体而言，代码量越少，越专注于逻辑表达，对阅读程序是越有帮助的。<br><code>动态类型语言的缺点</code>是无法保证变量的类型，从而在程序的运行期有可能发生跟类型相关的错误。</p>\n<p><strong>动态类型语言对变量类型的宽容给实际编码带来了很大的灵活性。由于无需进行类型检测，我们可以尝试调用任何对象的任意方法，而无需去考虑它原本是否被设计为拥有该方法。</strong></p>\n<h2 id=\"面向接口编程\"><a href=\"#面向接口编程\" class=\"headerlink\" title=\"面向接口编程\"></a>面向接口编程</h2><p>动态类型语言的面向对象设计中，鸭子类型的概念至关重要。利用鸭子类型的思想，我们不必借助<code>超类型</code>的帮助，就能轻松地在动态类型语言中实现一个原则：“面向接口编程，而不是面向实现编程”。<br>例如,</p>\n<ol>\n<li>一个对象若有push和pop方法，并且这些方法提供了正确的实现，它就可以被当作栈来使用。</li>\n<li>一个对象如果有length属性，也可以依照下标来存取属性（最好还要拥有slice和splice等方法），这个对象就可以被当作数组来使用。</li>\n<li>比如在python中，有很多file-like的东西，比如StringIO,GzipFile,socket。它们有很多相同的方法，我们把它们当作文件使用。</li>\n<li>又比如list.extend()方法中,我们并不关心它的参数是不是list,只要它是可迭代的,所以它的参数可以是list/tuple/dict/字符串/生成器等.</li>\n</ol>\n<p>鸭子类型在动态语言中经常使用，非常灵活，使得python不想java那样专门去弄一大堆的设计模式。</p>\n<p>在静态类型语言中，要实现“面向接口编程”并不是一件容易的事情，往往要通过抽象类或者接口等将对象进行<code>向上转型</code>。当对象的真正类型被隐藏在它的超类型身后，这些对象才能在<code>类型检查系统</code>的“监视”之下互相被替换使用。只有当对象能够被互相替换使用，才能体现出对象多态性的价值。</p>\n<h2 id=\"Python中的多态\"><a href=\"#Python中的多态\" class=\"headerlink\" title=\"Python中的多态\"></a>Python中的多态</h2><p><strong>Python中的鸭子类型允许我们使用任何提供所需方法的对象，而不需要迫使它成为一个子类。</strong><br>由于python属于动态语言，当你定义了一个基类和基类中的方法，并编写几个继承该基类的子类时，由于python在定义变量时不指定变量的类型，而是由解释器根据变量内容推断变量类型的（也就是说变量的类型取决于所关联的对象），这就使得python的多态不像是c++或java中那样—定义一个基类类型变量而隐藏了具体子类的细节。</p>\n<p>请看下面的例子和说明：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AudioFile</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, filename)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> filename.endswith(self.ext):</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> Exception(<span class=\"string\">\"Invalid file format\"</span>)</span><br><span class=\"line\">        self.filename = filename</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MP3File</span><span class=\"params\">(AudioFile)</span>:</span></span><br><span class=\"line\">    ext = <span class=\"string\">\"mp3\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">play</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">\"Playing &#123;&#125; as mp3\"</span>.format(self.filename))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WavFile</span><span class=\"params\">(AudioFile)</span>:</span></span><br><span class=\"line\">    ext = <span class=\"string\">\"wav\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">play</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">\"Playing &#123;&#125; as wav\"</span>.format(self.filename))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OggFile</span><span class=\"params\">(AudioFile)</span>:</span></span><br><span class=\"line\">    ext = <span class=\"string\">\"ogg\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">play</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">\"Playing &#123;&#125; as ogg\"</span>.format(self.filename))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FlacFile</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    Though FlacFile class doesn't inherit AudioFile class,</span></span><br><span class=\"line\"><span class=\"string\">    it also has the same interface as three subclass of AudioFile.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    It is called duck typing.</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, filename)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> filename.endswith(<span class=\"string\">\".flac\"</span>):</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> Exception(<span class=\"string\">\"Invalid file format\"</span>)</span><br><span class=\"line\">        self.filename = filename</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">play</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">\"Playing &#123;&#125; as flac\"</span>.format(self.filename))</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>Though FlacFile class doesn’t inherit AudioFile class,<br>it also has the same interface as three subclass of AudioFile.<br>It is called duck typing.</p>\n</blockquote>\n<p>上面的代码中，<code>MP3File</code>、<code>WavFile</code>、<code>OggFile</code>三个类型继承了<code>AudioFile</code>这一积累，而<code>FlacFile</code>没有扩展<code>AudioFile</code>，但是可以在python中使用完全相同的接口与之交互。  </p>\n<p>因为任何提供正确接口的对象都可以在python中交替使用，它减少了多态的一般<code>超类</code>的需求。继承仍然可以用来共享代码，但是如果所有被共享的都是公共接口，鸭子类型就是所有所需的。这减少了继承的需要，同时也减少了多重继承的需要；通常，当多重继承似乎是一个有效方案的时候，我们只需要使用鸭子类型去模拟多个超类之一（定义和那个超类一样的接口和实现）就可以了。</p>\n<blockquote>\n<p>作者：JasonDing<br>链接：<a href=\"https://www.jianshu.com/p/650485b78d11\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/650485b78d11</a><br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n</blockquote>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://baike.baidu.com/item/鸭子类型/10845665?fr=aladdin\" target=\"_blank\" rel=\"noopener\">https://baike.baidu.com/item/鸭子类型/10845665?fr=aladdin</a></li>\n<li><a href=\"https://www.jianshu.com/p/650485b78d11\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/650485b78d11</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"来源和解释\"><a href=\"#来源和解释\" class=\"headerlink\" title=\"来源和解释\"></a>来源和解释</h2><p>Duck typing 这个概念来源于美国印第安纳州的诗人詹姆斯·惠特科姆·莱利（James Whitcomb Riley,1849-1916）的诗句：</p>\n<blockquote>\n<p>“ When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.”</p>\n</blockquote>\n<p>中文：</p>\n<blockquote>\n<p>“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”</p>\n</blockquote>\n<p>“鸭子类型”的语言是这么推断的：一只鸟走起来像鸭子、游起泳来像鸭子、叫起来也像鸭子，那它就可以被当做鸭子。也就是说，它不关注对象的类型，而是关注对象具有的行为(方法)。<br>","more":"</p>\n<p>鸭子类型是程序设计中的一种类型推断风格，这种风格适用于动态语言(比如PHP、Python、Ruby、Typescript、Perl、Objective-C、Lua、Julia、JavaScript、Java、Groovy、C#等)和某些静态语言(比如Golang,一般来说，静态类型语言在编译时便已确定了变量的类型，但是Golang的实现是：在编译时推断变量的类型)，支持”鸭子类型”的语言的解释器/编译器将会在解析(Parse)或编译时，推断对象的类型。</p>\n<p><code>在鸭子类型中，关注的不是对象的类型本身，而是它是如何使用的。</code> 例如，在不使用鸭子类型的语言中，我们可以编写一个函数，它接受一个类型为鸭的对象，并调用它的走和叫方法。在使用鸭子类型的语言中，这样的一个函数可以接受一个任意类型的对象，并调用它的走和叫方法。如果这些需要被调用的方法不存在，那么将引发一个运行时错误。任何拥有这样的正确的走和叫方法的对象都可被函数接受的这种行为引出了以上表述，这种决定类型的方式因此得名。</p>\n<p><code>鸭子类型通常得益于不测试方法和函数中参数的类型，而是依赖文档、清晰的代码和测试来确保正确使用。</code>从静态类型语言转向动态类型语言的用户通常试图添加一些静态的（在运行之前的）类型检查，从而影响了鸭子类型的益处和可伸缩性，并约束了语言的动态特性。</p>\n<h2 id=\"不足\"><a href=\"#不足\" class=\"headerlink\" title=\"不足\"></a>不足</h2><p>“鸭子类型”没有任何静态检查，如类型检查、属性检查、方法签名检查等。</p>\n<p>“鸭子类型”语言的程序可能会在运行时因为不具备某种特定的方法而抛出异常：如果一只小狗(对象)想加入合唱团(以对象会不会嘎嘎嘎叫的方法为检验标准)，也学鸭子那么嘎嘎嘎叫，好吧，它加入了，可是加入之后，却不会像鸭子那样走路，那么，迟早要出问题的。</p>\n<p>再举个例子：一只小老鼠被猫盯上了，情急之下，它学了狗叫，猫撤了之后，小老鼠的妈妈不无感叹的对它说：看吧，我让你学的这门儿外语多么重要啊。这虽然是个段子，但是，由于猫在思考时，使用了 “鸭子测试”，它以为会叫的就是狗，会对自己产生威胁，所以撤退了，也正是因为这个错误的判断，它误失了一次进食机会。</p>\n<h2 id=\"静态类型语言和动态类型语言的区别\"><a href=\"#静态类型语言和动态类型语言的区别\" class=\"headerlink\" title=\"静态类型语言和动态类型语言的区别\"></a>静态类型语言和动态类型语言的区别</h2><p>静态类型语言在编译时便已确定变量的类型，而动态类型语言的变量类型要到程序运行的时候，待变量被赋予某个值之后，才会具有某种类型。  </p>\n<p><code>静态类型语言的优点</code>首先是在编译时就能发现类型不匹配的错误，编辑器可以帮助我们提前避免程序在运行期间有可能发生的一些错误。其次，如果在程序中明确地规定了数据类型，编译器还可以针对这些信息对程序进行一些优化工作，提高程序执行速度。  </p>\n<p><code>静态类型语言的缺点</code>首先是迫使程序员依照强契约来编写程序，为每个变量规定数据类型，归根结底只是辅助我们编写可靠性高程序的一种手段，而不是编写程序的目的，毕竟大部分人编写程序的目的是为了完成需求交付生产。其次，类型的声明也会增加更多的代码，在程序编写过程中，这些细节会让程序员的精力从思考业务逻辑上分散开来。  </p>\n<p><code>动态类型语言的优点</code>是编写的代码数量更少，看起来也更加简洁，程序员可以把精力更多地放在业务逻辑上面。虽然不区分类型在某些情况下会让程序变得难以理解，但整体而言，代码量越少，越专注于逻辑表达，对阅读程序是越有帮助的。<br><code>动态类型语言的缺点</code>是无法保证变量的类型，从而在程序的运行期有可能发生跟类型相关的错误。</p>\n<p><strong>动态类型语言对变量类型的宽容给实际编码带来了很大的灵活性。由于无需进行类型检测，我们可以尝试调用任何对象的任意方法，而无需去考虑它原本是否被设计为拥有该方法。</strong></p>\n<h2 id=\"面向接口编程\"><a href=\"#面向接口编程\" class=\"headerlink\" title=\"面向接口编程\"></a>面向接口编程</h2><p>动态类型语言的面向对象设计中，鸭子类型的概念至关重要。利用鸭子类型的思想，我们不必借助<code>超类型</code>的帮助，就能轻松地在动态类型语言中实现一个原则：“面向接口编程，而不是面向实现编程”。<br>例如,</p>\n<ol>\n<li>一个对象若有push和pop方法，并且这些方法提供了正确的实现，它就可以被当作栈来使用。</li>\n<li>一个对象如果有length属性，也可以依照下标来存取属性（最好还要拥有slice和splice等方法），这个对象就可以被当作数组来使用。</li>\n<li>比如在python中，有很多file-like的东西，比如StringIO,GzipFile,socket。它们有很多相同的方法，我们把它们当作文件使用。</li>\n<li>又比如list.extend()方法中,我们并不关心它的参数是不是list,只要它是可迭代的,所以它的参数可以是list/tuple/dict/字符串/生成器等.</li>\n</ol>\n<p>鸭子类型在动态语言中经常使用，非常灵活，使得python不想java那样专门去弄一大堆的设计模式。</p>\n<p>在静态类型语言中，要实现“面向接口编程”并不是一件容易的事情，往往要通过抽象类或者接口等将对象进行<code>向上转型</code>。当对象的真正类型被隐藏在它的超类型身后，这些对象才能在<code>类型检查系统</code>的“监视”之下互相被替换使用。只有当对象能够被互相替换使用，才能体现出对象多态性的价值。</p>\n<h2 id=\"Python中的多态\"><a href=\"#Python中的多态\" class=\"headerlink\" title=\"Python中的多态\"></a>Python中的多态</h2><p><strong>Python中的鸭子类型允许我们使用任何提供所需方法的对象，而不需要迫使它成为一个子类。</strong><br>由于python属于动态语言，当你定义了一个基类和基类中的方法，并编写几个继承该基类的子类时，由于python在定义变量时不指定变量的类型，而是由解释器根据变量内容推断变量类型的（也就是说变量的类型取决于所关联的对象），这就使得python的多态不像是c++或java中那样—定义一个基类类型变量而隐藏了具体子类的细节。</p>\n<p>请看下面的例子和说明：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AudioFile</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, filename)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> filename.endswith(self.ext):</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> Exception(<span class=\"string\">\"Invalid file format\"</span>)</span><br><span class=\"line\">        self.filename = filename</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MP3File</span><span class=\"params\">(AudioFile)</span>:</span></span><br><span class=\"line\">    ext = <span class=\"string\">\"mp3\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">play</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">\"Playing &#123;&#125; as mp3\"</span>.format(self.filename))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WavFile</span><span class=\"params\">(AudioFile)</span>:</span></span><br><span class=\"line\">    ext = <span class=\"string\">\"wav\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">play</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">\"Playing &#123;&#125; as wav\"</span>.format(self.filename))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OggFile</span><span class=\"params\">(AudioFile)</span>:</span></span><br><span class=\"line\">    ext = <span class=\"string\">\"ogg\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">play</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">\"Playing &#123;&#125; as ogg\"</span>.format(self.filename))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FlacFile</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">    Though FlacFile class doesn't inherit AudioFile class,</span></span><br><span class=\"line\"><span class=\"string\">    it also has the same interface as three subclass of AudioFile.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    It is called duck typing.</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, filename)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> filename.endswith(<span class=\"string\">\".flac\"</span>):</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> Exception(<span class=\"string\">\"Invalid file format\"</span>)</span><br><span class=\"line\">        self.filename = filename</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">play</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">\"Playing &#123;&#125; as flac\"</span>.format(self.filename))</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>Though FlacFile class doesn’t inherit AudioFile class,<br>it also has the same interface as three subclass of AudioFile.<br>It is called duck typing.</p>\n</blockquote>\n<p>上面的代码中，<code>MP3File</code>、<code>WavFile</code>、<code>OggFile</code>三个类型继承了<code>AudioFile</code>这一积累，而<code>FlacFile</code>没有扩展<code>AudioFile</code>，但是可以在python中使用完全相同的接口与之交互。  </p>\n<p>因为任何提供正确接口的对象都可以在python中交替使用，它减少了多态的一般<code>超类</code>的需求。继承仍然可以用来共享代码，但是如果所有被共享的都是公共接口，鸭子类型就是所有所需的。这减少了继承的需要，同时也减少了多重继承的需要；通常，当多重继承似乎是一个有效方案的时候，我们只需要使用鸭子类型去模拟多个超类之一（定义和那个超类一样的接口和实现）就可以了。</p>\n<blockquote>\n<p>作者：JasonDing<br>链接：<a href=\"https://www.jianshu.com/p/650485b78d11\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/650485b78d11</a><br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n</blockquote>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://baike.baidu.com/item/鸭子类型/10845665?fr=aladdin\" target=\"_blank\" rel=\"noopener\">https://baike.baidu.com/item/鸭子类型/10845665?fr=aladdin</a></li>\n<li><a href=\"https://www.jianshu.com/p/650485b78d11\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/650485b78d11</a></li>\n</ol>"},{"title":"TCP 套接字编程","date":"2018-07-25T12:50:59.000Z","_content":"\n\n![Screen Shot 2018-07-25 at 19.55.29.png](https://upload-images.jianshu.io/upload_images/2952111-016af56091643bbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n<!-- more -->\n\n\n## TCPClient.py\n```python\nfrom socket import *\n\nserverName = 'server.kunxiang.wang'\nserverPort = 12000\n\nclientSocket = socket(AF_INET, SOCK_STREAM)\n\n# 如果不绑定客户端进程端口，则自动选择端口\nclientSocket.bind(('', 34567))\n\nclientSocket.connect((serverName, serverPort))\n\nmsg = input('please input lowercase sentence: ').encode()\n\nclientSocket.send(msg)\n\nmodifiedMsg = clientSocket.recv(2048)\n\nprint(modifiedMsg)\n\n\nclientSocket.close()\n```\n\n## TCPServer.py\n```python\nfrom socket import *\n\nserverPort = 12000\n\nserverSocket = socket(AF_INET, SOCK_STREAM)\nserverSocket.bind(('', serverPort))\nserverSocket.listen(1)\n\nprint('the server is ready to receive')\n\nwhile True:\n    connectionSocket, clientAddress = serverSocket.accept()\n    print(connectionSocket, clientAddress)\n\n    msg = connectionSocket.recv(1024)\n    print(msg)\n\n    modifiedMsg = msg.upper()\n    connectionSocket.send(modifiedMsg)\n    connectionSocket.close()\n\n```","source":"_posts/TCP-套接字编程.md","raw":"---\ntitle: TCP 套接字编程\ndate: 2018-07-25 20:50:59\ntags:\n  - 网络\ncategories:\n  - 网络\n---\n\n\n![Screen Shot 2018-07-25 at 19.55.29.png](https://upload-images.jianshu.io/upload_images/2952111-016af56091643bbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n<!-- more -->\n\n\n## TCPClient.py\n```python\nfrom socket import *\n\nserverName = 'server.kunxiang.wang'\nserverPort = 12000\n\nclientSocket = socket(AF_INET, SOCK_STREAM)\n\n# 如果不绑定客户端进程端口，则自动选择端口\nclientSocket.bind(('', 34567))\n\nclientSocket.connect((serverName, serverPort))\n\nmsg = input('please input lowercase sentence: ').encode()\n\nclientSocket.send(msg)\n\nmodifiedMsg = clientSocket.recv(2048)\n\nprint(modifiedMsg)\n\n\nclientSocket.close()\n```\n\n## TCPServer.py\n```python\nfrom socket import *\n\nserverPort = 12000\n\nserverSocket = socket(AF_INET, SOCK_STREAM)\nserverSocket.bind(('', serverPort))\nserverSocket.listen(1)\n\nprint('the server is ready to receive')\n\nwhile True:\n    connectionSocket, clientAddress = serverSocket.accept()\n    print(connectionSocket, clientAddress)\n\n    msg = connectionSocket.recv(1024)\n    print(msg)\n\n    modifiedMsg = msg.upper()\n    connectionSocket.send(modifiedMsg)\n    connectionSocket.close()\n\n```","slug":"TCP-套接字编程","published":1,"updated":"2018-07-28T06:47:41.361Z","_id":"cjk14ozm5004c8motij15owur","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"https://upload-images.jianshu.io/upload_images/2952111-016af56091643bbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Screen Shot 2018-07-25 at 19.55.29.png\"></p>\n<a id=\"more\"></a>\n<h2 id=\"TCPClient-py\"><a href=\"#TCPClient-py\" class=\"headerlink\" title=\"TCPClient.py\"></a>TCPClient.py</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> socket <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">serverName = <span class=\"string\">'server.kunxiang.wang'</span></span><br><span class=\"line\">serverPort = <span class=\"number\">12000</span></span><br><span class=\"line\"></span><br><span class=\"line\">clientSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果不绑定客户端进程端口，则自动选择端口</span></span><br><span class=\"line\">clientSocket.bind((<span class=\"string\">''</span>, <span class=\"number\">34567</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">clientSocket.connect((serverName, serverPort))</span><br><span class=\"line\"></span><br><span class=\"line\">msg = input(<span class=\"string\">'please input lowercase sentence: '</span>).encode()</span><br><span class=\"line\"></span><br><span class=\"line\">clientSocket.send(msg)</span><br><span class=\"line\"></span><br><span class=\"line\">modifiedMsg = clientSocket.recv(<span class=\"number\">2048</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">print(modifiedMsg)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">clientSocket.close()</span><br></pre></td></tr></table></figure>\n<h2 id=\"TCPServer-py\"><a href=\"#TCPServer-py\" class=\"headerlink\" title=\"TCPServer.py\"></a>TCPServer.py</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> socket <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">serverPort = <span class=\"number\">12000</span></span><br><span class=\"line\"></span><br><span class=\"line\">serverSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class=\"line\">serverSocket.bind((<span class=\"string\">''</span>, serverPort))</span><br><span class=\"line\">serverSocket.listen(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'the server is ready to receive'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">    connectionSocket, clientAddress = serverSocket.accept()</span><br><span class=\"line\">    print(connectionSocket, clientAddress)</span><br><span class=\"line\"></span><br><span class=\"line\">    msg = connectionSocket.recv(<span class=\"number\">1024</span>)</span><br><span class=\"line\">    print(msg)</span><br><span class=\"line\"></span><br><span class=\"line\">    modifiedMsg = msg.upper()</span><br><span class=\"line\">    connectionSocket.send(modifiedMsg)</span><br><span class=\"line\">    connectionSocket.close()</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p><img src=\"https://upload-images.jianshu.io/upload_images/2952111-016af56091643bbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Screen Shot 2018-07-25 at 19.55.29.png\"></p>","more":"<h2 id=\"TCPClient-py\"><a href=\"#TCPClient-py\" class=\"headerlink\" title=\"TCPClient.py\"></a>TCPClient.py</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> socket <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">serverName = <span class=\"string\">'server.kunxiang.wang'</span></span><br><span class=\"line\">serverPort = <span class=\"number\">12000</span></span><br><span class=\"line\"></span><br><span class=\"line\">clientSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果不绑定客户端进程端口，则自动选择端口</span></span><br><span class=\"line\">clientSocket.bind((<span class=\"string\">''</span>, <span class=\"number\">34567</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">clientSocket.connect((serverName, serverPort))</span><br><span class=\"line\"></span><br><span class=\"line\">msg = input(<span class=\"string\">'please input lowercase sentence: '</span>).encode()</span><br><span class=\"line\"></span><br><span class=\"line\">clientSocket.send(msg)</span><br><span class=\"line\"></span><br><span class=\"line\">modifiedMsg = clientSocket.recv(<span class=\"number\">2048</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">print(modifiedMsg)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">clientSocket.close()</span><br></pre></td></tr></table></figure>\n<h2 id=\"TCPServer-py\"><a href=\"#TCPServer-py\" class=\"headerlink\" title=\"TCPServer.py\"></a>TCPServer.py</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> socket <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">serverPort = <span class=\"number\">12000</span></span><br><span class=\"line\"></span><br><span class=\"line\">serverSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class=\"line\">serverSocket.bind((<span class=\"string\">''</span>, serverPort))</span><br><span class=\"line\">serverSocket.listen(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'the server is ready to receive'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">    connectionSocket, clientAddress = serverSocket.accept()</span><br><span class=\"line\">    print(connectionSocket, clientAddress)</span><br><span class=\"line\"></span><br><span class=\"line\">    msg = connectionSocket.recv(<span class=\"number\">1024</span>)</span><br><span class=\"line\">    print(msg)</span><br><span class=\"line\"></span><br><span class=\"line\">    modifiedMsg = msg.upper()</span><br><span class=\"line\">    connectionSocket.send(modifiedMsg)</span><br><span class=\"line\">    connectionSocket.close()</span><br></pre></td></tr></table></figure>"},{"title":"Tesseract的使用","date":"2018-03-12T04:35:36.000Z","_content":"\n## Running Tesseract with command-line\n\nTesseract is a command-line program, so first open a terminal or command prompt. The command is used like this:\n```bash    \ntesseract imagename outputbase [-l lang] [-psm pagesegmode] [configfile...]\n```\nSo basic usage to do OCR on an image called 'myscan.png' and save the result to 'out.txt' would be:\n```bash    \ntesseract myscan.png out\n```\nOr to do the same with German:\n```bash   \ntesseract myscan.png out -l deu\n```\nIt can even be used with multiple languages traineddata at a time eg. English and German:\n```bash\n     tesseract myscan.png out -l eng+deu\n```\n<!-- more -->\nTesseract also includes a hOCR mode, which produces a special HTML file with the coordinates of each word. This can be used to create a searchable pdf, using a tool such as [Hocr2PDF](https://exactcode.com/opensource/exactimage/). To use it, use the 'hocr' config option, like this:\n```bash    \ntesseract myscan.png out hocr\n```\nYou can also create a searchable pdf directly from tesseract ( versions >=3.03):\n```bash    \ntesseract myscan.png out pdf\n```\nMore information about the various options is available in the [Tesseract manpage](https://github.com/tesseract-ocr/tesseract/blob/master/doc/tesseract.1.asc).\n\n### Other Languages\n\nTesseract has been trained for [many languages](https://github.com/tesseract-ocr/tesseract/blob/master/doc/tesseract.1.asc#languages), check for your language in the [Tessdata repository](https://github.com/tesseract-ocr/tessdata).\n\nFor example, if we want Tesseract support Chinese language, just put `chi_sim.traineddata` into the path `/usr/local/Cellar/tesseract/3.05.01/share/tessdata/`。\n\nIt can also be trained to support other languages and scripts; for more details see [TrainingTesseract](https://github.com/tesseract-ocr/tesseract/wiki/TrainingTesseract).\n\n\n## Running Tesseract with Python\nPython-tesseract is an optical character recognition (OCR) tool for python. That is, it will recognize and \"read\" the text embedded in images.\n\n### Usage\n** Quick start **\n```Python\ntry:\n    import Image\nexcept ImportError:\n    from PIL import Image\nimport pytesseract\n\npytesseract.pytesseract.tesseract_cmd = '<full_path_to_your_tesseract_executable>'\n# Include the above line, if you don't have tesseract executable in your PATH\n# Example tesseract_cmd: 'C:\\\\Program Files (x86)\\\\Tesseract-OCR\\\\tesseract'\n\n# Simple image to string\nprint(pytesseract.image_to_string(Image.open('test.png')))\n\n# French text image to string\nprint(pytesseract.image_to_string(Image.open('test-european.jpg'), lang='fra'))\n\n# Get bounding box estimates\nprint(pytesseract.image_to_boxes(Image.open('test.png')))\n\n# Get verbose data including boxes, confidences, line and page numbers\nprint(pytesseract.image_to_data(Image.open('test.png')))\n```\nSupport for OpenCV image/NumPy array objects\n```python\nimport cv2\n\nimg = cv2.imread('/**path_to_image**/digits.png')\nprint(pytesseract.image_to_string(img))\n# OR explicit beforehand converting\nprint(pytesseract.image_to_string(Image.fromarray(img))\n```\nAdd the following config, if you have tessdata error like: \"Error opening data file...\"\n```python\ntessdata_dir_config = '--tessdata-dir \"<replace_with_your_tessdata_dir_path>\"'\n# Example config: '--tessdata-dir \"C:\\\\Program Files (x86)\\\\Tesseract-OCR\\\\tessdata\"'\n# It's important to add double quotes around the dir path.\n\npytesseract.image_to_string(image, lang='chi_sim', config=tessdata_dir_config)\n\n```\n\n**Functions**\n\n- **image_to_string** Returns the result of a Tesseract OCR run on the image to string\n- **image_to_boxes** Returns result containing recognized characters and their box boundaries\n- **image_to_data** Returns result containing box boundaries, confidences, and other information. Requires Tesseract 3.05+. For more information, please check the [Tesseract TSV documentation](https://github.com/tesseract-ocr/tesseract/wiki/Command-Line-Usage#tsv-output-currently-available-in-305-dev-in-master-branch-on-github)\n\n**Parameters**\n\n`image_to_data(image, lang=None, config='', nice=0, output_type=Output.STRING)`\n\n- **image** Object, PIL Image/NumPy array of the image to be processed by Tesseract\n- **lang** String, Tesseract language code string\n- **config** String, Any additional configurations as a string, ex: `config='--psm 6'`\n- **nice** Integer, modifies the processor priority for the Tesseract run. Not supported on Windows. Nice adjusts the niceness of unix-like processes.\n- **output_type** Class attribute, specifies the type of the output, defaults to `string`. For the full list of all supported types, please check the definition of [pytesseract.Output](https://github.com/madmaze/pytesseract/blob/master/src/pytesseract.py) class.\n","source":"_posts/Tesseract的使用.md","raw":"---\ntitle: Tesseract的使用\ndate: 2018-03-12 12:35:36\ntags:\n  - Tesseract\ncategories:\n  - Tesseract\n---\n\n## Running Tesseract with command-line\n\nTesseract is a command-line program, so first open a terminal or command prompt. The command is used like this:\n```bash    \ntesseract imagename outputbase [-l lang] [-psm pagesegmode] [configfile...]\n```\nSo basic usage to do OCR on an image called 'myscan.png' and save the result to 'out.txt' would be:\n```bash    \ntesseract myscan.png out\n```\nOr to do the same with German:\n```bash   \ntesseract myscan.png out -l deu\n```\nIt can even be used with multiple languages traineddata at a time eg. English and German:\n```bash\n     tesseract myscan.png out -l eng+deu\n```\n<!-- more -->\nTesseract also includes a hOCR mode, which produces a special HTML file with the coordinates of each word. This can be used to create a searchable pdf, using a tool such as [Hocr2PDF](https://exactcode.com/opensource/exactimage/). To use it, use the 'hocr' config option, like this:\n```bash    \ntesseract myscan.png out hocr\n```\nYou can also create a searchable pdf directly from tesseract ( versions >=3.03):\n```bash    \ntesseract myscan.png out pdf\n```\nMore information about the various options is available in the [Tesseract manpage](https://github.com/tesseract-ocr/tesseract/blob/master/doc/tesseract.1.asc).\n\n### Other Languages\n\nTesseract has been trained for [many languages](https://github.com/tesseract-ocr/tesseract/blob/master/doc/tesseract.1.asc#languages), check for your language in the [Tessdata repository](https://github.com/tesseract-ocr/tessdata).\n\nFor example, if we want Tesseract support Chinese language, just put `chi_sim.traineddata` into the path `/usr/local/Cellar/tesseract/3.05.01/share/tessdata/`。\n\nIt can also be trained to support other languages and scripts; for more details see [TrainingTesseract](https://github.com/tesseract-ocr/tesseract/wiki/TrainingTesseract).\n\n\n## Running Tesseract with Python\nPython-tesseract is an optical character recognition (OCR) tool for python. That is, it will recognize and \"read\" the text embedded in images.\n\n### Usage\n** Quick start **\n```Python\ntry:\n    import Image\nexcept ImportError:\n    from PIL import Image\nimport pytesseract\n\npytesseract.pytesseract.tesseract_cmd = '<full_path_to_your_tesseract_executable>'\n# Include the above line, if you don't have tesseract executable in your PATH\n# Example tesseract_cmd: 'C:\\\\Program Files (x86)\\\\Tesseract-OCR\\\\tesseract'\n\n# Simple image to string\nprint(pytesseract.image_to_string(Image.open('test.png')))\n\n# French text image to string\nprint(pytesseract.image_to_string(Image.open('test-european.jpg'), lang='fra'))\n\n# Get bounding box estimates\nprint(pytesseract.image_to_boxes(Image.open('test.png')))\n\n# Get verbose data including boxes, confidences, line and page numbers\nprint(pytesseract.image_to_data(Image.open('test.png')))\n```\nSupport for OpenCV image/NumPy array objects\n```python\nimport cv2\n\nimg = cv2.imread('/**path_to_image**/digits.png')\nprint(pytesseract.image_to_string(img))\n# OR explicit beforehand converting\nprint(pytesseract.image_to_string(Image.fromarray(img))\n```\nAdd the following config, if you have tessdata error like: \"Error opening data file...\"\n```python\ntessdata_dir_config = '--tessdata-dir \"<replace_with_your_tessdata_dir_path>\"'\n# Example config: '--tessdata-dir \"C:\\\\Program Files (x86)\\\\Tesseract-OCR\\\\tessdata\"'\n# It's important to add double quotes around the dir path.\n\npytesseract.image_to_string(image, lang='chi_sim', config=tessdata_dir_config)\n\n```\n\n**Functions**\n\n- **image_to_string** Returns the result of a Tesseract OCR run on the image to string\n- **image_to_boxes** Returns result containing recognized characters and their box boundaries\n- **image_to_data** Returns result containing box boundaries, confidences, and other information. Requires Tesseract 3.05+. For more information, please check the [Tesseract TSV documentation](https://github.com/tesseract-ocr/tesseract/wiki/Command-Line-Usage#tsv-output-currently-available-in-305-dev-in-master-branch-on-github)\n\n**Parameters**\n\n`image_to_data(image, lang=None, config='', nice=0, output_type=Output.STRING)`\n\n- **image** Object, PIL Image/NumPy array of the image to be processed by Tesseract\n- **lang** String, Tesseract language code string\n- **config** String, Any additional configurations as a string, ex: `config='--psm 6'`\n- **nice** Integer, modifies the processor priority for the Tesseract run. Not supported on Windows. Nice adjusts the niceness of unix-like processes.\n- **output_type** Class attribute, specifies the type of the output, defaults to `string`. For the full list of all supported types, please check the definition of [pytesseract.Output](https://github.com/madmaze/pytesseract/blob/master/src/pytesseract.py) class.\n","slug":"Tesseract的使用","published":1,"updated":"2018-03-12T06:34:34.885Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozm7004g8motuo5msz5b","content":"<h2 id=\"Running-Tesseract-with-command-line\"><a href=\"#Running-Tesseract-with-command-line\" class=\"headerlink\" title=\"Running Tesseract with command-line\"></a>Running Tesseract with command-line</h2><p>Tesseract is a command-line program, so first open a terminal or command prompt. The command is used like this:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tesseract imagename outputbase [-l lang] [-psm pagesegmode] [configfile...]</span><br></pre></td></tr></table></figure></p>\n<p>So basic usage to do OCR on an image called ‘myscan.png’ and save the result to ‘out.txt’ would be:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tesseract myscan.png out</span><br></pre></td></tr></table></figure></p>\n<p>Or to do the same with German:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tesseract myscan.png out -l deu</span><br></pre></td></tr></table></figure></p>\n<p>It can even be used with multiple languages traineddata at a time eg. English and German:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tesseract myscan.png out -l eng+deu</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>Tesseract also includes a hOCR mode, which produces a special HTML file with the coordinates of each word. This can be used to create a searchable pdf, using a tool such as <a href=\"https://exactcode.com/opensource/exactimage/\" target=\"_blank\" rel=\"noopener\">Hocr2PDF</a>. To use it, use the ‘hocr’ config option, like this:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tesseract myscan.png out hocr</span><br></pre></td></tr></table></figure></p>\n<p>You can also create a searchable pdf directly from tesseract ( versions &gt;=3.03):<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tesseract myscan.png out pdf</span><br></pre></td></tr></table></figure></p>\n<p>More information about the various options is available in the <a href=\"https://github.com/tesseract-ocr/tesseract/blob/master/doc/tesseract.1.asc\" target=\"_blank\" rel=\"noopener\">Tesseract manpage</a>.</p>\n<h3 id=\"Other-Languages\"><a href=\"#Other-Languages\" class=\"headerlink\" title=\"Other Languages\"></a>Other Languages</h3><p>Tesseract has been trained for <a href=\"https://github.com/tesseract-ocr/tesseract/blob/master/doc/tesseract.1.asc#languages\" target=\"_blank\" rel=\"noopener\">many languages</a>, check for your language in the <a href=\"https://github.com/tesseract-ocr/tessdata\" target=\"_blank\" rel=\"noopener\">Tessdata repository</a>.</p>\n<p>For example, if we want Tesseract support Chinese language, just put <code>chi_sim.traineddata</code> into the path <code>/usr/local/Cellar/tesseract/3.05.01/share/tessdata/</code>。</p>\n<p>It can also be trained to support other languages and scripts; for more details see <a href=\"https://github.com/tesseract-ocr/tesseract/wiki/TrainingTesseract\" target=\"_blank\" rel=\"noopener\">TrainingTesseract</a>.</p>\n<h2 id=\"Running-Tesseract-with-Python\"><a href=\"#Running-Tesseract-with-Python\" class=\"headerlink\" title=\"Running Tesseract with Python\"></a>Running Tesseract with Python</h2><p>Python-tesseract is an optical character recognition (OCR) tool for python. That is, it will recognize and “read” the text embedded in images.</p>\n<h3 id=\"Usage\"><a href=\"#Usage\" class=\"headerlink\" title=\"Usage\"></a>Usage</h3><p><strong> Quick start </strong><br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    <span class=\"keyword\">import</span> Image</span><br><span class=\"line\"><span class=\"keyword\">except</span> ImportError:</span><br><span class=\"line\">    <span class=\"keyword\">from</span> PIL <span class=\"keyword\">import</span> Image</span><br><span class=\"line\"><span class=\"keyword\">import</span> pytesseract</span><br><span class=\"line\"></span><br><span class=\"line\">pytesseract.pytesseract.tesseract_cmd = <span class=\"string\">'&lt;full_path_to_your_tesseract_executable&gt;'</span></span><br><span class=\"line\"><span class=\"comment\"># Include the above line, if you don't have tesseract executable in your PATH</span></span><br><span class=\"line\"><span class=\"comment\"># Example tesseract_cmd: 'C:\\\\Program Files (x86)\\\\Tesseract-OCR\\\\tesseract'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Simple image to string</span></span><br><span class=\"line\">print(pytesseract.image_to_string(Image.open(<span class=\"string\">'test.png'</span>)))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># French text image to string</span></span><br><span class=\"line\">print(pytesseract.image_to_string(Image.open(<span class=\"string\">'test-european.jpg'</span>), lang=<span class=\"string\">'fra'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Get bounding box estimates</span></span><br><span class=\"line\">print(pytesseract.image_to_boxes(Image.open(<span class=\"string\">'test.png'</span>)))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Get verbose data including boxes, confidences, line and page numbers</span></span><br><span class=\"line\">print(pytesseract.image_to_data(Image.open(<span class=\"string\">'test.png'</span>)))</span><br></pre></td></tr></table></figure></p>\n<p>Support for OpenCV image/NumPy array objects<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> cv2</span><br><span class=\"line\"></span><br><span class=\"line\">img = cv2.imread(<span class=\"string\">'/**path_to_image**/digits.png'</span>)</span><br><span class=\"line\">print(pytesseract.image_to_string(img))</span><br><span class=\"line\"><span class=\"comment\"># OR explicit beforehand converting</span></span><br><span class=\"line\">print(pytesseract.image_to_string(Image.fromarray(img))</span><br></pre></td></tr></table></figure></p>\n<p>Add the following config, if you have tessdata error like: “Error opening data file…”<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tessdata_dir_config = <span class=\"string\">'--tessdata-dir \"&lt;replace_with_your_tessdata_dir_path&gt;\"'</span></span><br><span class=\"line\"><span class=\"comment\"># Example config: '--tessdata-dir \"C:\\\\Program Files (x86)\\\\Tesseract-OCR\\\\tessdata\"'</span></span><br><span class=\"line\"><span class=\"comment\"># It's important to add double quotes around the dir path.</span></span><br><span class=\"line\"></span><br><span class=\"line\">pytesseract.image_to_string(image, lang=<span class=\"string\">'chi_sim'</span>, config=tessdata_dir_config)</span><br></pre></td></tr></table></figure></p>\n<p><strong>Functions</strong></p>\n<ul>\n<li><strong>image_to_string</strong> Returns the result of a Tesseract OCR run on the image to string</li>\n<li><strong>image_to_boxes</strong> Returns result containing recognized characters and their box boundaries</li>\n<li><strong>image_to_data</strong> Returns result containing box boundaries, confidences, and other information. Requires Tesseract 3.05+. For more information, please check the <a href=\"https://github.com/tesseract-ocr/tesseract/wiki/Command-Line-Usage#tsv-output-currently-available-in-305-dev-in-master-branch-on-github\" target=\"_blank\" rel=\"noopener\">Tesseract TSV documentation</a></li>\n</ul>\n<p><strong>Parameters</strong></p>\n<p><code>image_to_data(image, lang=None, config=&#39;&#39;, nice=0, output_type=Output.STRING)</code></p>\n<ul>\n<li><strong>image</strong> Object, PIL Image/NumPy array of the image to be processed by Tesseract</li>\n<li><strong>lang</strong> String, Tesseract language code string</li>\n<li><strong>config</strong> String, Any additional configurations as a string, ex: <code>config=&#39;--psm 6&#39;</code></li>\n<li><strong>nice</strong> Integer, modifies the processor priority for the Tesseract run. Not supported on Windows. Nice adjusts the niceness of unix-like processes.</li>\n<li><strong>output_type</strong> Class attribute, specifies the type of the output, defaults to <code>string</code>. For the full list of all supported types, please check the definition of <a href=\"https://github.com/madmaze/pytesseract/blob/master/src/pytesseract.py\" target=\"_blank\" rel=\"noopener\">pytesseract.Output</a> class.</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"Running-Tesseract-with-command-line\"><a href=\"#Running-Tesseract-with-command-line\" class=\"headerlink\" title=\"Running Tesseract with command-line\"></a>Running Tesseract with command-line</h2><p>Tesseract is a command-line program, so first open a terminal or command prompt. The command is used like this:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tesseract imagename outputbase [-l lang] [-psm pagesegmode] [configfile...]</span><br></pre></td></tr></table></figure></p>\n<p>So basic usage to do OCR on an image called ‘myscan.png’ and save the result to ‘out.txt’ would be:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tesseract myscan.png out</span><br></pre></td></tr></table></figure></p>\n<p>Or to do the same with German:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tesseract myscan.png out -l deu</span><br></pre></td></tr></table></figure></p>\n<p>It can even be used with multiple languages traineddata at a time eg. English and German:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tesseract myscan.png out -l eng+deu</span><br></pre></td></tr></table></figure></p>","more":"<p>Tesseract also includes a hOCR mode, which produces a special HTML file with the coordinates of each word. This can be used to create a searchable pdf, using a tool such as <a href=\"https://exactcode.com/opensource/exactimage/\" target=\"_blank\" rel=\"noopener\">Hocr2PDF</a>. To use it, use the ‘hocr’ config option, like this:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tesseract myscan.png out hocr</span><br></pre></td></tr></table></figure></p>\n<p>You can also create a searchable pdf directly from tesseract ( versions &gt;=3.03):<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tesseract myscan.png out pdf</span><br></pre></td></tr></table></figure></p>\n<p>More information about the various options is available in the <a href=\"https://github.com/tesseract-ocr/tesseract/blob/master/doc/tesseract.1.asc\" target=\"_blank\" rel=\"noopener\">Tesseract manpage</a>.</p>\n<h3 id=\"Other-Languages\"><a href=\"#Other-Languages\" class=\"headerlink\" title=\"Other Languages\"></a>Other Languages</h3><p>Tesseract has been trained for <a href=\"https://github.com/tesseract-ocr/tesseract/blob/master/doc/tesseract.1.asc#languages\" target=\"_blank\" rel=\"noopener\">many languages</a>, check for your language in the <a href=\"https://github.com/tesseract-ocr/tessdata\" target=\"_blank\" rel=\"noopener\">Tessdata repository</a>.</p>\n<p>For example, if we want Tesseract support Chinese language, just put <code>chi_sim.traineddata</code> into the path <code>/usr/local/Cellar/tesseract/3.05.01/share/tessdata/</code>。</p>\n<p>It can also be trained to support other languages and scripts; for more details see <a href=\"https://github.com/tesseract-ocr/tesseract/wiki/TrainingTesseract\" target=\"_blank\" rel=\"noopener\">TrainingTesseract</a>.</p>\n<h2 id=\"Running-Tesseract-with-Python\"><a href=\"#Running-Tesseract-with-Python\" class=\"headerlink\" title=\"Running Tesseract with Python\"></a>Running Tesseract with Python</h2><p>Python-tesseract is an optical character recognition (OCR) tool for python. That is, it will recognize and “read” the text embedded in images.</p>\n<h3 id=\"Usage\"><a href=\"#Usage\" class=\"headerlink\" title=\"Usage\"></a>Usage</h3><p><strong> Quick start </strong><br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    <span class=\"keyword\">import</span> Image</span><br><span class=\"line\"><span class=\"keyword\">except</span> ImportError:</span><br><span class=\"line\">    <span class=\"keyword\">from</span> PIL <span class=\"keyword\">import</span> Image</span><br><span class=\"line\"><span class=\"keyword\">import</span> pytesseract</span><br><span class=\"line\"></span><br><span class=\"line\">pytesseract.pytesseract.tesseract_cmd = <span class=\"string\">'&lt;full_path_to_your_tesseract_executable&gt;'</span></span><br><span class=\"line\"><span class=\"comment\"># Include the above line, if you don't have tesseract executable in your PATH</span></span><br><span class=\"line\"><span class=\"comment\"># Example tesseract_cmd: 'C:\\\\Program Files (x86)\\\\Tesseract-OCR\\\\tesseract'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Simple image to string</span></span><br><span class=\"line\">print(pytesseract.image_to_string(Image.open(<span class=\"string\">'test.png'</span>)))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># French text image to string</span></span><br><span class=\"line\">print(pytesseract.image_to_string(Image.open(<span class=\"string\">'test-european.jpg'</span>), lang=<span class=\"string\">'fra'</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Get bounding box estimates</span></span><br><span class=\"line\">print(pytesseract.image_to_boxes(Image.open(<span class=\"string\">'test.png'</span>)))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Get verbose data including boxes, confidences, line and page numbers</span></span><br><span class=\"line\">print(pytesseract.image_to_data(Image.open(<span class=\"string\">'test.png'</span>)))</span><br></pre></td></tr></table></figure></p>\n<p>Support for OpenCV image/NumPy array objects<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> cv2</span><br><span class=\"line\"></span><br><span class=\"line\">img = cv2.imread(<span class=\"string\">'/**path_to_image**/digits.png'</span>)</span><br><span class=\"line\">print(pytesseract.image_to_string(img))</span><br><span class=\"line\"><span class=\"comment\"># OR explicit beforehand converting</span></span><br><span class=\"line\">print(pytesseract.image_to_string(Image.fromarray(img))</span><br></pre></td></tr></table></figure></p>\n<p>Add the following config, if you have tessdata error like: “Error opening data file…”<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tessdata_dir_config = <span class=\"string\">'--tessdata-dir \"&lt;replace_with_your_tessdata_dir_path&gt;\"'</span></span><br><span class=\"line\"><span class=\"comment\"># Example config: '--tessdata-dir \"C:\\\\Program Files (x86)\\\\Tesseract-OCR\\\\tessdata\"'</span></span><br><span class=\"line\"><span class=\"comment\"># It's important to add double quotes around the dir path.</span></span><br><span class=\"line\"></span><br><span class=\"line\">pytesseract.image_to_string(image, lang=<span class=\"string\">'chi_sim'</span>, config=tessdata_dir_config)</span><br></pre></td></tr></table></figure></p>\n<p><strong>Functions</strong></p>\n<ul>\n<li><strong>image_to_string</strong> Returns the result of a Tesseract OCR run on the image to string</li>\n<li><strong>image_to_boxes</strong> Returns result containing recognized characters and their box boundaries</li>\n<li><strong>image_to_data</strong> Returns result containing box boundaries, confidences, and other information. Requires Tesseract 3.05+. For more information, please check the <a href=\"https://github.com/tesseract-ocr/tesseract/wiki/Command-Line-Usage#tsv-output-currently-available-in-305-dev-in-master-branch-on-github\" target=\"_blank\" rel=\"noopener\">Tesseract TSV documentation</a></li>\n</ul>\n<p><strong>Parameters</strong></p>\n<p><code>image_to_data(image, lang=None, config=&#39;&#39;, nice=0, output_type=Output.STRING)</code></p>\n<ul>\n<li><strong>image</strong> Object, PIL Image/NumPy array of the image to be processed by Tesseract</li>\n<li><strong>lang</strong> String, Tesseract language code string</li>\n<li><strong>config</strong> String, Any additional configurations as a string, ex: <code>config=&#39;--psm 6&#39;</code></li>\n<li><strong>nice</strong> Integer, modifies the processor priority for the Tesseract run. Not supported on Windows. Nice adjusts the niceness of unix-like processes.</li>\n<li><strong>output_type</strong> Class attribute, specifies the type of the output, defaults to <code>string</code>. For the full list of all supported types, please check the definition of <a href=\"https://github.com/madmaze/pytesseract/blob/master/src/pytesseract.py\" target=\"_blank\" rel=\"noopener\">pytesseract.Output</a> class.</li>\n</ul>"},{"title":"What is the difference between “ is None ” and “ ==None ” --- Reprint","date":"2018-03-28T19:08:51.000Z","_content":"## Answer 1\nThe answer is explained [here](http://jaredgrubb.blogspot.com/2009/04/python-is-none-vs-none.html).\n\nTo quote:\n\n> A class is free to implement comparison any way it chooses, and it can choose to make comparison against None mean something (which actually makes sense; if someone told you to implement the None object from scratch, how else would you get it to compare True against itself?).\n\nPractically-speaking, there is not much difference since custom comparison operators are rare. But you should use `is None` as a general rule.\n\n`is None` is a bit (~50%) faster than `== None` :) – [Nas Banov](https://stackoverflow.com/users/226086/nas-banov)\n\n<!-- more -->\n## Answer 2\n`is` always returns `True` if it compares the same object instance\n\nWhereas `==` is ultimately determined by the `__eq__()` method\n\ni.e.\n\n```python\nclass Foo:\n    def __eq__(self,other):\n        return True\nfoo=Foo()\n\nprint(foo==None)\n# True\n\nprint(foo is None)\n# False\n```\n\n## Answer 3\nIn this case, they are the same. `None` is a singleton object (there only ever exists one `None`).\n\n`is` checks to see if the object is the same object, while == just checks if they are equivalent.\n\nFor example:\n```Python\np = [1]\nq = [1]\np is q # False because they are not the same actual object\np == q # True because they are equivalent\n\n```\nBut since there is only one `None`, they will always be the same, and `is` will return True.\n\n```Python\np = None\nq = None\np is q # True because they are both pointing to the same \"None\"\n```\n\n## Answer 4\n`(ob1 is ob2)` equal to `(id(ob1) == id(ob2))`\n\n... but (ob is ob2) is a LOT faster. Timeit says \"(a is b)\" is 0.0365 usec per loop and \"(id(a)==id(b))\" is 0.153 usec per loop. 4.2x faster! – [AKX](https://stackoverflow.com/users/51685/akx)\n\n`{} is {}` is false and `id({}) == id({})` can be (and **is** in CPython) true.\n\n\n## Reference\n\n1. [What is the difference between “ is None ” and “ ==None ”](https://stackoverflow.com/questions/3257919/what-is-the-difference-between-is-none-and-none)\n2. [Is there any difference between “foo is None” and “foo == None”?](https://stackoverflow.com/questions/26595/is-there-any-difference-between-foo-is-none-and-foo-none)\n","source":"_posts/What-is-the-difference-between-“-is-None-”-and-“-None-”-Reprint.md","raw":"---\ntitle: What is the difference between “ is None ” and “ ==None ” --- Reprint\ndate: 2018-03-29 03:08:51\ntags:\n  - Python3\ncategories:\n  - Python3 进阶\n---\n## Answer 1\nThe answer is explained [here](http://jaredgrubb.blogspot.com/2009/04/python-is-none-vs-none.html).\n\nTo quote:\n\n> A class is free to implement comparison any way it chooses, and it can choose to make comparison against None mean something (which actually makes sense; if someone told you to implement the None object from scratch, how else would you get it to compare True against itself?).\n\nPractically-speaking, there is not much difference since custom comparison operators are rare. But you should use `is None` as a general rule.\n\n`is None` is a bit (~50%) faster than `== None` :) – [Nas Banov](https://stackoverflow.com/users/226086/nas-banov)\n\n<!-- more -->\n## Answer 2\n`is` always returns `True` if it compares the same object instance\n\nWhereas `==` is ultimately determined by the `__eq__()` method\n\ni.e.\n\n```python\nclass Foo:\n    def __eq__(self,other):\n        return True\nfoo=Foo()\n\nprint(foo==None)\n# True\n\nprint(foo is None)\n# False\n```\n\n## Answer 3\nIn this case, they are the same. `None` is a singleton object (there only ever exists one `None`).\n\n`is` checks to see if the object is the same object, while == just checks if they are equivalent.\n\nFor example:\n```Python\np = [1]\nq = [1]\np is q # False because they are not the same actual object\np == q # True because they are equivalent\n\n```\nBut since there is only one `None`, they will always be the same, and `is` will return True.\n\n```Python\np = None\nq = None\np is q # True because they are both pointing to the same \"None\"\n```\n\n## Answer 4\n`(ob1 is ob2)` equal to `(id(ob1) == id(ob2))`\n\n... but (ob is ob2) is a LOT faster. Timeit says \"(a is b)\" is 0.0365 usec per loop and \"(id(a)==id(b))\" is 0.153 usec per loop. 4.2x faster! – [AKX](https://stackoverflow.com/users/51685/akx)\n\n`{} is {}` is false and `id({}) == id({})` can be (and **is** in CPython) true.\n\n\n## Reference\n\n1. [What is the difference between “ is None ” and “ ==None ”](https://stackoverflow.com/questions/3257919/what-is-the-difference-between-is-none-and-none)\n2. [Is there any difference between “foo is None” and “foo == None”?](https://stackoverflow.com/questions/26595/is-there-any-difference-between-foo-is-none-and-foo-none)\n","slug":"What-is-the-difference-between-“-is-None-”-and-“-None-”-Reprint","published":1,"updated":"2018-03-28T19:23:18.970Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozm8004k8motbvrjtfuc","content":"<h2 id=\"Answer-1\"><a href=\"#Answer-1\" class=\"headerlink\" title=\"Answer 1\"></a>Answer 1</h2><p>The answer is explained <a href=\"http://jaredgrubb.blogspot.com/2009/04/python-is-none-vs-none.html\" target=\"_blank\" rel=\"noopener\">here</a>.</p>\n<p>To quote:</p>\n<blockquote>\n<p>A class is free to implement comparison any way it chooses, and it can choose to make comparison against None mean something (which actually makes sense; if someone told you to implement the None object from scratch, how else would you get it to compare True against itself?).</p>\n</blockquote>\n<p>Practically-speaking, there is not much difference since custom comparison operators are rare. But you should use <code>is None</code> as a general rule.</p>\n<p><code>is None</code> is a bit (~50%) faster than <code>== None</code> :) – <a href=\"https://stackoverflow.com/users/226086/nas-banov\" target=\"_blank\" rel=\"noopener\">Nas Banov</a></p>\n<a id=\"more\"></a>\n<h2 id=\"Answer-2\"><a href=\"#Answer-2\" class=\"headerlink\" title=\"Answer 2\"></a>Answer 2</h2><p><code>is</code> always returns <code>True</code> if it compares the same object instance</p>\n<p>Whereas <code>==</code> is ultimately determined by the <code>__eq__()</code> method</p>\n<p>i.e.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__eq__</span><span class=\"params\">(self,other)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">foo=Foo()</span><br><span class=\"line\"></span><br><span class=\"line\">print(foo==<span class=\"keyword\">None</span>)</span><br><span class=\"line\"><span class=\"comment\"># True</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(foo <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>)</span><br><span class=\"line\"><span class=\"comment\"># False</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Answer-3\"><a href=\"#Answer-3\" class=\"headerlink\" title=\"Answer 3\"></a>Answer 3</h2><p>In this case, they are the same. <code>None</code> is a singleton object (there only ever exists one <code>None</code>).</p>\n<p><code>is</code> checks to see if the object is the same object, while == just checks if they are equivalent.</p>\n<p>For example:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p = [<span class=\"number\">1</span>]</span><br><span class=\"line\">q = [<span class=\"number\">1</span>]</span><br><span class=\"line\">p <span class=\"keyword\">is</span> q <span class=\"comment\"># False because they are not the same actual object</span></span><br><span class=\"line\">p == q <span class=\"comment\"># True because they are equivalent</span></span><br></pre></td></tr></table></figure></p>\n<p>But since there is only one <code>None</code>, they will always be the same, and <code>is</code> will return True.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p = <span class=\"keyword\">None</span></span><br><span class=\"line\">q = <span class=\"keyword\">None</span></span><br><span class=\"line\">p <span class=\"keyword\">is</span> q <span class=\"comment\"># True because they are both pointing to the same \"None\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Answer-4\"><a href=\"#Answer-4\" class=\"headerlink\" title=\"Answer 4\"></a>Answer 4</h2><p><code>(ob1 is ob2)</code> equal to <code>(id(ob1) == id(ob2))</code></p>\n<p>… but (ob is ob2) is a LOT faster. Timeit says “(a is b)” is 0.0365 usec per loop and “(id(a)==id(b))” is 0.153 usec per loop. 4.2x faster! – <a href=\"https://stackoverflow.com/users/51685/akx\" target=\"_blank\" rel=\"noopener\">AKX</a></p>\n<p><code>{} is {}</code> is false and <code>id({}) == id({})</code> can be (and <strong>is</strong> in CPython) true.</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><ol>\n<li><a href=\"https://stackoverflow.com/questions/3257919/what-is-the-difference-between-is-none-and-none\" target=\"_blank\" rel=\"noopener\">What is the difference between “ is None ” and “ ==None ”</a></li>\n<li><a href=\"https://stackoverflow.com/questions/26595/is-there-any-difference-between-foo-is-none-and-foo-none\" target=\"_blank\" rel=\"noopener\">Is there any difference between “foo is None” and “foo == None”?</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"Answer-1\"><a href=\"#Answer-1\" class=\"headerlink\" title=\"Answer 1\"></a>Answer 1</h2><p>The answer is explained <a href=\"http://jaredgrubb.blogspot.com/2009/04/python-is-none-vs-none.html\" target=\"_blank\" rel=\"noopener\">here</a>.</p>\n<p>To quote:</p>\n<blockquote>\n<p>A class is free to implement comparison any way it chooses, and it can choose to make comparison against None mean something (which actually makes sense; if someone told you to implement the None object from scratch, how else would you get it to compare True against itself?).</p>\n</blockquote>\n<p>Practically-speaking, there is not much difference since custom comparison operators are rare. But you should use <code>is None</code> as a general rule.</p>\n<p><code>is None</code> is a bit (~50%) faster than <code>== None</code> :) – <a href=\"https://stackoverflow.com/users/226086/nas-banov\" target=\"_blank\" rel=\"noopener\">Nas Banov</a></p>","more":"<h2 id=\"Answer-2\"><a href=\"#Answer-2\" class=\"headerlink\" title=\"Answer 2\"></a>Answer 2</h2><p><code>is</code> always returns <code>True</code> if it compares the same object instance</p>\n<p>Whereas <code>==</code> is ultimately determined by the <code>__eq__()</code> method</p>\n<p>i.e.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__eq__</span><span class=\"params\">(self,other)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">True</span></span><br><span class=\"line\">foo=Foo()</span><br><span class=\"line\"></span><br><span class=\"line\">print(foo==<span class=\"keyword\">None</span>)</span><br><span class=\"line\"><span class=\"comment\"># True</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(foo <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>)</span><br><span class=\"line\"><span class=\"comment\"># False</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Answer-3\"><a href=\"#Answer-3\" class=\"headerlink\" title=\"Answer 3\"></a>Answer 3</h2><p>In this case, they are the same. <code>None</code> is a singleton object (there only ever exists one <code>None</code>).</p>\n<p><code>is</code> checks to see if the object is the same object, while == just checks if they are equivalent.</p>\n<p>For example:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p = [<span class=\"number\">1</span>]</span><br><span class=\"line\">q = [<span class=\"number\">1</span>]</span><br><span class=\"line\">p <span class=\"keyword\">is</span> q <span class=\"comment\"># False because they are not the same actual object</span></span><br><span class=\"line\">p == q <span class=\"comment\"># True because they are equivalent</span></span><br></pre></td></tr></table></figure></p>\n<p>But since there is only one <code>None</code>, they will always be the same, and <code>is</code> will return True.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p = <span class=\"keyword\">None</span></span><br><span class=\"line\">q = <span class=\"keyword\">None</span></span><br><span class=\"line\">p <span class=\"keyword\">is</span> q <span class=\"comment\"># True because they are both pointing to the same \"None\"</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Answer-4\"><a href=\"#Answer-4\" class=\"headerlink\" title=\"Answer 4\"></a>Answer 4</h2><p><code>(ob1 is ob2)</code> equal to <code>(id(ob1) == id(ob2))</code></p>\n<p>… but (ob is ob2) is a LOT faster. Timeit says “(a is b)” is 0.0365 usec per loop and “(id(a)==id(b))” is 0.153 usec per loop. 4.2x faster! – <a href=\"https://stackoverflow.com/users/51685/akx\" target=\"_blank\" rel=\"noopener\">AKX</a></p>\n<p><code>{} is {}</code> is false and <code>id({}) == id({})</code> can be (and <strong>is</strong> in CPython) true.</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><ol>\n<li><a href=\"https://stackoverflow.com/questions/3257919/what-is-the-difference-between-is-none-and-none\" target=\"_blank\" rel=\"noopener\">What is the difference between “ is None ” and “ ==None ”</a></li>\n<li><a href=\"https://stackoverflow.com/questions/26595/is-there-any-difference-between-foo-is-none-and-foo-none\" target=\"_blank\" rel=\"noopener\">Is there any difference between “foo is None” and “foo == None”?</a></li>\n</ol>"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n非常好的一篇markdown参考手册\n\n<!--more-->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n非常好的一篇markdown参考手册\n\n<!--more-->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2018-02-25T18:47:57.250Z","updated":"2018-02-27T06:43:43.774Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozma004o8motdvyslypb","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<p>非常好的一篇markdown参考手册</p>\n<a id=\"more\"></a>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<p>非常好的一篇markdown参考手册</p>","more":"<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>"},{"title":"if __name__ == '__main__': ?","date":"2018-03-01T11:50:06.000Z","_content":">Every Python module has it's `__name__` defined and if this is `'__main__'`, it implies that the module is being run standalone by the user and we can do corresponding appropriate actions.\n\n当Python解析器读取一个源文件时,它会执行所有的代码.在执行代码前,会定义一些特殊的变量.例如,如果解析器运行的模块(源文件)作为主程序,它将会把`__name__`变量设置成`\"__main__\"`.如果只是引入其他的模块,`__name__`变量将会设置成模块的名字.\n<!-- more -->\n\n这么做的原因是有时你想让你的模块既可以直接的执行,还可以被当做模块导入到其他模块中去.通过检查是不是主函数,可以让你的代码只在它作为主程序运行时执行,而当其他人调用你的模块中的函数的时候不必执行.\n\n直接上一个栗子：\n```python\n# Filename: using_name.py\n\nprint(__name__)\nif __name__ == '__main__':\n\tprint('This program is being run by itself')\nelse:\n\tprint('I am being imported from another module')\n\n```\n\n```Python\n\n$ python using_name.py\n__main__\nThis program is being run by itself\n\n$ python\n>>> import using_name\nusing_name\nI am being imported from another module\n>>>\n\n```\n","source":"_posts/if-name-main.md","raw":"---\ntitle: 'if __name__ == ''__main__'': ?'\ndate: 2018-03-01 19:50:06\ntags:\n  - Python3\ncategories:\n  - Python3 进阶\n---\n>Every Python module has it's `__name__` defined and if this is `'__main__'`, it implies that the module is being run standalone by the user and we can do corresponding appropriate actions.\n\n当Python解析器读取一个源文件时,它会执行所有的代码.在执行代码前,会定义一些特殊的变量.例如,如果解析器运行的模块(源文件)作为主程序,它将会把`__name__`变量设置成`\"__main__\"`.如果只是引入其他的模块,`__name__`变量将会设置成模块的名字.\n<!-- more -->\n\n这么做的原因是有时你想让你的模块既可以直接的执行,还可以被当做模块导入到其他模块中去.通过检查是不是主函数,可以让你的代码只在它作为主程序运行时执行,而当其他人调用你的模块中的函数的时候不必执行.\n\n直接上一个栗子：\n```python\n# Filename: using_name.py\n\nprint(__name__)\nif __name__ == '__main__':\n\tprint('This program is being run by itself')\nelse:\n\tprint('I am being imported from another module')\n\n```\n\n```Python\n\n$ python using_name.py\n__main__\nThis program is being run by itself\n\n$ python\n>>> import using_name\nusing_name\nI am being imported from another module\n>>>\n\n```\n","slug":"if-name-main","published":1,"updated":"2018-03-01T12:13:18.245Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozmc004s8motq1neez2l","content":"<blockquote>\n<p>Every Python module has it’s <code>__name__</code> defined and if this is <code>&#39;__main__&#39;</code>, it implies that the module is being run standalone by the user and we can do corresponding appropriate actions.</p>\n</blockquote>\n<p>当Python解析器读取一个源文件时,它会执行所有的代码.在执行代码前,会定义一些特殊的变量.例如,如果解析器运行的模块(源文件)作为主程序,它将会把<code>__name__</code>变量设置成<code>&quot;__main__&quot;</code>.如果只是引入其他的模块,<code>__name__</code>变量将会设置成模块的名字.<br><a id=\"more\"></a></p>\n<p>这么做的原因是有时你想让你的模块既可以直接的执行,还可以被当做模块导入到其他模块中去.通过检查是不是主函数,可以让你的代码只在它作为主程序运行时执行,而当其他人调用你的模块中的函数的时候不必执行.</p>\n<p>直接上一个栗子：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Filename: using_name.py</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(__name__)</span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">\tprint(<span class=\"string\">'This program is being run by itself'</span>)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">\tprint(<span class=\"string\">'I am being imported from another module'</span>)</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">$ python using_name.py</span><br><span class=\"line\">__main__</span><br><span class=\"line\">This program <span class=\"keyword\">is</span> being run by itself</span><br><span class=\"line\"></span><br><span class=\"line\">$ python</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> using_name</span><br><span class=\"line\">using_name</span><br><span class=\"line\">I am being imported <span class=\"keyword\">from</span> another module</span><br><span class=\"line\">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>Every Python module has it’s <code>__name__</code> defined and if this is <code>&#39;__main__&#39;</code>, it implies that the module is being run standalone by the user and we can do corresponding appropriate actions.</p>\n</blockquote>\n<p>当Python解析器读取一个源文件时,它会执行所有的代码.在执行代码前,会定义一些特殊的变量.例如,如果解析器运行的模块(源文件)作为主程序,它将会把<code>__name__</code>变量设置成<code>&quot;__main__&quot;</code>.如果只是引入其他的模块,<code>__name__</code>变量将会设置成模块的名字.<br>","more":"</p>\n<p>这么做的原因是有时你想让你的模块既可以直接的执行,还可以被当做模块导入到其他模块中去.通过检查是不是主函数,可以让你的代码只在它作为主程序运行时执行,而当其他人调用你的模块中的函数的时候不必执行.</p>\n<p>直接上一个栗子：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Filename: using_name.py</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(__name__)</span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">\tprint(<span class=\"string\">'This program is being run by itself'</span>)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">\tprint(<span class=\"string\">'I am being imported from another module'</span>)</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">$ python using_name.py</span><br><span class=\"line\">__main__</span><br><span class=\"line\">This program <span class=\"keyword\">is</span> being run by itself</span><br><span class=\"line\"></span><br><span class=\"line\">$ python</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> using_name</span><br><span class=\"line\">using_name</span><br><span class=\"line\">I am being imported <span class=\"keyword\">from</span> another module</span><br><span class=\"line\">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>"},{"title":"python3 如何用一个表达式合并两个字典","date":"2018-03-02T17:00:28.000Z","_content":"\n有两个Python字典,写一个表达式来返回两个字典的合并。`update()`方法返回的是空值而不是返回合并后的对象.\n```python    \n>>> x = {'a':1, 'b': 2}\n>>> y = {'b':10, 'c': 11}\n>>> z = x.update(y)\n>>> print z\nNone\n>>> x\n{'a': 1, 'b': 10, 'c': 11}\n```\n如何才能让值保存在z而不是x?\n<!-- more -->\n\n对于python2可以用下面的方法:\n```python    \nz = dict(x.items() + y.items())\n```\n最后就是你想要的最终结果保存在字典z中,而键`b`的值会被第二个字典的值覆盖.\n```python\n>>> x = {'a':1, 'b': 2}\n>>> y = {'b':10, 'c': 11}\n>>> z = dict(x.items() + y.items())\n>>> z\n{'a': 1, 'c': 11, 'b': 10}\n```\n\n对于Python3：\n```python\n>>> z = dict(list(x.items()) + list(y.items()))\n>>> z\n{'a': 1, 'c': 11, 'b': 10}\n```\n\n还可以这样:\n```python\nz = x.copy()\nz.update(y)\n```\n","source":"_posts/python3-如何用一个表达式合并两个字典.md","raw":"---\ntitle: python3 如何用一个表达式合并两个字典\ndate: 2018-03-03 01:00:28\ntags:\n  - Python3\ncategories:\n  - Python3 进阶\n  - Python3 数据结构\n---\n\n有两个Python字典,写一个表达式来返回两个字典的合并。`update()`方法返回的是空值而不是返回合并后的对象.\n```python    \n>>> x = {'a':1, 'b': 2}\n>>> y = {'b':10, 'c': 11}\n>>> z = x.update(y)\n>>> print z\nNone\n>>> x\n{'a': 1, 'b': 10, 'c': 11}\n```\n如何才能让值保存在z而不是x?\n<!-- more -->\n\n对于python2可以用下面的方法:\n```python    \nz = dict(x.items() + y.items())\n```\n最后就是你想要的最终结果保存在字典z中,而键`b`的值会被第二个字典的值覆盖.\n```python\n>>> x = {'a':1, 'b': 2}\n>>> y = {'b':10, 'c': 11}\n>>> z = dict(x.items() + y.items())\n>>> z\n{'a': 1, 'c': 11, 'b': 10}\n```\n\n对于Python3：\n```python\n>>> z = dict(list(x.items()) + list(y.items()))\n>>> z\n{'a': 1, 'c': 11, 'b': 10}\n```\n\n还可以这样:\n```python\nz = x.copy()\nz.update(y)\n```\n","slug":"python3-如何用一个表达式合并两个字典","published":1,"updated":"2018-03-02T17:11:37.046Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozme004w8mot6tx3r0jw","content":"<p>有两个Python字典,写一个表达式来返回两个字典的合并。<code>update()</code>方法返回的是空值而不是返回合并后的对象.<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>x = &#123;<span class=\"string\">'a'</span>:<span class=\"number\">1</span>, <span class=\"string\">'b'</span>: <span class=\"number\">2</span>&#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>y = &#123;<span class=\"string\">'b'</span>:<span class=\"number\">10</span>, <span class=\"string\">'c'</span>: <span class=\"number\">11</span>&#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>z = x.update(y)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> z</span><br><span class=\"line\"><span class=\"keyword\">None</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>x</span><br><span class=\"line\">&#123;<span class=\"string\">'a'</span>: <span class=\"number\">1</span>, <span class=\"string\">'b'</span>: <span class=\"number\">10</span>, <span class=\"string\">'c'</span>: <span class=\"number\">11</span>&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如何才能让值保存在z而不是x?<br><a id=\"more\"></a></p>\n<p>对于python2可以用下面的方法:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">z = dict(x.items() + y.items())</span><br></pre></td></tr></table></figure></p>\n<p>最后就是你想要的最终结果保存在字典z中,而键<code>b</code>的值会被第二个字典的值覆盖.<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>x = &#123;<span class=\"string\">'a'</span>:<span class=\"number\">1</span>, <span class=\"string\">'b'</span>: <span class=\"number\">2</span>&#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>y = &#123;<span class=\"string\">'b'</span>:<span class=\"number\">10</span>, <span class=\"string\">'c'</span>: <span class=\"number\">11</span>&#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>z = dict(x.items() + y.items())</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>z</span><br><span class=\"line\">&#123;<span class=\"string\">'a'</span>: <span class=\"number\">1</span>, <span class=\"string\">'c'</span>: <span class=\"number\">11</span>, <span class=\"string\">'b'</span>: <span class=\"number\">10</span>&#125;</span><br></pre></td></tr></table></figure></p>\n<p>对于Python3：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>z = dict(list(x.items()) + list(y.items()))</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>z</span><br><span class=\"line\">&#123;<span class=\"string\">'a'</span>: <span class=\"number\">1</span>, <span class=\"string\">'c'</span>: <span class=\"number\">11</span>, <span class=\"string\">'b'</span>: <span class=\"number\">10</span>&#125;</span><br></pre></td></tr></table></figure></p>\n<p>还可以这样:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">z = x.copy()</span><br><span class=\"line\">z.update(y)</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>有两个Python字典,写一个表达式来返回两个字典的合并。<code>update()</code>方法返回的是空值而不是返回合并后的对象.<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>x = &#123;<span class=\"string\">'a'</span>:<span class=\"number\">1</span>, <span class=\"string\">'b'</span>: <span class=\"number\">2</span>&#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>y = &#123;<span class=\"string\">'b'</span>:<span class=\"number\">10</span>, <span class=\"string\">'c'</span>: <span class=\"number\">11</span>&#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>z = x.update(y)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">print</span> z</span><br><span class=\"line\"><span class=\"keyword\">None</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>x</span><br><span class=\"line\">&#123;<span class=\"string\">'a'</span>: <span class=\"number\">1</span>, <span class=\"string\">'b'</span>: <span class=\"number\">10</span>, <span class=\"string\">'c'</span>: <span class=\"number\">11</span>&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如何才能让值保存在z而不是x?<br>","more":"</p>\n<p>对于python2可以用下面的方法:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">z = dict(x.items() + y.items())</span><br></pre></td></tr></table></figure></p>\n<p>最后就是你想要的最终结果保存在字典z中,而键<code>b</code>的值会被第二个字典的值覆盖.<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>x = &#123;<span class=\"string\">'a'</span>:<span class=\"number\">1</span>, <span class=\"string\">'b'</span>: <span class=\"number\">2</span>&#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>y = &#123;<span class=\"string\">'b'</span>:<span class=\"number\">10</span>, <span class=\"string\">'c'</span>: <span class=\"number\">11</span>&#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>z = dict(x.items() + y.items())</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>z</span><br><span class=\"line\">&#123;<span class=\"string\">'a'</span>: <span class=\"number\">1</span>, <span class=\"string\">'c'</span>: <span class=\"number\">11</span>, <span class=\"string\">'b'</span>: <span class=\"number\">10</span>&#125;</span><br></pre></td></tr></table></figure></p>\n<p>对于Python3：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>z = dict(list(x.items()) + list(y.items()))</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>z</span><br><span class=\"line\">&#123;<span class=\"string\">'a'</span>: <span class=\"number\">1</span>, <span class=\"string\">'c'</span>: <span class=\"number\">11</span>, <span class=\"string\">'b'</span>: <span class=\"number\">10</span>&#125;</span><br></pre></td></tr></table></figure></p>\n<p>还可以这样:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">z = x.copy()</span><br><span class=\"line\">z.update(y)</span><br></pre></td></tr></table></figure></p>"},{"title":"python3 产生随机字符串","date":"2018-04-19T08:26:53.000Z","_content":"\n```python\nimport random\nimport string\n\n\n# 长度为16的随机字符串\nrand_str = ''.join(random.SystemRandom().choice(string.ascii_uppercase + string.ascii_lowercase + string.digits) for _ in range(16))\n\n```\n","source":"_posts/python3-产生随机字符串.md","raw":"---\ntitle: python3 产生随机字符串\ndate: 2018-04-19 16:26:53\ntags:\n  - Python3\ncategories:\n  - Python3 进阶\n---\n\n```python\nimport random\nimport string\n\n\n# 长度为16的随机字符串\nrand_str = ''.join(random.SystemRandom().choice(string.ascii_uppercase + string.ascii_lowercase + string.digits) for _ in range(16))\n\n```\n","slug":"python3-产生随机字符串","published":1,"updated":"2018-04-19T08:28:16.623Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozmf00508mot4oppl5m7","content":"<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> random</span><br><span class=\"line\"><span class=\"keyword\">import</span> string</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 长度为16的随机字符串</span></span><br><span class=\"line\">rand_str = <span class=\"string\">''</span>.join(random.SystemRandom().choice(string.ascii_uppercase + string.ascii_lowercase + string.digits) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(<span class=\"number\">16</span>))</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> random</span><br><span class=\"line\"><span class=\"keyword\">import</span> string</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 长度为16的随机字符串</span></span><br><span class=\"line\">rand_str = <span class=\"string\">''</span>.join(random.SystemRandom().choice(string.ascii_uppercase + string.ascii_lowercase + string.digits) <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> range(<span class=\"number\">16</span>))</span><br></pre></td></tr></table></figure>\n"},{"title":"python3 可迭代对象、迭代器和生成器","date":"2018-03-01T12:17:53.000Z","_content":"\n## 前言\n迭代是数据处理的基石。扫描内存中放不下数据集时，我们要找到一种惰性获取数据项的方式，即按需一次获取一个数据项，这就是迭代器模式（iterator pattern）。所有的`生成器`都是`迭代器`，因为生成器完全实现了迭代器接口。在python社区中，大多数时候都把`迭代器`和`生成器`视作同一概念。\n\n所有python程序员都知道，序列可迭代，下面说明具体原因。\n<!-- more -->\n## 序列可迭代的原因：iter函数\n解释器需要迭代对象x时，会自动调用`iter(x)`。\n内置的iter函数有以下作用。\n\n1. 检查对象是否实现了`__iter__`方法，如果实现了就调用它，获得一个迭代器。\n2. 如果没有实现`__iter__`方法，但是实现了`__getitem__`方法，python会创建一个迭代器，尝试按顺序（从索引0开始）获取元素。\n3. 如果尝试失败，python会抛出`TypeError`异常，通常会提示\"C object is not iterable\",其中C是目标对象所属的类。\n\n任何Python序列都可迭代的原因是它们实现了`__getitem__`方法。其实标准的序列也都实现了`__iter__`方法。之所以对`__getitem__`方法做特殊处理是为了向后兼容。\n\n从Python3.4开始，检查x能否迭代，最准确的方法是调用iter(x)函数，如果不可迭代，再处理TypeError异常。这比使用isinstance(x, abc.Iterable)更准确，因为iter(x)函数会考虑到遗留的`__getitem__`方法，而abc.Iterable类则不考虑。\n\n## 可迭代的对象与迭代器的对比\n\n### 可迭代对象\n\n**使用iter内置函数可以获取迭代器的对象。** 如果实现了能返回迭代器的`__iter__`方法，那么对象就是可迭代的。序列都可以迭代；实现了`__getitem__`方法，而且七参数是从零开始的索引，这种对象也是可迭代的。\n\n我们要明确可迭代对象和迭代器之间的关系：**Python从可迭代的对象中获取迭代器**\n\n标准的迭代器接口有两个方法，即：\n1. `__next__`:返回下一个可用元素，如果没有元素，抛出`StopIteration`异常\n2. `__iter__`:返回self,以便在应该使用可迭代对象的地方使用迭代器，比如for循环中。\n\n因为`迭代器`只需`__next__`和`__iter__`两个方法，所以除了调用next()方法，以及捕获`StopIteration`异常之外，没有办法检查是否还有遗留的元素。此外，也没有办法还原迭代器。如果想再次迭代，那就要调用iter(...)，传入之前构建迭代器的可迭代对象。\n\n### 迭代器\n\n迭代器是这样的对象：实现了无参数的`__next__`方法，返回序列中的下一个元素；如果没有元素了，那么抛出`StopIteration`异常。Python迭代器还实现了`__iter__`方法，因此迭代器也可以迭代。\n\n构建`可迭代对象`和`迭代器`时经常会出现错误，原因是混淆了两者。要知道，`可迭代的对象`有个`__iter__`方法，每次都实例化一个新的迭代器；而`迭代器`要实现`__next__`方法，返回单个元素，此外还要实现`__iter__`方法，返回迭代器本身。因此，`迭代器`可以迭代，但是`可迭代的对象`不是迭代器。\n\n可迭代的对象一定不是自身的迭代器。也就是说，可迭代的对象必须实现`__iter__`方法，但不能实现`__next__`方法。另一方面，迭代器应该一直可以迭代，迭代器的`__iter__`方法应该返回自身。\n\n```python\na = [1,2,3]\n'__iter__' in dir(a)            # True\n'__iter__' in dir(iter(a))      # True\n\n```\n\n## 生成器函数\n\n只要Python函数的定义体中有yield关键字，该函数就是生成器函数。调用生成器函数时，会返回一个生成器对象。也就是说，生成器函数是生成器工厂。\n\n普通的函数与生成器函数在句法上的唯一区别是，在后者的定义体中有`yield`关键字。有些人认为定义生成器函数应该使用一个新的关键字，例如gen，而不是def，但是Guido不同意。\n### 生成器函数工作原理\n\n```python\ndef gen_123():  # 只要Python代码中包含yield，该函数就是生成器函数\n    yield 1    #生成器函数的定义体中通常都有循环，不过这不是必要条件；此处重复使用了3次yield\n    yield 2\n    yield 3\n\nif __name__ == '__main__':\n    print(gen_123)    # 可以看出gen_123是函数对象\n    # <function gen_123 at 0x10be199d8>\n    print(gen_123())  # 函数调用时返回的是一个生成器对象\n    # <generator object gen_123 at 0x10be31ca8>\n\n    for i in gen_123(): # 生成器是迭代器，会生成传给yield关键字的表达式的值\n        print(i)    \n        # 1\n        # 2\n        # 3\n\n    g = gen_123() # 为了仔细检查，把生成器对象赋值给g\n    print(next(g))  # 1\n    print(next(g))  # 2\n    print(next(g))  # 3\n    print(next(g))   # 生成器函数的定义体执行完毕后，生成器对象会抛出异常。\n# Traceback (most recent call last):\n#   File \"test.py\", line 17, in <module>\n#     print(next(g))\n# StopIteration\n\n```\n\n如上述代码所示：\n1. 只要Python代码中包含yield，该函数就是生成器函数\n2. 生成器函数的定义体中通常都有循环，不过这不是必要条件；此处重复使用了3次yield\n3. 可以看出gen_123是函数对象\n4. 函数调用时返回的是一个生成器对象\n5. 生成器是迭代器，会`生成`传给yield关键字的表达式的值\n6. 为了仔细检查，把生成器对象赋值给g\n7. 因为g是迭代器，所以调用nest(g)会获取yield`生成`的下一个元素\n8. 生成器函数的定义体执行完毕后，生成器对象会抛出异常。\n\n\n使用准确的词语描述从生成器中获取结果的过程有助于理解生成器。注意，此处说的是`产出`或`生成`值。如果说生成器`返回`值，就会让人难以理解。\n>函数返回值; 调用生成器函数返回生成器; 生成器`产出`或`生成`值。生成器不会以常规方式`返回`值;\n\n\n```python\n\nIn [66]: def gen_AB():            # 1\n    ...:     print('start')       \n    ...:     yield 'A'            # 2\n    ...:     print('continue')\n    ...:     yield 'B'            # 3\n    ...:     print('end.')        # 4\n    ...:\n\nIn [67]: for c in gen_AB():       # 5\n    ...:     print('-->', c)      # 6\n    ...:\nstart       # 7\n--> A       # 8\ncontinue    # 9\n--> B       # 10\nend.        # 11\n\n```\n1. 定义生成的器函数的方式与普通函数无异，只不过要使用yield关键字\n2. 在for循环中第一次隐式调用next()函数时（序号5），会打印'start'，然后停在第一个yield语句，生成值 'A'\n3. 在for循环第二次隐式调用next()函数时，会打印'continue'，然后停在第二个yield语句，生成值'B'\n4. 第三次调用 next()函数时，会打印'end.'，然后到达函数定义体末尾。导致生成器对象抛出StopIteration异常\n5. 迭代时, for 机制的作用与g = iter(gen_AB())一样，用于获取生成器对象，然后每次迭代时调用next(g)\n6. 循环打印 --> 与 next(g)返回的值。但是，生成器函数中的print函数输出结果之后才会看到这个输出\n7. 'start'是生成器函数定义体中print('start')输出的记过\n8. 生成器函数定义体中的yield 'A' 语句会生成值 A，提供给for循环使用，而A会赋值给变量c，最终输出--> A\n9. 第二次调用next(g)，继续迭代，生成器函数定义体中的代码由yield 'A'前进到 yield 'B'。文本continue是由生成器函数定义体中的第二个print函数输出的\n10. 生成器函数定义体中的yield 'B' 语句会生成值 B，提供给for循环使用，而B会赋值给变量c，最终输出--> B\n11. 第三次调用next(g)，继续迭代，前进到生成器函数的结尾。文本 end. 是由生成器函数定义体中第三个print函数输出的。\n12. 到达生成器函数定义体结尾时，生成器对象抛出StopIteration异常。for 机制会捕捉异常，因此循环终止没有报错。\n\n## 生成器表达式\n\n简单的生成器函数，可以替换成生成器表达式。生成器表达式可以理解为列表推导的惰性版本：不会迫切的构建列表，而是返回一个生成器，按需惰性生成元素。也就是说，如果列表推导是制造工厂的列表，那么生成器表达式就是制造生成器的工厂。如下演示了一个简单的生成器表达式，并且与列表推导做了对比。\n\n```python\n\nIn [66]: def gen_AB():            # 1\n    ...:     print('start')       \n    ...:     yield 'A'            \n    ...:     print('continue')\n    ...:     yield 'B'            \n    ...:     print('end.')        \n    ...:\n\nIn [67]: res1 = [x*3 for x in gen_AB()]  # 2\nstart\ncontinue\nend.\n\nIn [68]: for i in res1():       # 3\n    ...:     print('-->', i)      \n    ...:\nAAA\nBBB\n\nIn [69]: res2 = (x*3 for x in gen_AB())  # 4\n\nIn [70]: res2  # 5\n<generator object <genexpr> at 0x106a07620>\n\nIn [71]: for i in res2():       # 6\n    ...:     print('-->', i)\n    ...:\nstart   \n--> A   \ncontinue\n--> B       \nend.\n\n```\n1. 创建gen_AB函数\n2. 列表推到迫切的迭代gen_AB()函数生成的生成器对象产出的元素：'A'和'B'。注意。下面输出的是start、continue、end.。\n3. for循环迭代列表推导生成的res1列表\n4. 把生成器表达式返回的值赋值给res2。只需调用gen_AB()函数，虽然调用时会返回一个生成器，但是这里并不使用。\n5. 可以看出res2是一个生成器对象。\n6. 只有for循环迭代res2时，gen_AB函数的定义体才会真正执行。for循环每次迭代时会隐式调用next(res2)，前进到gen_AB函数中的下一个yield语句。注意，gen_AB函数的输出与for循环中print函数的输出夹杂在一起。\n\n生成器表达式会产出生成器，因此可以使用生成器表达式进一步减少代码量。生成器表达式是一种语法糖，完全可以替换成生成器函数，不过有时候使用生成器表达式更便利。\n\n\n## 何时使用生成器表达式\n\n生成器表达式是创建生成器的简洁句法，这样无需定义函数再调用。不过，生成器函数灵活的多，可以使用多个语句实现复杂的逻辑，也可以作为`协程`使用。遇到简单的情况时，可以使用生成器表达式，因为这样扫一眼就知道代码的作用。其实选择那种句法很容易判断：如果生成器表达式需要分行写，倾向于定义成生成器函数，以便提高可读性。此外生成器函数有名称，因此可以重用。\n","source":"_posts/python3-可迭代对象、迭代器和生成器.md","raw":"---\ntitle: python3 可迭代对象、迭代器和生成器\ndate: 2018-03-01 20:17:53\ntags:\n  - Python3\ncategories:\n  - Python3 进阶\n  - Python3 迭代器和生成器\n---\n\n## 前言\n迭代是数据处理的基石。扫描内存中放不下数据集时，我们要找到一种惰性获取数据项的方式，即按需一次获取一个数据项，这就是迭代器模式（iterator pattern）。所有的`生成器`都是`迭代器`，因为生成器完全实现了迭代器接口。在python社区中，大多数时候都把`迭代器`和`生成器`视作同一概念。\n\n所有python程序员都知道，序列可迭代，下面说明具体原因。\n<!-- more -->\n## 序列可迭代的原因：iter函数\n解释器需要迭代对象x时，会自动调用`iter(x)`。\n内置的iter函数有以下作用。\n\n1. 检查对象是否实现了`__iter__`方法，如果实现了就调用它，获得一个迭代器。\n2. 如果没有实现`__iter__`方法，但是实现了`__getitem__`方法，python会创建一个迭代器，尝试按顺序（从索引0开始）获取元素。\n3. 如果尝试失败，python会抛出`TypeError`异常，通常会提示\"C object is not iterable\",其中C是目标对象所属的类。\n\n任何Python序列都可迭代的原因是它们实现了`__getitem__`方法。其实标准的序列也都实现了`__iter__`方法。之所以对`__getitem__`方法做特殊处理是为了向后兼容。\n\n从Python3.4开始，检查x能否迭代，最准确的方法是调用iter(x)函数，如果不可迭代，再处理TypeError异常。这比使用isinstance(x, abc.Iterable)更准确，因为iter(x)函数会考虑到遗留的`__getitem__`方法，而abc.Iterable类则不考虑。\n\n## 可迭代的对象与迭代器的对比\n\n### 可迭代对象\n\n**使用iter内置函数可以获取迭代器的对象。** 如果实现了能返回迭代器的`__iter__`方法，那么对象就是可迭代的。序列都可以迭代；实现了`__getitem__`方法，而且七参数是从零开始的索引，这种对象也是可迭代的。\n\n我们要明确可迭代对象和迭代器之间的关系：**Python从可迭代的对象中获取迭代器**\n\n标准的迭代器接口有两个方法，即：\n1. `__next__`:返回下一个可用元素，如果没有元素，抛出`StopIteration`异常\n2. `__iter__`:返回self,以便在应该使用可迭代对象的地方使用迭代器，比如for循环中。\n\n因为`迭代器`只需`__next__`和`__iter__`两个方法，所以除了调用next()方法，以及捕获`StopIteration`异常之外，没有办法检查是否还有遗留的元素。此外，也没有办法还原迭代器。如果想再次迭代，那就要调用iter(...)，传入之前构建迭代器的可迭代对象。\n\n### 迭代器\n\n迭代器是这样的对象：实现了无参数的`__next__`方法，返回序列中的下一个元素；如果没有元素了，那么抛出`StopIteration`异常。Python迭代器还实现了`__iter__`方法，因此迭代器也可以迭代。\n\n构建`可迭代对象`和`迭代器`时经常会出现错误，原因是混淆了两者。要知道，`可迭代的对象`有个`__iter__`方法，每次都实例化一个新的迭代器；而`迭代器`要实现`__next__`方法，返回单个元素，此外还要实现`__iter__`方法，返回迭代器本身。因此，`迭代器`可以迭代，但是`可迭代的对象`不是迭代器。\n\n可迭代的对象一定不是自身的迭代器。也就是说，可迭代的对象必须实现`__iter__`方法，但不能实现`__next__`方法。另一方面，迭代器应该一直可以迭代，迭代器的`__iter__`方法应该返回自身。\n\n```python\na = [1,2,3]\n'__iter__' in dir(a)            # True\n'__iter__' in dir(iter(a))      # True\n\n```\n\n## 生成器函数\n\n只要Python函数的定义体中有yield关键字，该函数就是生成器函数。调用生成器函数时，会返回一个生成器对象。也就是说，生成器函数是生成器工厂。\n\n普通的函数与生成器函数在句法上的唯一区别是，在后者的定义体中有`yield`关键字。有些人认为定义生成器函数应该使用一个新的关键字，例如gen，而不是def，但是Guido不同意。\n### 生成器函数工作原理\n\n```python\ndef gen_123():  # 只要Python代码中包含yield，该函数就是生成器函数\n    yield 1    #生成器函数的定义体中通常都有循环，不过这不是必要条件；此处重复使用了3次yield\n    yield 2\n    yield 3\n\nif __name__ == '__main__':\n    print(gen_123)    # 可以看出gen_123是函数对象\n    # <function gen_123 at 0x10be199d8>\n    print(gen_123())  # 函数调用时返回的是一个生成器对象\n    # <generator object gen_123 at 0x10be31ca8>\n\n    for i in gen_123(): # 生成器是迭代器，会生成传给yield关键字的表达式的值\n        print(i)    \n        # 1\n        # 2\n        # 3\n\n    g = gen_123() # 为了仔细检查，把生成器对象赋值给g\n    print(next(g))  # 1\n    print(next(g))  # 2\n    print(next(g))  # 3\n    print(next(g))   # 生成器函数的定义体执行完毕后，生成器对象会抛出异常。\n# Traceback (most recent call last):\n#   File \"test.py\", line 17, in <module>\n#     print(next(g))\n# StopIteration\n\n```\n\n如上述代码所示：\n1. 只要Python代码中包含yield，该函数就是生成器函数\n2. 生成器函数的定义体中通常都有循环，不过这不是必要条件；此处重复使用了3次yield\n3. 可以看出gen_123是函数对象\n4. 函数调用时返回的是一个生成器对象\n5. 生成器是迭代器，会`生成`传给yield关键字的表达式的值\n6. 为了仔细检查，把生成器对象赋值给g\n7. 因为g是迭代器，所以调用nest(g)会获取yield`生成`的下一个元素\n8. 生成器函数的定义体执行完毕后，生成器对象会抛出异常。\n\n\n使用准确的词语描述从生成器中获取结果的过程有助于理解生成器。注意，此处说的是`产出`或`生成`值。如果说生成器`返回`值，就会让人难以理解。\n>函数返回值; 调用生成器函数返回生成器; 生成器`产出`或`生成`值。生成器不会以常规方式`返回`值;\n\n\n```python\n\nIn [66]: def gen_AB():            # 1\n    ...:     print('start')       \n    ...:     yield 'A'            # 2\n    ...:     print('continue')\n    ...:     yield 'B'            # 3\n    ...:     print('end.')        # 4\n    ...:\n\nIn [67]: for c in gen_AB():       # 5\n    ...:     print('-->', c)      # 6\n    ...:\nstart       # 7\n--> A       # 8\ncontinue    # 9\n--> B       # 10\nend.        # 11\n\n```\n1. 定义生成的器函数的方式与普通函数无异，只不过要使用yield关键字\n2. 在for循环中第一次隐式调用next()函数时（序号5），会打印'start'，然后停在第一个yield语句，生成值 'A'\n3. 在for循环第二次隐式调用next()函数时，会打印'continue'，然后停在第二个yield语句，生成值'B'\n4. 第三次调用 next()函数时，会打印'end.'，然后到达函数定义体末尾。导致生成器对象抛出StopIteration异常\n5. 迭代时, for 机制的作用与g = iter(gen_AB())一样，用于获取生成器对象，然后每次迭代时调用next(g)\n6. 循环打印 --> 与 next(g)返回的值。但是，生成器函数中的print函数输出结果之后才会看到这个输出\n7. 'start'是生成器函数定义体中print('start')输出的记过\n8. 生成器函数定义体中的yield 'A' 语句会生成值 A，提供给for循环使用，而A会赋值给变量c，最终输出--> A\n9. 第二次调用next(g)，继续迭代，生成器函数定义体中的代码由yield 'A'前进到 yield 'B'。文本continue是由生成器函数定义体中的第二个print函数输出的\n10. 生成器函数定义体中的yield 'B' 语句会生成值 B，提供给for循环使用，而B会赋值给变量c，最终输出--> B\n11. 第三次调用next(g)，继续迭代，前进到生成器函数的结尾。文本 end. 是由生成器函数定义体中第三个print函数输出的。\n12. 到达生成器函数定义体结尾时，生成器对象抛出StopIteration异常。for 机制会捕捉异常，因此循环终止没有报错。\n\n## 生成器表达式\n\n简单的生成器函数，可以替换成生成器表达式。生成器表达式可以理解为列表推导的惰性版本：不会迫切的构建列表，而是返回一个生成器，按需惰性生成元素。也就是说，如果列表推导是制造工厂的列表，那么生成器表达式就是制造生成器的工厂。如下演示了一个简单的生成器表达式，并且与列表推导做了对比。\n\n```python\n\nIn [66]: def gen_AB():            # 1\n    ...:     print('start')       \n    ...:     yield 'A'            \n    ...:     print('continue')\n    ...:     yield 'B'            \n    ...:     print('end.')        \n    ...:\n\nIn [67]: res1 = [x*3 for x in gen_AB()]  # 2\nstart\ncontinue\nend.\n\nIn [68]: for i in res1():       # 3\n    ...:     print('-->', i)      \n    ...:\nAAA\nBBB\n\nIn [69]: res2 = (x*3 for x in gen_AB())  # 4\n\nIn [70]: res2  # 5\n<generator object <genexpr> at 0x106a07620>\n\nIn [71]: for i in res2():       # 6\n    ...:     print('-->', i)\n    ...:\nstart   \n--> A   \ncontinue\n--> B       \nend.\n\n```\n1. 创建gen_AB函数\n2. 列表推到迫切的迭代gen_AB()函数生成的生成器对象产出的元素：'A'和'B'。注意。下面输出的是start、continue、end.。\n3. for循环迭代列表推导生成的res1列表\n4. 把生成器表达式返回的值赋值给res2。只需调用gen_AB()函数，虽然调用时会返回一个生成器，但是这里并不使用。\n5. 可以看出res2是一个生成器对象。\n6. 只有for循环迭代res2时，gen_AB函数的定义体才会真正执行。for循环每次迭代时会隐式调用next(res2)，前进到gen_AB函数中的下一个yield语句。注意，gen_AB函数的输出与for循环中print函数的输出夹杂在一起。\n\n生成器表达式会产出生成器，因此可以使用生成器表达式进一步减少代码量。生成器表达式是一种语法糖，完全可以替换成生成器函数，不过有时候使用生成器表达式更便利。\n\n\n## 何时使用生成器表达式\n\n生成器表达式是创建生成器的简洁句法，这样无需定义函数再调用。不过，生成器函数灵活的多，可以使用多个语句实现复杂的逻辑，也可以作为`协程`使用。遇到简单的情况时，可以使用生成器表达式，因为这样扫一眼就知道代码的作用。其实选择那种句法很容易判断：如果生成器表达式需要分行写，倾向于定义成生成器函数，以便提高可读性。此外生成器函数有名称，因此可以重用。\n","slug":"python3-可迭代对象、迭代器和生成器","published":1,"updated":"2018-03-02T04:55:21.925Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozmh00538mot92upklck","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>迭代是数据处理的基石。扫描内存中放不下数据集时，我们要找到一种惰性获取数据项的方式，即按需一次获取一个数据项，这就是迭代器模式（iterator pattern）。所有的<code>生成器</code>都是<code>迭代器</code>，因为生成器完全实现了迭代器接口。在python社区中，大多数时候都把<code>迭代器</code>和<code>生成器</code>视作同一概念。</p>\n<p>所有python程序员都知道，序列可迭代，下面说明具体原因。<br><a id=\"more\"></a></p>\n<h2 id=\"序列可迭代的原因：iter函数\"><a href=\"#序列可迭代的原因：iter函数\" class=\"headerlink\" title=\"序列可迭代的原因：iter函数\"></a>序列可迭代的原因：iter函数</h2><p>解释器需要迭代对象x时，会自动调用<code>iter(x)</code>。<br>内置的iter函数有以下作用。</p>\n<ol>\n<li>检查对象是否实现了<code>__iter__</code>方法，如果实现了就调用它，获得一个迭代器。</li>\n<li>如果没有实现<code>__iter__</code>方法，但是实现了<code>__getitem__</code>方法，python会创建一个迭代器，尝试按顺序（从索引0开始）获取元素。</li>\n<li>如果尝试失败，python会抛出<code>TypeError</code>异常，通常会提示”C object is not iterable”,其中C是目标对象所属的类。</li>\n</ol>\n<p>任何Python序列都可迭代的原因是它们实现了<code>__getitem__</code>方法。其实标准的序列也都实现了<code>__iter__</code>方法。之所以对<code>__getitem__</code>方法做特殊处理是为了向后兼容。</p>\n<p>从Python3.4开始，检查x能否迭代，最准确的方法是调用iter(x)函数，如果不可迭代，再处理TypeError异常。这比使用isinstance(x, abc.Iterable)更准确，因为iter(x)函数会考虑到遗留的<code>__getitem__</code>方法，而abc.Iterable类则不考虑。</p>\n<h2 id=\"可迭代的对象与迭代器的对比\"><a href=\"#可迭代的对象与迭代器的对比\" class=\"headerlink\" title=\"可迭代的对象与迭代器的对比\"></a>可迭代的对象与迭代器的对比</h2><h3 id=\"可迭代对象\"><a href=\"#可迭代对象\" class=\"headerlink\" title=\"可迭代对象\"></a>可迭代对象</h3><p><strong>使用iter内置函数可以获取迭代器的对象。</strong> 如果实现了能返回迭代器的<code>__iter__</code>方法，那么对象就是可迭代的。序列都可以迭代；实现了<code>__getitem__</code>方法，而且七参数是从零开始的索引，这种对象也是可迭代的。</p>\n<p>我们要明确可迭代对象和迭代器之间的关系：<strong>Python从可迭代的对象中获取迭代器</strong></p>\n<p>标准的迭代器接口有两个方法，即：</p>\n<ol>\n<li><code>__next__</code>:返回下一个可用元素，如果没有元素，抛出<code>StopIteration</code>异常</li>\n<li><code>__iter__</code>:返回self,以便在应该使用可迭代对象的地方使用迭代器，比如for循环中。</li>\n</ol>\n<p>因为<code>迭代器</code>只需<code>__next__</code>和<code>__iter__</code>两个方法，所以除了调用next()方法，以及捕获<code>StopIteration</code>异常之外，没有办法检查是否还有遗留的元素。此外，也没有办法还原迭代器。如果想再次迭代，那就要调用iter(…)，传入之前构建迭代器的可迭代对象。</p>\n<h3 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h3><p>迭代器是这样的对象：实现了无参数的<code>__next__</code>方法，返回序列中的下一个元素；如果没有元素了，那么抛出<code>StopIteration</code>异常。Python迭代器还实现了<code>__iter__</code>方法，因此迭代器也可以迭代。</p>\n<p>构建<code>可迭代对象</code>和<code>迭代器</code>时经常会出现错误，原因是混淆了两者。要知道，<code>可迭代的对象</code>有个<code>__iter__</code>方法，每次都实例化一个新的迭代器；而<code>迭代器</code>要实现<code>__next__</code>方法，返回单个元素，此外还要实现<code>__iter__</code>方法，返回迭代器本身。因此，<code>迭代器</code>可以迭代，但是<code>可迭代的对象</code>不是迭代器。</p>\n<p>可迭代的对象一定不是自身的迭代器。也就是说，可迭代的对象必须实现<code>__iter__</code>方法，但不能实现<code>__next__</code>方法。另一方面，迭代器应该一直可以迭代，迭代器的<code>__iter__</code>方法应该返回自身。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"string\">'__iter__'</span> <span class=\"keyword\">in</span> dir(a)            <span class=\"comment\"># True</span></span><br><span class=\"line\"><span class=\"string\">'__iter__'</span> <span class=\"keyword\">in</span> dir(iter(a))      <span class=\"comment\"># True</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"生成器函数\"><a href=\"#生成器函数\" class=\"headerlink\" title=\"生成器函数\"></a>生成器函数</h2><p>只要Python函数的定义体中有yield关键字，该函数就是生成器函数。调用生成器函数时，会返回一个生成器对象。也就是说，生成器函数是生成器工厂。</p>\n<p>普通的函数与生成器函数在句法上的唯一区别是，在后者的定义体中有<code>yield</code>关键字。有些人认为定义生成器函数应该使用一个新的关键字，例如gen，而不是def，但是Guido不同意。</p>\n<h3 id=\"生成器函数工作原理\"><a href=\"#生成器函数工作原理\" class=\"headerlink\" title=\"生成器函数工作原理\"></a>生成器函数工作原理</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">gen_123</span><span class=\"params\">()</span>:</span>  <span class=\"comment\"># 只要Python代码中包含yield，该函数就是生成器函数</span></span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"number\">1</span>    <span class=\"comment\">#生成器函数的定义体中通常都有循环，不过这不是必要条件；此处重复使用了3次yield</span></span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    print(gen_123)    <span class=\"comment\"># 可以看出gen_123是函数对象</span></span><br><span class=\"line\">    <span class=\"comment\"># &lt;function gen_123 at 0x10be199d8&gt;</span></span><br><span class=\"line\">    print(gen_123())  <span class=\"comment\"># 函数调用时返回的是一个生成器对象</span></span><br><span class=\"line\">    <span class=\"comment\"># &lt;generator object gen_123 at 0x10be31ca8&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> gen_123(): <span class=\"comment\"># 生成器是迭代器，会生成传给yield关键字的表达式的值</span></span><br><span class=\"line\">        print(i)    </span><br><span class=\"line\">        <span class=\"comment\"># 1</span></span><br><span class=\"line\">        <span class=\"comment\"># 2</span></span><br><span class=\"line\">        <span class=\"comment\"># 3</span></span><br><span class=\"line\"></span><br><span class=\"line\">    g = gen_123() <span class=\"comment\"># 为了仔细检查，把生成器对象赋值给g</span></span><br><span class=\"line\">    print(next(g))  <span class=\"comment\"># 1</span></span><br><span class=\"line\">    print(next(g))  <span class=\"comment\"># 2</span></span><br><span class=\"line\">    print(next(g))  <span class=\"comment\"># 3</span></span><br><span class=\"line\">    print(next(g))   <span class=\"comment\"># 生成器函数的定义体执行完毕后，生成器对象会抛出异常。</span></span><br><span class=\"line\"><span class=\"comment\"># Traceback (most recent call last):</span></span><br><span class=\"line\"><span class=\"comment\">#   File \"test.py\", line 17, in &lt;module&gt;</span></span><br><span class=\"line\"><span class=\"comment\">#     print(next(g))</span></span><br><span class=\"line\"><span class=\"comment\"># StopIteration</span></span><br></pre></td></tr></table></figure>\n<p>如上述代码所示：</p>\n<ol>\n<li>只要Python代码中包含yield，该函数就是生成器函数</li>\n<li>生成器函数的定义体中通常都有循环，不过这不是必要条件；此处重复使用了3次yield</li>\n<li>可以看出gen_123是函数对象</li>\n<li>函数调用时返回的是一个生成器对象</li>\n<li>生成器是迭代器，会<code>生成</code>传给yield关键字的表达式的值</li>\n<li>为了仔细检查，把生成器对象赋值给g</li>\n<li>因为g是迭代器，所以调用nest(g)会获取yield<code>生成</code>的下一个元素</li>\n<li>生成器函数的定义体执行完毕后，生成器对象会抛出异常。</li>\n</ol>\n<p>使用准确的词语描述从生成器中获取结果的过程有助于理解生成器。注意，此处说的是<code>产出</code>或<code>生成</code>值。如果说生成器<code>返回</code>值，就会让人难以理解。</p>\n<blockquote>\n<p>函数返回值; 调用生成器函数返回生成器; 生成器<code>产出</code>或<code>生成</code>值。生成器不会以常规方式<code>返回</code>值;</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">In [<span class=\"number\">66</span>]: <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">gen_AB</span><span class=\"params\">()</span>:</span>            <span class=\"comment\"># 1</span></span><br><span class=\"line\">    ...:     print(<span class=\"string\">'start'</span>)       </span><br><span class=\"line\">    ...:     <span class=\"keyword\">yield</span> <span class=\"string\">'A'</span>            <span class=\"comment\"># 2</span></span><br><span class=\"line\">    ...:     print(<span class=\"string\">'continue'</span>)</span><br><span class=\"line\">    ...:     <span class=\"keyword\">yield</span> <span class=\"string\">'B'</span>            <span class=\"comment\"># 3</span></span><br><span class=\"line\">    ...:     print(<span class=\"string\">'end.'</span>)        <span class=\"comment\"># 4</span></span><br><span class=\"line\">    ...:</span><br><span class=\"line\"></span><br><span class=\"line\">In [<span class=\"number\">67</span>]: <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> gen_AB():       <span class=\"comment\"># 5</span></span><br><span class=\"line\">    ...:     print(<span class=\"string\">'--&gt;'</span>, c)      <span class=\"comment\"># 6</span></span><br><span class=\"line\">    ...:</span><br><span class=\"line\">start       <span class=\"comment\"># 7</span></span><br><span class=\"line\">--&gt; A       # 8</span><br><span class=\"line\"><span class=\"keyword\">continue</span>    <span class=\"comment\"># 9</span></span><br><span class=\"line\">--&gt; B       # 10</span><br><span class=\"line\">end.        <span class=\"comment\"># 11</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>定义生成的器函数的方式与普通函数无异，只不过要使用yield关键字</li>\n<li>在for循环中第一次隐式调用next()函数时（序号5），会打印’start’，然后停在第一个yield语句，生成值 ‘A’</li>\n<li>在for循环第二次隐式调用next()函数时，会打印’continue’，然后停在第二个yield语句，生成值’B’</li>\n<li>第三次调用 next()函数时，会打印’end.’，然后到达函数定义体末尾。导致生成器对象抛出StopIteration异常</li>\n<li>迭代时, for 机制的作用与g = iter(gen_AB())一样，用于获取生成器对象，然后每次迭代时调用next(g)</li>\n<li>循环打印 –&gt; 与 next(g)返回的值。但是，生成器函数中的print函数输出结果之后才会看到这个输出</li>\n<li>‘start’是生成器函数定义体中print(‘start’)输出的记过</li>\n<li>生成器函数定义体中的yield ‘A’ 语句会生成值 A，提供给for循环使用，而A会赋值给变量c，最终输出–&gt; A</li>\n<li>第二次调用next(g)，继续迭代，生成器函数定义体中的代码由yield ‘A’前进到 yield ‘B’。文本continue是由生成器函数定义体中的第二个print函数输出的</li>\n<li>生成器函数定义体中的yield ‘B’ 语句会生成值 B，提供给for循环使用，而B会赋值给变量c，最终输出–&gt; B</li>\n<li>第三次调用next(g)，继续迭代，前进到生成器函数的结尾。文本 end. 是由生成器函数定义体中第三个print函数输出的。</li>\n<li>到达生成器函数定义体结尾时，生成器对象抛出StopIteration异常。for 机制会捕捉异常，因此循环终止没有报错。</li>\n</ol>\n<h2 id=\"生成器表达式\"><a href=\"#生成器表达式\" class=\"headerlink\" title=\"生成器表达式\"></a>生成器表达式</h2><p>简单的生成器函数，可以替换成生成器表达式。生成器表达式可以理解为列表推导的惰性版本：不会迫切的构建列表，而是返回一个生成器，按需惰性生成元素。也就是说，如果列表推导是制造工厂的列表，那么生成器表达式就是制造生成器的工厂。如下演示了一个简单的生成器表达式，并且与列表推导做了对比。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">In [<span class=\"number\">66</span>]: <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">gen_AB</span><span class=\"params\">()</span>:</span>            <span class=\"comment\"># 1</span></span><br><span class=\"line\">    ...:     print(<span class=\"string\">'start'</span>)       </span><br><span class=\"line\">    ...:     <span class=\"keyword\">yield</span> <span class=\"string\">'A'</span>            </span><br><span class=\"line\">    ...:     print(<span class=\"string\">'continue'</span>)</span><br><span class=\"line\">    ...:     <span class=\"keyword\">yield</span> <span class=\"string\">'B'</span>            </span><br><span class=\"line\">    ...:     print(<span class=\"string\">'end.'</span>)        </span><br><span class=\"line\">    ...:</span><br><span class=\"line\"></span><br><span class=\"line\">In [<span class=\"number\">67</span>]: res1 = [x*<span class=\"number\">3</span> <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> gen_AB()]  <span class=\"comment\"># 2</span></span><br><span class=\"line\">start</span><br><span class=\"line\"><span class=\"keyword\">continue</span></span><br><span class=\"line\">end.</span><br><span class=\"line\"></span><br><span class=\"line\">In [<span class=\"number\">68</span>]: <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> res1():       <span class=\"comment\"># 3</span></span><br><span class=\"line\">    ...:     print(<span class=\"string\">'--&gt;'</span>, i)      </span><br><span class=\"line\">    ...:</span><br><span class=\"line\">AAA</span><br><span class=\"line\">BBB</span><br><span class=\"line\"></span><br><span class=\"line\">In [<span class=\"number\">69</span>]: res2 = (x*<span class=\"number\">3</span> <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> gen_AB())  <span class=\"comment\"># 4</span></span><br><span class=\"line\"></span><br><span class=\"line\">In [<span class=\"number\">70</span>]: res2  <span class=\"comment\"># 5</span></span><br><span class=\"line\">&lt;generator object &lt;genexpr&gt; at <span class=\"number\">0x106a07620</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">In [<span class=\"number\">71</span>]: <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> res2():       <span class=\"comment\"># 6</span></span><br><span class=\"line\">    ...:     print(<span class=\"string\">'--&gt;'</span>, i)</span><br><span class=\"line\">    ...:</span><br><span class=\"line\">start   </span><br><span class=\"line\">--&gt; A   </span><br><span class=\"line\"><span class=\"keyword\">continue</span></span><br><span class=\"line\">--&gt; B       </span><br><span class=\"line\">end.</span><br></pre></td></tr></table></figure>\n<ol>\n<li>创建gen_AB函数</li>\n<li>列表推到迫切的迭代gen_AB()函数生成的生成器对象产出的元素：’A’和’B’。注意。下面输出的是start、continue、end.。</li>\n<li>for循环迭代列表推导生成的res1列表</li>\n<li>把生成器表达式返回的值赋值给res2。只需调用gen_AB()函数，虽然调用时会返回一个生成器，但是这里并不使用。</li>\n<li>可以看出res2是一个生成器对象。</li>\n<li>只有for循环迭代res2时，gen_AB函数的定义体才会真正执行。for循环每次迭代时会隐式调用next(res2)，前进到gen_AB函数中的下一个yield语句。注意，gen_AB函数的输出与for循环中print函数的输出夹杂在一起。</li>\n</ol>\n<p>生成器表达式会产出生成器，因此可以使用生成器表达式进一步减少代码量。生成器表达式是一种语法糖，完全可以替换成生成器函数，不过有时候使用生成器表达式更便利。</p>\n<h2 id=\"何时使用生成器表达式\"><a href=\"#何时使用生成器表达式\" class=\"headerlink\" title=\"何时使用生成器表达式\"></a>何时使用生成器表达式</h2><p>生成器表达式是创建生成器的简洁句法，这样无需定义函数再调用。不过，生成器函数灵活的多，可以使用多个语句实现复杂的逻辑，也可以作为<code>协程</code>使用。遇到简单的情况时，可以使用生成器表达式，因为这样扫一眼就知道代码的作用。其实选择那种句法很容易判断：如果生成器表达式需要分行写，倾向于定义成生成器函数，以便提高可读性。此外生成器函数有名称，因此可以重用。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>迭代是数据处理的基石。扫描内存中放不下数据集时，我们要找到一种惰性获取数据项的方式，即按需一次获取一个数据项，这就是迭代器模式（iterator pattern）。所有的<code>生成器</code>都是<code>迭代器</code>，因为生成器完全实现了迭代器接口。在python社区中，大多数时候都把<code>迭代器</code>和<code>生成器</code>视作同一概念。</p>\n<p>所有python程序员都知道，序列可迭代，下面说明具体原因。<br>","more":"</p>\n<h2 id=\"序列可迭代的原因：iter函数\"><a href=\"#序列可迭代的原因：iter函数\" class=\"headerlink\" title=\"序列可迭代的原因：iter函数\"></a>序列可迭代的原因：iter函数</h2><p>解释器需要迭代对象x时，会自动调用<code>iter(x)</code>。<br>内置的iter函数有以下作用。</p>\n<ol>\n<li>检查对象是否实现了<code>__iter__</code>方法，如果实现了就调用它，获得一个迭代器。</li>\n<li>如果没有实现<code>__iter__</code>方法，但是实现了<code>__getitem__</code>方法，python会创建一个迭代器，尝试按顺序（从索引0开始）获取元素。</li>\n<li>如果尝试失败，python会抛出<code>TypeError</code>异常，通常会提示”C object is not iterable”,其中C是目标对象所属的类。</li>\n</ol>\n<p>任何Python序列都可迭代的原因是它们实现了<code>__getitem__</code>方法。其实标准的序列也都实现了<code>__iter__</code>方法。之所以对<code>__getitem__</code>方法做特殊处理是为了向后兼容。</p>\n<p>从Python3.4开始，检查x能否迭代，最准确的方法是调用iter(x)函数，如果不可迭代，再处理TypeError异常。这比使用isinstance(x, abc.Iterable)更准确，因为iter(x)函数会考虑到遗留的<code>__getitem__</code>方法，而abc.Iterable类则不考虑。</p>\n<h2 id=\"可迭代的对象与迭代器的对比\"><a href=\"#可迭代的对象与迭代器的对比\" class=\"headerlink\" title=\"可迭代的对象与迭代器的对比\"></a>可迭代的对象与迭代器的对比</h2><h3 id=\"可迭代对象\"><a href=\"#可迭代对象\" class=\"headerlink\" title=\"可迭代对象\"></a>可迭代对象</h3><p><strong>使用iter内置函数可以获取迭代器的对象。</strong> 如果实现了能返回迭代器的<code>__iter__</code>方法，那么对象就是可迭代的。序列都可以迭代；实现了<code>__getitem__</code>方法，而且七参数是从零开始的索引，这种对象也是可迭代的。</p>\n<p>我们要明确可迭代对象和迭代器之间的关系：<strong>Python从可迭代的对象中获取迭代器</strong></p>\n<p>标准的迭代器接口有两个方法，即：</p>\n<ol>\n<li><code>__next__</code>:返回下一个可用元素，如果没有元素，抛出<code>StopIteration</code>异常</li>\n<li><code>__iter__</code>:返回self,以便在应该使用可迭代对象的地方使用迭代器，比如for循环中。</li>\n</ol>\n<p>因为<code>迭代器</code>只需<code>__next__</code>和<code>__iter__</code>两个方法，所以除了调用next()方法，以及捕获<code>StopIteration</code>异常之外，没有办法检查是否还有遗留的元素。此外，也没有办法还原迭代器。如果想再次迭代，那就要调用iter(…)，传入之前构建迭代器的可迭代对象。</p>\n<h3 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h3><p>迭代器是这样的对象：实现了无参数的<code>__next__</code>方法，返回序列中的下一个元素；如果没有元素了，那么抛出<code>StopIteration</code>异常。Python迭代器还实现了<code>__iter__</code>方法，因此迭代器也可以迭代。</p>\n<p>构建<code>可迭代对象</code>和<code>迭代器</code>时经常会出现错误，原因是混淆了两者。要知道，<code>可迭代的对象</code>有个<code>__iter__</code>方法，每次都实例化一个新的迭代器；而<code>迭代器</code>要实现<code>__next__</code>方法，返回单个元素，此外还要实现<code>__iter__</code>方法，返回迭代器本身。因此，<code>迭代器</code>可以迭代，但是<code>可迭代的对象</code>不是迭代器。</p>\n<p>可迭代的对象一定不是自身的迭代器。也就是说，可迭代的对象必须实现<code>__iter__</code>方法，但不能实现<code>__next__</code>方法。另一方面，迭代器应该一直可以迭代，迭代器的<code>__iter__</code>方法应该返回自身。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"string\">'__iter__'</span> <span class=\"keyword\">in</span> dir(a)            <span class=\"comment\"># True</span></span><br><span class=\"line\"><span class=\"string\">'__iter__'</span> <span class=\"keyword\">in</span> dir(iter(a))      <span class=\"comment\"># True</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"生成器函数\"><a href=\"#生成器函数\" class=\"headerlink\" title=\"生成器函数\"></a>生成器函数</h2><p>只要Python函数的定义体中有yield关键字，该函数就是生成器函数。调用生成器函数时，会返回一个生成器对象。也就是说，生成器函数是生成器工厂。</p>\n<p>普通的函数与生成器函数在句法上的唯一区别是，在后者的定义体中有<code>yield</code>关键字。有些人认为定义生成器函数应该使用一个新的关键字，例如gen，而不是def，但是Guido不同意。</p>\n<h3 id=\"生成器函数工作原理\"><a href=\"#生成器函数工作原理\" class=\"headerlink\" title=\"生成器函数工作原理\"></a>生成器函数工作原理</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">gen_123</span><span class=\"params\">()</span>:</span>  <span class=\"comment\"># 只要Python代码中包含yield，该函数就是生成器函数</span></span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"number\">1</span>    <span class=\"comment\">#生成器函数的定义体中通常都有循环，不过这不是必要条件；此处重复使用了3次yield</span></span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">yield</span> <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    print(gen_123)    <span class=\"comment\"># 可以看出gen_123是函数对象</span></span><br><span class=\"line\">    <span class=\"comment\"># &lt;function gen_123 at 0x10be199d8&gt;</span></span><br><span class=\"line\">    print(gen_123())  <span class=\"comment\"># 函数调用时返回的是一个生成器对象</span></span><br><span class=\"line\">    <span class=\"comment\"># &lt;generator object gen_123 at 0x10be31ca8&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> gen_123(): <span class=\"comment\"># 生成器是迭代器，会生成传给yield关键字的表达式的值</span></span><br><span class=\"line\">        print(i)    </span><br><span class=\"line\">        <span class=\"comment\"># 1</span></span><br><span class=\"line\">        <span class=\"comment\"># 2</span></span><br><span class=\"line\">        <span class=\"comment\"># 3</span></span><br><span class=\"line\"></span><br><span class=\"line\">    g = gen_123() <span class=\"comment\"># 为了仔细检查，把生成器对象赋值给g</span></span><br><span class=\"line\">    print(next(g))  <span class=\"comment\"># 1</span></span><br><span class=\"line\">    print(next(g))  <span class=\"comment\"># 2</span></span><br><span class=\"line\">    print(next(g))  <span class=\"comment\"># 3</span></span><br><span class=\"line\">    print(next(g))   <span class=\"comment\"># 生成器函数的定义体执行完毕后，生成器对象会抛出异常。</span></span><br><span class=\"line\"><span class=\"comment\"># Traceback (most recent call last):</span></span><br><span class=\"line\"><span class=\"comment\">#   File \"test.py\", line 17, in &lt;module&gt;</span></span><br><span class=\"line\"><span class=\"comment\">#     print(next(g))</span></span><br><span class=\"line\"><span class=\"comment\"># StopIteration</span></span><br></pre></td></tr></table></figure>\n<p>如上述代码所示：</p>\n<ol>\n<li>只要Python代码中包含yield，该函数就是生成器函数</li>\n<li>生成器函数的定义体中通常都有循环，不过这不是必要条件；此处重复使用了3次yield</li>\n<li>可以看出gen_123是函数对象</li>\n<li>函数调用时返回的是一个生成器对象</li>\n<li>生成器是迭代器，会<code>生成</code>传给yield关键字的表达式的值</li>\n<li>为了仔细检查，把生成器对象赋值给g</li>\n<li>因为g是迭代器，所以调用nest(g)会获取yield<code>生成</code>的下一个元素</li>\n<li>生成器函数的定义体执行完毕后，生成器对象会抛出异常。</li>\n</ol>\n<p>使用准确的词语描述从生成器中获取结果的过程有助于理解生成器。注意，此处说的是<code>产出</code>或<code>生成</code>值。如果说生成器<code>返回</code>值，就会让人难以理解。</p>\n<blockquote>\n<p>函数返回值; 调用生成器函数返回生成器; 生成器<code>产出</code>或<code>生成</code>值。生成器不会以常规方式<code>返回</code>值;</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">In [<span class=\"number\">66</span>]: <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">gen_AB</span><span class=\"params\">()</span>:</span>            <span class=\"comment\"># 1</span></span><br><span class=\"line\">    ...:     print(<span class=\"string\">'start'</span>)       </span><br><span class=\"line\">    ...:     <span class=\"keyword\">yield</span> <span class=\"string\">'A'</span>            <span class=\"comment\"># 2</span></span><br><span class=\"line\">    ...:     print(<span class=\"string\">'continue'</span>)</span><br><span class=\"line\">    ...:     <span class=\"keyword\">yield</span> <span class=\"string\">'B'</span>            <span class=\"comment\"># 3</span></span><br><span class=\"line\">    ...:     print(<span class=\"string\">'end.'</span>)        <span class=\"comment\"># 4</span></span><br><span class=\"line\">    ...:</span><br><span class=\"line\"></span><br><span class=\"line\">In [<span class=\"number\">67</span>]: <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> gen_AB():       <span class=\"comment\"># 5</span></span><br><span class=\"line\">    ...:     print(<span class=\"string\">'--&gt;'</span>, c)      <span class=\"comment\"># 6</span></span><br><span class=\"line\">    ...:</span><br><span class=\"line\">start       <span class=\"comment\"># 7</span></span><br><span class=\"line\">--&gt; A       # 8</span><br><span class=\"line\"><span class=\"keyword\">continue</span>    <span class=\"comment\"># 9</span></span><br><span class=\"line\">--&gt; B       # 10</span><br><span class=\"line\">end.        <span class=\"comment\"># 11</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>定义生成的器函数的方式与普通函数无异，只不过要使用yield关键字</li>\n<li>在for循环中第一次隐式调用next()函数时（序号5），会打印’start’，然后停在第一个yield语句，生成值 ‘A’</li>\n<li>在for循环第二次隐式调用next()函数时，会打印’continue’，然后停在第二个yield语句，生成值’B’</li>\n<li>第三次调用 next()函数时，会打印’end.’，然后到达函数定义体末尾。导致生成器对象抛出StopIteration异常</li>\n<li>迭代时, for 机制的作用与g = iter(gen_AB())一样，用于获取生成器对象，然后每次迭代时调用next(g)</li>\n<li>循环打印 –&gt; 与 next(g)返回的值。但是，生成器函数中的print函数输出结果之后才会看到这个输出</li>\n<li>‘start’是生成器函数定义体中print(‘start’)输出的记过</li>\n<li>生成器函数定义体中的yield ‘A’ 语句会生成值 A，提供给for循环使用，而A会赋值给变量c，最终输出–&gt; A</li>\n<li>第二次调用next(g)，继续迭代，生成器函数定义体中的代码由yield ‘A’前进到 yield ‘B’。文本continue是由生成器函数定义体中的第二个print函数输出的</li>\n<li>生成器函数定义体中的yield ‘B’ 语句会生成值 B，提供给for循环使用，而B会赋值给变量c，最终输出–&gt; B</li>\n<li>第三次调用next(g)，继续迭代，前进到生成器函数的结尾。文本 end. 是由生成器函数定义体中第三个print函数输出的。</li>\n<li>到达生成器函数定义体结尾时，生成器对象抛出StopIteration异常。for 机制会捕捉异常，因此循环终止没有报错。</li>\n</ol>\n<h2 id=\"生成器表达式\"><a href=\"#生成器表达式\" class=\"headerlink\" title=\"生成器表达式\"></a>生成器表达式</h2><p>简单的生成器函数，可以替换成生成器表达式。生成器表达式可以理解为列表推导的惰性版本：不会迫切的构建列表，而是返回一个生成器，按需惰性生成元素。也就是说，如果列表推导是制造工厂的列表，那么生成器表达式就是制造生成器的工厂。如下演示了一个简单的生成器表达式，并且与列表推导做了对比。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">In [<span class=\"number\">66</span>]: <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">gen_AB</span><span class=\"params\">()</span>:</span>            <span class=\"comment\"># 1</span></span><br><span class=\"line\">    ...:     print(<span class=\"string\">'start'</span>)       </span><br><span class=\"line\">    ...:     <span class=\"keyword\">yield</span> <span class=\"string\">'A'</span>            </span><br><span class=\"line\">    ...:     print(<span class=\"string\">'continue'</span>)</span><br><span class=\"line\">    ...:     <span class=\"keyword\">yield</span> <span class=\"string\">'B'</span>            </span><br><span class=\"line\">    ...:     print(<span class=\"string\">'end.'</span>)        </span><br><span class=\"line\">    ...:</span><br><span class=\"line\"></span><br><span class=\"line\">In [<span class=\"number\">67</span>]: res1 = [x*<span class=\"number\">3</span> <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> gen_AB()]  <span class=\"comment\"># 2</span></span><br><span class=\"line\">start</span><br><span class=\"line\"><span class=\"keyword\">continue</span></span><br><span class=\"line\">end.</span><br><span class=\"line\"></span><br><span class=\"line\">In [<span class=\"number\">68</span>]: <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> res1():       <span class=\"comment\"># 3</span></span><br><span class=\"line\">    ...:     print(<span class=\"string\">'--&gt;'</span>, i)      </span><br><span class=\"line\">    ...:</span><br><span class=\"line\">AAA</span><br><span class=\"line\">BBB</span><br><span class=\"line\"></span><br><span class=\"line\">In [<span class=\"number\">69</span>]: res2 = (x*<span class=\"number\">3</span> <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> gen_AB())  <span class=\"comment\"># 4</span></span><br><span class=\"line\"></span><br><span class=\"line\">In [<span class=\"number\">70</span>]: res2  <span class=\"comment\"># 5</span></span><br><span class=\"line\">&lt;generator object &lt;genexpr&gt; at <span class=\"number\">0x106a07620</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">In [<span class=\"number\">71</span>]: <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> res2():       <span class=\"comment\"># 6</span></span><br><span class=\"line\">    ...:     print(<span class=\"string\">'--&gt;'</span>, i)</span><br><span class=\"line\">    ...:</span><br><span class=\"line\">start   </span><br><span class=\"line\">--&gt; A   </span><br><span class=\"line\"><span class=\"keyword\">continue</span></span><br><span class=\"line\">--&gt; B       </span><br><span class=\"line\">end.</span><br></pre></td></tr></table></figure>\n<ol>\n<li>创建gen_AB函数</li>\n<li>列表推到迫切的迭代gen_AB()函数生成的生成器对象产出的元素：’A’和’B’。注意。下面输出的是start、continue、end.。</li>\n<li>for循环迭代列表推导生成的res1列表</li>\n<li>把生成器表达式返回的值赋值给res2。只需调用gen_AB()函数，虽然调用时会返回一个生成器，但是这里并不使用。</li>\n<li>可以看出res2是一个生成器对象。</li>\n<li>只有for循环迭代res2时，gen_AB函数的定义体才会真正执行。for循环每次迭代时会隐式调用next(res2)，前进到gen_AB函数中的下一个yield语句。注意，gen_AB函数的输出与for循环中print函数的输出夹杂在一起。</li>\n</ol>\n<p>生成器表达式会产出生成器，因此可以使用生成器表达式进一步减少代码量。生成器表达式是一种语法糖，完全可以替换成生成器函数，不过有时候使用生成器表达式更便利。</p>\n<h2 id=\"何时使用生成器表达式\"><a href=\"#何时使用生成器表达式\" class=\"headerlink\" title=\"何时使用生成器表达式\"></a>何时使用生成器表达式</h2><p>生成器表达式是创建生成器的简洁句法，这样无需定义函数再调用。不过，生成器函数灵活的多，可以使用多个语句实现复杂的逻辑，也可以作为<code>协程</code>使用。遇到简单的情况时，可以使用生成器表达式，因为这样扫一眼就知道代码的作用。其实选择那种句法很容易判断：如果生成器表达式需要分行写，倾向于定义成生成器函数，以便提高可读性。此外生成器函数有名称，因此可以重用。</p>"},{"title":"一次完整的HTTP请求流程","date":"2018-03-19T17:34:08.000Z","_content":"\nHTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤：\n\n## 1. 建立TCP连接：\n\n在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，\n\n即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能进行更高层协议的连接，\n\n因此，首先要建立TCP连接，一般TCP连接的端口号是80。\n\n## 2. Web浏览器向Web服务器发送请求命令： \n\n一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET/sample/hello.jsp HTTP/1.1。\n\n## 3. Web浏览器发送请求头信息 ：\n\n浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。\n\n## 4. Web服务器应答 ：\n\n客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。\n\n## 5. Web服务器发送应答头信息： \n\n正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。\n\n## 6. Web服务器向浏览器发送数据： \n\nWeb服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。\n\n## 7. Web服务器关闭TCP连接 ：\n\n一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：Connection:keep-alive；\n\nTCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。\n\n<!-- more -->\n![http请求.jpg](https://upload-images.jianshu.io/upload_images/2952111-d8db37f9da639c61.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n","source":"_posts/一次完整的HTTP请求流程.md","raw":"---\ntitle: 一次完整的HTTP请求流程\ndate: 2018-03-20 01:34:08\ntags:\n  - 网络\ncategories:\n  - 网络\n---\n\nHTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤：\n\n## 1. 建立TCP连接：\n\n在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，\n\n即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能进行更高层协议的连接，\n\n因此，首先要建立TCP连接，一般TCP连接的端口号是80。\n\n## 2. Web浏览器向Web服务器发送请求命令： \n\n一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET/sample/hello.jsp HTTP/1.1。\n\n## 3. Web浏览器发送请求头信息 ：\n\n浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。\n\n## 4. Web服务器应答 ：\n\n客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。\n\n## 5. Web服务器发送应答头信息： \n\n正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。\n\n## 6. Web服务器向浏览器发送数据： \n\nWeb服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。\n\n## 7. Web服务器关闭TCP连接 ：\n\n一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：Connection:keep-alive；\n\nTCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。\n\n<!-- more -->\n![http请求.jpg](https://upload-images.jianshu.io/upload_images/2952111-d8db37f9da639c61.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n","slug":"一次完整的HTTP请求流程","published":1,"updated":"2018-03-19T18:00:53.753Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozmj00588motcpty3qh1","content":"<p>HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤：</p>\n<h2 id=\"1-建立TCP连接：\"><a href=\"#1-建立TCP连接：\" class=\"headerlink\" title=\"1. 建立TCP连接：\"></a>1. 建立TCP连接：</h2><p>在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，</p>\n<p>即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能进行更高层协议的连接，</p>\n<p>因此，首先要建立TCP连接，一般TCP连接的端口号是80。</p>\n<h2 id=\"2-Web浏览器向Web服务器发送请求命令：\"><a href=\"#2-Web浏览器向Web服务器发送请求命令：\" class=\"headerlink\" title=\"2. Web浏览器向Web服务器发送请求命令：\"></a>2. Web浏览器向Web服务器发送请求命令：</h2><p>一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET/sample/hello.jsp HTTP/1.1。</p>\n<h2 id=\"3-Web浏览器发送请求头信息-：\"><a href=\"#3-Web浏览器发送请求头信息-：\" class=\"headerlink\" title=\"3. Web浏览器发送请求头信息 ：\"></a>3. Web浏览器发送请求头信息 ：</h2><p>浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。</p>\n<h2 id=\"4-Web服务器应答-：\"><a href=\"#4-Web服务器应答-：\" class=\"headerlink\" title=\"4. Web服务器应答 ：\"></a>4. Web服务器应答 ：</h2><p>客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。</p>\n<h2 id=\"5-Web服务器发送应答头信息：\"><a href=\"#5-Web服务器发送应答头信息：\" class=\"headerlink\" title=\"5. Web服务器发送应答头信息：\"></a>5. Web服务器发送应答头信息：</h2><p>正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。</p>\n<h2 id=\"6-Web服务器向浏览器发送数据：\"><a href=\"#6-Web服务器向浏览器发送数据：\" class=\"headerlink\" title=\"6. Web服务器向浏览器发送数据：\"></a>6. Web服务器向浏览器发送数据：</h2><p>Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。</p>\n<h2 id=\"7-Web服务器关闭TCP连接-：\"><a href=\"#7-Web服务器关闭TCP连接-：\" class=\"headerlink\" title=\"7. Web服务器关闭TCP连接 ：\"></a>7. Web服务器关闭TCP连接 ：</h2><p>一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：Connection:keep-alive；</p>\n<p>TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p>\n<a id=\"more\"></a>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2952111-d8db37f9da639c61.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"http请求.jpg\"></p>\n","site":{"data":{}},"excerpt":"<p>HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤：</p>\n<h2 id=\"1-建立TCP连接：\"><a href=\"#1-建立TCP连接：\" class=\"headerlink\" title=\"1. 建立TCP连接：\"></a>1. 建立TCP连接：</h2><p>在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，</p>\n<p>即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能进行更高层协议的连接，</p>\n<p>因此，首先要建立TCP连接，一般TCP连接的端口号是80。</p>\n<h2 id=\"2-Web浏览器向Web服务器发送请求命令：\"><a href=\"#2-Web浏览器向Web服务器发送请求命令：\" class=\"headerlink\" title=\"2. Web浏览器向Web服务器发送请求命令：\"></a>2. Web浏览器向Web服务器发送请求命令：</h2><p>一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET/sample/hello.jsp HTTP/1.1。</p>\n<h2 id=\"3-Web浏览器发送请求头信息-：\"><a href=\"#3-Web浏览器发送请求头信息-：\" class=\"headerlink\" title=\"3. Web浏览器发送请求头信息 ：\"></a>3. Web浏览器发送请求头信息 ：</h2><p>浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。</p>\n<h2 id=\"4-Web服务器应答-：\"><a href=\"#4-Web服务器应答-：\" class=\"headerlink\" title=\"4. Web服务器应答 ：\"></a>4. Web服务器应答 ：</h2><p>客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。</p>\n<h2 id=\"5-Web服务器发送应答头信息：\"><a href=\"#5-Web服务器发送应答头信息：\" class=\"headerlink\" title=\"5. Web服务器发送应答头信息：\"></a>5. Web服务器发送应答头信息：</h2><p>正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。</p>\n<h2 id=\"6-Web服务器向浏览器发送数据：\"><a href=\"#6-Web服务器向浏览器发送数据：\" class=\"headerlink\" title=\"6. Web服务器向浏览器发送数据：\"></a>6. Web服务器向浏览器发送数据：</h2><p>Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。</p>\n<h2 id=\"7-Web服务器关闭TCP连接-：\"><a href=\"#7-Web服务器关闭TCP连接-：\" class=\"headerlink\" title=\"7. Web服务器关闭TCP连接 ：\"></a>7. Web服务器关闭TCP连接 ：</h2><p>一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：Connection:keep-alive；</p>\n<p>TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p>","more":"<p><img src=\"https://upload-images.jianshu.io/upload_images/2952111-d8db37f9da639c61.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"http请求.jpg\"></p>"},{"title":"一种Git保留两个repo的commit信息进行合并的方法","date":"2018-02-27T06:46:37.000Z","_content":"\n以往的合并时首先要删除repo的.git文件夹，然后重新add-commit-push。带来的问题是会丢失某一个仓库的提交信息，不利于时光倒退。经过摸索终于实现了保留两个仓库提交信息的合并方法。介绍如下：\n\n<!--more-->\n\n比如要将DownloadPicsBySeleniumAndPhantomJS这个项目合并到Web-Spider中，终端中执行：\n```Bash\n$ git remote add other git@github.com:ByiProX/****.git\n$ git fetch other\n$ git checkout -b repo1 other/mster\n$ git checkout master\n$ git merge repo1 --allow-unrelated-histories\n```\n\n![](http://img.blog.csdn.net/20180213030000117)\n\n接下来解决merge冲突即可（可以尝试使用mergetool），如有需要可以删除多余分支和远程连接\n\n\n```Bash\n$ git mergetool # 解决merge冲突  \n```\n```bash\n\n$ git remote rm other # 删除远程连接  \n$ git branch -d repo1 # 删除分支操作  \n```\n","source":"_posts/一种Git保留两个repo的commit信息进行合并的方法.md","raw":"---\ntitle: 一种Git保留两个repo的commit信息进行合并的方法\ndate: 2018-02-27 14:46:37\ntags:\n  - Git\ncategories:\n  - Git\n\n---\n\n以往的合并时首先要删除repo的.git文件夹，然后重新add-commit-push。带来的问题是会丢失某一个仓库的提交信息，不利于时光倒退。经过摸索终于实现了保留两个仓库提交信息的合并方法。介绍如下：\n\n<!--more-->\n\n比如要将DownloadPicsBySeleniumAndPhantomJS这个项目合并到Web-Spider中，终端中执行：\n```Bash\n$ git remote add other git@github.com:ByiProX/****.git\n$ git fetch other\n$ git checkout -b repo1 other/mster\n$ git checkout master\n$ git merge repo1 --allow-unrelated-histories\n```\n\n![](http://img.blog.csdn.net/20180213030000117)\n\n接下来解决merge冲突即可（可以尝试使用mergetool），如有需要可以删除多余分支和远程连接\n\n\n```Bash\n$ git mergetool # 解决merge冲突  \n```\n```bash\n\n$ git remote rm other # 删除远程连接  \n$ git branch -d repo1 # 删除分支操作  \n```\n","slug":"一种Git保留两个repo的commit信息进行合并的方法","published":1,"updated":"2018-02-27T07:19:42.036Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozmm005b8motouwfxma6","content":"<p>以往的合并时首先要删除repo的.git文件夹，然后重新add-commit-push。带来的问题是会丢失某一个仓库的提交信息，不利于时光倒退。经过摸索终于实现了保留两个仓库提交信息的合并方法。介绍如下：</p>\n<a id=\"more\"></a>\n<p>比如要将DownloadPicsBySeleniumAndPhantomJS这个项目合并到Web-Spider中，终端中执行：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote add other git@github.com:ByiProX/****.git</span><br><span class=\"line\">$ git fetch other</span><br><span class=\"line\">$ git checkout -b repo1 other/mster</span><br><span class=\"line\">$ git checkout master</span><br><span class=\"line\">$ git merge repo1 --allow-unrelated-histories</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://img.blog.csdn.net/20180213030000117\" alt=\"\"></p>\n<p>接下来解决merge冲突即可（可以尝试使用mergetool），如有需要可以删除多余分支和远程连接</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git mergetool <span class=\"comment\"># 解决merge冲突</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">$ git remote rm other <span class=\"comment\"># 删除远程连接  </span></span><br><span class=\"line\">$ git branch -d repo1 <span class=\"comment\"># 删除分支操作</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>以往的合并时首先要删除repo的.git文件夹，然后重新add-commit-push。带来的问题是会丢失某一个仓库的提交信息，不利于时光倒退。经过摸索终于实现了保留两个仓库提交信息的合并方法。介绍如下：</p>","more":"<p>比如要将DownloadPicsBySeleniumAndPhantomJS这个项目合并到Web-Spider中，终端中执行：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git remote add other git@github.com:ByiProX/****.git</span><br><span class=\"line\">$ git fetch other</span><br><span class=\"line\">$ git checkout -b repo1 other/mster</span><br><span class=\"line\">$ git checkout master</span><br><span class=\"line\">$ git merge repo1 --allow-unrelated-histories</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"http://img.blog.csdn.net/20180213030000117\" alt=\"\"></p>\n<p>接下来解决merge冲突即可（可以尝试使用mergetool），如有需要可以删除多余分支和远程连接</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git mergetool <span class=\"comment\"># 解决merge冲突</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">$ git remote rm other <span class=\"comment\"># 删除远程连接  </span></span><br><span class=\"line\">$ git branch -d repo1 <span class=\"comment\"># 删除分支操作</span></span><br></pre></td></tr></table></figure>"},{"title":"三次握手 | 四次挥手","date":"2018-03-19T15:30:52.000Z","_content":"## 三次握手\n**第一次握手**\n\n建立连接时，客户端发送`syn包（syn=j）`到服务器，并进入SYN_SENT状态，等待服务器确认；\nSYN即`同步序列编号`(synchronize sequence numbers)。\n\n**第二次握手**\n\n服务器收到`syn包`，必须确认客户的SYN（ack = j+1）,同时自己也发送一个SYN包（syn=k），即发`送SYN和ACK包`，此时服务器进入`SYN_RECV`状态。\n\n\n**第三次握手**\n\n客户端收到服务器的`SYN+ACK包`，向服务器发送确认`包ACK（ack=k+1）`，此包发送完毕，客户端和服务器进入`ESTABLISHED`状态，TCP连接成功，完成三次握手。\n\n完成上述三次握手后，客户端和服务器开始传送数据。\n\n\n## 四次挥手\n对于一个已经建立的连接，TCP使用改进的三次握手来释放连接（使用一个带有FIN附加标记的字段）。TCP关闭连接的步骤如下\n\n1. 当主机A的应用程序通知TCP数据已经发送完毕时，TCP向主机B发送一个带有FIN附加标记的报文段（FIN=finish）\n2. 当主机B收到这个FIN报文段之后，并不立即用FIN报文回复主机A，而是想主机A发送一个确认序号ACK，同时通知自己的应用程序：对方要求关闭连接。【先发送ACK的目的是为了防止在这段时间内，对方重传FIN报文】\n3. 主机B的应用程序告诉TCP：我要彻底关闭连接，TCP向主机A发送一个FIN报文段。\n4. 主机A收到这个FIN报文段后，向主机B发送一个ACK表示连接彻底释放。\n","source":"_posts/三次握手 | 四次挥手.md","raw":"---\ntitle: 三次握手 | 四次挥手\ndate: 2018-03-19 23:30:52\ntags:\n  - 网络\ncategories:\n  - 网络\n---\n## 三次握手\n**第一次握手**\n\n建立连接时，客户端发送`syn包（syn=j）`到服务器，并进入SYN_SENT状态，等待服务器确认；\nSYN即`同步序列编号`(synchronize sequence numbers)。\n\n**第二次握手**\n\n服务器收到`syn包`，必须确认客户的SYN（ack = j+1）,同时自己也发送一个SYN包（syn=k），即发`送SYN和ACK包`，此时服务器进入`SYN_RECV`状态。\n\n\n**第三次握手**\n\n客户端收到服务器的`SYN+ACK包`，向服务器发送确认`包ACK（ack=k+1）`，此包发送完毕，客户端和服务器进入`ESTABLISHED`状态，TCP连接成功，完成三次握手。\n\n完成上述三次握手后，客户端和服务器开始传送数据。\n\n\n## 四次挥手\n对于一个已经建立的连接，TCP使用改进的三次握手来释放连接（使用一个带有FIN附加标记的字段）。TCP关闭连接的步骤如下\n\n1. 当主机A的应用程序通知TCP数据已经发送完毕时，TCP向主机B发送一个带有FIN附加标记的报文段（FIN=finish）\n2. 当主机B收到这个FIN报文段之后，并不立即用FIN报文回复主机A，而是想主机A发送一个确认序号ACK，同时通知自己的应用程序：对方要求关闭连接。【先发送ACK的目的是为了防止在这段时间内，对方重传FIN报文】\n3. 主机B的应用程序告诉TCP：我要彻底关闭连接，TCP向主机A发送一个FIN报文段。\n4. 主机A收到这个FIN报文段后，向主机B发送一个ACK表示连接彻底释放。\n","slug":"三次握手 | 四次挥手","published":1,"updated":"2018-03-19T16:01:53.251Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozmo005g8motcbu4u0fv","content":"<h2 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h2><p><strong>第一次握手</strong></p>\n<p>建立连接时，客户端发送<code>syn包（syn=j）</code>到服务器，并进入SYN_SENT状态，等待服务器确认；<br>SYN即<code>同步序列编号</code>(synchronize sequence numbers)。</p>\n<p><strong>第二次握手</strong></p>\n<p>服务器收到<code>syn包</code>，必须确认客户的SYN（ack = j+1）,同时自己也发送一个SYN包（syn=k），即发<code>送SYN和ACK包</code>，此时服务器进入<code>SYN_RECV</code>状态。</p>\n<p><strong>第三次握手</strong></p>\n<p>客户端收到服务器的<code>SYN+ACK包</code>，向服务器发送确认<code>包ACK（ack=k+1）</code>，此包发送完毕，客户端和服务器进入<code>ESTABLISHED</code>状态，TCP连接成功，完成三次握手。</p>\n<p>完成上述三次握手后，客户端和服务器开始传送数据。</p>\n<h2 id=\"四次挥手\"><a href=\"#四次挥手\" class=\"headerlink\" title=\"四次挥手\"></a>四次挥手</h2><p>对于一个已经建立的连接，TCP使用改进的三次握手来释放连接（使用一个带有FIN附加标记的字段）。TCP关闭连接的步骤如下</p>\n<ol>\n<li>当主机A的应用程序通知TCP数据已经发送完毕时，TCP向主机B发送一个带有FIN附加标记的报文段（FIN=finish）</li>\n<li>当主机B收到这个FIN报文段之后，并不立即用FIN报文回复主机A，而是想主机A发送一个确认序号ACK，同时通知自己的应用程序：对方要求关闭连接。【先发送ACK的目的是为了防止在这段时间内，对方重传FIN报文】</li>\n<li>主机B的应用程序告诉TCP：我要彻底关闭连接，TCP向主机A发送一个FIN报文段。</li>\n<li>主机A收到这个FIN报文段后，向主机B发送一个ACK表示连接彻底释放。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h2><p><strong>第一次握手</strong></p>\n<p>建立连接时，客户端发送<code>syn包（syn=j）</code>到服务器，并进入SYN_SENT状态，等待服务器确认；<br>SYN即<code>同步序列编号</code>(synchronize sequence numbers)。</p>\n<p><strong>第二次握手</strong></p>\n<p>服务器收到<code>syn包</code>，必须确认客户的SYN（ack = j+1）,同时自己也发送一个SYN包（syn=k），即发<code>送SYN和ACK包</code>，此时服务器进入<code>SYN_RECV</code>状态。</p>\n<p><strong>第三次握手</strong></p>\n<p>客户端收到服务器的<code>SYN+ACK包</code>，向服务器发送确认<code>包ACK（ack=k+1）</code>，此包发送完毕，客户端和服务器进入<code>ESTABLISHED</code>状态，TCP连接成功，完成三次握手。</p>\n<p>完成上述三次握手后，客户端和服务器开始传送数据。</p>\n<h2 id=\"四次挥手\"><a href=\"#四次挥手\" class=\"headerlink\" title=\"四次挥手\"></a>四次挥手</h2><p>对于一个已经建立的连接，TCP使用改进的三次握手来释放连接（使用一个带有FIN附加标记的字段）。TCP关闭连接的步骤如下</p>\n<ol>\n<li>当主机A的应用程序通知TCP数据已经发送完毕时，TCP向主机B发送一个带有FIN附加标记的报文段（FIN=finish）</li>\n<li>当主机B收到这个FIN报文段之后，并不立即用FIN报文回复主机A，而是想主机A发送一个确认序号ACK，同时通知自己的应用程序：对方要求关闭连接。【先发送ACK的目的是为了防止在这段时间内，对方重传FIN报文】</li>\n<li>主机B的应用程序告诉TCP：我要彻底关闭连接，TCP向主机A发送一个FIN报文段。</li>\n<li>主机A收到这个FIN报文段后，向主机B发送一个ACK表示连接彻底释放。</li>\n</ol>\n"},{"title":"三种多路复用IO实现方式：select，poll，epoll","date":"2018-03-07T07:43:44.000Z","_content":"\nselect，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。\n\n在linux 没有实现epoll事件驱动机制之前，我们一般选择用select或者poll等IO多路复用的方法来实现并发服务程序。在大数据、高并发、集群等一些名词唱得火热之年代，select和poll的用武之地越来越有限，风头已经被epoll占尽。\n\n简单来讲\nselect有3个缺点:\n\n1. 连接数受限\n2. 查找配对速度慢\n3. 数据由内核拷贝到用户态\n\npoll改善了第一个缺点\nepoll改了三个缺点.\n\n<!-- more -->\n## 使用场景\n\nIO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合：\n\n1. 当客户处理多个描述符时（一般是交互式输入和网络套接口），必须使用I/O复用。\n\n2. 当一个客户同时处理多个套接口时，这种情况是可能的，但很少出现。\n\n3. 如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。\n\n4. 如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。\n\n5. 如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。\n\n\n## select、poll、epoll简介\n\n### select\n\n**基本原理：**select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。\n\n**基本流程，如图所示：**\n\n**![](https://images2015.cnblogs.com/blog/667911/201604/667911-20160426172125064-1263315531.png)**\n\n \n\n　　select目前几乎在所有的平台上支持，`其良好跨平台支持也是它的一个优点`。`select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制`，在Linux上一般为1024，`可以通过修改宏定义甚至重新编译内核的方式提升这一限制`，但是这样也会造成效率的降低。\n\n \n\n`select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理`。这样所带来的缺点是：\n\n1、select最大的缺陷就是单个进程所打开的FD是有一定限制的，它由FD_SETSIZE设置，默认值是1024。\n\n　　一般来说这个数目和系统内存关系很大，`具体数目可以cat /proc/sys/fs/file-max察看`。32位机默认是1024个。64位机默认是2048.\n\n2、对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低。\n\n　　当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。这会浪费很多CPU时间。`如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询`，这正是epoll与kqueue做的。\n\n`3、需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。`\n\n \n### poll\n\n**基本原理：**`poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间`，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。\n\n**它没有最大连接数的限制，`原因是它是基于链表来存储的`，但是同样有一个缺点：**\n\n`1）大量的fd的数组被整体复制于用户态和内核地址空间之间`，而不管这样的复制是不是有意义。\n\n`2）poll还有一个特点是“水平触发”`，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。\n\n**注意：**从上面看，select和poll都需要在返回后，`通过遍历文件描述符来获取已经就绪的socket`。事实上，`同时连接的大量客户端在一时刻可能只有很少的处于就绪状态`，因此随着监视的描述符数量的增长，其效率也会线性下降。\n\n### epoll\n\n　　epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。`epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次`。\n\n \n\n**基本原理：**`epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次`。还有一个特点是，`epoll使用“事件”的就绪通知方式`，通过epoll_ctl注册fd，`一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd`，epoll_wait便可以收到通知。\n\n\n**epoll的优点：**\n\n`1、没有最大并发连接的限制`，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。\n\n`2、效率提升，不是轮询的方式，不会随着FD数目的增加效率下降`。\n\n　　只有活跃可用的FD才会调用callback函数；`即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关`，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。\n\n`3、内存拷贝`，利用mmap()文件映射内存加速与内核空间的消息传递；`即epoll使用mmap减少复制开销`。\n\n\nepoll对文件描述符的操作有两种模式：`LT（level trigger）和ET（edge trigger）`。LT模式是默认模式，LT模式与ET模式的区别如下：\n\nLT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，`应用程序可以不立即处理该事件`。下次调用epoll_wait时，会再次响应应用程序并通知此事件。\n\nET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，`应用程序必须立即处理该事件`。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。\n\n\n## select、poll、epoll对比\n### **1、支持一个进程所能打开的最大连接数**\n\n![](https://images2015.cnblogs.com/blog/667911/201604/667911-20160426172727142-152295964.png)\n\n### **2、FD剧增后带来的IO效率问题**\n\n![](https://images2015.cnblogs.com/blog/667911/201604/667911-20160426173035611-62395960.png)\n\n### **3、消息传递方式**\n\n![](https://images2015.cnblogs.com/blog/667911/201604/667911-20160426172915283-1257843409.png)\n\n\n综上，在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点：\n\n1、表面上看epoll的性能最好，`但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好`，毕竟epoll的通知机制需要很多函数回调。\n\n`2、select低效是因为每次它都需要轮询`。但低效也是相对的，视情况而定，也可通过良好的设计改善。\n\n\n## 参考\n1. https://www.cnblogs.com/jeakeven/p/5435916.html\n2. http://blog.csdn.net/davidsguo008/article/details/73556811\n3. https://www.cnblogs.com/wangyufu/p/6593515.html\n","source":"_posts/三种多路复用IO实现方式：select，poll，epoll.md","raw":"---\ntitle: 三种多路复用IO实现方式：select，poll，epoll\ndate: 2018-03-07 15:43:44\ntags:\n  - 操作系统\ncategories:\n  - 操作系统\n  - 多任务处理\n---\n\nselect，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。\n\n在linux 没有实现epoll事件驱动机制之前，我们一般选择用select或者poll等IO多路复用的方法来实现并发服务程序。在大数据、高并发、集群等一些名词唱得火热之年代，select和poll的用武之地越来越有限，风头已经被epoll占尽。\n\n简单来讲\nselect有3个缺点:\n\n1. 连接数受限\n2. 查找配对速度慢\n3. 数据由内核拷贝到用户态\n\npoll改善了第一个缺点\nepoll改了三个缺点.\n\n<!-- more -->\n## 使用场景\n\nIO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合：\n\n1. 当客户处理多个描述符时（一般是交互式输入和网络套接口），必须使用I/O复用。\n\n2. 当一个客户同时处理多个套接口时，这种情况是可能的，但很少出现。\n\n3. 如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。\n\n4. 如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。\n\n5. 如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。\n\n\n## select、poll、epoll简介\n\n### select\n\n**基本原理：**select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。\n\n**基本流程，如图所示：**\n\n**![](https://images2015.cnblogs.com/blog/667911/201604/667911-20160426172125064-1263315531.png)**\n\n \n\n　　select目前几乎在所有的平台上支持，`其良好跨平台支持也是它的一个优点`。`select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制`，在Linux上一般为1024，`可以通过修改宏定义甚至重新编译内核的方式提升这一限制`，但是这样也会造成效率的降低。\n\n \n\n`select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理`。这样所带来的缺点是：\n\n1、select最大的缺陷就是单个进程所打开的FD是有一定限制的，它由FD_SETSIZE设置，默认值是1024。\n\n　　一般来说这个数目和系统内存关系很大，`具体数目可以cat /proc/sys/fs/file-max察看`。32位机默认是1024个。64位机默认是2048.\n\n2、对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低。\n\n　　当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。这会浪费很多CPU时间。`如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询`，这正是epoll与kqueue做的。\n\n`3、需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。`\n\n \n### poll\n\n**基本原理：**`poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间`，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。\n\n**它没有最大连接数的限制，`原因是它是基于链表来存储的`，但是同样有一个缺点：**\n\n`1）大量的fd的数组被整体复制于用户态和内核地址空间之间`，而不管这样的复制是不是有意义。\n\n`2）poll还有一个特点是“水平触发”`，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。\n\n**注意：**从上面看，select和poll都需要在返回后，`通过遍历文件描述符来获取已经就绪的socket`。事实上，`同时连接的大量客户端在一时刻可能只有很少的处于就绪状态`，因此随着监视的描述符数量的增长，其效率也会线性下降。\n\n### epoll\n\n　　epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。`epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次`。\n\n \n\n**基本原理：**`epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次`。还有一个特点是，`epoll使用“事件”的就绪通知方式`，通过epoll_ctl注册fd，`一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd`，epoll_wait便可以收到通知。\n\n\n**epoll的优点：**\n\n`1、没有最大并发连接的限制`，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。\n\n`2、效率提升，不是轮询的方式，不会随着FD数目的增加效率下降`。\n\n　　只有活跃可用的FD才会调用callback函数；`即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关`，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。\n\n`3、内存拷贝`，利用mmap()文件映射内存加速与内核空间的消息传递；`即epoll使用mmap减少复制开销`。\n\n\nepoll对文件描述符的操作有两种模式：`LT（level trigger）和ET（edge trigger）`。LT模式是默认模式，LT模式与ET模式的区别如下：\n\nLT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，`应用程序可以不立即处理该事件`。下次调用epoll_wait时，会再次响应应用程序并通知此事件。\n\nET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，`应用程序必须立即处理该事件`。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。\n\n\n## select、poll、epoll对比\n### **1、支持一个进程所能打开的最大连接数**\n\n![](https://images2015.cnblogs.com/blog/667911/201604/667911-20160426172727142-152295964.png)\n\n### **2、FD剧增后带来的IO效率问题**\n\n![](https://images2015.cnblogs.com/blog/667911/201604/667911-20160426173035611-62395960.png)\n\n### **3、消息传递方式**\n\n![](https://images2015.cnblogs.com/blog/667911/201604/667911-20160426172915283-1257843409.png)\n\n\n综上，在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点：\n\n1、表面上看epoll的性能最好，`但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好`，毕竟epoll的通知机制需要很多函数回调。\n\n`2、select低效是因为每次它都需要轮询`。但低效也是相对的，视情况而定，也可通过良好的设计改善。\n\n\n## 参考\n1. https://www.cnblogs.com/jeakeven/p/5435916.html\n2. http://blog.csdn.net/davidsguo008/article/details/73556811\n3. https://www.cnblogs.com/wangyufu/p/6593515.html\n","slug":"三种多路复用IO实现方式：select，poll，epoll","published":1,"updated":"2018-03-07T10:40:20.981Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozmq005j8motcuxlvndo","content":"<p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p>\n<p>在linux 没有实现epoll事件驱动机制之前，我们一般选择用select或者poll等IO多路复用的方法来实现并发服务程序。在大数据、高并发、集群等一些名词唱得火热之年代，select和poll的用武之地越来越有限，风头已经被epoll占尽。</p>\n<p>简单来讲<br>select有3个缺点:</p>\n<ol>\n<li>连接数受限</li>\n<li>查找配对速度慢</li>\n<li>数据由内核拷贝到用户态</li>\n</ol>\n<p>poll改善了第一个缺点<br>epoll改了三个缺点.</p>\n<a id=\"more\"></a>\n<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><p>IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合：</p>\n<ol>\n<li><p>当客户处理多个描述符时（一般是交互式输入和网络套接口），必须使用I/O复用。</p>\n</li>\n<li><p>当一个客户同时处理多个套接口时，这种情况是可能的，但很少出现。</p>\n</li>\n<li><p>如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。</p>\n</li>\n<li><p>如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。</p>\n</li>\n<li><p>如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。</p>\n</li>\n</ol>\n<h2 id=\"select、poll、epoll简介\"><a href=\"#select、poll、epoll简介\" class=\"headerlink\" title=\"select、poll、epoll简介\"></a>select、poll、epoll简介</h2><h3 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select\"></a>select</h3><p><strong>基本原理：</strong>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</p>\n<p><strong>基本流程，如图所示：</strong></p>\n<p><strong><img src=\"https://images2015.cnblogs.com/blog/667911/201604/667911-20160426172125064-1263315531.png\" alt=\"\"></strong></p>\n<p>　　select目前几乎在所有的平台上支持，<code>其良好跨平台支持也是它的一个优点</code>。<code>select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制</code>，在Linux上一般为1024，<code>可以通过修改宏定义甚至重新编译内核的方式提升这一限制</code>，但是这样也会造成效率的降低。</p>\n<p><code>select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理</code>。这样所带来的缺点是：</p>\n<p>1、select最大的缺陷就是单个进程所打开的FD是有一定限制的，它由FD_SETSIZE设置，默认值是1024。</p>\n<p>　　一般来说这个数目和系统内存关系很大，<code>具体数目可以cat /proc/sys/fs/file-max察看</code>。32位机默认是1024个。64位机默认是2048.</p>\n<p>2、对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低。</p>\n<p>　　当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。这会浪费很多CPU时间。<code>如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询</code>，这正是epoll与kqueue做的。</p>\n<p><code>3、需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。</code></p>\n<h3 id=\"poll\"><a href=\"#poll\" class=\"headerlink\" title=\"poll\"></a>poll</h3><p><strong>基本原理：</strong><code>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间</code>，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。</p>\n<p><strong>它没有最大连接数的限制，<code>原因是它是基于链表来存储的</code>，但是同样有一个缺点：</strong></p>\n<p><code>1）大量的fd的数组被整体复制于用户态和内核地址空间之间</code>，而不管这样的复制是不是有意义。</p>\n<p><code>2）poll还有一个特点是“水平触发”</code>，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</p>\n<p><strong>注意：</strong>从上面看，select和poll都需要在返回后，<code>通过遍历文件描述符来获取已经就绪的socket</code>。事实上，<code>同时连接的大量客户端在一时刻可能只有很少的处于就绪状态</code>，因此随着监视的描述符数量的增长，其效率也会线性下降。</p>\n<h3 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll\"></a>epoll</h3><p>　　epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。<code>epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次</code>。</p>\n<p><strong>基本原理：</strong><code>epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次</code>。还有一个特点是，<code>epoll使用“事件”的就绪通知方式</code>，通过epoll_ctl注册fd，<code>一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd</code>，epoll_wait便可以收到通知。</p>\n<p><strong>epoll的优点：</strong></p>\n<p><code>1、没有最大并发连接的限制</code>，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。</p>\n<p><code>2、效率提升，不是轮询的方式，不会随着FD数目的增加效率下降</code>。</p>\n<p>　　只有活跃可用的FD才会调用callback函数；<code>即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关</code>，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</p>\n<p><code>3、内存拷贝</code>，利用mmap()文件映射内存加速与内核空间的消息传递；<code>即epoll使用mmap减少复制开销</code>。</p>\n<p>epoll对文件描述符的操作有两种模式：<code>LT（level trigger）和ET（edge trigger）</code>。LT模式是默认模式，LT模式与ET模式的区别如下：</p>\n<p>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序可以不立即处理该事件</code>。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</p>\n<p>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序必须立即处理该事件</code>。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p>\n<h2 id=\"select、poll、epoll对比\"><a href=\"#select、poll、epoll对比\" class=\"headerlink\" title=\"select、poll、epoll对比\"></a>select、poll、epoll对比</h2><h3 id=\"1、支持一个进程所能打开的最大连接数\"><a href=\"#1、支持一个进程所能打开的最大连接数\" class=\"headerlink\" title=\"1、支持一个进程所能打开的最大连接数\"></a><strong>1、支持一个进程所能打开的最大连接数</strong></h3><p><img src=\"https://images2015.cnblogs.com/blog/667911/201604/667911-20160426172727142-152295964.png\" alt=\"\"></p>\n<h3 id=\"2、FD剧增后带来的IO效率问题\"><a href=\"#2、FD剧增后带来的IO效率问题\" class=\"headerlink\" title=\"2、FD剧增后带来的IO效率问题\"></a><strong>2、FD剧增后带来的IO效率问题</strong></h3><p><img src=\"https://images2015.cnblogs.com/blog/667911/201604/667911-20160426173035611-62395960.png\" alt=\"\"></p>\n<h3 id=\"3、消息传递方式\"><a href=\"#3、消息传递方式\" class=\"headerlink\" title=\"3、消息传递方式\"></a><strong>3、消息传递方式</strong></h3><p><img src=\"https://images2015.cnblogs.com/blog/667911/201604/667911-20160426172915283-1257843409.png\" alt=\"\"></p>\n<p>综上，在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点：</p>\n<p>1、表面上看epoll的性能最好，<code>但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好</code>，毕竟epoll的通知机制需要很多函数回调。</p>\n<p><code>2、select低效是因为每次它都需要轮询</code>。但低效也是相对的，视情况而定，也可通过良好的设计改善。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://www.cnblogs.com/jeakeven/p/5435916.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/jeakeven/p/5435916.html</a></li>\n<li><a href=\"http://blog.csdn.net/davidsguo008/article/details/73556811\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/davidsguo008/article/details/73556811</a></li>\n<li><a href=\"https://www.cnblogs.com/wangyufu/p/6593515.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/wangyufu/p/6593515.html</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p>\n<p>在linux 没有实现epoll事件驱动机制之前，我们一般选择用select或者poll等IO多路复用的方法来实现并发服务程序。在大数据、高并发、集群等一些名词唱得火热之年代，select和poll的用武之地越来越有限，风头已经被epoll占尽。</p>\n<p>简单来讲<br>select有3个缺点:</p>\n<ol>\n<li>连接数受限</li>\n<li>查找配对速度慢</li>\n<li>数据由内核拷贝到用户态</li>\n</ol>\n<p>poll改善了第一个缺点<br>epoll改了三个缺点.</p>","more":"<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><p>IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合：</p>\n<ol>\n<li><p>当客户处理多个描述符时（一般是交互式输入和网络套接口），必须使用I/O复用。</p>\n</li>\n<li><p>当一个客户同时处理多个套接口时，这种情况是可能的，但很少出现。</p>\n</li>\n<li><p>如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。</p>\n</li>\n<li><p>如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。</p>\n</li>\n<li><p>如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。</p>\n</li>\n</ol>\n<h2 id=\"select、poll、epoll简介\"><a href=\"#select、poll、epoll简介\" class=\"headerlink\" title=\"select、poll、epoll简介\"></a>select、poll、epoll简介</h2><h3 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select\"></a>select</h3><p><strong>基本原理：</strong>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</p>\n<p><strong>基本流程，如图所示：</strong></p>\n<p><strong><img src=\"https://images2015.cnblogs.com/blog/667911/201604/667911-20160426172125064-1263315531.png\" alt=\"\"></strong></p>\n<p>　　select目前几乎在所有的平台上支持，<code>其良好跨平台支持也是它的一个优点</code>。<code>select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制</code>，在Linux上一般为1024，<code>可以通过修改宏定义甚至重新编译内核的方式提升这一限制</code>，但是这样也会造成效率的降低。</p>\n<p><code>select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理</code>。这样所带来的缺点是：</p>\n<p>1、select最大的缺陷就是单个进程所打开的FD是有一定限制的，它由FD_SETSIZE设置，默认值是1024。</p>\n<p>　　一般来说这个数目和系统内存关系很大，<code>具体数目可以cat /proc/sys/fs/file-max察看</code>。32位机默认是1024个。64位机默认是2048.</p>\n<p>2、对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低。</p>\n<p>　　当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。这会浪费很多CPU时间。<code>如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询</code>，这正是epoll与kqueue做的。</p>\n<p><code>3、需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。</code></p>\n<h3 id=\"poll\"><a href=\"#poll\" class=\"headerlink\" title=\"poll\"></a>poll</h3><p><strong>基本原理：</strong><code>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间</code>，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。</p>\n<p><strong>它没有最大连接数的限制，<code>原因是它是基于链表来存储的</code>，但是同样有一个缺点：</strong></p>\n<p><code>1）大量的fd的数组被整体复制于用户态和内核地址空间之间</code>，而不管这样的复制是不是有意义。</p>\n<p><code>2）poll还有一个特点是“水平触发”</code>，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</p>\n<p><strong>注意：</strong>从上面看，select和poll都需要在返回后，<code>通过遍历文件描述符来获取已经就绪的socket</code>。事实上，<code>同时连接的大量客户端在一时刻可能只有很少的处于就绪状态</code>，因此随着监视的描述符数量的增长，其效率也会线性下降。</p>\n<h3 id=\"epoll\"><a href=\"#epoll\" class=\"headerlink\" title=\"epoll\"></a>epoll</h3><p>　　epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。<code>epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次</code>。</p>\n<p><strong>基本原理：</strong><code>epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次</code>。还有一个特点是，<code>epoll使用“事件”的就绪通知方式</code>，通过epoll_ctl注册fd，<code>一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd</code>，epoll_wait便可以收到通知。</p>\n<p><strong>epoll的优点：</strong></p>\n<p><code>1、没有最大并发连接的限制</code>，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。</p>\n<p><code>2、效率提升，不是轮询的方式，不会随着FD数目的增加效率下降</code>。</p>\n<p>　　只有活跃可用的FD才会调用callback函数；<code>即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关</code>，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</p>\n<p><code>3、内存拷贝</code>，利用mmap()文件映射内存加速与内核空间的消息传递；<code>即epoll使用mmap减少复制开销</code>。</p>\n<p>epoll对文件描述符的操作有两种模式：<code>LT（level trigger）和ET（edge trigger）</code>。LT模式是默认模式，LT模式与ET模式的区别如下：</p>\n<p>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序可以不立即处理该事件</code>。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</p>\n<p>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序必须立即处理该事件</code>。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p>\n<h2 id=\"select、poll、epoll对比\"><a href=\"#select、poll、epoll对比\" class=\"headerlink\" title=\"select、poll、epoll对比\"></a>select、poll、epoll对比</h2><h3 id=\"1、支持一个进程所能打开的最大连接数\"><a href=\"#1、支持一个进程所能打开的最大连接数\" class=\"headerlink\" title=\"1、支持一个进程所能打开的最大连接数\"></a><strong>1、支持一个进程所能打开的最大连接数</strong></h3><p><img src=\"https://images2015.cnblogs.com/blog/667911/201604/667911-20160426172727142-152295964.png\" alt=\"\"></p>\n<h3 id=\"2、FD剧增后带来的IO效率问题\"><a href=\"#2、FD剧增后带来的IO效率问题\" class=\"headerlink\" title=\"2、FD剧增后带来的IO效率问题\"></a><strong>2、FD剧增后带来的IO效率问题</strong></h3><p><img src=\"https://images2015.cnblogs.com/blog/667911/201604/667911-20160426173035611-62395960.png\" alt=\"\"></p>\n<h3 id=\"3、消息传递方式\"><a href=\"#3、消息传递方式\" class=\"headerlink\" title=\"3、消息传递方式\"></a><strong>3、消息传递方式</strong></h3><p><img src=\"https://images2015.cnblogs.com/blog/667911/201604/667911-20160426172915283-1257843409.png\" alt=\"\"></p>\n<p>综上，在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点：</p>\n<p>1、表面上看epoll的性能最好，<code>但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好</code>，毕竟epoll的通知机制需要很多函数回调。</p>\n<p><code>2、select低效是因为每次它都需要轮询</code>。但低效也是相对的，视情况而定，也可通过良好的设计改善。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://www.cnblogs.com/jeakeven/p/5435916.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/jeakeven/p/5435916.html</a></li>\n<li><a href=\"http://blog.csdn.net/davidsguo008/article/details/73556811\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/davidsguo008/article/details/73556811</a></li>\n<li><a href=\"https://www.cnblogs.com/wangyufu/p/6593515.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/wangyufu/p/6593515.html</a></li>\n</ol>"},{"title":"什么是Socket(转)","date":"2018-03-12T16:49:26.000Z","_content":"对TCP/IP、UDP、Socket编程这些词你不会很陌生吧？随着网络技术的发展，这些词充斥着我们的耳朵。那么我想问：\n1. 什么是TCP/IP、UDP？\n2. Socket在哪里呢？\n3. Socket是什么呢？\n4. 你会使用它们吗？\n\n## 什么是TCP/IP、UDP\n\nTCP/IP（Transmission Control Protocol/Internet Protocol）即传输控制协议/网间协议，是一个工业标准的协议集，它是为广域网（WANs）设计的。\nUDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是属于TCP/IP协议族中的一种。\n\n![1.jpg](https://upload-images.jianshu.io/upload_images/2952111-571c60b933d42028.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n<!-- more -->\nTCP/IP协议族包括运输层、网络层、链路层。由上图可以知道TCP/IP与UDP的关系。\n\n## Socket在哪里\n![2.jpg](https://upload-images.jianshu.io/upload_images/2952111-1dd2ce6b61d08816.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## Socket是什么\nSocket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。\n\n## 如何使用\n前人已经给我们做了好多的事了，网络间的通信也就简单了许多，但毕竟还是有挺多工作要做的。以前听到Socket编程，觉得它是比较高深的编程知识，但是只要弄清Socket编程的工作原理，神秘的面纱也就揭开了。\n一个生活中的场景。你要打电话给一个朋友，先拨号，朋友听到电话铃声后提起电话，这时你和你的朋友就建立起了连接，就可以讲话了。等交流结束，挂断电话结束此次交谈。    \n生活中的场景就解释了这工作原理，也许TCP/IP协议族就是诞生于生活中，这也不一定。\n\n![3.jpg](https://upload-images.jianshu.io/upload_images/2952111-99ebc49204f5b380.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n先从服务器端说起。服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。\n\n在这里我就举个简单的例子，我们走的是TCP协议这条路（见图2）。例子用MFC编写，运行的界面如下：\n\n\n![4.jpg](https://upload-images.jianshu.io/upload_images/2952111-36073682cf397e4f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![5.jpg](https://upload-images.jianshu.io/upload_images/2952111-61b92a5dbbb8bf69.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n在客户端输入服务器端的IP地址和发送的数据，然后按发送按钮，服务器端接收到数据，然后回应客户端。客户端读取回应的数据，显示在界面上。\n\n客户端就一个函数完成了一次通信。在这里IP地址为何用127.0.0.1呢？使用这个IP地址，服务器端和客户端就能运行在同一台机器上，这样调试方便多了。当然你可以在你朋友的机器上运行Server程序(本人在局域网中测试过)，在自己的机器上运行Client程序，当然输入的IP地址就该是你朋友机器的IP地址了。\n\n## 参考\n1. http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml\n","source":"_posts/什么是Socket-转.md","raw":"---\ntitle: 什么是Socket(转)\ndate: 2018-03-13 00:49:26\ntags:\n  - 网络\ncategories:\n  - 网络\n---\n对TCP/IP、UDP、Socket编程这些词你不会很陌生吧？随着网络技术的发展，这些词充斥着我们的耳朵。那么我想问：\n1. 什么是TCP/IP、UDP？\n2. Socket在哪里呢？\n3. Socket是什么呢？\n4. 你会使用它们吗？\n\n## 什么是TCP/IP、UDP\n\nTCP/IP（Transmission Control Protocol/Internet Protocol）即传输控制协议/网间协议，是一个工业标准的协议集，它是为广域网（WANs）设计的。\nUDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是属于TCP/IP协议族中的一种。\n\n![1.jpg](https://upload-images.jianshu.io/upload_images/2952111-571c60b933d42028.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n<!-- more -->\nTCP/IP协议族包括运输层、网络层、链路层。由上图可以知道TCP/IP与UDP的关系。\n\n## Socket在哪里\n![2.jpg](https://upload-images.jianshu.io/upload_images/2952111-1dd2ce6b61d08816.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## Socket是什么\nSocket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。\n\n## 如何使用\n前人已经给我们做了好多的事了，网络间的通信也就简单了许多，但毕竟还是有挺多工作要做的。以前听到Socket编程，觉得它是比较高深的编程知识，但是只要弄清Socket编程的工作原理，神秘的面纱也就揭开了。\n一个生活中的场景。你要打电话给一个朋友，先拨号，朋友听到电话铃声后提起电话，这时你和你的朋友就建立起了连接，就可以讲话了。等交流结束，挂断电话结束此次交谈。    \n生活中的场景就解释了这工作原理，也许TCP/IP协议族就是诞生于生活中，这也不一定。\n\n![3.jpg](https://upload-images.jianshu.io/upload_images/2952111-99ebc49204f5b380.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n先从服务器端说起。服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。\n\n在这里我就举个简单的例子，我们走的是TCP协议这条路（见图2）。例子用MFC编写，运行的界面如下：\n\n\n![4.jpg](https://upload-images.jianshu.io/upload_images/2952111-36073682cf397e4f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![5.jpg](https://upload-images.jianshu.io/upload_images/2952111-61b92a5dbbb8bf69.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n在客户端输入服务器端的IP地址和发送的数据，然后按发送按钮，服务器端接收到数据，然后回应客户端。客户端读取回应的数据，显示在界面上。\n\n客户端就一个函数完成了一次通信。在这里IP地址为何用127.0.0.1呢？使用这个IP地址，服务器端和客户端就能运行在同一台机器上，这样调试方便多了。当然你可以在你朋友的机器上运行Server程序(本人在局域网中测试过)，在自己的机器上运行Client程序，当然输入的IP地址就该是你朋友机器的IP地址了。\n\n## 参考\n1. http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml\n","slug":"什么是Socket-转","published":1,"updated":"2018-03-12T17:03:47.890Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozmt005o8mots35911q9","content":"<p>对TCP/IP、UDP、Socket编程这些词你不会很陌生吧？随着网络技术的发展，这些词充斥着我们的耳朵。那么我想问：</p>\n<ol>\n<li>什么是TCP/IP、UDP？</li>\n<li>Socket在哪里呢？</li>\n<li>Socket是什么呢？</li>\n<li>你会使用它们吗？</li>\n</ol>\n<h2 id=\"什么是TCP-IP、UDP\"><a href=\"#什么是TCP-IP、UDP\" class=\"headerlink\" title=\"什么是TCP/IP、UDP\"></a>什么是TCP/IP、UDP</h2><p>TCP/IP（Transmission Control Protocol/Internet Protocol）即传输控制协议/网间协议，是一个工业标准的协议集，它是为广域网（WANs）设计的。<br>UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是属于TCP/IP协议族中的一种。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2952111-571c60b933d42028.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"1.jpg\"></p>\n<a id=\"more\"></a>\n<p>TCP/IP协议族包括运输层、网络层、链路层。由上图可以知道TCP/IP与UDP的关系。</p>\n<h2 id=\"Socket在哪里\"><a href=\"#Socket在哪里\" class=\"headerlink\" title=\"Socket在哪里\"></a>Socket在哪里</h2><p><img src=\"https://upload-images.jianshu.io/upload_images/2952111-1dd2ce6b61d08816.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"2.jpg\"></p>\n<h2 id=\"Socket是什么\"><a href=\"#Socket是什么\" class=\"headerlink\" title=\"Socket是什么\"></a>Socket是什么</h2><p>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p>\n<h2 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h2><p>前人已经给我们做了好多的事了，网络间的通信也就简单了许多，但毕竟还是有挺多工作要做的。以前听到Socket编程，觉得它是比较高深的编程知识，但是只要弄清Socket编程的工作原理，神秘的面纱也就揭开了。<br>一个生活中的场景。你要打电话给一个朋友，先拨号，朋友听到电话铃声后提起电话，这时你和你的朋友就建立起了连接，就可以讲话了。等交流结束，挂断电话结束此次交谈。<br>生活中的场景就解释了这工作原理，也许TCP/IP协议族就是诞生于生活中，这也不一定。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2952111-99ebc49204f5b380.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"3.jpg\"></p>\n<p>先从服务器端说起。服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。</p>\n<p>在这里我就举个简单的例子，我们走的是TCP协议这条路（见图2）。例子用MFC编写，运行的界面如下：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2952111-36073682cf397e4f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"4.jpg\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2952111-61b92a5dbbb8bf69.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"5.jpg\"></p>\n<p>在客户端输入服务器端的IP地址和发送的数据，然后按发送按钮，服务器端接收到数据，然后回应客户端。客户端读取回应的数据，显示在界面上。</p>\n<p>客户端就一个函数完成了一次通信。在这里IP地址为何用127.0.0.1呢？使用这个IP地址，服务器端和客户端就能运行在同一台机器上，这样调试方便多了。当然你可以在你朋友的机器上运行Server程序(本人在局域网中测试过)，在自己的机器上运行Client程序，当然输入的IP地址就该是你朋友机器的IP地址了。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml\" target=\"_blank\" rel=\"noopener\">http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>对TCP/IP、UDP、Socket编程这些词你不会很陌生吧？随着网络技术的发展，这些词充斥着我们的耳朵。那么我想问：</p>\n<ol>\n<li>什么是TCP/IP、UDP？</li>\n<li>Socket在哪里呢？</li>\n<li>Socket是什么呢？</li>\n<li>你会使用它们吗？</li>\n</ol>\n<h2 id=\"什么是TCP-IP、UDP\"><a href=\"#什么是TCP-IP、UDP\" class=\"headerlink\" title=\"什么是TCP/IP、UDP\"></a>什么是TCP/IP、UDP</h2><p>TCP/IP（Transmission Control Protocol/Internet Protocol）即传输控制协议/网间协议，是一个工业标准的协议集，它是为广域网（WANs）设计的。<br>UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是属于TCP/IP协议族中的一种。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2952111-571c60b933d42028.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"1.jpg\"></p>","more":"<p>TCP/IP协议族包括运输层、网络层、链路层。由上图可以知道TCP/IP与UDP的关系。</p>\n<h2 id=\"Socket在哪里\"><a href=\"#Socket在哪里\" class=\"headerlink\" title=\"Socket在哪里\"></a>Socket在哪里</h2><p><img src=\"https://upload-images.jianshu.io/upload_images/2952111-1dd2ce6b61d08816.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"2.jpg\"></p>\n<h2 id=\"Socket是什么\"><a href=\"#Socket是什么\" class=\"headerlink\" title=\"Socket是什么\"></a>Socket是什么</h2><p>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p>\n<h2 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h2><p>前人已经给我们做了好多的事了，网络间的通信也就简单了许多，但毕竟还是有挺多工作要做的。以前听到Socket编程，觉得它是比较高深的编程知识，但是只要弄清Socket编程的工作原理，神秘的面纱也就揭开了。<br>一个生活中的场景。你要打电话给一个朋友，先拨号，朋友听到电话铃声后提起电话，这时你和你的朋友就建立起了连接，就可以讲话了。等交流结束，挂断电话结束此次交谈。<br>生活中的场景就解释了这工作原理，也许TCP/IP协议族就是诞生于生活中，这也不一定。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2952111-99ebc49204f5b380.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"3.jpg\"></p>\n<p>先从服务器端说起。服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。</p>\n<p>在这里我就举个简单的例子，我们走的是TCP协议这条路（见图2）。例子用MFC编写，运行的界面如下：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2952111-36073682cf397e4f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"4.jpg\"></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/2952111-61b92a5dbbb8bf69.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"5.jpg\"></p>\n<p>在客户端输入服务器端的IP地址和发送的数据，然后按发送按钮，服务器端接收到数据，然后回应客户端。客户端读取回应的数据，显示在界面上。</p>\n<p>客户端就一个函数完成了一次通信。在这里IP地址为何用127.0.0.1呢？使用这个IP地址，服务器端和客户端就能运行在同一台机器上，这样调试方便多了。当然你可以在你朋友的机器上运行Server程序(本人在局域网中测试过)，在自己的机器上运行Client程序，当然输入的IP地址就该是你朋友机器的IP地址了。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml\" target=\"_blank\" rel=\"noopener\">http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml</a></li>\n</ol>"},{"title":"从零开始学爬虫-01","date":"2018-02-27T16:37:37.000Z","_content":"\n### 本节关键字\n*urllib | chardet*\n\n### urllib 简介\n在Python3.x中，我们可以使用urlib这个组件抓取网页，urllib是一个URL处理包，这个包中集合了一些处理URL的模块，如下：\n<!-- more -->\n\n>1.urllib.request模块是用来打开和读取URLs的；\n\n>2.urllib.error模块包含一些有urllib.request产生的错误，可以使用try进行捕捉处理；\n\n>3.urllib.parse模块包含了一些解析URLs的方法；\n\n>4.urllib.robotparser模块用来解析robots.txt文本文件.它提供了一个单独的RobotFileParser类，通过该类提供的can_fetch()方法测试爬虫是否可以下载一个页面。\n\n\n使用urllib.request.urlopen()这个接口函数就可以访问一个网站，读取并打印信息。\nurlopen有一些可选参数，具体信息可以查阅Python自带的documentation。\n\n### urllib 测试\n了解到这些，我们就可以写一个最简单的程序，文件名为urllib_test01.py，感受一个urllib库的魅力：\n```python\n# -*- coding: UTF-8 -*-\nfrom urllib import request\n\nif __name__ == \"__main__\":\n    response = request.urlopen(\"http://fanyi.baidu.com\")\n    html = response.read()\n    print(html)\n```\n\nurllib使用使用request.urlopen()访问和读取URLs信息，返回的对象response如同一个文本对象，我们可以调用read()，进行读取。再通过print()屏幕打印。\n\n浏览器就是作为客户端从服务器端获取信息，然后将信息解析，再展示给我们的。但是显然他们都是二进制的乱码。\n\n我们可以通过简单的decode()命令将网页的信息进行解码，并显示出来，我们新创建一个文件，命名为urllib_test02.py，编写如下代码：\n\n```python\n# -*- coding: UTF-8 -*-\nfrom urllib import request\n\nif __name__ == \"__main__\":\n    response = request.urlopen(\"http://fanyi.baidu.com/\")\n    html = response.read()\n    html = html.decode(\"utf-8\")\n    print(html)\n```\n\n这样我们就可以得到这样的结果，显然解码后的信息看起来工整和舒服多了：\n\n\n当然这个前提是我们已经知道了这个网页是使用utf-8编码的，怎么查看网页的编码方式呢？非常简单的方法是使用使用浏览器审查元素，只需要找到head标签开始位置的chareset，就知道网页是采用何种编码。\n\n这样我们就知道了这个网站的编码方式，但是这需要我们每次都打开浏览器，并找下编码方式，显然有些费事，使用几行代码解决更加省事并且显得酷一些。\n\n我们需要安装第三方库chardet，它是用来判断编码的模块。安装好后，我们就可以使用chardet.detect()方法，判断网页的编码方式了。至此，我们就可以编写一个小程序判断网页的编码方式了，新建文件名为chardet_test01.py：\n```Python\n# -*- coding: UTF-8 -*-\nfrom urllib import request\nimport chardet\n\nif __name__ == \"__main__\":\n    response = request.urlopen(\"http://fanyi.baidu.com\")\n    html = response.read()\n    charset = chardet.detect(html)\n    print(charset)\n```\n","source":"_posts/从零开始学爬虫-01.md","raw":"---\ntitle: 从零开始学爬虫-01\ndate: 2018-02-28 00:37:37\ntags:\n  - Spider\n  - Urllib\n  - Python3\ncategories:\n  - Spider\n  - Urllib\n---\n\n### 本节关键字\n*urllib | chardet*\n\n### urllib 简介\n在Python3.x中，我们可以使用urlib这个组件抓取网页，urllib是一个URL处理包，这个包中集合了一些处理URL的模块，如下：\n<!-- more -->\n\n>1.urllib.request模块是用来打开和读取URLs的；\n\n>2.urllib.error模块包含一些有urllib.request产生的错误，可以使用try进行捕捉处理；\n\n>3.urllib.parse模块包含了一些解析URLs的方法；\n\n>4.urllib.robotparser模块用来解析robots.txt文本文件.它提供了一个单独的RobotFileParser类，通过该类提供的can_fetch()方法测试爬虫是否可以下载一个页面。\n\n\n使用urllib.request.urlopen()这个接口函数就可以访问一个网站，读取并打印信息。\nurlopen有一些可选参数，具体信息可以查阅Python自带的documentation。\n\n### urllib 测试\n了解到这些，我们就可以写一个最简单的程序，文件名为urllib_test01.py，感受一个urllib库的魅力：\n```python\n# -*- coding: UTF-8 -*-\nfrom urllib import request\n\nif __name__ == \"__main__\":\n    response = request.urlopen(\"http://fanyi.baidu.com\")\n    html = response.read()\n    print(html)\n```\n\nurllib使用使用request.urlopen()访问和读取URLs信息，返回的对象response如同一个文本对象，我们可以调用read()，进行读取。再通过print()屏幕打印。\n\n浏览器就是作为客户端从服务器端获取信息，然后将信息解析，再展示给我们的。但是显然他们都是二进制的乱码。\n\n我们可以通过简单的decode()命令将网页的信息进行解码，并显示出来，我们新创建一个文件，命名为urllib_test02.py，编写如下代码：\n\n```python\n# -*- coding: UTF-8 -*-\nfrom urllib import request\n\nif __name__ == \"__main__\":\n    response = request.urlopen(\"http://fanyi.baidu.com/\")\n    html = response.read()\n    html = html.decode(\"utf-8\")\n    print(html)\n```\n\n这样我们就可以得到这样的结果，显然解码后的信息看起来工整和舒服多了：\n\n\n当然这个前提是我们已经知道了这个网页是使用utf-8编码的，怎么查看网页的编码方式呢？非常简单的方法是使用使用浏览器审查元素，只需要找到head标签开始位置的chareset，就知道网页是采用何种编码。\n\n这样我们就知道了这个网站的编码方式，但是这需要我们每次都打开浏览器，并找下编码方式，显然有些费事，使用几行代码解决更加省事并且显得酷一些。\n\n我们需要安装第三方库chardet，它是用来判断编码的模块。安装好后，我们就可以使用chardet.detect()方法，判断网页的编码方式了。至此，我们就可以编写一个小程序判断网页的编码方式了，新建文件名为chardet_test01.py：\n```Python\n# -*- coding: UTF-8 -*-\nfrom urllib import request\nimport chardet\n\nif __name__ == \"__main__\":\n    response = request.urlopen(\"http://fanyi.baidu.com\")\n    html = response.read()\n    charset = chardet.detect(html)\n    print(charset)\n```\n","slug":"从零开始学爬虫-01","published":1,"updated":"2018-02-27T17:04:40.535Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozmu005r8mot74g4ezwb","content":"<h3 id=\"本节关键字\"><a href=\"#本节关键字\" class=\"headerlink\" title=\"本节关键字\"></a>本节关键字</h3><p><em>urllib | chardet</em></p>\n<h3 id=\"urllib-简介\"><a href=\"#urllib-简介\" class=\"headerlink\" title=\"urllib 简介\"></a>urllib 简介</h3><p>在Python3.x中，我们可以使用urlib这个组件抓取网页，urllib是一个URL处理包，这个包中集合了一些处理URL的模块，如下：<br><a id=\"more\"></a></p>\n<blockquote>\n<p>1.urllib.request模块是用来打开和读取URLs的；</p>\n</blockquote>\n<blockquote>\n<p>2.urllib.error模块包含一些有urllib.request产生的错误，可以使用try进行捕捉处理；</p>\n</blockquote>\n<blockquote>\n<p>3.urllib.parse模块包含了一些解析URLs的方法；</p>\n</blockquote>\n<blockquote>\n<p>4.urllib.robotparser模块用来解析robots.txt文本文件.它提供了一个单独的RobotFileParser类，通过该类提供的can_fetch()方法测试爬虫是否可以下载一个页面。</p>\n</blockquote>\n<p>使用urllib.request.urlopen()这个接口函数就可以访问一个网站，读取并打印信息。<br>urlopen有一些可选参数，具体信息可以查阅Python自带的documentation。</p>\n<h3 id=\"urllib-测试\"><a href=\"#urllib-测试\" class=\"headerlink\" title=\"urllib 测试\"></a>urllib 测试</h3><p>了解到这些，我们就可以写一个最简单的程序，文件名为urllib_test01.py，感受一个urllib库的魅力：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> request</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    response = request.urlopen(<span class=\"string\">\"http://fanyi.baidu.com\"</span>)</span><br><span class=\"line\">    html = response.read()</span><br><span class=\"line\">    print(html)</span><br></pre></td></tr></table></figure></p>\n<p>urllib使用使用request.urlopen()访问和读取URLs信息，返回的对象response如同一个文本对象，我们可以调用read()，进行读取。再通过print()屏幕打印。</p>\n<p>浏览器就是作为客户端从服务器端获取信息，然后将信息解析，再展示给我们的。但是显然他们都是二进制的乱码。</p>\n<p>我们可以通过简单的decode()命令将网页的信息进行解码，并显示出来，我们新创建一个文件，命名为urllib_test02.py，编写如下代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> request</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    response = request.urlopen(<span class=\"string\">\"http://fanyi.baidu.com/\"</span>)</span><br><span class=\"line\">    html = response.read()</span><br><span class=\"line\">    html = html.decode(<span class=\"string\">\"utf-8\"</span>)</span><br><span class=\"line\">    print(html)</span><br></pre></td></tr></table></figure>\n<p>这样我们就可以得到这样的结果，显然解码后的信息看起来工整和舒服多了：</p>\n<p>当然这个前提是我们已经知道了这个网页是使用utf-8编码的，怎么查看网页的编码方式呢？非常简单的方法是使用使用浏览器审查元素，只需要找到head标签开始位置的chareset，就知道网页是采用何种编码。</p>\n<p>这样我们就知道了这个网站的编码方式，但是这需要我们每次都打开浏览器，并找下编码方式，显然有些费事，使用几行代码解决更加省事并且显得酷一些。</p>\n<p>我们需要安装第三方库chardet，它是用来判断编码的模块。安装好后，我们就可以使用chardet.detect()方法，判断网页的编码方式了。至此，我们就可以编写一个小程序判断网页的编码方式了，新建文件名为chardet_test01.py：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> request</span><br><span class=\"line\"><span class=\"keyword\">import</span> chardet</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    response = request.urlopen(<span class=\"string\">\"http://fanyi.baidu.com\"</span>)</span><br><span class=\"line\">    html = response.read()</span><br><span class=\"line\">    charset = chardet.detect(html)</span><br><span class=\"line\">    print(charset)</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"本节关键字\"><a href=\"#本节关键字\" class=\"headerlink\" title=\"本节关键字\"></a>本节关键字</h3><p><em>urllib | chardet</em></p>\n<h3 id=\"urllib-简介\"><a href=\"#urllib-简介\" class=\"headerlink\" title=\"urllib 简介\"></a>urllib 简介</h3><p>在Python3.x中，我们可以使用urlib这个组件抓取网页，urllib是一个URL处理包，这个包中集合了一些处理URL的模块，如下：<br>","more":"</p>\n<blockquote>\n<p>1.urllib.request模块是用来打开和读取URLs的；</p>\n</blockquote>\n<blockquote>\n<p>2.urllib.error模块包含一些有urllib.request产生的错误，可以使用try进行捕捉处理；</p>\n</blockquote>\n<blockquote>\n<p>3.urllib.parse模块包含了一些解析URLs的方法；</p>\n</blockquote>\n<blockquote>\n<p>4.urllib.robotparser模块用来解析robots.txt文本文件.它提供了一个单独的RobotFileParser类，通过该类提供的can_fetch()方法测试爬虫是否可以下载一个页面。</p>\n</blockquote>\n<p>使用urllib.request.urlopen()这个接口函数就可以访问一个网站，读取并打印信息。<br>urlopen有一些可选参数，具体信息可以查阅Python自带的documentation。</p>\n<h3 id=\"urllib-测试\"><a href=\"#urllib-测试\" class=\"headerlink\" title=\"urllib 测试\"></a>urllib 测试</h3><p>了解到这些，我们就可以写一个最简单的程序，文件名为urllib_test01.py，感受一个urllib库的魅力：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> request</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    response = request.urlopen(<span class=\"string\">\"http://fanyi.baidu.com\"</span>)</span><br><span class=\"line\">    html = response.read()</span><br><span class=\"line\">    print(html)</span><br></pre></td></tr></table></figure></p>\n<p>urllib使用使用request.urlopen()访问和读取URLs信息，返回的对象response如同一个文本对象，我们可以调用read()，进行读取。再通过print()屏幕打印。</p>\n<p>浏览器就是作为客户端从服务器端获取信息，然后将信息解析，再展示给我们的。但是显然他们都是二进制的乱码。</p>\n<p>我们可以通过简单的decode()命令将网页的信息进行解码，并显示出来，我们新创建一个文件，命名为urllib_test02.py，编写如下代码：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> request</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    response = request.urlopen(<span class=\"string\">\"http://fanyi.baidu.com/\"</span>)</span><br><span class=\"line\">    html = response.read()</span><br><span class=\"line\">    html = html.decode(<span class=\"string\">\"utf-8\"</span>)</span><br><span class=\"line\">    print(html)</span><br></pre></td></tr></table></figure>\n<p>这样我们就可以得到这样的结果，显然解码后的信息看起来工整和舒服多了：</p>\n<p>当然这个前提是我们已经知道了这个网页是使用utf-8编码的，怎么查看网页的编码方式呢？非常简单的方法是使用使用浏览器审查元素，只需要找到head标签开始位置的chareset，就知道网页是采用何种编码。</p>\n<p>这样我们就知道了这个网站的编码方式，但是这需要我们每次都打开浏览器，并找下编码方式，显然有些费事，使用几行代码解决更加省事并且显得酷一些。</p>\n<p>我们需要安装第三方库chardet，它是用来判断编码的模块。安装好后，我们就可以使用chardet.detect()方法，判断网页的编码方式了。至此，我们就可以编写一个小程序判断网页的编码方式了，新建文件名为chardet_test01.py：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> request</span><br><span class=\"line\"><span class=\"keyword\">import</span> chardet</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    response = request.urlopen(<span class=\"string\">\"http://fanyi.baidu.com\"</span>)</span><br><span class=\"line\">    html = response.read()</span><br><span class=\"line\">    charset = chardet.detect(html)</span><br><span class=\"line\">    print(charset)</span><br></pre></td></tr></table></figure></p>"},{"title":"从零开始学爬虫-02","date":"2018-02-27T16:48:24.000Z","_content":"\n### 一个疑问尚未解决疑问，小弟在此跪求大牛解答一下\n为什么把url里的 \"_o\" 删掉后就可以正常爬取呢？\n<!-- more -->\n### urlopen的url参数 Agent\n\n\nurl不仅可以是一个字符串，例如:http://www.baidu.com。\n\nurl也可以是一个Request对象，这就需要我们先定义一个Request对象，然后将这个Request对象作为urlopen的参数使用，方法如下：\n\n```python\n# -*- coding: UTF-8 -*-\nfrom urllib import request\n\nif __name__ == \"__main__\":\n    req = request.Request(\"http://fanyi.baidu.com/\")\n    response = request.urlopen(req)\n    html = response.read()\n    html = html.decode(\"utf-8\")\n    print(html)\n```\n\n同样，运行这段代码同样可以得到网页信息。可以看一下这段代码和上个笔记中代码的不同，对比一下就明白了。\n\nurlopen()返回的对象，可以使用read()进行读取，同样也可以使用geturl()方法、info()方法、getcode()方法。\n\n\n\n- geturl()返回的是一个url的字符串；\n\n- info()返回的是一些meta标记的元信息，包括一些服务器的信息；\n\n- getcode()返回的是HTTP的状态码，如果返回200表示请求成功。\n\n关于META标签和HTTP状态码的内容可以自行百度百科，里面有很详细的介绍。\n\n\n了解到这些，我们就可以进行新一轮的测试，新建文件名urllib_test04.py，编写如下代码：\n```python\n# -*- coding: UTF-8 -*-\nfrom urllib import request\n\nif __name__ == \"__main__\":\n    req = request.Request(\"http://fanyi.baidu.com/\")\n    response = request.urlopen(req)\n    print(\"geturl打印信息：%s\"%(response.geturl()))\n    print('**********************************************')\n    print(\"info打印信息：%s\"%(response.info()))\n    print('**********************************************')\n    print(\"getcode打印信息：%s\"%(response.getcode()))\n\n```\n\n\n### urlopen的data参数\n\n我们可以使用data参数，向服务器发送数据。根据HTTP规范，GET用于信息获取，POST是向服务器提交数据的一种请求，再换句话说：\n\n从客户端向服务器提交数据使用POST；\n\n从服务器获得数据到客户端使用GET(GET也可以提交，暂不考虑)。\n\n如果没有设置urlopen()函数的data参数，HTTP请求采用GET方式，也就是我们从服务器获取信息，如果我们设置data参数，HTTP请求采用POST方式，也就是我们向服务器传递数据。\n\ndata参数有自己的格式，它是一个基于application/x-www.form-urlencoded的格式，具体格式我们不用了解， 因为我们可以使用urllib.parse.urlencode()函数将字符串自动转换成上面所说的格式。\n\n### 发送data实例\n\n向有道翻译发送data，得到翻译结果。\n####  (1).打开有道翻译界面，如下图所示：\n\n ![image](http://upload-images.jianshu.io/upload_images/2952111-31f629ec53534a43?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n####  (2).鼠标右键检查，也就是审查元素，如下图所示：\n\n![image](http://upload-images.jianshu.io/upload_images/2952111-f199c9cbcd80b40f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n####  (3).选择右侧出现的Network，如下图所示：\n\n ![image](http://upload-images.jianshu.io/upload_images/2952111-4354c17b0169d4b9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n####  (4).在左侧输入翻译内容，输入Jack，如下图所示：\n\n ![image](http://upload-images.jianshu.io/upload_images/2952111-1a5e4f785e7bbccf?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n####  (5).点击自动翻译按钮，我们就可以看到右侧出现的内容，如下图所示：\n![image](http://upload-images.jianshu.io/upload_images/2952111-37b47520ec88de2e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n####  (6).点击上图红框中的内容，查看它的信息，如下图所示：\n\n ![image](http://upload-images.jianshu.io/upload_images/2952111-9b692ceecf538fd5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n![image](http://upload-images.jianshu.io/upload_images/2952111-1dc2354ec47dc6ff?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n####  (7).记住这些信息，这是我们一会儿写程序需要用到的。\n\n  新建文件translate_test.py，编写如下代码：\n ```python\n# -*- coding: UTF-8 -*-\nfrom urllib import request\nfrom urllib import parse\nimport json\n\nif __name__ == \"__main__\":\n    #对应上图的Request URL\n    Request_URL = 'http://fanyi.youdao.com/translate?smartresult=dict&smartresult=rule&sessionFrom=null'\n    #创建Form_Data字典，存储上图的Form Data\n    Form_Data = {}\n    Form_Data['type'] = 'AUTO'\n    Form_Data['i'] = 'Jack'\n    Form_Data['doctype'] = 'json'\n    Form_Data['xmlVersion'] = '1.8'\n    Form_Data['keyfrom'] = 'fanyi.web'\n    Form_Data['ue'] = 'ue:UTF-8'\n    Form_Data['action'] = 'FY_BY_CLICKBUTTON'\n    #使用urlencode方法转换标准格式\n    data = parse.urlencode(Form_Data).encode('utf-8')\n    #传递Request对象和转换完格式的数据\n    response = request.urlopen(Request_URL,data)\n    #读取信息并解码\n    html = response.read().decode('utf-8')\n    #使用JSON\n    translate_results = json.loads(html)\n    #找到翻译结果\n    translate_results = translate_results['translateResult'][0][0]['tgt']\n    #打印翻译信息\n    print(\"翻译的结果是：%s\" % translate_results)\n```\n\n运行查看翻译结果\n","source":"_posts/从零开始学爬虫-02.md","raw":"---\ntitle: 从零开始学爬虫-02\ndate: 2018-02-28 00:48:24\ntags:\n  - Spider\n  - Urllib\n  - Python3\ncategories:\n  - Spider\n  - Urllib\n---\n\n### 一个疑问尚未解决疑问，小弟在此跪求大牛解答一下\n为什么把url里的 \"_o\" 删掉后就可以正常爬取呢？\n<!-- more -->\n### urlopen的url参数 Agent\n\n\nurl不仅可以是一个字符串，例如:http://www.baidu.com。\n\nurl也可以是一个Request对象，这就需要我们先定义一个Request对象，然后将这个Request对象作为urlopen的参数使用，方法如下：\n\n```python\n# -*- coding: UTF-8 -*-\nfrom urllib import request\n\nif __name__ == \"__main__\":\n    req = request.Request(\"http://fanyi.baidu.com/\")\n    response = request.urlopen(req)\n    html = response.read()\n    html = html.decode(\"utf-8\")\n    print(html)\n```\n\n同样，运行这段代码同样可以得到网页信息。可以看一下这段代码和上个笔记中代码的不同，对比一下就明白了。\n\nurlopen()返回的对象，可以使用read()进行读取，同样也可以使用geturl()方法、info()方法、getcode()方法。\n\n\n\n- geturl()返回的是一个url的字符串；\n\n- info()返回的是一些meta标记的元信息，包括一些服务器的信息；\n\n- getcode()返回的是HTTP的状态码，如果返回200表示请求成功。\n\n关于META标签和HTTP状态码的内容可以自行百度百科，里面有很详细的介绍。\n\n\n了解到这些，我们就可以进行新一轮的测试，新建文件名urllib_test04.py，编写如下代码：\n```python\n# -*- coding: UTF-8 -*-\nfrom urllib import request\n\nif __name__ == \"__main__\":\n    req = request.Request(\"http://fanyi.baidu.com/\")\n    response = request.urlopen(req)\n    print(\"geturl打印信息：%s\"%(response.geturl()))\n    print('**********************************************')\n    print(\"info打印信息：%s\"%(response.info()))\n    print('**********************************************')\n    print(\"getcode打印信息：%s\"%(response.getcode()))\n\n```\n\n\n### urlopen的data参数\n\n我们可以使用data参数，向服务器发送数据。根据HTTP规范，GET用于信息获取，POST是向服务器提交数据的一种请求，再换句话说：\n\n从客户端向服务器提交数据使用POST；\n\n从服务器获得数据到客户端使用GET(GET也可以提交，暂不考虑)。\n\n如果没有设置urlopen()函数的data参数，HTTP请求采用GET方式，也就是我们从服务器获取信息，如果我们设置data参数，HTTP请求采用POST方式，也就是我们向服务器传递数据。\n\ndata参数有自己的格式，它是一个基于application/x-www.form-urlencoded的格式，具体格式我们不用了解， 因为我们可以使用urllib.parse.urlencode()函数将字符串自动转换成上面所说的格式。\n\n### 发送data实例\n\n向有道翻译发送data，得到翻译结果。\n####  (1).打开有道翻译界面，如下图所示：\n\n ![image](http://upload-images.jianshu.io/upload_images/2952111-31f629ec53534a43?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n####  (2).鼠标右键检查，也就是审查元素，如下图所示：\n\n![image](http://upload-images.jianshu.io/upload_images/2952111-f199c9cbcd80b40f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n####  (3).选择右侧出现的Network，如下图所示：\n\n ![image](http://upload-images.jianshu.io/upload_images/2952111-4354c17b0169d4b9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n####  (4).在左侧输入翻译内容，输入Jack，如下图所示：\n\n ![image](http://upload-images.jianshu.io/upload_images/2952111-1a5e4f785e7bbccf?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n####  (5).点击自动翻译按钮，我们就可以看到右侧出现的内容，如下图所示：\n![image](http://upload-images.jianshu.io/upload_images/2952111-37b47520ec88de2e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n####  (6).点击上图红框中的内容，查看它的信息，如下图所示：\n\n ![image](http://upload-images.jianshu.io/upload_images/2952111-9b692ceecf538fd5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n![image](http://upload-images.jianshu.io/upload_images/2952111-1dc2354ec47dc6ff?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n####  (7).记住这些信息，这是我们一会儿写程序需要用到的。\n\n  新建文件translate_test.py，编写如下代码：\n ```python\n# -*- coding: UTF-8 -*-\nfrom urllib import request\nfrom urllib import parse\nimport json\n\nif __name__ == \"__main__\":\n    #对应上图的Request URL\n    Request_URL = 'http://fanyi.youdao.com/translate?smartresult=dict&smartresult=rule&sessionFrom=null'\n    #创建Form_Data字典，存储上图的Form Data\n    Form_Data = {}\n    Form_Data['type'] = 'AUTO'\n    Form_Data['i'] = 'Jack'\n    Form_Data['doctype'] = 'json'\n    Form_Data['xmlVersion'] = '1.8'\n    Form_Data['keyfrom'] = 'fanyi.web'\n    Form_Data['ue'] = 'ue:UTF-8'\n    Form_Data['action'] = 'FY_BY_CLICKBUTTON'\n    #使用urlencode方法转换标准格式\n    data = parse.urlencode(Form_Data).encode('utf-8')\n    #传递Request对象和转换完格式的数据\n    response = request.urlopen(Request_URL,data)\n    #读取信息并解码\n    html = response.read().decode('utf-8')\n    #使用JSON\n    translate_results = json.loads(html)\n    #找到翻译结果\n    translate_results = translate_results['translateResult'][0][0]['tgt']\n    #打印翻译信息\n    print(\"翻译的结果是：%s\" % translate_results)\n```\n\n运行查看翻译结果\n","slug":"从零开始学爬虫-02","published":1,"updated":"2018-02-27T17:04:42.158Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozmx005w8motqp87dch1","content":"<h3 id=\"一个疑问尚未解决疑问，小弟在此跪求大牛解答一下\"><a href=\"#一个疑问尚未解决疑问，小弟在此跪求大牛解答一下\" class=\"headerlink\" title=\"一个疑问尚未解决疑问，小弟在此跪求大牛解答一下\"></a>一个疑问尚未解决疑问，小弟在此跪求大牛解答一下</h3><p>为什么把url里的 “_o” 删掉后就可以正常爬取呢？<br><a id=\"more\"></a></p>\n<h3 id=\"urlopen的url参数-Agent\"><a href=\"#urlopen的url参数-Agent\" class=\"headerlink\" title=\"urlopen的url参数 Agent\"></a>urlopen的url参数 Agent</h3><p>url不仅可以是一个字符串，例如:<a href=\"http://www.baidu.com。\" target=\"_blank\" rel=\"noopener\">http://www.baidu.com。</a></p>\n<p>url也可以是一个Request对象，这就需要我们先定义一个Request对象，然后将这个Request对象作为urlopen的参数使用，方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> request</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    req = request.Request(<span class=\"string\">\"http://fanyi.baidu.com/\"</span>)</span><br><span class=\"line\">    response = request.urlopen(req)</span><br><span class=\"line\">    html = response.read()</span><br><span class=\"line\">    html = html.decode(<span class=\"string\">\"utf-8\"</span>)</span><br><span class=\"line\">    print(html)</span><br></pre></td></tr></table></figure>\n<p>同样，运行这段代码同样可以得到网页信息。可以看一下这段代码和上个笔记中代码的不同，对比一下就明白了。</p>\n<p>urlopen()返回的对象，可以使用read()进行读取，同样也可以使用geturl()方法、info()方法、getcode()方法。</p>\n<ul>\n<li><p>geturl()返回的是一个url的字符串；</p>\n</li>\n<li><p>info()返回的是一些meta标记的元信息，包括一些服务器的信息；</p>\n</li>\n<li><p>getcode()返回的是HTTP的状态码，如果返回200表示请求成功。</p>\n</li>\n</ul>\n<p>关于META标签和HTTP状态码的内容可以自行百度百科，里面有很详细的介绍。</p>\n<p>了解到这些，我们就可以进行新一轮的测试，新建文件名urllib_test04.py，编写如下代码：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> request</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    req = request.Request(<span class=\"string\">\"http://fanyi.baidu.com/\"</span>)</span><br><span class=\"line\">    response = request.urlopen(req)</span><br><span class=\"line\">    print(<span class=\"string\">\"geturl打印信息：%s\"</span>%(response.geturl()))</span><br><span class=\"line\">    print(<span class=\"string\">'**********************************************'</span>)</span><br><span class=\"line\">    print(<span class=\"string\">\"info打印信息：%s\"</span>%(response.info()))</span><br><span class=\"line\">    print(<span class=\"string\">'**********************************************'</span>)</span><br><span class=\"line\">    print(<span class=\"string\">\"getcode打印信息：%s\"</span>%(response.getcode()))</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"urlopen的data参数\"><a href=\"#urlopen的data参数\" class=\"headerlink\" title=\"urlopen的data参数\"></a>urlopen的data参数</h3><p>我们可以使用data参数，向服务器发送数据。根据HTTP规范，GET用于信息获取，POST是向服务器提交数据的一种请求，再换句话说：</p>\n<p>从客户端向服务器提交数据使用POST；</p>\n<p>从服务器获得数据到客户端使用GET(GET也可以提交，暂不考虑)。</p>\n<p>如果没有设置urlopen()函数的data参数，HTTP请求采用GET方式，也就是我们从服务器获取信息，如果我们设置data参数，HTTP请求采用POST方式，也就是我们向服务器传递数据。</p>\n<p>data参数有自己的格式，它是一个基于application/x-<a href=\"http://www.form-urlencoded的格式，具体格式我们不用了解，\" target=\"_blank\" rel=\"noopener\">www.form-urlencoded的格式，具体格式我们不用了解，</a> 因为我们可以使用urllib.parse.urlencode()函数将字符串自动转换成上面所说的格式。</p>\n<h3 id=\"发送data实例\"><a href=\"#发送data实例\" class=\"headerlink\" title=\"发送data实例\"></a>发送data实例</h3><p>向有道翻译发送data，得到翻译结果。</p>\n<h4 id=\"1-打开有道翻译界面，如下图所示：\"><a href=\"#1-打开有道翻译界面，如下图所示：\" class=\"headerlink\" title=\"(1).打开有道翻译界面，如下图所示：\"></a>(1).打开有道翻译界面，如下图所示：</h4><p> <img src=\"http://upload-images.jianshu.io/upload_images/2952111-31f629ec53534a43?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"2-鼠标右键检查，也就是审查元素，如下图所示：\"><a href=\"#2-鼠标右键检查，也就是审查元素，如下图所示：\" class=\"headerlink\" title=\"(2).鼠标右键检查，也就是审查元素，如下图所示：\"></a>(2).鼠标右键检查，也就是审查元素，如下图所示：</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-f199c9cbcd80b40f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"3-选择右侧出现的Network，如下图所示：\"><a href=\"#3-选择右侧出现的Network，如下图所示：\" class=\"headerlink\" title=\"(3).选择右侧出现的Network，如下图所示：\"></a>(3).选择右侧出现的Network，如下图所示：</h4><p> <img src=\"http://upload-images.jianshu.io/upload_images/2952111-4354c17b0169d4b9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"4-在左侧输入翻译内容，输入Jack，如下图所示：\"><a href=\"#4-在左侧输入翻译内容，输入Jack，如下图所示：\" class=\"headerlink\" title=\"(4).在左侧输入翻译内容，输入Jack，如下图所示：\"></a>(4).在左侧输入翻译内容，输入Jack，如下图所示：</h4><p> <img src=\"http://upload-images.jianshu.io/upload_images/2952111-1a5e4f785e7bbccf?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"5-点击自动翻译按钮，我们就可以看到右侧出现的内容，如下图所示：\"><a href=\"#5-点击自动翻译按钮，我们就可以看到右侧出现的内容，如下图所示：\" class=\"headerlink\" title=\"(5).点击自动翻译按钮，我们就可以看到右侧出现的内容，如下图所示：\"></a>(5).点击自动翻译按钮，我们就可以看到右侧出现的内容，如下图所示：</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-37b47520ec88de2e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"6-点击上图红框中的内容，查看它的信息，如下图所示：\"><a href=\"#6-点击上图红框中的内容，查看它的信息，如下图所示：\" class=\"headerlink\" title=\"(6).点击上图红框中的内容，查看它的信息，如下图所示：\"></a>(6).点击上图红框中的内容，查看它的信息，如下图所示：</h4><p> <img src=\"http://upload-images.jianshu.io/upload_images/2952111-9b692ceecf538fd5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-1dc2354ec47dc6ff?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"7-记住这些信息，这是我们一会儿写程序需要用到的。\"><a href=\"#7-记住这些信息，这是我们一会儿写程序需要用到的。\" class=\"headerlink\" title=\"(7).记住这些信息，这是我们一会儿写程序需要用到的。\"></a>(7).记住这些信息，这是我们一会儿写程序需要用到的。</h4><p>  新建文件translate_test.py，编写如下代码：<br> <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> request</span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> parse</span><br><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    <span class=\"comment\">#对应上图的Request URL</span></span><br><span class=\"line\">    Request_URL = <span class=\"string\">'http://fanyi.youdao.com/translate?smartresult=dict&amp;smartresult=rule&amp;sessionFrom=null'</span></span><br><span class=\"line\">    <span class=\"comment\">#创建Form_Data字典，存储上图的Form Data</span></span><br><span class=\"line\">    Form_Data = &#123;&#125;</span><br><span class=\"line\">    Form_Data[<span class=\"string\">'type'</span>] = <span class=\"string\">'AUTO'</span></span><br><span class=\"line\">    Form_Data[<span class=\"string\">'i'</span>] = <span class=\"string\">'Jack'</span></span><br><span class=\"line\">    Form_Data[<span class=\"string\">'doctype'</span>] = <span class=\"string\">'json'</span></span><br><span class=\"line\">    Form_Data[<span class=\"string\">'xmlVersion'</span>] = <span class=\"string\">'1.8'</span></span><br><span class=\"line\">    Form_Data[<span class=\"string\">'keyfrom'</span>] = <span class=\"string\">'fanyi.web'</span></span><br><span class=\"line\">    Form_Data[<span class=\"string\">'ue'</span>] = <span class=\"string\">'ue:UTF-8'</span></span><br><span class=\"line\">    Form_Data[<span class=\"string\">'action'</span>] = <span class=\"string\">'FY_BY_CLICKBUTTON'</span></span><br><span class=\"line\">    <span class=\"comment\">#使用urlencode方法转换标准格式</span></span><br><span class=\"line\">    data = parse.urlencode(Form_Data).encode(<span class=\"string\">'utf-8'</span>)</span><br><span class=\"line\">    <span class=\"comment\">#传递Request对象和转换完格式的数据</span></span><br><span class=\"line\">    response = request.urlopen(Request_URL,data)</span><br><span class=\"line\">    <span class=\"comment\">#读取信息并解码</span></span><br><span class=\"line\">    html = response.read().decode(<span class=\"string\">'utf-8'</span>)</span><br><span class=\"line\">    <span class=\"comment\">#使用JSON</span></span><br><span class=\"line\">    translate_results = json.loads(html)</span><br><span class=\"line\">    <span class=\"comment\">#找到翻译结果</span></span><br><span class=\"line\">    translate_results = translate_results[<span class=\"string\">'translateResult'</span>][<span class=\"number\">0</span>][<span class=\"number\">0</span>][<span class=\"string\">'tgt'</span>]</span><br><span class=\"line\">    <span class=\"comment\">#打印翻译信息</span></span><br><span class=\"line\">    print(<span class=\"string\">\"翻译的结果是：%s\"</span> % translate_results)</span><br></pre></td></tr></table></figure></p>\n<p>运行查看翻译结果</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"一个疑问尚未解决疑问，小弟在此跪求大牛解答一下\"><a href=\"#一个疑问尚未解决疑问，小弟在此跪求大牛解答一下\" class=\"headerlink\" title=\"一个疑问尚未解决疑问，小弟在此跪求大牛解答一下\"></a>一个疑问尚未解决疑问，小弟在此跪求大牛解答一下</h3><p>为什么把url里的 “_o” 删掉后就可以正常爬取呢？<br>","more":"</p>\n<h3 id=\"urlopen的url参数-Agent\"><a href=\"#urlopen的url参数-Agent\" class=\"headerlink\" title=\"urlopen的url参数 Agent\"></a>urlopen的url参数 Agent</h3><p>url不仅可以是一个字符串，例如:<a href=\"http://www.baidu.com。\" target=\"_blank\" rel=\"noopener\">http://www.baidu.com。</a></p>\n<p>url也可以是一个Request对象，这就需要我们先定义一个Request对象，然后将这个Request对象作为urlopen的参数使用，方法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> request</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    req = request.Request(<span class=\"string\">\"http://fanyi.baidu.com/\"</span>)</span><br><span class=\"line\">    response = request.urlopen(req)</span><br><span class=\"line\">    html = response.read()</span><br><span class=\"line\">    html = html.decode(<span class=\"string\">\"utf-8\"</span>)</span><br><span class=\"line\">    print(html)</span><br></pre></td></tr></table></figure>\n<p>同样，运行这段代码同样可以得到网页信息。可以看一下这段代码和上个笔记中代码的不同，对比一下就明白了。</p>\n<p>urlopen()返回的对象，可以使用read()进行读取，同样也可以使用geturl()方法、info()方法、getcode()方法。</p>\n<ul>\n<li><p>geturl()返回的是一个url的字符串；</p>\n</li>\n<li><p>info()返回的是一些meta标记的元信息，包括一些服务器的信息；</p>\n</li>\n<li><p>getcode()返回的是HTTP的状态码，如果返回200表示请求成功。</p>\n</li>\n</ul>\n<p>关于META标签和HTTP状态码的内容可以自行百度百科，里面有很详细的介绍。</p>\n<p>了解到这些，我们就可以进行新一轮的测试，新建文件名urllib_test04.py，编写如下代码：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> request</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    req = request.Request(<span class=\"string\">\"http://fanyi.baidu.com/\"</span>)</span><br><span class=\"line\">    response = request.urlopen(req)</span><br><span class=\"line\">    print(<span class=\"string\">\"geturl打印信息：%s\"</span>%(response.geturl()))</span><br><span class=\"line\">    print(<span class=\"string\">'**********************************************'</span>)</span><br><span class=\"line\">    print(<span class=\"string\">\"info打印信息：%s\"</span>%(response.info()))</span><br><span class=\"line\">    print(<span class=\"string\">'**********************************************'</span>)</span><br><span class=\"line\">    print(<span class=\"string\">\"getcode打印信息：%s\"</span>%(response.getcode()))</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"urlopen的data参数\"><a href=\"#urlopen的data参数\" class=\"headerlink\" title=\"urlopen的data参数\"></a>urlopen的data参数</h3><p>我们可以使用data参数，向服务器发送数据。根据HTTP规范，GET用于信息获取，POST是向服务器提交数据的一种请求，再换句话说：</p>\n<p>从客户端向服务器提交数据使用POST；</p>\n<p>从服务器获得数据到客户端使用GET(GET也可以提交，暂不考虑)。</p>\n<p>如果没有设置urlopen()函数的data参数，HTTP请求采用GET方式，也就是我们从服务器获取信息，如果我们设置data参数，HTTP请求采用POST方式，也就是我们向服务器传递数据。</p>\n<p>data参数有自己的格式，它是一个基于application/x-<a href=\"http://www.form-urlencoded的格式，具体格式我们不用了解，\" target=\"_blank\" rel=\"noopener\">www.form-urlencoded的格式，具体格式我们不用了解，</a> 因为我们可以使用urllib.parse.urlencode()函数将字符串自动转换成上面所说的格式。</p>\n<h3 id=\"发送data实例\"><a href=\"#发送data实例\" class=\"headerlink\" title=\"发送data实例\"></a>发送data实例</h3><p>向有道翻译发送data，得到翻译结果。</p>\n<h4 id=\"1-打开有道翻译界面，如下图所示：\"><a href=\"#1-打开有道翻译界面，如下图所示：\" class=\"headerlink\" title=\"(1).打开有道翻译界面，如下图所示：\"></a>(1).打开有道翻译界面，如下图所示：</h4><p> <img src=\"http://upload-images.jianshu.io/upload_images/2952111-31f629ec53534a43?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"2-鼠标右键检查，也就是审查元素，如下图所示：\"><a href=\"#2-鼠标右键检查，也就是审查元素，如下图所示：\" class=\"headerlink\" title=\"(2).鼠标右键检查，也就是审查元素，如下图所示：\"></a>(2).鼠标右键检查，也就是审查元素，如下图所示：</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-f199c9cbcd80b40f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"3-选择右侧出现的Network，如下图所示：\"><a href=\"#3-选择右侧出现的Network，如下图所示：\" class=\"headerlink\" title=\"(3).选择右侧出现的Network，如下图所示：\"></a>(3).选择右侧出现的Network，如下图所示：</h4><p> <img src=\"http://upload-images.jianshu.io/upload_images/2952111-4354c17b0169d4b9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"4-在左侧输入翻译内容，输入Jack，如下图所示：\"><a href=\"#4-在左侧输入翻译内容，输入Jack，如下图所示：\" class=\"headerlink\" title=\"(4).在左侧输入翻译内容，输入Jack，如下图所示：\"></a>(4).在左侧输入翻译内容，输入Jack，如下图所示：</h4><p> <img src=\"http://upload-images.jianshu.io/upload_images/2952111-1a5e4f785e7bbccf?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"5-点击自动翻译按钮，我们就可以看到右侧出现的内容，如下图所示：\"><a href=\"#5-点击自动翻译按钮，我们就可以看到右侧出现的内容，如下图所示：\" class=\"headerlink\" title=\"(5).点击自动翻译按钮，我们就可以看到右侧出现的内容，如下图所示：\"></a>(5).点击自动翻译按钮，我们就可以看到右侧出现的内容，如下图所示：</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-37b47520ec88de2e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"6-点击上图红框中的内容，查看它的信息，如下图所示：\"><a href=\"#6-点击上图红框中的内容，查看它的信息，如下图所示：\" class=\"headerlink\" title=\"(6).点击上图红框中的内容，查看它的信息，如下图所示：\"></a>(6).点击上图红框中的内容，查看它的信息，如下图所示：</h4><p> <img src=\"http://upload-images.jianshu.io/upload_images/2952111-9b692ceecf538fd5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-1dc2354ec47dc6ff?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<h4 id=\"7-记住这些信息，这是我们一会儿写程序需要用到的。\"><a href=\"#7-记住这些信息，这是我们一会儿写程序需要用到的。\" class=\"headerlink\" title=\"(7).记住这些信息，这是我们一会儿写程序需要用到的。\"></a>(7).记住这些信息，这是我们一会儿写程序需要用到的。</h4><p>  新建文件translate_test.py，编写如下代码：<br> <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> request</span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> parse</span><br><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    <span class=\"comment\">#对应上图的Request URL</span></span><br><span class=\"line\">    Request_URL = <span class=\"string\">'http://fanyi.youdao.com/translate?smartresult=dict&amp;smartresult=rule&amp;sessionFrom=null'</span></span><br><span class=\"line\">    <span class=\"comment\">#创建Form_Data字典，存储上图的Form Data</span></span><br><span class=\"line\">    Form_Data = &#123;&#125;</span><br><span class=\"line\">    Form_Data[<span class=\"string\">'type'</span>] = <span class=\"string\">'AUTO'</span></span><br><span class=\"line\">    Form_Data[<span class=\"string\">'i'</span>] = <span class=\"string\">'Jack'</span></span><br><span class=\"line\">    Form_Data[<span class=\"string\">'doctype'</span>] = <span class=\"string\">'json'</span></span><br><span class=\"line\">    Form_Data[<span class=\"string\">'xmlVersion'</span>] = <span class=\"string\">'1.8'</span></span><br><span class=\"line\">    Form_Data[<span class=\"string\">'keyfrom'</span>] = <span class=\"string\">'fanyi.web'</span></span><br><span class=\"line\">    Form_Data[<span class=\"string\">'ue'</span>] = <span class=\"string\">'ue:UTF-8'</span></span><br><span class=\"line\">    Form_Data[<span class=\"string\">'action'</span>] = <span class=\"string\">'FY_BY_CLICKBUTTON'</span></span><br><span class=\"line\">    <span class=\"comment\">#使用urlencode方法转换标准格式</span></span><br><span class=\"line\">    data = parse.urlencode(Form_Data).encode(<span class=\"string\">'utf-8'</span>)</span><br><span class=\"line\">    <span class=\"comment\">#传递Request对象和转换完格式的数据</span></span><br><span class=\"line\">    response = request.urlopen(Request_URL,data)</span><br><span class=\"line\">    <span class=\"comment\">#读取信息并解码</span></span><br><span class=\"line\">    html = response.read().decode(<span class=\"string\">'utf-8'</span>)</span><br><span class=\"line\">    <span class=\"comment\">#使用JSON</span></span><br><span class=\"line\">    translate_results = json.loads(html)</span><br><span class=\"line\">    <span class=\"comment\">#找到翻译结果</span></span><br><span class=\"line\">    translate_results = translate_results[<span class=\"string\">'translateResult'</span>][<span class=\"number\">0</span>][<span class=\"number\">0</span>][<span class=\"string\">'tgt'</span>]</span><br><span class=\"line\">    <span class=\"comment\">#打印翻译信息</span></span><br><span class=\"line\">    print(<span class=\"string\">\"翻译的结果是：%s\"</span> % translate_results)</span><br></pre></td></tr></table></figure></p>\n<p>运行查看翻译结果</p>"},{"title":"从零开始学爬虫-03","date":"2018-02-27T16:57:01.000Z","_content":"\n## urllib.error\n\nurllib.error可以接收有urllib.request产生的异常。urllib.error有两个方法，URLError和HTTPError。如下图所示：\n![Screen Shot 2018-02-12 at 14.39.09.png](http://upload-images.jianshu.io/upload_images/2952111-165a6b7bb4f6e5af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nURLError是OSError的一个子类，HTTPError是URLError的一个子类，服务器上HTTP的响应会返回一个状态码，根据这个HTTP状态码，我们可以知道我们的访问是否成功。例如第二个笔记中提到的200状态码，表示请求成功，再比如常见的404错误等。\n<!-- more -->\n\n### (1).URLError\n\n让我们先看下URLError的异常，创建文件urllib_test05.py，编写如下代码：\n```python\n# -*- coding: UTF-8 -*-\nfrom urllib import request\nfrom urllib import error\n\nif __name__ == \"__main__\":\n    #一个不存在的连接\n    url = \"http://www.dskfclyfiydl.com/\"\n    req = request.Request(url)\n    try:\n        response = request.urlopen(req)\n        html = response.read().decode('utf-8')\n        print(html)\n    except error.URLError as e:\n        print(e.reason)\n```\n\n可以看到如下运行结果：\n\n![Screen Shot 2018-02-12 at 14.35.56.png](http://upload-images.jianshu.io/upload_images/2952111-5e9dfdc6af1af203.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### (2).HTTPError\n\n再看下HTTPError异常，创建文件urllib_test06.py，编写如下代码：\n```python\n# -*- coding: UTF-8 -*-\nfrom urllib import request\nfrom urllib import error\n\nif __name__ == \"__main__\":\n    #一个不存在的连接\n    url = \"http://www.douyu.com/wkx.html\"\n    req = request.Request(url)\n    try:\n        responese = request.urlopen(req)\n        # html = responese.read()\n    except error.HTTPError as e:\n        print(e.code, '\\n' ,e.reason, '\\n', e.headers)\n```\n\n运行之后，我们可以看到404，这说明请求的资源没有在服务器上找到，www.douyu.com 这个服务器是存在的，但是我们要查找的 Jack_Cui.html 资源是没有的，所以抛出404异常。\n\n![Screen Shot 2018-02-12 at 14.36.07.png](http://upload-images.jianshu.io/upload_images/2952111-877b52f32e81d2cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### (3).URLError和HTTPError混合使用\n\n最后值得注意的一点是，如果想用HTTPError和URLError一起捕获异常，那么需要将HTTPError放在URLError的前面，因为HTTPError是URLError的一个子类。如果URLError放在前面，出现HTTP异常会先响应URLError，这样HTTPError就捕获不到错误信息了。\n\n![image](http://upload-images.jianshu.io/upload_images/2952111-81c31b50ef0e4f0d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n如果不用上面的方法，也可以使用hasattr函数判断URLError含有的属性，如果含有reason属性表明是URLError，如果含有code属性表明是HTTPError。创建文件urllib_test07.py，编写代码如下：\n```python\n# -*- coding: UTF-8 -*-\nfrom urllib import request\nfrom urllib import error\n\nif __name__ == \"__main__\":\n    #一个不存在的连接\n    url = \"http://www.douyu.com/wkx.html\"\n    req = request.Request(url)\n    try:\n        responese = request.urlopen(req)\n    except error.URLError as e:\n        if hasattr(e, 'code'):\n            print(\"HTTPError\")\n            print(e.code)\n        elif hasattr(e, 'reason'):\n            print(\"URLError\")\n            print(e.reason)\n```\n\n运行结果如下：\n\n![Screen Shot 2018-02-12 at 14.37.39.png](http://upload-images.jianshu.io/upload_images/2952111-9105667f71cd7051.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n","source":"_posts/从零开始学爬虫-03.md","raw":"---\ntitle: 从零开始学爬虫-03\ndate: 2018-02-28 00:57:01\ntags:\n  - Spider\n  - Urllib\n  - Python3\ncategories:\n  - Spider\n  - Urllib\n---\n\n## urllib.error\n\nurllib.error可以接收有urllib.request产生的异常。urllib.error有两个方法，URLError和HTTPError。如下图所示：\n![Screen Shot 2018-02-12 at 14.39.09.png](http://upload-images.jianshu.io/upload_images/2952111-165a6b7bb4f6e5af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nURLError是OSError的一个子类，HTTPError是URLError的一个子类，服务器上HTTP的响应会返回一个状态码，根据这个HTTP状态码，我们可以知道我们的访问是否成功。例如第二个笔记中提到的200状态码，表示请求成功，再比如常见的404错误等。\n<!-- more -->\n\n### (1).URLError\n\n让我们先看下URLError的异常，创建文件urllib_test05.py，编写如下代码：\n```python\n# -*- coding: UTF-8 -*-\nfrom urllib import request\nfrom urllib import error\n\nif __name__ == \"__main__\":\n    #一个不存在的连接\n    url = \"http://www.dskfclyfiydl.com/\"\n    req = request.Request(url)\n    try:\n        response = request.urlopen(req)\n        html = response.read().decode('utf-8')\n        print(html)\n    except error.URLError as e:\n        print(e.reason)\n```\n\n可以看到如下运行结果：\n\n![Screen Shot 2018-02-12 at 14.35.56.png](http://upload-images.jianshu.io/upload_images/2952111-5e9dfdc6af1af203.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### (2).HTTPError\n\n再看下HTTPError异常，创建文件urllib_test06.py，编写如下代码：\n```python\n# -*- coding: UTF-8 -*-\nfrom urllib import request\nfrom urllib import error\n\nif __name__ == \"__main__\":\n    #一个不存在的连接\n    url = \"http://www.douyu.com/wkx.html\"\n    req = request.Request(url)\n    try:\n        responese = request.urlopen(req)\n        # html = responese.read()\n    except error.HTTPError as e:\n        print(e.code, '\\n' ,e.reason, '\\n', e.headers)\n```\n\n运行之后，我们可以看到404，这说明请求的资源没有在服务器上找到，www.douyu.com 这个服务器是存在的，但是我们要查找的 Jack_Cui.html 资源是没有的，所以抛出404异常。\n\n![Screen Shot 2018-02-12 at 14.36.07.png](http://upload-images.jianshu.io/upload_images/2952111-877b52f32e81d2cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### (3).URLError和HTTPError混合使用\n\n最后值得注意的一点是，如果想用HTTPError和URLError一起捕获异常，那么需要将HTTPError放在URLError的前面，因为HTTPError是URLError的一个子类。如果URLError放在前面，出现HTTP异常会先响应URLError，这样HTTPError就捕获不到错误信息了。\n\n![image](http://upload-images.jianshu.io/upload_images/2952111-81c31b50ef0e4f0d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n如果不用上面的方法，也可以使用hasattr函数判断URLError含有的属性，如果含有reason属性表明是URLError，如果含有code属性表明是HTTPError。创建文件urllib_test07.py，编写代码如下：\n```python\n# -*- coding: UTF-8 -*-\nfrom urllib import request\nfrom urllib import error\n\nif __name__ == \"__main__\":\n    #一个不存在的连接\n    url = \"http://www.douyu.com/wkx.html\"\n    req = request.Request(url)\n    try:\n        responese = request.urlopen(req)\n    except error.URLError as e:\n        if hasattr(e, 'code'):\n            print(\"HTTPError\")\n            print(e.code)\n        elif hasattr(e, 'reason'):\n            print(\"URLError\")\n            print(e.reason)\n```\n\n运行结果如下：\n\n![Screen Shot 2018-02-12 at 14.37.39.png](http://upload-images.jianshu.io/upload_images/2952111-9105667f71cd7051.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n","slug":"从零开始学爬虫-03","published":1,"updated":"2018-02-27T17:04:43.829Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozmy005z8mot78iu9n0c","content":"<h2 id=\"urllib-error\"><a href=\"#urllib-error\" class=\"headerlink\" title=\"urllib.error\"></a>urllib.error</h2><p>urllib.error可以接收有urllib.request产生的异常。urllib.error有两个方法，URLError和HTTPError。如下图所示：<br><img src=\"http://upload-images.jianshu.io/upload_images/2952111-165a6b7bb4f6e5af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Screen Shot 2018-02-12 at 14.39.09.png\"></p>\n<p>URLError是OSError的一个子类，HTTPError是URLError的一个子类，服务器上HTTP的响应会返回一个状态码，根据这个HTTP状态码，我们可以知道我们的访问是否成功。例如第二个笔记中提到的200状态码，表示请求成功，再比如常见的404错误等。<br><a id=\"more\"></a></p>\n<h3 id=\"1-URLError\"><a href=\"#1-URLError\" class=\"headerlink\" title=\"(1).URLError\"></a>(1).URLError</h3><p>让我们先看下URLError的异常，创建文件urllib_test05.py，编写如下代码：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> request</span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> error</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    <span class=\"comment\">#一个不存在的连接</span></span><br><span class=\"line\">    url = <span class=\"string\">\"http://www.dskfclyfiydl.com/\"</span></span><br><span class=\"line\">    req = request.Request(url)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        response = request.urlopen(req)</span><br><span class=\"line\">        html = response.read().decode(<span class=\"string\">'utf-8'</span>)</span><br><span class=\"line\">        print(html)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> error.URLError <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        print(e.reason)</span><br></pre></td></tr></table></figure></p>\n<p>可以看到如下运行结果：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-5e9dfdc6af1af203.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Screen Shot 2018-02-12 at 14.35.56.png\"></p>\n<h3 id=\"2-HTTPError\"><a href=\"#2-HTTPError\" class=\"headerlink\" title=\"(2).HTTPError\"></a>(2).HTTPError</h3><p>再看下HTTPError异常，创建文件urllib_test06.py，编写如下代码：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> request</span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> error</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    <span class=\"comment\">#一个不存在的连接</span></span><br><span class=\"line\">    url = <span class=\"string\">\"http://www.douyu.com/wkx.html\"</span></span><br><span class=\"line\">    req = request.Request(url)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        responese = request.urlopen(req)</span><br><span class=\"line\">        <span class=\"comment\"># html = responese.read()</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span> error.HTTPError <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        print(e.code, <span class=\"string\">'\\n'</span> ,e.reason, <span class=\"string\">'\\n'</span>, e.headers)</span><br></pre></td></tr></table></figure></p>\n<p>运行之后，我们可以看到404，这说明请求的资源没有在服务器上找到，<a href=\"http://www.douyu.com\" target=\"_blank\" rel=\"noopener\">www.douyu.com</a> 这个服务器是存在的，但是我们要查找的 Jack_Cui.html 资源是没有的，所以抛出404异常。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-877b52f32e81d2cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Screen Shot 2018-02-12 at 14.36.07.png\"></p>\n<h3 id=\"3-URLError和HTTPError混合使用\"><a href=\"#3-URLError和HTTPError混合使用\" class=\"headerlink\" title=\"(3).URLError和HTTPError混合使用\"></a>(3).URLError和HTTPError混合使用</h3><p>最后值得注意的一点是，如果想用HTTPError和URLError一起捕获异常，那么需要将HTTPError放在URLError的前面，因为HTTPError是URLError的一个子类。如果URLError放在前面，出现HTTP异常会先响应URLError，这样HTTPError就捕获不到错误信息了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-81c31b50ef0e4f0d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>如果不用上面的方法，也可以使用hasattr函数判断URLError含有的属性，如果含有reason属性表明是URLError，如果含有code属性表明是HTTPError。创建文件urllib_test07.py，编写代码如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> request</span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> error</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    <span class=\"comment\">#一个不存在的连接</span></span><br><span class=\"line\">    url = <span class=\"string\">\"http://www.douyu.com/wkx.html\"</span></span><br><span class=\"line\">    req = request.Request(url)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        responese = request.urlopen(req)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> error.URLError <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> hasattr(e, <span class=\"string\">'code'</span>):</span><br><span class=\"line\">            print(<span class=\"string\">\"HTTPError\"</span>)</span><br><span class=\"line\">            print(e.code)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> hasattr(e, <span class=\"string\">'reason'</span>):</span><br><span class=\"line\">            print(<span class=\"string\">\"URLError\"</span>)</span><br><span class=\"line\">            print(e.reason)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-9105667f71cd7051.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Screen Shot 2018-02-12 at 14.37.39.png\"></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"urllib-error\"><a href=\"#urllib-error\" class=\"headerlink\" title=\"urllib.error\"></a>urllib.error</h2><p>urllib.error可以接收有urllib.request产生的异常。urllib.error有两个方法，URLError和HTTPError。如下图所示：<br><img src=\"http://upload-images.jianshu.io/upload_images/2952111-165a6b7bb4f6e5af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Screen Shot 2018-02-12 at 14.39.09.png\"></p>\n<p>URLError是OSError的一个子类，HTTPError是URLError的一个子类，服务器上HTTP的响应会返回一个状态码，根据这个HTTP状态码，我们可以知道我们的访问是否成功。例如第二个笔记中提到的200状态码，表示请求成功，再比如常见的404错误等。<br>","more":"</p>\n<h3 id=\"1-URLError\"><a href=\"#1-URLError\" class=\"headerlink\" title=\"(1).URLError\"></a>(1).URLError</h3><p>让我们先看下URLError的异常，创建文件urllib_test05.py，编写如下代码：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> request</span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> error</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    <span class=\"comment\">#一个不存在的连接</span></span><br><span class=\"line\">    url = <span class=\"string\">\"http://www.dskfclyfiydl.com/\"</span></span><br><span class=\"line\">    req = request.Request(url)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        response = request.urlopen(req)</span><br><span class=\"line\">        html = response.read().decode(<span class=\"string\">'utf-8'</span>)</span><br><span class=\"line\">        print(html)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> error.URLError <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        print(e.reason)</span><br></pre></td></tr></table></figure></p>\n<p>可以看到如下运行结果：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-5e9dfdc6af1af203.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Screen Shot 2018-02-12 at 14.35.56.png\"></p>\n<h3 id=\"2-HTTPError\"><a href=\"#2-HTTPError\" class=\"headerlink\" title=\"(2).HTTPError\"></a>(2).HTTPError</h3><p>再看下HTTPError异常，创建文件urllib_test06.py，编写如下代码：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> request</span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> error</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    <span class=\"comment\">#一个不存在的连接</span></span><br><span class=\"line\">    url = <span class=\"string\">\"http://www.douyu.com/wkx.html\"</span></span><br><span class=\"line\">    req = request.Request(url)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        responese = request.urlopen(req)</span><br><span class=\"line\">        <span class=\"comment\"># html = responese.read()</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span> error.HTTPError <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        print(e.code, <span class=\"string\">'\\n'</span> ,e.reason, <span class=\"string\">'\\n'</span>, e.headers)</span><br></pre></td></tr></table></figure></p>\n<p>运行之后，我们可以看到404，这说明请求的资源没有在服务器上找到，<a href=\"http://www.douyu.com\" target=\"_blank\" rel=\"noopener\">www.douyu.com</a> 这个服务器是存在的，但是我们要查找的 Jack_Cui.html 资源是没有的，所以抛出404异常。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-877b52f32e81d2cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Screen Shot 2018-02-12 at 14.36.07.png\"></p>\n<h3 id=\"3-URLError和HTTPError混合使用\"><a href=\"#3-URLError和HTTPError混合使用\" class=\"headerlink\" title=\"(3).URLError和HTTPError混合使用\"></a>(3).URLError和HTTPError混合使用</h3><p>最后值得注意的一点是，如果想用HTTPError和URLError一起捕获异常，那么需要将HTTPError放在URLError的前面，因为HTTPError是URLError的一个子类。如果URLError放在前面，出现HTTP异常会先响应URLError，这样HTTPError就捕获不到错误信息了。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-81c31b50ef0e4f0d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image\"></p>\n<p>如果不用上面的方法，也可以使用hasattr函数判断URLError含有的属性，如果含有reason属性表明是URLError，如果含有code属性表明是HTTPError。创建文件urllib_test07.py，编写代码如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> request</span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> error</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    <span class=\"comment\">#一个不存在的连接</span></span><br><span class=\"line\">    url = <span class=\"string\">\"http://www.douyu.com/wkx.html\"</span></span><br><span class=\"line\">    req = request.Request(url)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        responese = request.urlopen(req)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> error.URLError <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> hasattr(e, <span class=\"string\">'code'</span>):</span><br><span class=\"line\">            print(<span class=\"string\">\"HTTPError\"</span>)</span><br><span class=\"line\">            print(e.code)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> hasattr(e, <span class=\"string\">'reason'</span>):</span><br><span class=\"line\">            print(<span class=\"string\">\"URLError\"</span>)</span><br><span class=\"line\">            print(e.reason)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2952111-9105667f71cd7051.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Screen Shot 2018-02-12 at 14.37.39.png\"></p>"},{"title":"从零开始学爬虫-04","date":"2018-02-27T17:06:56.000Z","_content":"\n## 说在前面\n\nurllib_test10.py已经无法爬取了，因为原网站已经添加了防爬虫机制\n\n## (一)、为何要设置User Agent\n\n有一些网站不喜欢被爬虫程序访问，所以会检测连接对象，如果是爬虫程序，也就是非人点击访问，它就会不让你继续访问，所以为了要让程序可以正常运行，需要隐藏自己的爬虫程序的身份。此时，我们就可以通过设置User Agent的来达到隐藏身份的目的，User Agent的中文名为用户代理，简称UA。\n\nUser Agent存放于Headers中，服务器就是通过查看Headers中的User Agent来判断是谁在访问。在Python中，如果不设置User Agent，程序将使用默认的参数，那么这个User Agent就会有Python的字样，如果服务器检查User Agent，那么没有设置User Agent的Python程序将无法正常访问网站。\n\nPython允许我们修改这个User Agent来模拟浏览器访问，它的强大毋庸置疑。\n<!-- more -->\n\n## (二)、常见的User Agent\n\n### (1).Android\n\n  - Mozilla/5.0 (Linux; Android 4.1.1; Nexus 7 Build/JRO03D) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.166 Safari/535.19\n  - Mozilla/5.0 (Linux; U; Android 4.0.4; en-gb; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30\n  - Mozilla/5.0 (Linux; U; Android 2.2; en-gb; GT-P1000 Build/FROYO) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1\n\n### (2).Firefox\n\n  - Mozilla/5.0 (Windows NT 6.2; WOW64; rv:21.0) Gecko/20100101 Firefox/21.0\n  - Mozilla/5.0 (Android; Mobile; rv:14.0) Gecko/14.0 Firefox/14.0\n\n### (3).Google Chrome\n\n  - Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.94 Safari/537.36\n  - Mozilla/5.0 (Linux; Android 4.0.4; Galaxy Nexus Build/IMM76B) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.133 Mobile Safari/535.19\n\n### (4).iOS\n\n  - Mozilla/5.0 (iPad; CPU OS 5_0 like Mac OS X) AppleWebKit/534.46 (KHTML, like Gecko) Version/5.1 Mobile/9A334 Safari/7534.48.3\n  - Mozilla/5.0 (iPod; U; CPU like Mac OS X; en) AppleWebKit/420.1 (KHTML, like Gecko) Version/3.0 Mobile/3A101a Safari/419.3\n\n上面列举了Andriod、Firefox、Google Chrome、iOS的一些User Agent，直接copy就能用。\n\n## (三)、设置User Agent的方法\n\n先看下urllib.request.Request()\n\n ![1](http://img.blog.csdn.net/20170303123244632?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n从上图可以看出，在创建Request对象的时候，可以传入headers参数。因此，想要设置User Agent，有两种方法：\n\n- 1.在创建Request对象的时候，填入headers参数(包含User Agent信息)，这个Headers参数要求为字典；\n\n- 2.在创建Request对象的时候不添加headers参数，在创建完成之后，使用add_header()的方法，添加headers。\n\n### 方法一\n\n创建文件urllib_test08.py，使用上面提到的Android的第一个User Agent，在创建Request对象的时候传入headers参数，编写代码如下：\n```python\n# -*- coding: UTF-8 -*-\nfrom urllib import request\n\nif __name__ == \"__main__\":\n    url = 'http://www.csdn.net/'\n    head = {}\n    #写入User Agent信息\n    head['User-Agent'] = 'Mozilla/5.0 (Linux; Android 4.1.1; Nexus 7 Build/JRO03D) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.166  Safari/535.19'\n    #创建Request对象\n    req = request.Request(url, headers=head)\n    #传入创建好的Request对象\n    response = request.urlopen(req)\n    #读取响应信息并解码\n    html = response.read().decode('utf-8')\n    #打印信息\n    print(html)\n```\n\n运行结果如下：\n\n ![2](http://img.blog.csdn.net/20170303123738649?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n### 方法二\n\n创建文件urllib_test09.py，使用上面提到的Android的第一个User Agent，在创建Request对象时不传入headers参数，创建之后使用add_header()方法，添加headers，编写代码如下：\n```Python\n# -*- coding: UTF-8 -*-\nfrom urllib import request\n\nif __name__ == \"__main__\":\n    #以CSDN为例，CSDN不更改User Agent是无法访问的\n    url = 'http://www.csdn.net/'\n    #创建Request对象\n    req = request.Request(url)\n    #传入headers\n    req.add_header('User-Agent', 'Mozilla/5.0 (Linux; Android 4.1.1; Nexus 7 Build/JRO03D) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.166  Safari/535.19')\n    #传入创建好的Request对象\n    response = request.urlopen(req)\n    #读取响应信息并解码\n    html = response.read().decode('utf-8')\n    #打印信息\n    print(html)\n```\n\n运行结果和上一个方法是一样的。\n\n## (四)、IP代理的使用\n\n### (1).为何使用IP代理\n\nUser Agent已经设置好了，但是还应该考虑一个问题，程序的运行速度是很快的，如果我们利用一个爬虫程序在网站爬取东西，一个固定IP的访问频率就会很高，这不符合人为操作的标准，因为人操作不可能在几ms内，进行如此频繁的访问。所以一些网站会设置一个IP访问频率的阈值，如果一个IP访问频率超过这个阈值，说明这个不是人在访问，而是一个爬虫程序。\n\n### (2).一般步骤说明\n\n一个很简单的解决办法就是设置延时，但是这显然不符合爬虫快速爬取信息的目的，所以另一种更好的方法就是使用IP代理。使用代理的步骤：\n\n**(1)** 调用urlib.request.ProxyHandler()，proxies参数为一个字典。\n\n ![4](http://img.blog.csdn.net/20170303124421012?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n**(2)** 创建Opener(类似于urlopen，这个代开方式是我们自己定制的)\n\n![5](http://img.blog.csdn.net/20170303124447169?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n**(3)** 安装Opener\n\n![引用容](http://img.blog.csdn.net/20170303124507044?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n使用install_opener方法之后，会将程序默认的urlopen方法替换掉。也就是说，如果使用install_opener之后，在该文件中，再次调用urlopen会使用自己创建好的opener。如果不想替换掉，只是想临时使用一下，可以使用opener.open(url)，这样就不会对程序默认的urlopen有影响。\n\n### (3).代理IP选取\n\n在写代码之前，先在代理IP网站选好一个IP地址，推荐西刺代理IP。\n\nURL：[http://www.xicidaili.com/](http://www.xicidaili.com/)\n\n注意：当然也可以写个正则表达式从网站直接爬取IP，但是要记住不要太频繁爬取，加个延时什么的，太频繁给服务器带来压力了，服务器会直接把你block，不让你访问的，我就被封了两天。\n\n从西刺网站选出信号好的IP，我的选择如下：(106.46.136.112:808)\n\n ![6](http://img.blog.csdn.net/20170303124651091?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n编写代码访问[http://www.whatismyip.com.tw/](http://www.whatismyip.com.tw/)，该网站是测试自己IP为多少的网址，服务器会返回访问者的IP。\n\n### (4).代码实例\n\n创建文件urllib_test10.py，编写代码如下：\n```python\n# -*- coding: UTF-8 -*-\nfrom urllib import request\n\nif __name__ == \"__main__\":\n    #访问网址\n    url = 'http://www.whatismyip.com.tw/'\n    #这是代理IP\n    proxy = {'http':'106.46.136.112:808'}\n    #创建ProxyHandler\n    proxy_support = request.ProxyHandler(proxy)\n    #创建Opener\n    opener = request.build_opener(proxy_support)\n    #添加User Angent\n    opener.addheaders = [('User-Agent','Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36')]\n    #安装OPener\n    request.install_opener(opener)\n    #使用自己安装好的Opener\n    response = request.urlopen(url)\n    #读取相应信息并解码\n    html = response.read().decode(\"utf-8\")\n    #打印信息\n    print(html)\n```\n\n运行结果如下：\n![7](http://img.blog.csdn.net/20170303124823038?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n从上图可以看出，访问的IP已经伪装成了106.46.136.112。\n","source":"_posts/从零开始学爬虫-04.md","raw":"---\ntitle: 从零开始学爬虫-04\ndate: 2018-02-28 01:06:56\ntags:\n  - Spider\n  - Urllib\n  - Python3\ncategories:\n  - Spider\n  - Urllib\n---\n\n## 说在前面\n\nurllib_test10.py已经无法爬取了，因为原网站已经添加了防爬虫机制\n\n## (一)、为何要设置User Agent\n\n有一些网站不喜欢被爬虫程序访问，所以会检测连接对象，如果是爬虫程序，也就是非人点击访问，它就会不让你继续访问，所以为了要让程序可以正常运行，需要隐藏自己的爬虫程序的身份。此时，我们就可以通过设置User Agent的来达到隐藏身份的目的，User Agent的中文名为用户代理，简称UA。\n\nUser Agent存放于Headers中，服务器就是通过查看Headers中的User Agent来判断是谁在访问。在Python中，如果不设置User Agent，程序将使用默认的参数，那么这个User Agent就会有Python的字样，如果服务器检查User Agent，那么没有设置User Agent的Python程序将无法正常访问网站。\n\nPython允许我们修改这个User Agent来模拟浏览器访问，它的强大毋庸置疑。\n<!-- more -->\n\n## (二)、常见的User Agent\n\n### (1).Android\n\n  - Mozilla/5.0 (Linux; Android 4.1.1; Nexus 7 Build/JRO03D) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.166 Safari/535.19\n  - Mozilla/5.0 (Linux; U; Android 4.0.4; en-gb; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30\n  - Mozilla/5.0 (Linux; U; Android 2.2; en-gb; GT-P1000 Build/FROYO) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1\n\n### (2).Firefox\n\n  - Mozilla/5.0 (Windows NT 6.2; WOW64; rv:21.0) Gecko/20100101 Firefox/21.0\n  - Mozilla/5.0 (Android; Mobile; rv:14.0) Gecko/14.0 Firefox/14.0\n\n### (3).Google Chrome\n\n  - Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.94 Safari/537.36\n  - Mozilla/5.0 (Linux; Android 4.0.4; Galaxy Nexus Build/IMM76B) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.133 Mobile Safari/535.19\n\n### (4).iOS\n\n  - Mozilla/5.0 (iPad; CPU OS 5_0 like Mac OS X) AppleWebKit/534.46 (KHTML, like Gecko) Version/5.1 Mobile/9A334 Safari/7534.48.3\n  - Mozilla/5.0 (iPod; U; CPU like Mac OS X; en) AppleWebKit/420.1 (KHTML, like Gecko) Version/3.0 Mobile/3A101a Safari/419.3\n\n上面列举了Andriod、Firefox、Google Chrome、iOS的一些User Agent，直接copy就能用。\n\n## (三)、设置User Agent的方法\n\n先看下urllib.request.Request()\n\n ![1](http://img.blog.csdn.net/20170303123244632?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n从上图可以看出，在创建Request对象的时候，可以传入headers参数。因此，想要设置User Agent，有两种方法：\n\n- 1.在创建Request对象的时候，填入headers参数(包含User Agent信息)，这个Headers参数要求为字典；\n\n- 2.在创建Request对象的时候不添加headers参数，在创建完成之后，使用add_header()的方法，添加headers。\n\n### 方法一\n\n创建文件urllib_test08.py，使用上面提到的Android的第一个User Agent，在创建Request对象的时候传入headers参数，编写代码如下：\n```python\n# -*- coding: UTF-8 -*-\nfrom urllib import request\n\nif __name__ == \"__main__\":\n    url = 'http://www.csdn.net/'\n    head = {}\n    #写入User Agent信息\n    head['User-Agent'] = 'Mozilla/5.0 (Linux; Android 4.1.1; Nexus 7 Build/JRO03D) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.166  Safari/535.19'\n    #创建Request对象\n    req = request.Request(url, headers=head)\n    #传入创建好的Request对象\n    response = request.urlopen(req)\n    #读取响应信息并解码\n    html = response.read().decode('utf-8')\n    #打印信息\n    print(html)\n```\n\n运行结果如下：\n\n ![2](http://img.blog.csdn.net/20170303123738649?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n### 方法二\n\n创建文件urllib_test09.py，使用上面提到的Android的第一个User Agent，在创建Request对象时不传入headers参数，创建之后使用add_header()方法，添加headers，编写代码如下：\n```Python\n# -*- coding: UTF-8 -*-\nfrom urllib import request\n\nif __name__ == \"__main__\":\n    #以CSDN为例，CSDN不更改User Agent是无法访问的\n    url = 'http://www.csdn.net/'\n    #创建Request对象\n    req = request.Request(url)\n    #传入headers\n    req.add_header('User-Agent', 'Mozilla/5.0 (Linux; Android 4.1.1; Nexus 7 Build/JRO03D) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.166  Safari/535.19')\n    #传入创建好的Request对象\n    response = request.urlopen(req)\n    #读取响应信息并解码\n    html = response.read().decode('utf-8')\n    #打印信息\n    print(html)\n```\n\n运行结果和上一个方法是一样的。\n\n## (四)、IP代理的使用\n\n### (1).为何使用IP代理\n\nUser Agent已经设置好了，但是还应该考虑一个问题，程序的运行速度是很快的，如果我们利用一个爬虫程序在网站爬取东西，一个固定IP的访问频率就会很高，这不符合人为操作的标准，因为人操作不可能在几ms内，进行如此频繁的访问。所以一些网站会设置一个IP访问频率的阈值，如果一个IP访问频率超过这个阈值，说明这个不是人在访问，而是一个爬虫程序。\n\n### (2).一般步骤说明\n\n一个很简单的解决办法就是设置延时，但是这显然不符合爬虫快速爬取信息的目的，所以另一种更好的方法就是使用IP代理。使用代理的步骤：\n\n**(1)** 调用urlib.request.ProxyHandler()，proxies参数为一个字典。\n\n ![4](http://img.blog.csdn.net/20170303124421012?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n**(2)** 创建Opener(类似于urlopen，这个代开方式是我们自己定制的)\n\n![5](http://img.blog.csdn.net/20170303124447169?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n**(3)** 安装Opener\n\n![引用容](http://img.blog.csdn.net/20170303124507044?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n使用install_opener方法之后，会将程序默认的urlopen方法替换掉。也就是说，如果使用install_opener之后，在该文件中，再次调用urlopen会使用自己创建好的opener。如果不想替换掉，只是想临时使用一下，可以使用opener.open(url)，这样就不会对程序默认的urlopen有影响。\n\n### (3).代理IP选取\n\n在写代码之前，先在代理IP网站选好一个IP地址，推荐西刺代理IP。\n\nURL：[http://www.xicidaili.com/](http://www.xicidaili.com/)\n\n注意：当然也可以写个正则表达式从网站直接爬取IP，但是要记住不要太频繁爬取，加个延时什么的，太频繁给服务器带来压力了，服务器会直接把你block，不让你访问的，我就被封了两天。\n\n从西刺网站选出信号好的IP，我的选择如下：(106.46.136.112:808)\n\n ![6](http://img.blog.csdn.net/20170303124651091?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n编写代码访问[http://www.whatismyip.com.tw/](http://www.whatismyip.com.tw/)，该网站是测试自己IP为多少的网址，服务器会返回访问者的IP。\n\n### (4).代码实例\n\n创建文件urllib_test10.py，编写代码如下：\n```python\n# -*- coding: UTF-8 -*-\nfrom urllib import request\n\nif __name__ == \"__main__\":\n    #访问网址\n    url = 'http://www.whatismyip.com.tw/'\n    #这是代理IP\n    proxy = {'http':'106.46.136.112:808'}\n    #创建ProxyHandler\n    proxy_support = request.ProxyHandler(proxy)\n    #创建Opener\n    opener = request.build_opener(proxy_support)\n    #添加User Angent\n    opener.addheaders = [('User-Agent','Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36')]\n    #安装OPener\n    request.install_opener(opener)\n    #使用自己安装好的Opener\n    response = request.urlopen(url)\n    #读取相应信息并解码\n    html = response.read().decode(\"utf-8\")\n    #打印信息\n    print(html)\n```\n\n运行结果如下：\n![7](http://img.blog.csdn.net/20170303124823038?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n从上图可以看出，访问的IP已经伪装成了106.46.136.112。\n","slug":"从零开始学爬虫-04","published":1,"updated":"2018-02-27T17:18:25.138Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozn100648motvfam25zy","content":"<h2 id=\"说在前面\"><a href=\"#说在前面\" class=\"headerlink\" title=\"说在前面\"></a>说在前面</h2><p>urllib_test10.py已经无法爬取了，因为原网站已经添加了防爬虫机制</p>\n<h2 id=\"一-、为何要设置User-Agent\"><a href=\"#一-、为何要设置User-Agent\" class=\"headerlink\" title=\"(一)、为何要设置User Agent\"></a>(一)、为何要设置User Agent</h2><p>有一些网站不喜欢被爬虫程序访问，所以会检测连接对象，如果是爬虫程序，也就是非人点击访问，它就会不让你继续访问，所以为了要让程序可以正常运行，需要隐藏自己的爬虫程序的身份。此时，我们就可以通过设置User Agent的来达到隐藏身份的目的，User Agent的中文名为用户代理，简称UA。</p>\n<p>User Agent存放于Headers中，服务器就是通过查看Headers中的User Agent来判断是谁在访问。在Python中，如果不设置User Agent，程序将使用默认的参数，那么这个User Agent就会有Python的字样，如果服务器检查User Agent，那么没有设置User Agent的Python程序将无法正常访问网站。</p>\n<p>Python允许我们修改这个User Agent来模拟浏览器访问，它的强大毋庸置疑。<br><a id=\"more\"></a></p>\n<h2 id=\"二-、常见的User-Agent\"><a href=\"#二-、常见的User-Agent\" class=\"headerlink\" title=\"(二)、常见的User Agent\"></a>(二)、常见的User Agent</h2><h3 id=\"1-Android\"><a href=\"#1-Android\" class=\"headerlink\" title=\"(1).Android\"></a>(1).Android</h3><ul>\n<li>Mozilla/5.0 (Linux; Android 4.1.1; Nexus 7 Build/JRO03D) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.166 Safari/535.19</li>\n<li>Mozilla/5.0 (Linux; U; Android 4.0.4; en-gb; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30</li>\n<li>Mozilla/5.0 (Linux; U; Android 2.2; en-gb; GT-P1000 Build/FROYO) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1</li>\n</ul>\n<h3 id=\"2-Firefox\"><a href=\"#2-Firefox\" class=\"headerlink\" title=\"(2).Firefox\"></a>(2).Firefox</h3><ul>\n<li>Mozilla/5.0 (Windows NT 6.2; WOW64; rv:21.0) Gecko/20100101 Firefox/21.0</li>\n<li>Mozilla/5.0 (Android; Mobile; rv:14.0) Gecko/14.0 Firefox/14.0</li>\n</ul>\n<h3 id=\"3-Google-Chrome\"><a href=\"#3-Google-Chrome\" class=\"headerlink\" title=\"(3).Google Chrome\"></a>(3).Google Chrome</h3><ul>\n<li>Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.94 Safari/537.36</li>\n<li>Mozilla/5.0 (Linux; Android 4.0.4; Galaxy Nexus Build/IMM76B) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.133 Mobile Safari/535.19</li>\n</ul>\n<h3 id=\"4-iOS\"><a href=\"#4-iOS\" class=\"headerlink\" title=\"(4).iOS\"></a>(4).iOS</h3><ul>\n<li>Mozilla/5.0 (iPad; CPU OS 5_0 like Mac OS X) AppleWebKit/534.46 (KHTML, like Gecko) Version/5.1 Mobile/9A334 Safari/7534.48.3</li>\n<li>Mozilla/5.0 (iPod; U; CPU like Mac OS X; en) AppleWebKit/420.1 (KHTML, like Gecko) Version/3.0 Mobile/3A101a Safari/419.3</li>\n</ul>\n<p>上面列举了Andriod、Firefox、Google Chrome、iOS的一些User Agent，直接copy就能用。</p>\n<h2 id=\"三-、设置User-Agent的方法\"><a href=\"#三-、设置User-Agent的方法\" class=\"headerlink\" title=\"(三)、设置User Agent的方法\"></a>(三)、设置User Agent的方法</h2><p>先看下urllib.request.Request()</p>\n<p> <img src=\"http://img.blog.csdn.net/20170303123244632?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"1\"></p>\n<p>从上图可以看出，在创建Request对象的时候，可以传入headers参数。因此，想要设置User Agent，有两种方法：</p>\n<ul>\n<li><p>1.在创建Request对象的时候，填入headers参数(包含User Agent信息)，这个Headers参数要求为字典；</p>\n</li>\n<li><p>2.在创建Request对象的时候不添加headers参数，在创建完成之后，使用add_header()的方法，添加headers。</p>\n</li>\n</ul>\n<h3 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h3><p>创建文件urllib_test08.py，使用上面提到的Android的第一个User Agent，在创建Request对象的时候传入headers参数，编写代码如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> request</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    url = <span class=\"string\">'http://www.csdn.net/'</span></span><br><span class=\"line\">    head = &#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">#写入User Agent信息</span></span><br><span class=\"line\">    head[<span class=\"string\">'User-Agent'</span>] = <span class=\"string\">'Mozilla/5.0 (Linux; Android 4.1.1; Nexus 7 Build/JRO03D) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.166  Safari/535.19'</span></span><br><span class=\"line\">    <span class=\"comment\">#创建Request对象</span></span><br><span class=\"line\">    req = request.Request(url, headers=head)</span><br><span class=\"line\">    <span class=\"comment\">#传入创建好的Request对象</span></span><br><span class=\"line\">    response = request.urlopen(req)</span><br><span class=\"line\">    <span class=\"comment\">#读取响应信息并解码</span></span><br><span class=\"line\">    html = response.read().decode(<span class=\"string\">'utf-8'</span>)</span><br><span class=\"line\">    <span class=\"comment\">#打印信息</span></span><br><span class=\"line\">    print(html)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：</p>\n<p> <img src=\"http://img.blog.csdn.net/20170303123738649?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"2\"></p>\n<h3 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h3><p>创建文件urllib_test09.py，使用上面提到的Android的第一个User Agent，在创建Request对象时不传入headers参数，创建之后使用add_header()方法，添加headers，编写代码如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> request</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    <span class=\"comment\">#以CSDN为例，CSDN不更改User Agent是无法访问的</span></span><br><span class=\"line\">    url = <span class=\"string\">'http://www.csdn.net/'</span></span><br><span class=\"line\">    <span class=\"comment\">#创建Request对象</span></span><br><span class=\"line\">    req = request.Request(url)</span><br><span class=\"line\">    <span class=\"comment\">#传入headers</span></span><br><span class=\"line\">    req.add_header(<span class=\"string\">'User-Agent'</span>, <span class=\"string\">'Mozilla/5.0 (Linux; Android 4.1.1; Nexus 7 Build/JRO03D) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.166  Safari/535.19'</span>)</span><br><span class=\"line\">    <span class=\"comment\">#传入创建好的Request对象</span></span><br><span class=\"line\">    response = request.urlopen(req)</span><br><span class=\"line\">    <span class=\"comment\">#读取响应信息并解码</span></span><br><span class=\"line\">    html = response.read().decode(<span class=\"string\">'utf-8'</span>)</span><br><span class=\"line\">    <span class=\"comment\">#打印信息</span></span><br><span class=\"line\">    print(html)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果和上一个方法是一样的。</p>\n<h2 id=\"四-、IP代理的使用\"><a href=\"#四-、IP代理的使用\" class=\"headerlink\" title=\"(四)、IP代理的使用\"></a>(四)、IP代理的使用</h2><h3 id=\"1-为何使用IP代理\"><a href=\"#1-为何使用IP代理\" class=\"headerlink\" title=\"(1).为何使用IP代理\"></a>(1).为何使用IP代理</h3><p>User Agent已经设置好了，但是还应该考虑一个问题，程序的运行速度是很快的，如果我们利用一个爬虫程序在网站爬取东西，一个固定IP的访问频率就会很高，这不符合人为操作的标准，因为人操作不可能在几ms内，进行如此频繁的访问。所以一些网站会设置一个IP访问频率的阈值，如果一个IP访问频率超过这个阈值，说明这个不是人在访问，而是一个爬虫程序。</p>\n<h3 id=\"2-一般步骤说明\"><a href=\"#2-一般步骤说明\" class=\"headerlink\" title=\"(2).一般步骤说明\"></a>(2).一般步骤说明</h3><p>一个很简单的解决办法就是设置延时，但是这显然不符合爬虫快速爬取信息的目的，所以另一种更好的方法就是使用IP代理。使用代理的步骤：</p>\n<p><strong>(1)</strong> 调用urlib.request.ProxyHandler()，proxies参数为一个字典。</p>\n<p> <img src=\"http://img.blog.csdn.net/20170303124421012?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"4\"></p>\n<p><strong>(2)</strong> 创建Opener(类似于urlopen，这个代开方式是我们自己定制的)</p>\n<p><img src=\"http://img.blog.csdn.net/20170303124447169?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"5\"></p>\n<p><strong>(3)</strong> 安装Opener</p>\n<p><img src=\"http://img.blog.csdn.net/20170303124507044?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"引用容\"></p>\n<p>使用install_opener方法之后，会将程序默认的urlopen方法替换掉。也就是说，如果使用install_opener之后，在该文件中，再次调用urlopen会使用自己创建好的opener。如果不想替换掉，只是想临时使用一下，可以使用opener.open(url)，这样就不会对程序默认的urlopen有影响。</p>\n<h3 id=\"3-代理IP选取\"><a href=\"#3-代理IP选取\" class=\"headerlink\" title=\"(3).代理IP选取\"></a>(3).代理IP选取</h3><p>在写代码之前，先在代理IP网站选好一个IP地址，推荐西刺代理IP。</p>\n<p>URL：<a href=\"http://www.xicidaili.com/\" target=\"_blank\" rel=\"noopener\">http://www.xicidaili.com/</a></p>\n<p>注意：当然也可以写个正则表达式从网站直接爬取IP，但是要记住不要太频繁爬取，加个延时什么的，太频繁给服务器带来压力了，服务器会直接把你block，不让你访问的，我就被封了两天。</p>\n<p>从西刺网站选出信号好的IP，我的选择如下：(106.46.136.112:808)</p>\n<p> <img src=\"http://img.blog.csdn.net/20170303124651091?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"6\"></p>\n<p>编写代码访问<a href=\"http://www.whatismyip.com.tw/\" target=\"_blank\" rel=\"noopener\">http://www.whatismyip.com.tw/</a>，该网站是测试自己IP为多少的网址，服务器会返回访问者的IP。</p>\n<h3 id=\"4-代码实例\"><a href=\"#4-代码实例\" class=\"headerlink\" title=\"(4).代码实例\"></a>(4).代码实例</h3><p>创建文件urllib_test10.py，编写代码如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> request</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    <span class=\"comment\">#访问网址</span></span><br><span class=\"line\">    url = <span class=\"string\">'http://www.whatismyip.com.tw/'</span></span><br><span class=\"line\">    <span class=\"comment\">#这是代理IP</span></span><br><span class=\"line\">    proxy = &#123;<span class=\"string\">'http'</span>:<span class=\"string\">'106.46.136.112:808'</span>&#125;</span><br><span class=\"line\">    <span class=\"comment\">#创建ProxyHandler</span></span><br><span class=\"line\">    proxy_support = request.ProxyHandler(proxy)</span><br><span class=\"line\">    <span class=\"comment\">#创建Opener</span></span><br><span class=\"line\">    opener = request.build_opener(proxy_support)</span><br><span class=\"line\">    <span class=\"comment\">#添加User Angent</span></span><br><span class=\"line\">    opener.addheaders = [(<span class=\"string\">'User-Agent'</span>,<span class=\"string\">'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36'</span>)]</span><br><span class=\"line\">    <span class=\"comment\">#安装OPener</span></span><br><span class=\"line\">    request.install_opener(opener)</span><br><span class=\"line\">    <span class=\"comment\">#使用自己安装好的Opener</span></span><br><span class=\"line\">    response = request.urlopen(url)</span><br><span class=\"line\">    <span class=\"comment\">#读取相应信息并解码</span></span><br><span class=\"line\">    html = response.read().decode(<span class=\"string\">\"utf-8\"</span>)</span><br><span class=\"line\">    <span class=\"comment\">#打印信息</span></span><br><span class=\"line\">    print(html)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><img src=\"http://img.blog.csdn.net/20170303124823038?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"7\"></p>\n<p>从上图可以看出，访问的IP已经伪装成了106.46.136.112。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"说在前面\"><a href=\"#说在前面\" class=\"headerlink\" title=\"说在前面\"></a>说在前面</h2><p>urllib_test10.py已经无法爬取了，因为原网站已经添加了防爬虫机制</p>\n<h2 id=\"一-、为何要设置User-Agent\"><a href=\"#一-、为何要设置User-Agent\" class=\"headerlink\" title=\"(一)、为何要设置User Agent\"></a>(一)、为何要设置User Agent</h2><p>有一些网站不喜欢被爬虫程序访问，所以会检测连接对象，如果是爬虫程序，也就是非人点击访问，它就会不让你继续访问，所以为了要让程序可以正常运行，需要隐藏自己的爬虫程序的身份。此时，我们就可以通过设置User Agent的来达到隐藏身份的目的，User Agent的中文名为用户代理，简称UA。</p>\n<p>User Agent存放于Headers中，服务器就是通过查看Headers中的User Agent来判断是谁在访问。在Python中，如果不设置User Agent，程序将使用默认的参数，那么这个User Agent就会有Python的字样，如果服务器检查User Agent，那么没有设置User Agent的Python程序将无法正常访问网站。</p>\n<p>Python允许我们修改这个User Agent来模拟浏览器访问，它的强大毋庸置疑。<br>","more":"</p>\n<h2 id=\"二-、常见的User-Agent\"><a href=\"#二-、常见的User-Agent\" class=\"headerlink\" title=\"(二)、常见的User Agent\"></a>(二)、常见的User Agent</h2><h3 id=\"1-Android\"><a href=\"#1-Android\" class=\"headerlink\" title=\"(1).Android\"></a>(1).Android</h3><ul>\n<li>Mozilla/5.0 (Linux; Android 4.1.1; Nexus 7 Build/JRO03D) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.166 Safari/535.19</li>\n<li>Mozilla/5.0 (Linux; U; Android 4.0.4; en-gb; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30</li>\n<li>Mozilla/5.0 (Linux; U; Android 2.2; en-gb; GT-P1000 Build/FROYO) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1</li>\n</ul>\n<h3 id=\"2-Firefox\"><a href=\"#2-Firefox\" class=\"headerlink\" title=\"(2).Firefox\"></a>(2).Firefox</h3><ul>\n<li>Mozilla/5.0 (Windows NT 6.2; WOW64; rv:21.0) Gecko/20100101 Firefox/21.0</li>\n<li>Mozilla/5.0 (Android; Mobile; rv:14.0) Gecko/14.0 Firefox/14.0</li>\n</ul>\n<h3 id=\"3-Google-Chrome\"><a href=\"#3-Google-Chrome\" class=\"headerlink\" title=\"(3).Google Chrome\"></a>(3).Google Chrome</h3><ul>\n<li>Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.94 Safari/537.36</li>\n<li>Mozilla/5.0 (Linux; Android 4.0.4; Galaxy Nexus Build/IMM76B) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.133 Mobile Safari/535.19</li>\n</ul>\n<h3 id=\"4-iOS\"><a href=\"#4-iOS\" class=\"headerlink\" title=\"(4).iOS\"></a>(4).iOS</h3><ul>\n<li>Mozilla/5.0 (iPad; CPU OS 5_0 like Mac OS X) AppleWebKit/534.46 (KHTML, like Gecko) Version/5.1 Mobile/9A334 Safari/7534.48.3</li>\n<li>Mozilla/5.0 (iPod; U; CPU like Mac OS X; en) AppleWebKit/420.1 (KHTML, like Gecko) Version/3.0 Mobile/3A101a Safari/419.3</li>\n</ul>\n<p>上面列举了Andriod、Firefox、Google Chrome、iOS的一些User Agent，直接copy就能用。</p>\n<h2 id=\"三-、设置User-Agent的方法\"><a href=\"#三-、设置User-Agent的方法\" class=\"headerlink\" title=\"(三)、设置User Agent的方法\"></a>(三)、设置User Agent的方法</h2><p>先看下urllib.request.Request()</p>\n<p> <img src=\"http://img.blog.csdn.net/20170303123244632?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"1\"></p>\n<p>从上图可以看出，在创建Request对象的时候，可以传入headers参数。因此，想要设置User Agent，有两种方法：</p>\n<ul>\n<li><p>1.在创建Request对象的时候，填入headers参数(包含User Agent信息)，这个Headers参数要求为字典；</p>\n</li>\n<li><p>2.在创建Request对象的时候不添加headers参数，在创建完成之后，使用add_header()的方法，添加headers。</p>\n</li>\n</ul>\n<h3 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h3><p>创建文件urllib_test08.py，使用上面提到的Android的第一个User Agent，在创建Request对象的时候传入headers参数，编写代码如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> request</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    url = <span class=\"string\">'http://www.csdn.net/'</span></span><br><span class=\"line\">    head = &#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">#写入User Agent信息</span></span><br><span class=\"line\">    head[<span class=\"string\">'User-Agent'</span>] = <span class=\"string\">'Mozilla/5.0 (Linux; Android 4.1.1; Nexus 7 Build/JRO03D) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.166  Safari/535.19'</span></span><br><span class=\"line\">    <span class=\"comment\">#创建Request对象</span></span><br><span class=\"line\">    req = request.Request(url, headers=head)</span><br><span class=\"line\">    <span class=\"comment\">#传入创建好的Request对象</span></span><br><span class=\"line\">    response = request.urlopen(req)</span><br><span class=\"line\">    <span class=\"comment\">#读取响应信息并解码</span></span><br><span class=\"line\">    html = response.read().decode(<span class=\"string\">'utf-8'</span>)</span><br><span class=\"line\">    <span class=\"comment\">#打印信息</span></span><br><span class=\"line\">    print(html)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：</p>\n<p> <img src=\"http://img.blog.csdn.net/20170303123738649?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"2\"></p>\n<h3 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h3><p>创建文件urllib_test09.py，使用上面提到的Android的第一个User Agent，在创建Request对象时不传入headers参数，创建之后使用add_header()方法，添加headers，编写代码如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> request</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    <span class=\"comment\">#以CSDN为例，CSDN不更改User Agent是无法访问的</span></span><br><span class=\"line\">    url = <span class=\"string\">'http://www.csdn.net/'</span></span><br><span class=\"line\">    <span class=\"comment\">#创建Request对象</span></span><br><span class=\"line\">    req = request.Request(url)</span><br><span class=\"line\">    <span class=\"comment\">#传入headers</span></span><br><span class=\"line\">    req.add_header(<span class=\"string\">'User-Agent'</span>, <span class=\"string\">'Mozilla/5.0 (Linux; Android 4.1.1; Nexus 7 Build/JRO03D) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.166  Safari/535.19'</span>)</span><br><span class=\"line\">    <span class=\"comment\">#传入创建好的Request对象</span></span><br><span class=\"line\">    response = request.urlopen(req)</span><br><span class=\"line\">    <span class=\"comment\">#读取响应信息并解码</span></span><br><span class=\"line\">    html = response.read().decode(<span class=\"string\">'utf-8'</span>)</span><br><span class=\"line\">    <span class=\"comment\">#打印信息</span></span><br><span class=\"line\">    print(html)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果和上一个方法是一样的。</p>\n<h2 id=\"四-、IP代理的使用\"><a href=\"#四-、IP代理的使用\" class=\"headerlink\" title=\"(四)、IP代理的使用\"></a>(四)、IP代理的使用</h2><h3 id=\"1-为何使用IP代理\"><a href=\"#1-为何使用IP代理\" class=\"headerlink\" title=\"(1).为何使用IP代理\"></a>(1).为何使用IP代理</h3><p>User Agent已经设置好了，但是还应该考虑一个问题，程序的运行速度是很快的，如果我们利用一个爬虫程序在网站爬取东西，一个固定IP的访问频率就会很高，这不符合人为操作的标准，因为人操作不可能在几ms内，进行如此频繁的访问。所以一些网站会设置一个IP访问频率的阈值，如果一个IP访问频率超过这个阈值，说明这个不是人在访问，而是一个爬虫程序。</p>\n<h3 id=\"2-一般步骤说明\"><a href=\"#2-一般步骤说明\" class=\"headerlink\" title=\"(2).一般步骤说明\"></a>(2).一般步骤说明</h3><p>一个很简单的解决办法就是设置延时，但是这显然不符合爬虫快速爬取信息的目的，所以另一种更好的方法就是使用IP代理。使用代理的步骤：</p>\n<p><strong>(1)</strong> 调用urlib.request.ProxyHandler()，proxies参数为一个字典。</p>\n<p> <img src=\"http://img.blog.csdn.net/20170303124421012?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"4\"></p>\n<p><strong>(2)</strong> 创建Opener(类似于urlopen，这个代开方式是我们自己定制的)</p>\n<p><img src=\"http://img.blog.csdn.net/20170303124447169?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"5\"></p>\n<p><strong>(3)</strong> 安装Opener</p>\n<p><img src=\"http://img.blog.csdn.net/20170303124507044?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"引用容\"></p>\n<p>使用install_opener方法之后，会将程序默认的urlopen方法替换掉。也就是说，如果使用install_opener之后，在该文件中，再次调用urlopen会使用自己创建好的opener。如果不想替换掉，只是想临时使用一下，可以使用opener.open(url)，这样就不会对程序默认的urlopen有影响。</p>\n<h3 id=\"3-代理IP选取\"><a href=\"#3-代理IP选取\" class=\"headerlink\" title=\"(3).代理IP选取\"></a>(3).代理IP选取</h3><p>在写代码之前，先在代理IP网站选好一个IP地址，推荐西刺代理IP。</p>\n<p>URL：<a href=\"http://www.xicidaili.com/\" target=\"_blank\" rel=\"noopener\">http://www.xicidaili.com/</a></p>\n<p>注意：当然也可以写个正则表达式从网站直接爬取IP，但是要记住不要太频繁爬取，加个延时什么的，太频繁给服务器带来压力了，服务器会直接把你block，不让你访问的，我就被封了两天。</p>\n<p>从西刺网站选出信号好的IP，我的选择如下：(106.46.136.112:808)</p>\n<p> <img src=\"http://img.blog.csdn.net/20170303124651091?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"6\"></p>\n<p>编写代码访问<a href=\"http://www.whatismyip.com.tw/\" target=\"_blank\" rel=\"noopener\">http://www.whatismyip.com.tw/</a>，该网站是测试自己IP为多少的网址，服务器会返回访问者的IP。</p>\n<h3 id=\"4-代码实例\"><a href=\"#4-代码实例\" class=\"headerlink\" title=\"(4).代码实例\"></a>(4).代码实例</h3><p>创建文件urllib_test10.py，编写代码如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> request</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">\"__main__\"</span>:</span><br><span class=\"line\">    <span class=\"comment\">#访问网址</span></span><br><span class=\"line\">    url = <span class=\"string\">'http://www.whatismyip.com.tw/'</span></span><br><span class=\"line\">    <span class=\"comment\">#这是代理IP</span></span><br><span class=\"line\">    proxy = &#123;<span class=\"string\">'http'</span>:<span class=\"string\">'106.46.136.112:808'</span>&#125;</span><br><span class=\"line\">    <span class=\"comment\">#创建ProxyHandler</span></span><br><span class=\"line\">    proxy_support = request.ProxyHandler(proxy)</span><br><span class=\"line\">    <span class=\"comment\">#创建Opener</span></span><br><span class=\"line\">    opener = request.build_opener(proxy_support)</span><br><span class=\"line\">    <span class=\"comment\">#添加User Angent</span></span><br><span class=\"line\">    opener.addheaders = [(<span class=\"string\">'User-Agent'</span>,<span class=\"string\">'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36'</span>)]</span><br><span class=\"line\">    <span class=\"comment\">#安装OPener</span></span><br><span class=\"line\">    request.install_opener(opener)</span><br><span class=\"line\">    <span class=\"comment\">#使用自己安装好的Opener</span></span><br><span class=\"line\">    response = request.urlopen(url)</span><br><span class=\"line\">    <span class=\"comment\">#读取相应信息并解码</span></span><br><span class=\"line\">    html = response.read().decode(<span class=\"string\">\"utf-8\"</span>)</span><br><span class=\"line\">    <span class=\"comment\">#打印信息</span></span><br><span class=\"line\">    print(html)</span><br></pre></td></tr></table></figure></p>\n<p>运行结果如下：<br><img src=\"http://img.blog.csdn.net/20170303124823038?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"7\"></p>\n<p>从上图可以看出，访问的IP已经伪装成了106.46.136.112。</p>"},{"title":"从零开始学爬虫-05","date":"2018-02-27T17:17:37.000Z","_content":"\n## 为什么要使用Cookie\n\nCookie，指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密)。   \n比如说有些网站需要登录后才能访问某个页面，在登录之前，你想抓取某个页面内容，登陆前与登陆后是不同的，或者不允许的。   \n使用Cookie和使用代理IP一样，也需要创建一个自己的opener。在HTTP包中，提供了cookiejar模块，用于提供对Cookie的支持。\n\n![](http://img.blog.csdn.net/20170409144243654?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n<!-- more -->\n\nhttp.cookiejar功能强大，我们可以利用本模块的CookieJar类的对象来捕获cookie并在后续连接请求时重新发送，比如可以实现模拟登录功能。该模块主要的对象有CookieJar、FileCookieJar、MozillaCookieJar、LWPCookieJar。\n\n**它们的关系：** CookieJar–派生–>FileCookieJar–派生–>MozillaCookieJar和LWPCookieJar\n\n**工作原理：** 创建一个带有cookie的opener，在访问登录的URL时，将登录后的cookie保存下来，然后利用这个cookie来访问其他网址。查看登录之后才能看到的信息。\n\n同样，我们以实例进行讲解，爬取伯乐在线的面向对象的漂亮MM的邮箱联系方式。\n\n## 实战\n\n### (1).背景介绍\n\n在伯乐在线有这么一个有趣的模块，面向对象，它说白了就是提供了一个程序员(媛)网上相亲的平台。\n\n**URL:** [http://date.jobbole.com/](http://date.jobbole.com/)\n\n它的样子是这样的：\n\n![](http://img.blog.csdn.net/20170409144753813?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n可以看到，这里有很多的相亲贴，随便点进去就会有网上相亲MM的详细信息，想获取MM的联系方式，需要积分，积分可以通过签到的方式获取。如果没有登陆账户，获取联系方式的地方是这个样子的：\n\n![](http://img.blog.csdn.net/20170409144912938?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n如果登陆了账号，获取联系方式的地方是这个样子的：\n\n![](http://img.blog.csdn.net/20170409144955289?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n想要爬取MM的联系邮箱，就需要用到我们本次讲到的知识，Cookie的使用。当然，首先你积分也得够。\n\n在讲解之前，推荐一款抓包工具–Fiddler，可以在Google Chrome的Google商店下载这个插件，它的样子是这样的：\n\n![](http://img.blog.csdn.net/20170409145106869?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n可以看到，通过这个插件，我们可以很容易找到Post的Form Data等信息，很方便，当然也可以用之前讲得浏览器审查元素的方式查看这些信息。\n\n### (2).过程分析\n\n在伯乐在线首页点击登陆的按钮，Fiddler的抓包内容如下：\n\n![](http://img.blog.csdn.net/20170409145240590?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n从上图可以看出，真正请求的url是\n\n [http://www.jobbole.com/wp-admin/admin-ajax.php](http://www.jobbole.com/wp-admin/admin-ajax.php)\n\nForm Data的内容记住，这些是我们编程需要用到的。user_login是用户名，user_pass是用户密码。\n\n在点击取得联系邮箱按钮的时候，Fiddler的抓包内容如下：\n\n![](http://img.blog.csdn.net/20170409145403065?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n从上图可以看出，此刻真正请求的url是\n\n [http://date.jobbole.com/wp-admin/admin-ajax.php](http://date.jobbole.com/wp-admin/admin-ajax.php)\n\n同样Form Data中内容要记下来。postId是每个帖子的id。例如，打开一个相亲贴，它的URL是[http://date.jobbole.com/4128/](http://date.jobbole.com/4128/)，那么它的这个postId就是4128。为了简化程序，这里就不讲解如何自动获取这个postId了，本实例直接指定postId。如果想要自动获取，可以使用beautifulsoup解析[http://date.jobbole.com/](http://date.jobbole.com/)返回的信息。beautifulsoup的使用。有机会的话，会在后面的爬虫笔记中进行讲解。\n\n### (3).测试\n\n**1)将Cookie保存到变量中**\n\n首先，我们先利用CookieJar对象实现获取cookie的功能，存储到变量中，先来感受一下,执行文件cookie01.py：\n\n```python\n# -*- coding: UTF-8 -*-\nfrom urllib import request\nfrom http import cookiejar\n\nif __name__ == '__main__':\n    #声明一个CookieJar对象实例来保存cookie\n    cookie = cookiejar.CookieJar()\n    #利用urllib.request库的HTTPCookieProcessor对象来创建cookie处理器,也就CookieHandler\n    handler=request.HTTPCookieProcessor(cookie)\n    #通过CookieHandler创建opener\n    opener = request.build_opener(handler)\n    #此处的open方法打开网页\n    response = opener.open('http://www.baidu.com')\n    #打印cookie信息\n    for item in cookie:\n        print('Name = %s' % item.name)\n        print('Value = %s' % item.value)\n```\n\n我们使用以上方法将cookie保存到变量中，然后打印出了cookie中的值，运行结果如下:\n\n![](http://img.blog.csdn.net/20170409145652613?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n**2)保存Cookie到文件**\n\n在上面的方法中，我们将cookie保存到了cookie这个变量中，如果我们想将cookie保存到文件中该怎么做呢？方便以后直接读取文件使用，这时，我们就要用到FileCookieJar这个对象了，在这里我们使用它的子类MozillaCookieJar来实现Cookie的保存，编写代码如下,文件为cookie02.py：\n```python\n# -*- coding: UTF-8 -*-\nfrom urllib import request\nfrom http import cookiejar\n\nif __name__ == '__main__':\n\n    #设置保存cookie的文件，同级目录下的cookie.txt\n    filename = 'cookie.txt'\n    #声明一个MozillaCookieJar对象实例来保存cookie，之后写入文件\n    cookie = cookiejar.MozillaCookieJar(filename)\n    #利用urllib.request库的HTTPCookieProcessor对象来创建cookie处理器,也就CookieHandler\n    handler=request.HTTPCookieProcessor(cookie)\n    #通过CookieHandler创建opener\n    opener = request.build_opener(handler)\n    #此处的open方法打开网页\n    response = opener.open('http://www.baidu.com')\n    #保存cookie到文件\n    cookie.save(ignore_discard=True, ignore_expires=True)\n```\n\ncookie.save的参数说明：\n\n  * ignore_discard的意思是即使cookies将被丢弃也将它保存下来；\n\n  * ignore_expires的意思是如果在该文件中cookies已经存在，则覆盖原文件写入。\n\n在这里，我们将这两个全部设置为True。\n\n运行之后，cookies将被保存到cookie.txt文件中。我们可以查看自己查看下cookie.txt这个文件的内容。\n\n**3)从文件中获取Cookie并访问**\n\n我们已经做到把Cookie保存到文件中了，如果以后想使用，可以利用下面的方法来读取cookie并访问网站，感受一下cookie03.py：\n```python\n# -*- coding: UTF-8 -*-\nfrom urllib import request\nfrom http import cookiejar\n\nif __name__ == '__main__':\n    #设置保存cookie的文件的文件名,相对路径,也就是同级目录下\n    filename = 'cookie.txt'\n    #创建MozillaCookieJar实例对象\n    cookie = cookiejar.MozillaCookieJar()\n    #从文件中读取cookie内容到变量\n    cookie.load(filename, ignore_discard=True, ignore_expires=True)\n    #利用urllib.request库的HTTPCookieProcessor对象来创建cookie处理器,也就CookieHandler\n    handler=request.HTTPCookieProcessor(cookie)\n    #通过CookieHandler创建opener\n    opener = request.build_opener(handler)\n    #此用opener的open方法打开网页\n    response = opener.open('http://www.baidu.com')\n    #打印信息\n    print(response.read().decode('utf-8'))\n```\n\n了解到以上内容，我们那就可以开始正式编写模拟登陆伯乐在线的程序了。同时，我们也可以获取相亲MM的联系方式。\n\n### (4).编写代码\n\n我们利用CookieJar对象实现获取cookie的功能，存储到变量中。然后使用这个cookie变量创建opener，使用这个设置好cookie的opener即可模拟登陆，同笔记四中讲到的IP代理的使用方法类似。\n\n创建cookie_test.py文件，编写代码如下：\n```python\n# -*- coding: UTF-8 -*-\nfrom urllib import request\nfrom urllib import error\nfrom urllib import parse\nfrom http import cookiejar\n\nif __name__ == '__main__':\n    #登陆地址\n    login_url = 'http://www.jobbole.com/wp-admin/admin-ajax.php'    \n    #User-Agent信息                   \n    user_agent = r'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.94 Safari/537.36'\n    #Headers信息\n    head = {'User-Agnet': user_agent, 'Connection': 'keep-alive'}\n    #登陆Form_Data信息\n    Login_Data = {}\n    Login_Data['action'] = 'user_login'\n    Login_Data['redirect_url'] = 'http://www.jobbole.com/'\n    Login_Data['remember_me'] = '0'         #是否一个月内自动登陆\n    Login_Data['user_login'] = '********'       #改成你自己的用户名\n    Login_Data['user_pass'] = '********'        #改成你自己的密码\n    #使用urlencode方法转换标准格式\n    logingpostdata = parse.urlencode(Login_Data).encode('utf-8')\n    #声明一个CookieJar对象实例来保存cookie\n    cookie = cookiejar.CookieJar()\n    #利用urllib.request库的HTTPCookieProcessor对象来创建cookie处理器,也就CookieHandler\n    cookie_support = request.HTTPCookieProcessor(cookie)\n    #通过CookieHandler创建opener\n    opener = request.build_opener(cookie_support)\n    #创建Request对象\n    req1 = request.Request(url=login_url, data=logingpostdata, headers=head)\n\n    #面向对象地址\n    date_url = 'http://date.jobbole.com/wp-admin/admin-ajax.php'\n    #面向对象\n    Date_Data = {}\n    Date_Data['action'] = 'get_date_contact'\n    Date_Data['postId'] = '4128'\n    #使用urlencode方法转换标准格式\n    datepostdata = parse.urlencode(Date_Data).encode('utf-8')\n    req2 = request.Request(url=date_url, data=datepostdata, headers=head)\n    try:\n        #使用自己创建的opener的open方法\n        response1 = opener.open(req1)\n        response2 = opener.open(req2)\n        html = response2.read().decode('utf-8')\n        index = html.find('jb_contact_email')\n        #打印查询结果\n        print('联系邮箱:%s' % html[index+19:-2])\n\n    except error.URLError as e:\n        if hasattr(e, 'code'):\n            print(\"HTTPError:%d\" % e.code)\n        elif hasattr(e, 'reason'):\n            print(\"URLError:%s\" % e.reason)\n```\n\n\n### (5).运行结果如下\n\n![](http://img.blog.csdn.net/20170409150252854?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n。\n","source":"_posts/从零开始学爬虫-05.md","raw":"---\ntitle: 从零开始学爬虫-05\ndate: 2018-02-28 01:17:37\ntags:\n  - Spider\n  - Urllib\n  - Python3\ncategories:\n  - Spider\n  - Urllib\n---\n\n## 为什么要使用Cookie\n\nCookie，指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密)。   \n比如说有些网站需要登录后才能访问某个页面，在登录之前，你想抓取某个页面内容，登陆前与登陆后是不同的，或者不允许的。   \n使用Cookie和使用代理IP一样，也需要创建一个自己的opener。在HTTP包中，提供了cookiejar模块，用于提供对Cookie的支持。\n\n![](http://img.blog.csdn.net/20170409144243654?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n<!-- more -->\n\nhttp.cookiejar功能强大，我们可以利用本模块的CookieJar类的对象来捕获cookie并在后续连接请求时重新发送，比如可以实现模拟登录功能。该模块主要的对象有CookieJar、FileCookieJar、MozillaCookieJar、LWPCookieJar。\n\n**它们的关系：** CookieJar–派生–>FileCookieJar–派生–>MozillaCookieJar和LWPCookieJar\n\n**工作原理：** 创建一个带有cookie的opener，在访问登录的URL时，将登录后的cookie保存下来，然后利用这个cookie来访问其他网址。查看登录之后才能看到的信息。\n\n同样，我们以实例进行讲解，爬取伯乐在线的面向对象的漂亮MM的邮箱联系方式。\n\n## 实战\n\n### (1).背景介绍\n\n在伯乐在线有这么一个有趣的模块，面向对象，它说白了就是提供了一个程序员(媛)网上相亲的平台。\n\n**URL:** [http://date.jobbole.com/](http://date.jobbole.com/)\n\n它的样子是这样的：\n\n![](http://img.blog.csdn.net/20170409144753813?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n可以看到，这里有很多的相亲贴，随便点进去就会有网上相亲MM的详细信息，想获取MM的联系方式，需要积分，积分可以通过签到的方式获取。如果没有登陆账户，获取联系方式的地方是这个样子的：\n\n![](http://img.blog.csdn.net/20170409144912938?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n如果登陆了账号，获取联系方式的地方是这个样子的：\n\n![](http://img.blog.csdn.net/20170409144955289?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n想要爬取MM的联系邮箱，就需要用到我们本次讲到的知识，Cookie的使用。当然，首先你积分也得够。\n\n在讲解之前，推荐一款抓包工具–Fiddler，可以在Google Chrome的Google商店下载这个插件，它的样子是这样的：\n\n![](http://img.blog.csdn.net/20170409145106869?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n可以看到，通过这个插件，我们可以很容易找到Post的Form Data等信息，很方便，当然也可以用之前讲得浏览器审查元素的方式查看这些信息。\n\n### (2).过程分析\n\n在伯乐在线首页点击登陆的按钮，Fiddler的抓包内容如下：\n\n![](http://img.blog.csdn.net/20170409145240590?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n从上图可以看出，真正请求的url是\n\n [http://www.jobbole.com/wp-admin/admin-ajax.php](http://www.jobbole.com/wp-admin/admin-ajax.php)\n\nForm Data的内容记住，这些是我们编程需要用到的。user_login是用户名，user_pass是用户密码。\n\n在点击取得联系邮箱按钮的时候，Fiddler的抓包内容如下：\n\n![](http://img.blog.csdn.net/20170409145403065?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n从上图可以看出，此刻真正请求的url是\n\n [http://date.jobbole.com/wp-admin/admin-ajax.php](http://date.jobbole.com/wp-admin/admin-ajax.php)\n\n同样Form Data中内容要记下来。postId是每个帖子的id。例如，打开一个相亲贴，它的URL是[http://date.jobbole.com/4128/](http://date.jobbole.com/4128/)，那么它的这个postId就是4128。为了简化程序，这里就不讲解如何自动获取这个postId了，本实例直接指定postId。如果想要自动获取，可以使用beautifulsoup解析[http://date.jobbole.com/](http://date.jobbole.com/)返回的信息。beautifulsoup的使用。有机会的话，会在后面的爬虫笔记中进行讲解。\n\n### (3).测试\n\n**1)将Cookie保存到变量中**\n\n首先，我们先利用CookieJar对象实现获取cookie的功能，存储到变量中，先来感受一下,执行文件cookie01.py：\n\n```python\n# -*- coding: UTF-8 -*-\nfrom urllib import request\nfrom http import cookiejar\n\nif __name__ == '__main__':\n    #声明一个CookieJar对象实例来保存cookie\n    cookie = cookiejar.CookieJar()\n    #利用urllib.request库的HTTPCookieProcessor对象来创建cookie处理器,也就CookieHandler\n    handler=request.HTTPCookieProcessor(cookie)\n    #通过CookieHandler创建opener\n    opener = request.build_opener(handler)\n    #此处的open方法打开网页\n    response = opener.open('http://www.baidu.com')\n    #打印cookie信息\n    for item in cookie:\n        print('Name = %s' % item.name)\n        print('Value = %s' % item.value)\n```\n\n我们使用以上方法将cookie保存到变量中，然后打印出了cookie中的值，运行结果如下:\n\n![](http://img.blog.csdn.net/20170409145652613?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n**2)保存Cookie到文件**\n\n在上面的方法中，我们将cookie保存到了cookie这个变量中，如果我们想将cookie保存到文件中该怎么做呢？方便以后直接读取文件使用，这时，我们就要用到FileCookieJar这个对象了，在这里我们使用它的子类MozillaCookieJar来实现Cookie的保存，编写代码如下,文件为cookie02.py：\n```python\n# -*- coding: UTF-8 -*-\nfrom urllib import request\nfrom http import cookiejar\n\nif __name__ == '__main__':\n\n    #设置保存cookie的文件，同级目录下的cookie.txt\n    filename = 'cookie.txt'\n    #声明一个MozillaCookieJar对象实例来保存cookie，之后写入文件\n    cookie = cookiejar.MozillaCookieJar(filename)\n    #利用urllib.request库的HTTPCookieProcessor对象来创建cookie处理器,也就CookieHandler\n    handler=request.HTTPCookieProcessor(cookie)\n    #通过CookieHandler创建opener\n    opener = request.build_opener(handler)\n    #此处的open方法打开网页\n    response = opener.open('http://www.baidu.com')\n    #保存cookie到文件\n    cookie.save(ignore_discard=True, ignore_expires=True)\n```\n\ncookie.save的参数说明：\n\n  * ignore_discard的意思是即使cookies将被丢弃也将它保存下来；\n\n  * ignore_expires的意思是如果在该文件中cookies已经存在，则覆盖原文件写入。\n\n在这里，我们将这两个全部设置为True。\n\n运行之后，cookies将被保存到cookie.txt文件中。我们可以查看自己查看下cookie.txt这个文件的内容。\n\n**3)从文件中获取Cookie并访问**\n\n我们已经做到把Cookie保存到文件中了，如果以后想使用，可以利用下面的方法来读取cookie并访问网站，感受一下cookie03.py：\n```python\n# -*- coding: UTF-8 -*-\nfrom urllib import request\nfrom http import cookiejar\n\nif __name__ == '__main__':\n    #设置保存cookie的文件的文件名,相对路径,也就是同级目录下\n    filename = 'cookie.txt'\n    #创建MozillaCookieJar实例对象\n    cookie = cookiejar.MozillaCookieJar()\n    #从文件中读取cookie内容到变量\n    cookie.load(filename, ignore_discard=True, ignore_expires=True)\n    #利用urllib.request库的HTTPCookieProcessor对象来创建cookie处理器,也就CookieHandler\n    handler=request.HTTPCookieProcessor(cookie)\n    #通过CookieHandler创建opener\n    opener = request.build_opener(handler)\n    #此用opener的open方法打开网页\n    response = opener.open('http://www.baidu.com')\n    #打印信息\n    print(response.read().decode('utf-8'))\n```\n\n了解到以上内容，我们那就可以开始正式编写模拟登陆伯乐在线的程序了。同时，我们也可以获取相亲MM的联系方式。\n\n### (4).编写代码\n\n我们利用CookieJar对象实现获取cookie的功能，存储到变量中。然后使用这个cookie变量创建opener，使用这个设置好cookie的opener即可模拟登陆，同笔记四中讲到的IP代理的使用方法类似。\n\n创建cookie_test.py文件，编写代码如下：\n```python\n# -*- coding: UTF-8 -*-\nfrom urllib import request\nfrom urllib import error\nfrom urllib import parse\nfrom http import cookiejar\n\nif __name__ == '__main__':\n    #登陆地址\n    login_url = 'http://www.jobbole.com/wp-admin/admin-ajax.php'    \n    #User-Agent信息                   \n    user_agent = r'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.94 Safari/537.36'\n    #Headers信息\n    head = {'User-Agnet': user_agent, 'Connection': 'keep-alive'}\n    #登陆Form_Data信息\n    Login_Data = {}\n    Login_Data['action'] = 'user_login'\n    Login_Data['redirect_url'] = 'http://www.jobbole.com/'\n    Login_Data['remember_me'] = '0'         #是否一个月内自动登陆\n    Login_Data['user_login'] = '********'       #改成你自己的用户名\n    Login_Data['user_pass'] = '********'        #改成你自己的密码\n    #使用urlencode方法转换标准格式\n    logingpostdata = parse.urlencode(Login_Data).encode('utf-8')\n    #声明一个CookieJar对象实例来保存cookie\n    cookie = cookiejar.CookieJar()\n    #利用urllib.request库的HTTPCookieProcessor对象来创建cookie处理器,也就CookieHandler\n    cookie_support = request.HTTPCookieProcessor(cookie)\n    #通过CookieHandler创建opener\n    opener = request.build_opener(cookie_support)\n    #创建Request对象\n    req1 = request.Request(url=login_url, data=logingpostdata, headers=head)\n\n    #面向对象地址\n    date_url = 'http://date.jobbole.com/wp-admin/admin-ajax.php'\n    #面向对象\n    Date_Data = {}\n    Date_Data['action'] = 'get_date_contact'\n    Date_Data['postId'] = '4128'\n    #使用urlencode方法转换标准格式\n    datepostdata = parse.urlencode(Date_Data).encode('utf-8')\n    req2 = request.Request(url=date_url, data=datepostdata, headers=head)\n    try:\n        #使用自己创建的opener的open方法\n        response1 = opener.open(req1)\n        response2 = opener.open(req2)\n        html = response2.read().decode('utf-8')\n        index = html.find('jb_contact_email')\n        #打印查询结果\n        print('联系邮箱:%s' % html[index+19:-2])\n\n    except error.URLError as e:\n        if hasattr(e, 'code'):\n            print(\"HTTPError:%d\" % e.code)\n        elif hasattr(e, 'reason'):\n            print(\"URLError:%s\" % e.reason)\n```\n\n\n### (5).运行结果如下\n\n![](http://img.blog.csdn.net/20170409150252854?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n。\n","slug":"从零开始学爬虫-05","published":1,"updated":"2018-02-27T17:22:51.289Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozn200678motl18h4w8a","content":"<h2 id=\"为什么要使用Cookie\"><a href=\"#为什么要使用Cookie\" class=\"headerlink\" title=\"为什么要使用Cookie\"></a>为什么要使用Cookie</h2><p>Cookie，指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密)。<br>比如说有些网站需要登录后才能访问某个页面，在登录之前，你想抓取某个页面内容，登陆前与登陆后是不同的，或者不允许的。<br>使用Cookie和使用代理IP一样，也需要创建一个自己的opener。在HTTP包中，提供了cookiejar模块，用于提供对Cookie的支持。</p>\n<p><img src=\"http://img.blog.csdn.net/20170409144243654?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br><a id=\"more\"></a></p>\n<p>http.cookiejar功能强大，我们可以利用本模块的CookieJar类的对象来捕获cookie并在后续连接请求时重新发送，比如可以实现模拟登录功能。该模块主要的对象有CookieJar、FileCookieJar、MozillaCookieJar、LWPCookieJar。</p>\n<p><strong>它们的关系：</strong> CookieJar–派生–&gt;FileCookieJar–派生–&gt;MozillaCookieJar和LWPCookieJar</p>\n<p><strong>工作原理：</strong> 创建一个带有cookie的opener，在访问登录的URL时，将登录后的cookie保存下来，然后利用这个cookie来访问其他网址。查看登录之后才能看到的信息。</p>\n<p>同样，我们以实例进行讲解，爬取伯乐在线的面向对象的漂亮MM的邮箱联系方式。</p>\n<h2 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h2><h3 id=\"1-背景介绍\"><a href=\"#1-背景介绍\" class=\"headerlink\" title=\"(1).背景介绍\"></a>(1).背景介绍</h3><p>在伯乐在线有这么一个有趣的模块，面向对象，它说白了就是提供了一个程序员(媛)网上相亲的平台。</p>\n<p><strong>URL:</strong> <a href=\"http://date.jobbole.com/\" target=\"_blank\" rel=\"noopener\">http://date.jobbole.com/</a></p>\n<p>它的样子是这样的：</p>\n<p><img src=\"http://img.blog.csdn.net/20170409144753813?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p>\n<p>可以看到，这里有很多的相亲贴，随便点进去就会有网上相亲MM的详细信息，想获取MM的联系方式，需要积分，积分可以通过签到的方式获取。如果没有登陆账户，获取联系方式的地方是这个样子的：</p>\n<p><img src=\"http://img.blog.csdn.net/20170409144912938?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p>\n<p>如果登陆了账号，获取联系方式的地方是这个样子的：</p>\n<p><img src=\"http://img.blog.csdn.net/20170409144955289?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p>\n<p>想要爬取MM的联系邮箱，就需要用到我们本次讲到的知识，Cookie的使用。当然，首先你积分也得够。</p>\n<p>在讲解之前，推荐一款抓包工具–Fiddler，可以在Google Chrome的Google商店下载这个插件，它的样子是这样的：</p>\n<p><img src=\"http://img.blog.csdn.net/20170409145106869?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p>\n<p>可以看到，通过这个插件，我们可以很容易找到Post的Form Data等信息，很方便，当然也可以用之前讲得浏览器审查元素的方式查看这些信息。</p>\n<h3 id=\"2-过程分析\"><a href=\"#2-过程分析\" class=\"headerlink\" title=\"(2).过程分析\"></a>(2).过程分析</h3><p>在伯乐在线首页点击登陆的按钮，Fiddler的抓包内容如下：</p>\n<p><img src=\"http://img.blog.csdn.net/20170409145240590?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p>\n<p>从上图可以看出，真正请求的url是</p>\n<p> <a href=\"http://www.jobbole.com/wp-admin/admin-ajax.php\" target=\"_blank\" rel=\"noopener\">http://www.jobbole.com/wp-admin/admin-ajax.php</a></p>\n<p>Form Data的内容记住，这些是我们编程需要用到的。user_login是用户名，user_pass是用户密码。</p>\n<p>在点击取得联系邮箱按钮的时候，Fiddler的抓包内容如下：</p>\n<p><img src=\"http://img.blog.csdn.net/20170409145403065?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p>\n<p>从上图可以看出，此刻真正请求的url是</p>\n<p> <a href=\"http://date.jobbole.com/wp-admin/admin-ajax.php\" target=\"_blank\" rel=\"noopener\">http://date.jobbole.com/wp-admin/admin-ajax.php</a></p>\n<p>同样Form Data中内容要记下来。postId是每个帖子的id。例如，打开一个相亲贴，它的URL是<a href=\"http://date.jobbole.com/4128/\" target=\"_blank\" rel=\"noopener\">http://date.jobbole.com/4128/</a>，那么它的这个postId就是4128。为了简化程序，这里就不讲解如何自动获取这个postId了，本实例直接指定postId。如果想要自动获取，可以使用beautifulsoup解析<a href=\"http://date.jobbole.com/\" target=\"_blank\" rel=\"noopener\">http://date.jobbole.com/</a>返回的信息。beautifulsoup的使用。有机会的话，会在后面的爬虫笔记中进行讲解。</p>\n<h3 id=\"3-测试\"><a href=\"#3-测试\" class=\"headerlink\" title=\"(3).测试\"></a>(3).测试</h3><p><strong>1)将Cookie保存到变量中</strong></p>\n<p>首先，我们先利用CookieJar对象实现获取cookie的功能，存储到变量中，先来感受一下,执行文件cookie01.py：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> request</span><br><span class=\"line\"><span class=\"keyword\">from</span> http <span class=\"keyword\">import</span> cookiejar</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    <span class=\"comment\">#声明一个CookieJar对象实例来保存cookie</span></span><br><span class=\"line\">    cookie = cookiejar.CookieJar()</span><br><span class=\"line\">    <span class=\"comment\">#利用urllib.request库的HTTPCookieProcessor对象来创建cookie处理器,也就CookieHandler</span></span><br><span class=\"line\">    handler=request.HTTPCookieProcessor(cookie)</span><br><span class=\"line\">    <span class=\"comment\">#通过CookieHandler创建opener</span></span><br><span class=\"line\">    opener = request.build_opener(handler)</span><br><span class=\"line\">    <span class=\"comment\">#此处的open方法打开网页</span></span><br><span class=\"line\">    response = opener.open(<span class=\"string\">'http://www.baidu.com'</span>)</span><br><span class=\"line\">    <span class=\"comment\">#打印cookie信息</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> cookie:</span><br><span class=\"line\">        print(<span class=\"string\">'Name = %s'</span> % item.name)</span><br><span class=\"line\">        print(<span class=\"string\">'Value = %s'</span> % item.value)</span><br></pre></td></tr></table></figure>\n<p>我们使用以上方法将cookie保存到变量中，然后打印出了cookie中的值，运行结果如下:</p>\n<p><img src=\"http://img.blog.csdn.net/20170409145652613?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p>\n<p><strong>2)保存Cookie到文件</strong></p>\n<p>在上面的方法中，我们将cookie保存到了cookie这个变量中，如果我们想将cookie保存到文件中该怎么做呢？方便以后直接读取文件使用，这时，我们就要用到FileCookieJar这个对象了，在这里我们使用它的子类MozillaCookieJar来实现Cookie的保存，编写代码如下,文件为cookie02.py：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> request</span><br><span class=\"line\"><span class=\"keyword\">from</span> http <span class=\"keyword\">import</span> cookiejar</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#设置保存cookie的文件，同级目录下的cookie.txt</span></span><br><span class=\"line\">    filename = <span class=\"string\">'cookie.txt'</span></span><br><span class=\"line\">    <span class=\"comment\">#声明一个MozillaCookieJar对象实例来保存cookie，之后写入文件</span></span><br><span class=\"line\">    cookie = cookiejar.MozillaCookieJar(filename)</span><br><span class=\"line\">    <span class=\"comment\">#利用urllib.request库的HTTPCookieProcessor对象来创建cookie处理器,也就CookieHandler</span></span><br><span class=\"line\">    handler=request.HTTPCookieProcessor(cookie)</span><br><span class=\"line\">    <span class=\"comment\">#通过CookieHandler创建opener</span></span><br><span class=\"line\">    opener = request.build_opener(handler)</span><br><span class=\"line\">    <span class=\"comment\">#此处的open方法打开网页</span></span><br><span class=\"line\">    response = opener.open(<span class=\"string\">'http://www.baidu.com'</span>)</span><br><span class=\"line\">    <span class=\"comment\">#保存cookie到文件</span></span><br><span class=\"line\">    cookie.save(ignore_discard=<span class=\"keyword\">True</span>, ignore_expires=<span class=\"keyword\">True</span>)</span><br></pre></td></tr></table></figure></p>\n<p>cookie.save的参数说明：</p>\n<ul>\n<li><p>ignore_discard的意思是即使cookies将被丢弃也将它保存下来；</p>\n</li>\n<li><p>ignore_expires的意思是如果在该文件中cookies已经存在，则覆盖原文件写入。</p>\n</li>\n</ul>\n<p>在这里，我们将这两个全部设置为True。</p>\n<p>运行之后，cookies将被保存到cookie.txt文件中。我们可以查看自己查看下cookie.txt这个文件的内容。</p>\n<p><strong>3)从文件中获取Cookie并访问</strong></p>\n<p>我们已经做到把Cookie保存到文件中了，如果以后想使用，可以利用下面的方法来读取cookie并访问网站，感受一下cookie03.py：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> request</span><br><span class=\"line\"><span class=\"keyword\">from</span> http <span class=\"keyword\">import</span> cookiejar</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    <span class=\"comment\">#设置保存cookie的文件的文件名,相对路径,也就是同级目录下</span></span><br><span class=\"line\">    filename = <span class=\"string\">'cookie.txt'</span></span><br><span class=\"line\">    <span class=\"comment\">#创建MozillaCookieJar实例对象</span></span><br><span class=\"line\">    cookie = cookiejar.MozillaCookieJar()</span><br><span class=\"line\">    <span class=\"comment\">#从文件中读取cookie内容到变量</span></span><br><span class=\"line\">    cookie.load(filename, ignore_discard=<span class=\"keyword\">True</span>, ignore_expires=<span class=\"keyword\">True</span>)</span><br><span class=\"line\">    <span class=\"comment\">#利用urllib.request库的HTTPCookieProcessor对象来创建cookie处理器,也就CookieHandler</span></span><br><span class=\"line\">    handler=request.HTTPCookieProcessor(cookie)</span><br><span class=\"line\">    <span class=\"comment\">#通过CookieHandler创建opener</span></span><br><span class=\"line\">    opener = request.build_opener(handler)</span><br><span class=\"line\">    <span class=\"comment\">#此用opener的open方法打开网页</span></span><br><span class=\"line\">    response = opener.open(<span class=\"string\">'http://www.baidu.com'</span>)</span><br><span class=\"line\">    <span class=\"comment\">#打印信息</span></span><br><span class=\"line\">    print(response.read().decode(<span class=\"string\">'utf-8'</span>))</span><br></pre></td></tr></table></figure></p>\n<p>了解到以上内容，我们那就可以开始正式编写模拟登陆伯乐在线的程序了。同时，我们也可以获取相亲MM的联系方式。</p>\n<h3 id=\"4-编写代码\"><a href=\"#4-编写代码\" class=\"headerlink\" title=\"(4).编写代码\"></a>(4).编写代码</h3><p>我们利用CookieJar对象实现获取cookie的功能，存储到变量中。然后使用这个cookie变量创建opener，使用这个设置好cookie的opener即可模拟登陆，同笔记四中讲到的IP代理的使用方法类似。</p>\n<p>创建cookie_test.py文件，编写代码如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> request</span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> error</span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> parse</span><br><span class=\"line\"><span class=\"keyword\">from</span> http <span class=\"keyword\">import</span> cookiejar</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    <span class=\"comment\">#登陆地址</span></span><br><span class=\"line\">    login_url = <span class=\"string\">'http://www.jobbole.com/wp-admin/admin-ajax.php'</span>    </span><br><span class=\"line\">    <span class=\"comment\">#User-Agent信息                   </span></span><br><span class=\"line\">    user_agent = <span class=\"string\">r'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.94 Safari/537.36'</span></span><br><span class=\"line\">    <span class=\"comment\">#Headers信息</span></span><br><span class=\"line\">    head = &#123;<span class=\"string\">'User-Agnet'</span>: user_agent, <span class=\"string\">'Connection'</span>: <span class=\"string\">'keep-alive'</span>&#125;</span><br><span class=\"line\">    <span class=\"comment\">#登陆Form_Data信息</span></span><br><span class=\"line\">    Login_Data = &#123;&#125;</span><br><span class=\"line\">    Login_Data[<span class=\"string\">'action'</span>] = <span class=\"string\">'user_login'</span></span><br><span class=\"line\">    Login_Data[<span class=\"string\">'redirect_url'</span>] = <span class=\"string\">'http://www.jobbole.com/'</span></span><br><span class=\"line\">    Login_Data[<span class=\"string\">'remember_me'</span>] = <span class=\"string\">'0'</span>         <span class=\"comment\">#是否一个月内自动登陆</span></span><br><span class=\"line\">    Login_Data[<span class=\"string\">'user_login'</span>] = <span class=\"string\">'********'</span>       <span class=\"comment\">#改成你自己的用户名</span></span><br><span class=\"line\">    Login_Data[<span class=\"string\">'user_pass'</span>] = <span class=\"string\">'********'</span>        <span class=\"comment\">#改成你自己的密码</span></span><br><span class=\"line\">    <span class=\"comment\">#使用urlencode方法转换标准格式</span></span><br><span class=\"line\">    logingpostdata = parse.urlencode(Login_Data).encode(<span class=\"string\">'utf-8'</span>)</span><br><span class=\"line\">    <span class=\"comment\">#声明一个CookieJar对象实例来保存cookie</span></span><br><span class=\"line\">    cookie = cookiejar.CookieJar()</span><br><span class=\"line\">    <span class=\"comment\">#利用urllib.request库的HTTPCookieProcessor对象来创建cookie处理器,也就CookieHandler</span></span><br><span class=\"line\">    cookie_support = request.HTTPCookieProcessor(cookie)</span><br><span class=\"line\">    <span class=\"comment\">#通过CookieHandler创建opener</span></span><br><span class=\"line\">    opener = request.build_opener(cookie_support)</span><br><span class=\"line\">    <span class=\"comment\">#创建Request对象</span></span><br><span class=\"line\">    req1 = request.Request(url=login_url, data=logingpostdata, headers=head)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#面向对象地址</span></span><br><span class=\"line\">    date_url = <span class=\"string\">'http://date.jobbole.com/wp-admin/admin-ajax.php'</span></span><br><span class=\"line\">    <span class=\"comment\">#面向对象</span></span><br><span class=\"line\">    Date_Data = &#123;&#125;</span><br><span class=\"line\">    Date_Data[<span class=\"string\">'action'</span>] = <span class=\"string\">'get_date_contact'</span></span><br><span class=\"line\">    Date_Data[<span class=\"string\">'postId'</span>] = <span class=\"string\">'4128'</span></span><br><span class=\"line\">    <span class=\"comment\">#使用urlencode方法转换标准格式</span></span><br><span class=\"line\">    datepostdata = parse.urlencode(Date_Data).encode(<span class=\"string\">'utf-8'</span>)</span><br><span class=\"line\">    req2 = request.Request(url=date_url, data=datepostdata, headers=head)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"comment\">#使用自己创建的opener的open方法</span></span><br><span class=\"line\">        response1 = opener.open(req1)</span><br><span class=\"line\">        response2 = opener.open(req2)</span><br><span class=\"line\">        html = response2.read().decode(<span class=\"string\">'utf-8'</span>)</span><br><span class=\"line\">        index = html.find(<span class=\"string\">'jb_contact_email'</span>)</span><br><span class=\"line\">        <span class=\"comment\">#打印查询结果</span></span><br><span class=\"line\">        print(<span class=\"string\">'联系邮箱:%s'</span> % html[index+<span class=\"number\">19</span>:<span class=\"number\">-2</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">except</span> error.URLError <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> hasattr(e, <span class=\"string\">'code'</span>):</span><br><span class=\"line\">            print(<span class=\"string\">\"HTTPError:%d\"</span> % e.code)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> hasattr(e, <span class=\"string\">'reason'</span>):</span><br><span class=\"line\">            print(<span class=\"string\">\"URLError:%s\"</span> % e.reason)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"5-运行结果如下\"><a href=\"#5-运行结果如下\" class=\"headerlink\" title=\"(5).运行结果如下\"></a>(5).运行结果如下</h3><p><img src=\"http://img.blog.csdn.net/20170409150252854?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"为什么要使用Cookie\"><a href=\"#为什么要使用Cookie\" class=\"headerlink\" title=\"为什么要使用Cookie\"></a>为什么要使用Cookie</h2><p>Cookie，指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密)。<br>比如说有些网站需要登录后才能访问某个页面，在登录之前，你想抓取某个页面内容，登陆前与登陆后是不同的，或者不允许的。<br>使用Cookie和使用代理IP一样，也需要创建一个自己的opener。在HTTP包中，提供了cookiejar模块，用于提供对Cookie的支持。</p>\n<p><img src=\"http://img.blog.csdn.net/20170409144243654?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>","more":"</p>\n<p>http.cookiejar功能强大，我们可以利用本模块的CookieJar类的对象来捕获cookie并在后续连接请求时重新发送，比如可以实现模拟登录功能。该模块主要的对象有CookieJar、FileCookieJar、MozillaCookieJar、LWPCookieJar。</p>\n<p><strong>它们的关系：</strong> CookieJar–派生–&gt;FileCookieJar–派生–&gt;MozillaCookieJar和LWPCookieJar</p>\n<p><strong>工作原理：</strong> 创建一个带有cookie的opener，在访问登录的URL时，将登录后的cookie保存下来，然后利用这个cookie来访问其他网址。查看登录之后才能看到的信息。</p>\n<p>同样，我们以实例进行讲解，爬取伯乐在线的面向对象的漂亮MM的邮箱联系方式。</p>\n<h2 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h2><h3 id=\"1-背景介绍\"><a href=\"#1-背景介绍\" class=\"headerlink\" title=\"(1).背景介绍\"></a>(1).背景介绍</h3><p>在伯乐在线有这么一个有趣的模块，面向对象，它说白了就是提供了一个程序员(媛)网上相亲的平台。</p>\n<p><strong>URL:</strong> <a href=\"http://date.jobbole.com/\" target=\"_blank\" rel=\"noopener\">http://date.jobbole.com/</a></p>\n<p>它的样子是这样的：</p>\n<p><img src=\"http://img.blog.csdn.net/20170409144753813?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p>\n<p>可以看到，这里有很多的相亲贴，随便点进去就会有网上相亲MM的详细信息，想获取MM的联系方式，需要积分，积分可以通过签到的方式获取。如果没有登陆账户，获取联系方式的地方是这个样子的：</p>\n<p><img src=\"http://img.blog.csdn.net/20170409144912938?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p>\n<p>如果登陆了账号，获取联系方式的地方是这个样子的：</p>\n<p><img src=\"http://img.blog.csdn.net/20170409144955289?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p>\n<p>想要爬取MM的联系邮箱，就需要用到我们本次讲到的知识，Cookie的使用。当然，首先你积分也得够。</p>\n<p>在讲解之前，推荐一款抓包工具–Fiddler，可以在Google Chrome的Google商店下载这个插件，它的样子是这样的：</p>\n<p><img src=\"http://img.blog.csdn.net/20170409145106869?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p>\n<p>可以看到，通过这个插件，我们可以很容易找到Post的Form Data等信息，很方便，当然也可以用之前讲得浏览器审查元素的方式查看这些信息。</p>\n<h3 id=\"2-过程分析\"><a href=\"#2-过程分析\" class=\"headerlink\" title=\"(2).过程分析\"></a>(2).过程分析</h3><p>在伯乐在线首页点击登陆的按钮，Fiddler的抓包内容如下：</p>\n<p><img src=\"http://img.blog.csdn.net/20170409145240590?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p>\n<p>从上图可以看出，真正请求的url是</p>\n<p> <a href=\"http://www.jobbole.com/wp-admin/admin-ajax.php\" target=\"_blank\" rel=\"noopener\">http://www.jobbole.com/wp-admin/admin-ajax.php</a></p>\n<p>Form Data的内容记住，这些是我们编程需要用到的。user_login是用户名，user_pass是用户密码。</p>\n<p>在点击取得联系邮箱按钮的时候，Fiddler的抓包内容如下：</p>\n<p><img src=\"http://img.blog.csdn.net/20170409145403065?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p>\n<p>从上图可以看出，此刻真正请求的url是</p>\n<p> <a href=\"http://date.jobbole.com/wp-admin/admin-ajax.php\" target=\"_blank\" rel=\"noopener\">http://date.jobbole.com/wp-admin/admin-ajax.php</a></p>\n<p>同样Form Data中内容要记下来。postId是每个帖子的id。例如，打开一个相亲贴，它的URL是<a href=\"http://date.jobbole.com/4128/\" target=\"_blank\" rel=\"noopener\">http://date.jobbole.com/4128/</a>，那么它的这个postId就是4128。为了简化程序，这里就不讲解如何自动获取这个postId了，本实例直接指定postId。如果想要自动获取，可以使用beautifulsoup解析<a href=\"http://date.jobbole.com/\" target=\"_blank\" rel=\"noopener\">http://date.jobbole.com/</a>返回的信息。beautifulsoup的使用。有机会的话，会在后面的爬虫笔记中进行讲解。</p>\n<h3 id=\"3-测试\"><a href=\"#3-测试\" class=\"headerlink\" title=\"(3).测试\"></a>(3).测试</h3><p><strong>1)将Cookie保存到变量中</strong></p>\n<p>首先，我们先利用CookieJar对象实现获取cookie的功能，存储到变量中，先来感受一下,执行文件cookie01.py：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> request</span><br><span class=\"line\"><span class=\"keyword\">from</span> http <span class=\"keyword\">import</span> cookiejar</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    <span class=\"comment\">#声明一个CookieJar对象实例来保存cookie</span></span><br><span class=\"line\">    cookie = cookiejar.CookieJar()</span><br><span class=\"line\">    <span class=\"comment\">#利用urllib.request库的HTTPCookieProcessor对象来创建cookie处理器,也就CookieHandler</span></span><br><span class=\"line\">    handler=request.HTTPCookieProcessor(cookie)</span><br><span class=\"line\">    <span class=\"comment\">#通过CookieHandler创建opener</span></span><br><span class=\"line\">    opener = request.build_opener(handler)</span><br><span class=\"line\">    <span class=\"comment\">#此处的open方法打开网页</span></span><br><span class=\"line\">    response = opener.open(<span class=\"string\">'http://www.baidu.com'</span>)</span><br><span class=\"line\">    <span class=\"comment\">#打印cookie信息</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> cookie:</span><br><span class=\"line\">        print(<span class=\"string\">'Name = %s'</span> % item.name)</span><br><span class=\"line\">        print(<span class=\"string\">'Value = %s'</span> % item.value)</span><br></pre></td></tr></table></figure>\n<p>我们使用以上方法将cookie保存到变量中，然后打印出了cookie中的值，运行结果如下:</p>\n<p><img src=\"http://img.blog.csdn.net/20170409145652613?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p>\n<p><strong>2)保存Cookie到文件</strong></p>\n<p>在上面的方法中，我们将cookie保存到了cookie这个变量中，如果我们想将cookie保存到文件中该怎么做呢？方便以后直接读取文件使用，这时，我们就要用到FileCookieJar这个对象了，在这里我们使用它的子类MozillaCookieJar来实现Cookie的保存，编写代码如下,文件为cookie02.py：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> request</span><br><span class=\"line\"><span class=\"keyword\">from</span> http <span class=\"keyword\">import</span> cookiejar</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#设置保存cookie的文件，同级目录下的cookie.txt</span></span><br><span class=\"line\">    filename = <span class=\"string\">'cookie.txt'</span></span><br><span class=\"line\">    <span class=\"comment\">#声明一个MozillaCookieJar对象实例来保存cookie，之后写入文件</span></span><br><span class=\"line\">    cookie = cookiejar.MozillaCookieJar(filename)</span><br><span class=\"line\">    <span class=\"comment\">#利用urllib.request库的HTTPCookieProcessor对象来创建cookie处理器,也就CookieHandler</span></span><br><span class=\"line\">    handler=request.HTTPCookieProcessor(cookie)</span><br><span class=\"line\">    <span class=\"comment\">#通过CookieHandler创建opener</span></span><br><span class=\"line\">    opener = request.build_opener(handler)</span><br><span class=\"line\">    <span class=\"comment\">#此处的open方法打开网页</span></span><br><span class=\"line\">    response = opener.open(<span class=\"string\">'http://www.baidu.com'</span>)</span><br><span class=\"line\">    <span class=\"comment\">#保存cookie到文件</span></span><br><span class=\"line\">    cookie.save(ignore_discard=<span class=\"keyword\">True</span>, ignore_expires=<span class=\"keyword\">True</span>)</span><br></pre></td></tr></table></figure></p>\n<p>cookie.save的参数说明：</p>\n<ul>\n<li><p>ignore_discard的意思是即使cookies将被丢弃也将它保存下来；</p>\n</li>\n<li><p>ignore_expires的意思是如果在该文件中cookies已经存在，则覆盖原文件写入。</p>\n</li>\n</ul>\n<p>在这里，我们将这两个全部设置为True。</p>\n<p>运行之后，cookies将被保存到cookie.txt文件中。我们可以查看自己查看下cookie.txt这个文件的内容。</p>\n<p><strong>3)从文件中获取Cookie并访问</strong></p>\n<p>我们已经做到把Cookie保存到文件中了，如果以后想使用，可以利用下面的方法来读取cookie并访问网站，感受一下cookie03.py：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> request</span><br><span class=\"line\"><span class=\"keyword\">from</span> http <span class=\"keyword\">import</span> cookiejar</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    <span class=\"comment\">#设置保存cookie的文件的文件名,相对路径,也就是同级目录下</span></span><br><span class=\"line\">    filename = <span class=\"string\">'cookie.txt'</span></span><br><span class=\"line\">    <span class=\"comment\">#创建MozillaCookieJar实例对象</span></span><br><span class=\"line\">    cookie = cookiejar.MozillaCookieJar()</span><br><span class=\"line\">    <span class=\"comment\">#从文件中读取cookie内容到变量</span></span><br><span class=\"line\">    cookie.load(filename, ignore_discard=<span class=\"keyword\">True</span>, ignore_expires=<span class=\"keyword\">True</span>)</span><br><span class=\"line\">    <span class=\"comment\">#利用urllib.request库的HTTPCookieProcessor对象来创建cookie处理器,也就CookieHandler</span></span><br><span class=\"line\">    handler=request.HTTPCookieProcessor(cookie)</span><br><span class=\"line\">    <span class=\"comment\">#通过CookieHandler创建opener</span></span><br><span class=\"line\">    opener = request.build_opener(handler)</span><br><span class=\"line\">    <span class=\"comment\">#此用opener的open方法打开网页</span></span><br><span class=\"line\">    response = opener.open(<span class=\"string\">'http://www.baidu.com'</span>)</span><br><span class=\"line\">    <span class=\"comment\">#打印信息</span></span><br><span class=\"line\">    print(response.read().decode(<span class=\"string\">'utf-8'</span>))</span><br></pre></td></tr></table></figure></p>\n<p>了解到以上内容，我们那就可以开始正式编写模拟登陆伯乐在线的程序了。同时，我们也可以获取相亲MM的联系方式。</p>\n<h3 id=\"4-编写代码\"><a href=\"#4-编写代码\" class=\"headerlink\" title=\"(4).编写代码\"></a>(4).编写代码</h3><p>我们利用CookieJar对象实现获取cookie的功能，存储到变量中。然后使用这个cookie变量创建opener，使用这个设置好cookie的opener即可模拟登陆，同笔记四中讲到的IP代理的使用方法类似。</p>\n<p>创建cookie_test.py文件，编写代码如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> request</span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> error</span><br><span class=\"line\"><span class=\"keyword\">from</span> urllib <span class=\"keyword\">import</span> parse</span><br><span class=\"line\"><span class=\"keyword\">from</span> http <span class=\"keyword\">import</span> cookiejar</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    <span class=\"comment\">#登陆地址</span></span><br><span class=\"line\">    login_url = <span class=\"string\">'http://www.jobbole.com/wp-admin/admin-ajax.php'</span>    </span><br><span class=\"line\">    <span class=\"comment\">#User-Agent信息                   </span></span><br><span class=\"line\">    user_agent = <span class=\"string\">r'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.94 Safari/537.36'</span></span><br><span class=\"line\">    <span class=\"comment\">#Headers信息</span></span><br><span class=\"line\">    head = &#123;<span class=\"string\">'User-Agnet'</span>: user_agent, <span class=\"string\">'Connection'</span>: <span class=\"string\">'keep-alive'</span>&#125;</span><br><span class=\"line\">    <span class=\"comment\">#登陆Form_Data信息</span></span><br><span class=\"line\">    Login_Data = &#123;&#125;</span><br><span class=\"line\">    Login_Data[<span class=\"string\">'action'</span>] = <span class=\"string\">'user_login'</span></span><br><span class=\"line\">    Login_Data[<span class=\"string\">'redirect_url'</span>] = <span class=\"string\">'http://www.jobbole.com/'</span></span><br><span class=\"line\">    Login_Data[<span class=\"string\">'remember_me'</span>] = <span class=\"string\">'0'</span>         <span class=\"comment\">#是否一个月内自动登陆</span></span><br><span class=\"line\">    Login_Data[<span class=\"string\">'user_login'</span>] = <span class=\"string\">'********'</span>       <span class=\"comment\">#改成你自己的用户名</span></span><br><span class=\"line\">    Login_Data[<span class=\"string\">'user_pass'</span>] = <span class=\"string\">'********'</span>        <span class=\"comment\">#改成你自己的密码</span></span><br><span class=\"line\">    <span class=\"comment\">#使用urlencode方法转换标准格式</span></span><br><span class=\"line\">    logingpostdata = parse.urlencode(Login_Data).encode(<span class=\"string\">'utf-8'</span>)</span><br><span class=\"line\">    <span class=\"comment\">#声明一个CookieJar对象实例来保存cookie</span></span><br><span class=\"line\">    cookie = cookiejar.CookieJar()</span><br><span class=\"line\">    <span class=\"comment\">#利用urllib.request库的HTTPCookieProcessor对象来创建cookie处理器,也就CookieHandler</span></span><br><span class=\"line\">    cookie_support = request.HTTPCookieProcessor(cookie)</span><br><span class=\"line\">    <span class=\"comment\">#通过CookieHandler创建opener</span></span><br><span class=\"line\">    opener = request.build_opener(cookie_support)</span><br><span class=\"line\">    <span class=\"comment\">#创建Request对象</span></span><br><span class=\"line\">    req1 = request.Request(url=login_url, data=logingpostdata, headers=head)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#面向对象地址</span></span><br><span class=\"line\">    date_url = <span class=\"string\">'http://date.jobbole.com/wp-admin/admin-ajax.php'</span></span><br><span class=\"line\">    <span class=\"comment\">#面向对象</span></span><br><span class=\"line\">    Date_Data = &#123;&#125;</span><br><span class=\"line\">    Date_Data[<span class=\"string\">'action'</span>] = <span class=\"string\">'get_date_contact'</span></span><br><span class=\"line\">    Date_Data[<span class=\"string\">'postId'</span>] = <span class=\"string\">'4128'</span></span><br><span class=\"line\">    <span class=\"comment\">#使用urlencode方法转换标准格式</span></span><br><span class=\"line\">    datepostdata = parse.urlencode(Date_Data).encode(<span class=\"string\">'utf-8'</span>)</span><br><span class=\"line\">    req2 = request.Request(url=date_url, data=datepostdata, headers=head)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"comment\">#使用自己创建的opener的open方法</span></span><br><span class=\"line\">        response1 = opener.open(req1)</span><br><span class=\"line\">        response2 = opener.open(req2)</span><br><span class=\"line\">        html = response2.read().decode(<span class=\"string\">'utf-8'</span>)</span><br><span class=\"line\">        index = html.find(<span class=\"string\">'jb_contact_email'</span>)</span><br><span class=\"line\">        <span class=\"comment\">#打印查询结果</span></span><br><span class=\"line\">        print(<span class=\"string\">'联系邮箱:%s'</span> % html[index+<span class=\"number\">19</span>:<span class=\"number\">-2</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">except</span> error.URLError <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> hasattr(e, <span class=\"string\">'code'</span>):</span><br><span class=\"line\">            print(<span class=\"string\">\"HTTPError:%d\"</span> % e.code)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> hasattr(e, <span class=\"string\">'reason'</span>):</span><br><span class=\"line\">            print(<span class=\"string\">\"URLError:%s\"</span> % e.reason)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"5-运行结果如下\"><a href=\"#5-运行结果如下\" class=\"headerlink\" title=\"(5).运行结果如下\"></a>(5).运行结果如下</h3><p><img src=\"http://img.blog.csdn.net/20170409150252854?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>。</p>"},{"title":"原码、反码、补码","date":"2018-03-27T08:10:24.000Z","_content":"## 机器数和真值\n\n在学习原码, 反码和补码之前, 需要先了解机器数和真值的概念\n### 机器数\n\n一个数在计算机中的二进制表示形式, 叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1.\n\n>比如，十进制中的数 +3 ，假设计算机字长为8位，转换成二进制就是 `00000011`。如果是 -3 ，就是 `10000011` 。那么，这里的 >`00000011` 和 `10000011` 就是机器数。\n\n### 真值\n\n因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 `10000011`，其最高位 1 代表负，其真正数值是 -3 而不是形式值131（`10000011` 转换成十进制等于 131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。\n\n>例：0000 0001 的真值 = +000 0001 = +1，1000 0001 的真值 = –000 0001 = –1\n\n在探求为何机器要使用补码之前, 让我们先了解原码, 反码和补码的概念\n<!-- more -->\n## 原码\n原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是 8 位二进制:\n\n> [+1]原 = 0000 0001\n\n> [-1]原 = 1000 0001\n\n因为第一位是符号位, 所以 8 位二进制数的取值范围就是:\n\n> [1111 1111 , 0111 1111] 即 [-127 , 127]\n\n原码是人脑最容易理解和计算的表示方式.\n\n## 反码\n反码的表示方法是:  **正数的反码是其本身，负数的反码是在其原码的基础上, 符号位不变，其余各个位取反。**\n>[+1] = [00000001]原 = [00000001]反\n\n>[-1] = [10000001]原 = [11111110]反\n\n可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.\n\n## 补码\n补码的表示方法是:  **正数的补码就是其本身, 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后 +1. `(即在反码的基础上 +1)`**\n>[+1] = [00000001]原 = [00000001]反 = [00000001]补\n\n>[-1] = [10000001]原 = [11111110]反 = [11111111]补\n\n对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.\n\n## 为何要使用原码, 反码和补码\n现在我们知道了计算机可以有三种编码方式表示一个数. 对于正数三种编码方式的结果都相同:\n> [+1] = [00000001]原 = [00000001]反 = [00000001]补\n\n是对于负数:\n\n> [-1] = [10000001]原 = [11111110]反 = [11111111]补\n\n可见原码, 反码和补码是完全不同的. 既然原码才是被人脑直接识别并用于计算表示方式, 为何还会有反码和补码呢?\n\n首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (真值的概念在本文最开头). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别\"符号位\"显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以`机器可以只有加法而没有减法`, 这样计算机运算的设计就更简单了.\n\n于是人们开始探索 将符号位参与运算, 并且只保留加法的方法. 首先来看原码:\n\n> // 计算十进制的表达式: 1 - 1 = 0\n\n> 1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2\n\n如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.`这也就是为何计算机内部不使用原码表示一个数`。\n\n**为了解决原码做减法的问题, 出现了反码:**\n\n>// 计算十进制的表达式: 1 - 1 = 0\n\n>1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0\n\n发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在\"0\"这个特殊的数值上. 虽然人们理解上 + 0和 -0 是一样的, 但是 0 带符号是没有任何意义的. 而且会有 `[0000 0000]原` 和 `[1000 0000]原` 两个编码表示 0.\n\n**于是补码的出现, 解决了0的符号以及两个编码的问题:**\n\n>1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原\n\n这样 0 用 `[0000 0000]` 表示, 而以前出现问题的 -0 则不存在了.而且可以用`[1000 0000]`表示 -128:\n\n>(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补\n\n-1-127 的结果应该是 -128, 在用补码运算的结果中, `[1000 0000]补` 就是 -128. 但是注意因为实际上是使用以前的-0的补码来表示 -128, **所以 -128 并没有原码和反码表示** (对 -128 的补码表示 `[1000 0000]补` 算出来的原码是`[0000 0000]原` , 这是不正确的)\n\n使用补码, `不仅仅修复了 0 的符号以及存在两个编码的问题`, 而且`还能够多表示一个最低数`. 这就是为什么 8 位二进制, 使用原码或反码表示的范围为 [-127, +127], 而使用补码表示的范围为 [-128, 127].\n\n**故机器的存储是使用补码**, 所以对于编程中常用到的 32 位 int 类型, 可以表示范围是: [-2^31, 2^31-1] 因为第一位表示的是符号位.`而使用补码表示时又可以多保存一个最小值。`\n\n\n\n## 参考\n1. https://www.jianshu.com/p/279d9eba0985\n","source":"_posts/原码、反码、补码.md","raw":"---\ntitle: 原码、反码、补码\ndate: 2018-03-27 16:10:24\ntags: 计算机基础\n---\n## 机器数和真值\n\n在学习原码, 反码和补码之前, 需要先了解机器数和真值的概念\n### 机器数\n\n一个数在计算机中的二进制表示形式, 叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1.\n\n>比如，十进制中的数 +3 ，假设计算机字长为8位，转换成二进制就是 `00000011`。如果是 -3 ，就是 `10000011` 。那么，这里的 >`00000011` 和 `10000011` 就是机器数。\n\n### 真值\n\n因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 `10000011`，其最高位 1 代表负，其真正数值是 -3 而不是形式值131（`10000011` 转换成十进制等于 131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。\n\n>例：0000 0001 的真值 = +000 0001 = +1，1000 0001 的真值 = –000 0001 = –1\n\n在探求为何机器要使用补码之前, 让我们先了解原码, 反码和补码的概念\n<!-- more -->\n## 原码\n原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是 8 位二进制:\n\n> [+1]原 = 0000 0001\n\n> [-1]原 = 1000 0001\n\n因为第一位是符号位, 所以 8 位二进制数的取值范围就是:\n\n> [1111 1111 , 0111 1111] 即 [-127 , 127]\n\n原码是人脑最容易理解和计算的表示方式.\n\n## 反码\n反码的表示方法是:  **正数的反码是其本身，负数的反码是在其原码的基础上, 符号位不变，其余各个位取反。**\n>[+1] = [00000001]原 = [00000001]反\n\n>[-1] = [10000001]原 = [11111110]反\n\n可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.\n\n## 补码\n补码的表示方法是:  **正数的补码就是其本身, 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后 +1. `(即在反码的基础上 +1)`**\n>[+1] = [00000001]原 = [00000001]反 = [00000001]补\n\n>[-1] = [10000001]原 = [11111110]反 = [11111111]补\n\n对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.\n\n## 为何要使用原码, 反码和补码\n现在我们知道了计算机可以有三种编码方式表示一个数. 对于正数三种编码方式的结果都相同:\n> [+1] = [00000001]原 = [00000001]反 = [00000001]补\n\n是对于负数:\n\n> [-1] = [10000001]原 = [11111110]反 = [11111111]补\n\n可见原码, 反码和补码是完全不同的. 既然原码才是被人脑直接识别并用于计算表示方式, 为何还会有反码和补码呢?\n\n首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (真值的概念在本文最开头). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别\"符号位\"显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以`机器可以只有加法而没有减法`, 这样计算机运算的设计就更简单了.\n\n于是人们开始探索 将符号位参与运算, 并且只保留加法的方法. 首先来看原码:\n\n> // 计算十进制的表达式: 1 - 1 = 0\n\n> 1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2\n\n如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.`这也就是为何计算机内部不使用原码表示一个数`。\n\n**为了解决原码做减法的问题, 出现了反码:**\n\n>// 计算十进制的表达式: 1 - 1 = 0\n\n>1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0\n\n发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在\"0\"这个特殊的数值上. 虽然人们理解上 + 0和 -0 是一样的, 但是 0 带符号是没有任何意义的. 而且会有 `[0000 0000]原` 和 `[1000 0000]原` 两个编码表示 0.\n\n**于是补码的出现, 解决了0的符号以及两个编码的问题:**\n\n>1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原\n\n这样 0 用 `[0000 0000]` 表示, 而以前出现问题的 -0 则不存在了.而且可以用`[1000 0000]`表示 -128:\n\n>(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补\n\n-1-127 的结果应该是 -128, 在用补码运算的结果中, `[1000 0000]补` 就是 -128. 但是注意因为实际上是使用以前的-0的补码来表示 -128, **所以 -128 并没有原码和反码表示** (对 -128 的补码表示 `[1000 0000]补` 算出来的原码是`[0000 0000]原` , 这是不正确的)\n\n使用补码, `不仅仅修复了 0 的符号以及存在两个编码的问题`, 而且`还能够多表示一个最低数`. 这就是为什么 8 位二进制, 使用原码或反码表示的范围为 [-127, +127], 而使用补码表示的范围为 [-128, 127].\n\n**故机器的存储是使用补码**, 所以对于编程中常用到的 32 位 int 类型, 可以表示范围是: [-2^31, 2^31-1] 因为第一位表示的是符号位.`而使用补码表示时又可以多保存一个最小值。`\n\n\n\n## 参考\n1. https://www.jianshu.com/p/279d9eba0985\n","slug":"原码、反码、补码","published":1,"updated":"2018-03-27T13:05:48.413Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozn6006c8motaz4gv2kh","content":"<h2 id=\"机器数和真值\"><a href=\"#机器数和真值\" class=\"headerlink\" title=\"机器数和真值\"></a>机器数和真值</h2><p>在学习原码, 反码和补码之前, 需要先了解机器数和真值的概念</p>\n<h3 id=\"机器数\"><a href=\"#机器数\" class=\"headerlink\" title=\"机器数\"></a>机器数</h3><p>一个数在计算机中的二进制表示形式, 叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1.</p>\n<blockquote>\n<p>比如，十进制中的数 +3 ，假设计算机字长为8位，转换成二进制就是 <code>00000011</code>。如果是 -3 ，就是 <code>10000011</code> 。那么，这里的 &gt;<code>00000011</code> 和 <code>10000011</code> 就是机器数。</p>\n</blockquote>\n<h3 id=\"真值\"><a href=\"#真值\" class=\"headerlink\" title=\"真值\"></a>真值</h3><p>因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 <code>10000011</code>，其最高位 1 代表负，其真正数值是 -3 而不是形式值131（<code>10000011</code> 转换成十进制等于 131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。</p>\n<blockquote>\n<p>例：0000 0001 的真值 = +000 0001 = +1，1000 0001 的真值 = –000 0001 = –1</p>\n</blockquote>\n<p>在探求为何机器要使用补码之前, 让我们先了解原码, 反码和补码的概念<br><a id=\"more\"></a></p>\n<h2 id=\"原码\"><a href=\"#原码\" class=\"headerlink\" title=\"原码\"></a>原码</h2><p>原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是 8 位二进制:</p>\n<blockquote>\n<p>[+1]原 = 0000 0001</p>\n</blockquote>\n<blockquote>\n<p>[-1]原 = 1000 0001</p>\n</blockquote>\n<p>因为第一位是符号位, 所以 8 位二进制数的取值范围就是:</p>\n<blockquote>\n<p>[1111 1111 , 0111 1111] 即 [-127 , 127]</p>\n</blockquote>\n<p>原码是人脑最容易理解和计算的表示方式.</p>\n<h2 id=\"反码\"><a href=\"#反码\" class=\"headerlink\" title=\"反码\"></a>反码</h2><p>反码的表示方法是:  <strong>正数的反码是其本身，负数的反码是在其原码的基础上, 符号位不变，其余各个位取反。</strong></p>\n<blockquote>\n<p>[+1] = [00000001]原 = [00000001]反</p>\n</blockquote>\n<blockquote>\n<p>[-1] = [10000001]原 = [11111110]反</p>\n</blockquote>\n<p>可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.</p>\n<h2 id=\"补码\"><a href=\"#补码\" class=\"headerlink\" title=\"补码\"></a>补码</h2><p>补码的表示方法是:  <strong>正数的补码就是其本身, 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后 +1. <code>(即在反码的基础上 +1)</code></strong></p>\n<blockquote>\n<p>[+1] = [00000001]原 = [00000001]反 = [00000001]补</p>\n</blockquote>\n<blockquote>\n<p>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p>\n</blockquote>\n<p>对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.</p>\n<h2 id=\"为何要使用原码-反码和补码\"><a href=\"#为何要使用原码-反码和补码\" class=\"headerlink\" title=\"为何要使用原码, 反码和补码\"></a>为何要使用原码, 反码和补码</h2><p>现在我们知道了计算机可以有三种编码方式表示一个数. 对于正数三种编码方式的结果都相同:</p>\n<blockquote>\n<p>[+1] = [00000001]原 = [00000001]反 = [00000001]补</p>\n</blockquote>\n<p>是对于负数:</p>\n<blockquote>\n<p>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p>\n</blockquote>\n<p>可见原码, 反码和补码是完全不同的. 既然原码才是被人脑直接识别并用于计算表示方式, 为何还会有反码和补码呢?</p>\n<p>首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (真值的概念在本文最开头). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别”符号位”显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以<code>机器可以只有加法而没有减法</code>, 这样计算机运算的设计就更简单了.</p>\n<p>于是人们开始探索 将符号位参与运算, 并且只保留加法的方法. 首先来看原码:</p>\n<blockquote>\n<p>// 计算十进制的表达式: 1 - 1 = 0</p>\n</blockquote>\n<blockquote>\n<p>1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2</p>\n</blockquote>\n<p>如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.<code>这也就是为何计算机内部不使用原码表示一个数</code>。</p>\n<p><strong>为了解决原码做减法的问题, 出现了反码:</strong></p>\n<blockquote>\n<p>// 计算十进制的表达式: 1 - 1 = 0</p>\n</blockquote>\n<blockquote>\n<p>1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0</p>\n</blockquote>\n<p>发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在”0”这个特殊的数值上. 虽然人们理解上 + 0和 -0 是一样的, 但是 0 带符号是没有任何意义的. 而且会有 <code>[0000 0000]原</code> 和 <code>[1000 0000]原</code> 两个编码表示 0.</p>\n<p><strong>于是补码的出现, 解决了0的符号以及两个编码的问题:</strong></p>\n<blockquote>\n<p>1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原</p>\n</blockquote>\n<p>这样 0 用 <code>[0000 0000]</code> 表示, 而以前出现问题的 -0 则不存在了.而且可以用<code>[1000 0000]</code>表示 -128:</p>\n<blockquote>\n<p>(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补</p>\n</blockquote>\n<p>-1-127 的结果应该是 -128, 在用补码运算的结果中, <code>[1000 0000]补</code> 就是 -128. 但是注意因为实际上是使用以前的-0的补码来表示 -128, <strong>所以 -128 并没有原码和反码表示</strong> (对 -128 的补码表示 <code>[1000 0000]补</code> 算出来的原码是<code>[0000 0000]原</code> , 这是不正确的)</p>\n<p>使用补码, <code>不仅仅修复了 0 的符号以及存在两个编码的问题</code>, 而且<code>还能够多表示一个最低数</code>. 这就是为什么 8 位二进制, 使用原码或反码表示的范围为 [-127, +127], 而使用补码表示的范围为 [-128, 127].</p>\n<p><strong>故机器的存储是使用补码</strong>, 所以对于编程中常用到的 32 位 int 类型, 可以表示范围是: [-2^31, 2^31-1] 因为第一位表示的是符号位.<code>而使用补码表示时又可以多保存一个最小值。</code></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://www.jianshu.com/p/279d9eba0985\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/279d9eba0985</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"机器数和真值\"><a href=\"#机器数和真值\" class=\"headerlink\" title=\"机器数和真值\"></a>机器数和真值</h2><p>在学习原码, 反码和补码之前, 需要先了解机器数和真值的概念</p>\n<h3 id=\"机器数\"><a href=\"#机器数\" class=\"headerlink\" title=\"机器数\"></a>机器数</h3><p>一个数在计算机中的二进制表示形式, 叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1.</p>\n<blockquote>\n<p>比如，十进制中的数 +3 ，假设计算机字长为8位，转换成二进制就是 <code>00000011</code>。如果是 -3 ，就是 <code>10000011</code> 。那么，这里的 &gt;<code>00000011</code> 和 <code>10000011</code> 就是机器数。</p>\n</blockquote>\n<h3 id=\"真值\"><a href=\"#真值\" class=\"headerlink\" title=\"真值\"></a>真值</h3><p>因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 <code>10000011</code>，其最高位 1 代表负，其真正数值是 -3 而不是形式值131（<code>10000011</code> 转换成十进制等于 131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。</p>\n<blockquote>\n<p>例：0000 0001 的真值 = +000 0001 = +1，1000 0001 的真值 = –000 0001 = –1</p>\n</blockquote>\n<p>在探求为何机器要使用补码之前, 让我们先了解原码, 反码和补码的概念<br>","more":"</p>\n<h2 id=\"原码\"><a href=\"#原码\" class=\"headerlink\" title=\"原码\"></a>原码</h2><p>原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是 8 位二进制:</p>\n<blockquote>\n<p>[+1]原 = 0000 0001</p>\n</blockquote>\n<blockquote>\n<p>[-1]原 = 1000 0001</p>\n</blockquote>\n<p>因为第一位是符号位, 所以 8 位二进制数的取值范围就是:</p>\n<blockquote>\n<p>[1111 1111 , 0111 1111] 即 [-127 , 127]</p>\n</blockquote>\n<p>原码是人脑最容易理解和计算的表示方式.</p>\n<h2 id=\"反码\"><a href=\"#反码\" class=\"headerlink\" title=\"反码\"></a>反码</h2><p>反码的表示方法是:  <strong>正数的反码是其本身，负数的反码是在其原码的基础上, 符号位不变，其余各个位取反。</strong></p>\n<blockquote>\n<p>[+1] = [00000001]原 = [00000001]反</p>\n</blockquote>\n<blockquote>\n<p>[-1] = [10000001]原 = [11111110]反</p>\n</blockquote>\n<p>可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.</p>\n<h2 id=\"补码\"><a href=\"#补码\" class=\"headerlink\" title=\"补码\"></a>补码</h2><p>补码的表示方法是:  <strong>正数的补码就是其本身, 负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后 +1. <code>(即在反码的基础上 +1)</code></strong></p>\n<blockquote>\n<p>[+1] = [00000001]原 = [00000001]反 = [00000001]补</p>\n</blockquote>\n<blockquote>\n<p>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p>\n</blockquote>\n<p>对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.</p>\n<h2 id=\"为何要使用原码-反码和补码\"><a href=\"#为何要使用原码-反码和补码\" class=\"headerlink\" title=\"为何要使用原码, 反码和补码\"></a>为何要使用原码, 反码和补码</h2><p>现在我们知道了计算机可以有三种编码方式表示一个数. 对于正数三种编码方式的结果都相同:</p>\n<blockquote>\n<p>[+1] = [00000001]原 = [00000001]反 = [00000001]补</p>\n</blockquote>\n<p>是对于负数:</p>\n<blockquote>\n<p>[-1] = [10000001]原 = [11111110]反 = [11111111]补</p>\n</blockquote>\n<p>可见原码, 反码和补码是完全不同的. 既然原码才是被人脑直接识别并用于计算表示方式, 为何还会有反码和补码呢?</p>\n<p>首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (真值的概念在本文最开头). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别”符号位”显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以<code>机器可以只有加法而没有减法</code>, 这样计算机运算的设计就更简单了.</p>\n<p>于是人们开始探索 将符号位参与运算, 并且只保留加法的方法. 首先来看原码:</p>\n<blockquote>\n<p>// 计算十进制的表达式: 1 - 1 = 0</p>\n</blockquote>\n<blockquote>\n<p>1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2</p>\n</blockquote>\n<p>如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.<code>这也就是为何计算机内部不使用原码表示一个数</code>。</p>\n<p><strong>为了解决原码做减法的问题, 出现了反码:</strong></p>\n<blockquote>\n<p>// 计算十进制的表达式: 1 - 1 = 0</p>\n</blockquote>\n<blockquote>\n<p>1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0</p>\n</blockquote>\n<p>发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在”0”这个特殊的数值上. 虽然人们理解上 + 0和 -0 是一样的, 但是 0 带符号是没有任何意义的. 而且会有 <code>[0000 0000]原</code> 和 <code>[1000 0000]原</code> 两个编码表示 0.</p>\n<p><strong>于是补码的出现, 解决了0的符号以及两个编码的问题:</strong></p>\n<blockquote>\n<p>1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原</p>\n</blockquote>\n<p>这样 0 用 <code>[0000 0000]</code> 表示, 而以前出现问题的 -0 则不存在了.而且可以用<code>[1000 0000]</code>表示 -128:</p>\n<blockquote>\n<p>(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补</p>\n</blockquote>\n<p>-1-127 的结果应该是 -128, 在用补码运算的结果中, <code>[1000 0000]补</code> 就是 -128. 但是注意因为实际上是使用以前的-0的补码来表示 -128, <strong>所以 -128 并没有原码和反码表示</strong> (对 -128 的补码表示 <code>[1000 0000]补</code> 算出来的原码是<code>[0000 0000]原</code> , 这是不正确的)</p>\n<p>使用补码, <code>不仅仅修复了 0 的符号以及存在两个编码的问题</code>, 而且<code>还能够多表示一个最低数</code>. 这就是为什么 8 位二进制, 使用原码或反码表示的范围为 [-127, +127], 而使用补码表示的范围为 [-128, 127].</p>\n<p><strong>故机器的存储是使用补码</strong>, 所以对于编程中常用到的 32 位 int 类型, 可以表示范围是: [-2^31, 2^31-1] 因为第一位表示的是符号位.<code>而使用补码表示时又可以多保存一个最小值。</code></p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://www.jianshu.com/p/279d9eba0985\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/279d9eba0985</a></li>\n</ol>"},{"title":"如何理解操作系统中的同步和异步、阻塞和非阻塞","date":"2018-03-06T17:29:38.000Z","_content":"\n## 同步\n所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。按照这个定义，其实绝大多数函数都是同步调用（例如sin, isdigit等）。但是一般而言，我们在说同步、异步的时候，特指那些需要其他部件协作或者需要一定时间完成的任务。\n\n同步，可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是出于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。\n\n最常见的例子就是 SendMessage。该函数发送一个消息给某个窗口，在对方处理完消息之前，这个函数不返回。当对方处理完毕以后，该函数才把消息处理函数所返回的 LRESULT值返回给调用者。\n\n## 异步\n异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。由另外的并行程序执行这段代码，处理完这个调用的部件在完成后，通过状态、通知和回调来通知调用者。以CAsycSocket类为例（注意，CSocket从CAsyncSocket派生，但是起功能已经由异步转化为同步），当一个客户端通过调用 Connect函数发出一个连接请求后，调用者线程立刻可以朝下运行。当连接真正建立起来以后，socket底层会发送一个消息通知该对象。\n\n这里提到执行部件和调用者通过三种途径返回结果：`状态、通知和回调`。可以使用哪一种依赖于执行部件的实现，除非执行部件提供多种选择，否则不受调用者控制。如果执行部件用状态来通知，那么调用者就需要每隔一定时间检查一次，效率就很低（有些初学多线程编程的人，总喜欢用一个循环去检查某个变量的值，这其实是一种很严重的错误）。如果是使用`通知`的方式，效率则很高，因为执行部件几乎不需要做额外的操作。至于回调函数，其实和通知没太多区别。\n\n异步，执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。\n\n<!-- more -->\n## 同步和异步类比\n同步，就是实时处理，比如服务器一接收客户端请求，马上响应，这样客户端可以在最短的时间内得到结果，但是如果多个客户端，或者一个客户端发出的请求很频繁，服务器无法同步处理，就会造成涌塞。同步如打电话，通信双方不能断（我们是同时进行，同步），你一句我一句，这样的好处是，对方想表达的信息我马上能收到，但是，我在打着电话，我无法做别的事情。\n\n异步，就是分时处理，服务器接收到客户端请求后并不是立即处理，而是等待服务器比较空闲的时候加以处理，可以避免涌塞。异步如收发收短信，对比打电话，打电话我一定要在电话的旁边听着，保证双方都在线，而收发短信，对方不用保证此刻我一定在手机旁，同时，我也不用时刻留意手机有没有来短信。这样的话，我看着视频，然后来了短信，我就处理短信（也可以不处理），接着再看视频。\n\n对于写程序，同步往往会阻塞，没有数据过来，我就等着，异步则不会阻塞，没数据来我干别的事，有数据来去处理这些数据。\n\n同步在一定程度上可以看做是单线程，这个线程请求一个方法后就待这个方法给他回复，否则他不往下执行（死心眼）。\n异步在一定程度上可以看做是多线程的（废话，一个线程怎么叫异步），请求一个方法后，就不管了，继续执行其他的方法。\n\n## 阻塞\n阻塞调用是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后才会返回。\n\n有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。例如，我们在CSocket中调用Receive函数，如果缓冲区中没有数据，这个函数就会一直等待，直到有数据才返回。而此时，当前线程还会继续处理各种各样的消息。如果主窗口和调用函数在同一个线程中，除非你在特殊的界面操作函数中调用，其实主界面还是应该可以刷新。\n\nsocket接收数据的另外一个函数recv则是一个阻塞调用的例子。当socket工作在阻塞模式的时候，如果没有数据的情况下调用该函数，则当前线程就会被挂起，直到有数据为止。\n\n## 非阻塞\n非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。\n\n### 对象的阻塞模式和阻塞函数调用\n\n对象是否处于阻塞模式和函数是不是阻塞调用有很强的相关性，但是并不是一一对应的。阻塞对象上可以有非阻塞的调用方式，我们可以通过一定的API去轮询状态，在适当的时候调用阻塞函数，就可以避免阻塞。而对于非阻塞对象，调用特殊的函数也可以进入阻塞调用。函数select就是这样的一个例子。\n","source":"_posts/如何理解操作系统中的同步和异步、阻塞和非阻塞.md","raw":"---\ntitle: 如何理解操作系统中的同步和异步、阻塞和非阻塞\ndate: 2018-03-07 01:29:38\ntags:\n  - 操作系统\ncategories:\n  - 操作系统\n  - 多任务处理\n---\n\n## 同步\n所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。按照这个定义，其实绝大多数函数都是同步调用（例如sin, isdigit等）。但是一般而言，我们在说同步、异步的时候，特指那些需要其他部件协作或者需要一定时间完成的任务。\n\n同步，可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是出于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。\n\n最常见的例子就是 SendMessage。该函数发送一个消息给某个窗口，在对方处理完消息之前，这个函数不返回。当对方处理完毕以后，该函数才把消息处理函数所返回的 LRESULT值返回给调用者。\n\n## 异步\n异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。由另外的并行程序执行这段代码，处理完这个调用的部件在完成后，通过状态、通知和回调来通知调用者。以CAsycSocket类为例（注意，CSocket从CAsyncSocket派生，但是起功能已经由异步转化为同步），当一个客户端通过调用 Connect函数发出一个连接请求后，调用者线程立刻可以朝下运行。当连接真正建立起来以后，socket底层会发送一个消息通知该对象。\n\n这里提到执行部件和调用者通过三种途径返回结果：`状态、通知和回调`。可以使用哪一种依赖于执行部件的实现，除非执行部件提供多种选择，否则不受调用者控制。如果执行部件用状态来通知，那么调用者就需要每隔一定时间检查一次，效率就很低（有些初学多线程编程的人，总喜欢用一个循环去检查某个变量的值，这其实是一种很严重的错误）。如果是使用`通知`的方式，效率则很高，因为执行部件几乎不需要做额外的操作。至于回调函数，其实和通知没太多区别。\n\n异步，执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。\n\n<!-- more -->\n## 同步和异步类比\n同步，就是实时处理，比如服务器一接收客户端请求，马上响应，这样客户端可以在最短的时间内得到结果，但是如果多个客户端，或者一个客户端发出的请求很频繁，服务器无法同步处理，就会造成涌塞。同步如打电话，通信双方不能断（我们是同时进行，同步），你一句我一句，这样的好处是，对方想表达的信息我马上能收到，但是，我在打着电话，我无法做别的事情。\n\n异步，就是分时处理，服务器接收到客户端请求后并不是立即处理，而是等待服务器比较空闲的时候加以处理，可以避免涌塞。异步如收发收短信，对比打电话，打电话我一定要在电话的旁边听着，保证双方都在线，而收发短信，对方不用保证此刻我一定在手机旁，同时，我也不用时刻留意手机有没有来短信。这样的话，我看着视频，然后来了短信，我就处理短信（也可以不处理），接着再看视频。\n\n对于写程序，同步往往会阻塞，没有数据过来，我就等着，异步则不会阻塞，没数据来我干别的事，有数据来去处理这些数据。\n\n同步在一定程度上可以看做是单线程，这个线程请求一个方法后就待这个方法给他回复，否则他不往下执行（死心眼）。\n异步在一定程度上可以看做是多线程的（废话，一个线程怎么叫异步），请求一个方法后，就不管了，继续执行其他的方法。\n\n## 阻塞\n阻塞调用是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后才会返回。\n\n有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。例如，我们在CSocket中调用Receive函数，如果缓冲区中没有数据，这个函数就会一直等待，直到有数据才返回。而此时，当前线程还会继续处理各种各样的消息。如果主窗口和调用函数在同一个线程中，除非你在特殊的界面操作函数中调用，其实主界面还是应该可以刷新。\n\nsocket接收数据的另外一个函数recv则是一个阻塞调用的例子。当socket工作在阻塞模式的时候，如果没有数据的情况下调用该函数，则当前线程就会被挂起，直到有数据为止。\n\n## 非阻塞\n非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。\n\n### 对象的阻塞模式和阻塞函数调用\n\n对象是否处于阻塞模式和函数是不是阻塞调用有很强的相关性，但是并不是一一对应的。阻塞对象上可以有非阻塞的调用方式，我们可以通过一定的API去轮询状态，在适当的时候调用阻塞函数，就可以避免阻塞。而对于非阻塞对象，调用特殊的函数也可以进入阻塞调用。函数select就是这样的一个例子。\n","slug":"如何理解操作系统中的同步和异步、阻塞和非阻塞","published":1,"updated":"2018-03-09T06:28:47.749Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozn8006f8moty751uial","content":"<h2 id=\"同步\"><a href=\"#同步\" class=\"headerlink\" title=\"同步\"></a>同步</h2><p>所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。按照这个定义，其实绝大多数函数都是同步调用（例如sin, isdigit等）。但是一般而言，我们在说同步、异步的时候，特指那些需要其他部件协作或者需要一定时间完成的任务。</p>\n<p>同步，可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是出于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。</p>\n<p>最常见的例子就是 SendMessage。该函数发送一个消息给某个窗口，在对方处理完消息之前，这个函数不返回。当对方处理完毕以后，该函数才把消息处理函数所返回的 LRESULT值返回给调用者。</p>\n<h2 id=\"异步\"><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a>异步</h2><p>异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。由另外的并行程序执行这段代码，处理完这个调用的部件在完成后，通过状态、通知和回调来通知调用者。以CAsycSocket类为例（注意，CSocket从CAsyncSocket派生，但是起功能已经由异步转化为同步），当一个客户端通过调用 Connect函数发出一个连接请求后，调用者线程立刻可以朝下运行。当连接真正建立起来以后，socket底层会发送一个消息通知该对象。</p>\n<p>这里提到执行部件和调用者通过三种途径返回结果：<code>状态、通知和回调</code>。可以使用哪一种依赖于执行部件的实现，除非执行部件提供多种选择，否则不受调用者控制。如果执行部件用状态来通知，那么调用者就需要每隔一定时间检查一次，效率就很低（有些初学多线程编程的人，总喜欢用一个循环去检查某个变量的值，这其实是一种很严重的错误）。如果是使用<code>通知</code>的方式，效率则很高，因为执行部件几乎不需要做额外的操作。至于回调函数，其实和通知没太多区别。</p>\n<p>异步，执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。</p>\n<a id=\"more\"></a>\n<h2 id=\"同步和异步类比\"><a href=\"#同步和异步类比\" class=\"headerlink\" title=\"同步和异步类比\"></a>同步和异步类比</h2><p>同步，就是实时处理，比如服务器一接收客户端请求，马上响应，这样客户端可以在最短的时间内得到结果，但是如果多个客户端，或者一个客户端发出的请求很频繁，服务器无法同步处理，就会造成涌塞。同步如打电话，通信双方不能断（我们是同时进行，同步），你一句我一句，这样的好处是，对方想表达的信息我马上能收到，但是，我在打着电话，我无法做别的事情。</p>\n<p>异步，就是分时处理，服务器接收到客户端请求后并不是立即处理，而是等待服务器比较空闲的时候加以处理，可以避免涌塞。异步如收发收短信，对比打电话，打电话我一定要在电话的旁边听着，保证双方都在线，而收发短信，对方不用保证此刻我一定在手机旁，同时，我也不用时刻留意手机有没有来短信。这样的话，我看着视频，然后来了短信，我就处理短信（也可以不处理），接着再看视频。</p>\n<p>对于写程序，同步往往会阻塞，没有数据过来，我就等着，异步则不会阻塞，没数据来我干别的事，有数据来去处理这些数据。</p>\n<p>同步在一定程度上可以看做是单线程，这个线程请求一个方法后就待这个方法给他回复，否则他不往下执行（死心眼）。<br>异步在一定程度上可以看做是多线程的（废话，一个线程怎么叫异步），请求一个方法后，就不管了，继续执行其他的方法。</p>\n<h2 id=\"阻塞\"><a href=\"#阻塞\" class=\"headerlink\" title=\"阻塞\"></a>阻塞</h2><p>阻塞调用是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后才会返回。</p>\n<p>有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。例如，我们在CSocket中调用Receive函数，如果缓冲区中没有数据，这个函数就会一直等待，直到有数据才返回。而此时，当前线程还会继续处理各种各样的消息。如果主窗口和调用函数在同一个线程中，除非你在特殊的界面操作函数中调用，其实主界面还是应该可以刷新。</p>\n<p>socket接收数据的另外一个函数recv则是一个阻塞调用的例子。当socket工作在阻塞模式的时候，如果没有数据的情况下调用该函数，则当前线程就会被挂起，直到有数据为止。</p>\n<h2 id=\"非阻塞\"><a href=\"#非阻塞\" class=\"headerlink\" title=\"非阻塞\"></a>非阻塞</h2><p>非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</p>\n<h3 id=\"对象的阻塞模式和阻塞函数调用\"><a href=\"#对象的阻塞模式和阻塞函数调用\" class=\"headerlink\" title=\"对象的阻塞模式和阻塞函数调用\"></a>对象的阻塞模式和阻塞函数调用</h3><p>对象是否处于阻塞模式和函数是不是阻塞调用有很强的相关性，但是并不是一一对应的。阻塞对象上可以有非阻塞的调用方式，我们可以通过一定的API去轮询状态，在适当的时候调用阻塞函数，就可以避免阻塞。而对于非阻塞对象，调用特殊的函数也可以进入阻塞调用。函数select就是这样的一个例子。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"同步\"><a href=\"#同步\" class=\"headerlink\" title=\"同步\"></a>同步</h2><p>所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。按照这个定义，其实绝大多数函数都是同步调用（例如sin, isdigit等）。但是一般而言，我们在说同步、异步的时候，特指那些需要其他部件协作或者需要一定时间完成的任务。</p>\n<p>同步，可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是出于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。</p>\n<p>最常见的例子就是 SendMessage。该函数发送一个消息给某个窗口，在对方处理完消息之前，这个函数不返回。当对方处理完毕以后，该函数才把消息处理函数所返回的 LRESULT值返回给调用者。</p>\n<h2 id=\"异步\"><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a>异步</h2><p>异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。由另外的并行程序执行这段代码，处理完这个调用的部件在完成后，通过状态、通知和回调来通知调用者。以CAsycSocket类为例（注意，CSocket从CAsyncSocket派生，但是起功能已经由异步转化为同步），当一个客户端通过调用 Connect函数发出一个连接请求后，调用者线程立刻可以朝下运行。当连接真正建立起来以后，socket底层会发送一个消息通知该对象。</p>\n<p>这里提到执行部件和调用者通过三种途径返回结果：<code>状态、通知和回调</code>。可以使用哪一种依赖于执行部件的实现，除非执行部件提供多种选择，否则不受调用者控制。如果执行部件用状态来通知，那么调用者就需要每隔一定时间检查一次，效率就很低（有些初学多线程编程的人，总喜欢用一个循环去检查某个变量的值，这其实是一种很严重的错误）。如果是使用<code>通知</code>的方式，效率则很高，因为执行部件几乎不需要做额外的操作。至于回调函数，其实和通知没太多区别。</p>\n<p>异步，执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。</p>","more":"<h2 id=\"同步和异步类比\"><a href=\"#同步和异步类比\" class=\"headerlink\" title=\"同步和异步类比\"></a>同步和异步类比</h2><p>同步，就是实时处理，比如服务器一接收客户端请求，马上响应，这样客户端可以在最短的时间内得到结果，但是如果多个客户端，或者一个客户端发出的请求很频繁，服务器无法同步处理，就会造成涌塞。同步如打电话，通信双方不能断（我们是同时进行，同步），你一句我一句，这样的好处是，对方想表达的信息我马上能收到，但是，我在打着电话，我无法做别的事情。</p>\n<p>异步，就是分时处理，服务器接收到客户端请求后并不是立即处理，而是等待服务器比较空闲的时候加以处理，可以避免涌塞。异步如收发收短信，对比打电话，打电话我一定要在电话的旁边听着，保证双方都在线，而收发短信，对方不用保证此刻我一定在手机旁，同时，我也不用时刻留意手机有没有来短信。这样的话，我看着视频，然后来了短信，我就处理短信（也可以不处理），接着再看视频。</p>\n<p>对于写程序，同步往往会阻塞，没有数据过来，我就等着，异步则不会阻塞，没数据来我干别的事，有数据来去处理这些数据。</p>\n<p>同步在一定程度上可以看做是单线程，这个线程请求一个方法后就待这个方法给他回复，否则他不往下执行（死心眼）。<br>异步在一定程度上可以看做是多线程的（废话，一个线程怎么叫异步），请求一个方法后，就不管了，继续执行其他的方法。</p>\n<h2 id=\"阻塞\"><a href=\"#阻塞\" class=\"headerlink\" title=\"阻塞\"></a>阻塞</h2><p>阻塞调用是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后才会返回。</p>\n<p>有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。例如，我们在CSocket中调用Receive函数，如果缓冲区中没有数据，这个函数就会一直等待，直到有数据才返回。而此时，当前线程还会继续处理各种各样的消息。如果主窗口和调用函数在同一个线程中，除非你在特殊的界面操作函数中调用，其实主界面还是应该可以刷新。</p>\n<p>socket接收数据的另外一个函数recv则是一个阻塞调用的例子。当socket工作在阻塞模式的时候，如果没有数据的情况下调用该函数，则当前线程就会被挂起，直到有数据为止。</p>\n<h2 id=\"非阻塞\"><a href=\"#非阻塞\" class=\"headerlink\" title=\"非阻塞\"></a>非阻塞</h2><p>非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</p>\n<h3 id=\"对象的阻塞模式和阻塞函数调用\"><a href=\"#对象的阻塞模式和阻塞函数调用\" class=\"headerlink\" title=\"对象的阻塞模式和阻塞函数调用\"></a>对象的阻塞模式和阻塞函数调用</h3><p>对象是否处于阻塞模式和函数是不是阻塞调用有很强的相关性，但是并不是一一对应的。阻塞对象上可以有非阻塞的调用方式，我们可以通过一定的API去轮询状态，在适当的时候调用阻塞函数，就可以避免阻塞。而对于非阻塞对象，调用特殊的函数也可以进入阻塞调用。函数select就是这样的一个例子。</p>"},{"title":"正向代理和反向代理","date":"2018-03-26T07:11:57.000Z","_content":"\n正向代理（forward proxy）代理客户端，隐藏真实客户端，\n反向代理（reverse proxy）代理服务器，隐藏真实服务端。\n\n<!-- more -->\n## 反向代理\n举例:用户想访问：\"http://ooxx.me/readme\"，但ooxx.me上并不存在readme页面，他是偷偷从另外一台服务器上取回来,然后作为自己的内容吐给用户，但用户并不知情，这很正常,用户一般都很笨。这里所提到的ooxx.me 这个域名对应的服务器就设置了反向代理功能。\n\n结论：对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。\n\n在计算机世界里，由于单个服务器的处理客户端（用户）请求能力有一个极限，当用户的接入请求蜂拥而入时，会造成服务器忙不过来的局面，可以使用多个服务器来共同分担成千上万的用户请求，这些服务器提供相同的服务，对于用户来说，根本感觉不到任何差别。\n### 反向代理用途\n1. 保证内网的安全，隐藏和保护原始服务器。可以使用反向代理提供WAF功能，阻止web攻击。大型网站，通常将反向代理作为公网访问地址，Web服务器是内网。\n2. 负载均衡，通过反向代理服务器来优化网站的负载\n\n### 反向代理的实现\n1. 需要有一个负载均衡设备来分发用户请求，将用户请求分发到空闲的服务器上\n2. 服务器返回自己的服务到负载均衡设备\n3. 负载均衡将服务器的服务返回用户\n\n以上的潜台词是：用户和负载均衡设备直接通信，也意味着`用户做服务器域名解析时，解析得到的IP其实是负载均衡的IP，而不是服务器的IP`，这样有一个好处是，当新加入/移走服务器时，仅仅需要修改负载均衡的服务器列表，而不会影响现有的服务。\n\n\n## 正向代理\n正向代理,也就是传说中的代理,他的工作原理就像一个跳板,简单的说,我是一个用户,我访问不了某网站,但是我能访问一个代理服务器，这个代理服务器呢,他能访问那个我不能访问的网站，于是我先连上代理服务器,告诉他我需要那个无法访问网站的内容，代理服务器去取回来,然后返回给我。从网站的角度,只在代理服务器来取内容的时候有一次记录，有时候并不知道是用户的请求,也隐藏了用户的资料,这取决于代理告不告诉网站。\n\n正向代理是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。\n\n### 正向代理的用途\n1. 访问原来无法访问的资源，如google\n2. 可以做缓存，加速访问资源\n3. 对客户端访问授权，上网进行认证\n4. 代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息\n\n为了便于理解，摘自[阿笠博士的回答](https://www.zhihu.com/question/24723688/answer/48369770),\n![代理.jpg](https://upload-images.jianshu.io/upload_images/2952111-a57a95d1c15ae0de.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n正向代理中，proxy和client同属一个LAN，对server透明；反向代理中，proxy和server同属一个LAN，对client透明。实际上proxy在两种代理中做的事都是代为收发请求和响应，不过从结构上来看正好左右互换了下，所以把后出现的那种代理方式叫成了反向代理。\n\n## 正向代理和反向代理的区别\n\n从用途上来讲：正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用缓冲特性减少网络使用率。反向代理的典型用途是将防火墙后面的服务器提供给Internet用户访问。反向代理还可以为后端的多台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。另外，反向代理还可以启用高级URL策略和管理技术，从而使处于不同web服务器系统的web页面同时存在于同一个URL空间下。\n\n从安全性来讲：正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此你必须采取安全措施以确保仅为经过授权的客户端提供服务。反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。\n\n打个比方，a,b,c三个人，正向代理是a通过b向C借钱，a知道c的存在 。反向代理是a向b借钱，b又向C借，a不知道c的存在。\n\n## 参考\n1. https://www.zhihu.com/question/24723688/answer/160252724\n2. https://blog.csdn.net/andyzhaojianhui/article/details/48247969\n3. https://www.cnblogs.com/Anker/p/6056540.html\n","source":"_posts/正向代理和反向代理.md","raw":"---\ntitle: 正向代理和反向代理\ndate: 2018-03-26 15:11:57\ntags:\n  - 网络\ncategories:\n  - 网络\n---\n\n正向代理（forward proxy）代理客户端，隐藏真实客户端，\n反向代理（reverse proxy）代理服务器，隐藏真实服务端。\n\n<!-- more -->\n## 反向代理\n举例:用户想访问：\"http://ooxx.me/readme\"，但ooxx.me上并不存在readme页面，他是偷偷从另外一台服务器上取回来,然后作为自己的内容吐给用户，但用户并不知情，这很正常,用户一般都很笨。这里所提到的ooxx.me 这个域名对应的服务器就设置了反向代理功能。\n\n结论：对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。\n\n在计算机世界里，由于单个服务器的处理客户端（用户）请求能力有一个极限，当用户的接入请求蜂拥而入时，会造成服务器忙不过来的局面，可以使用多个服务器来共同分担成千上万的用户请求，这些服务器提供相同的服务，对于用户来说，根本感觉不到任何差别。\n### 反向代理用途\n1. 保证内网的安全，隐藏和保护原始服务器。可以使用反向代理提供WAF功能，阻止web攻击。大型网站，通常将反向代理作为公网访问地址，Web服务器是内网。\n2. 负载均衡，通过反向代理服务器来优化网站的负载\n\n### 反向代理的实现\n1. 需要有一个负载均衡设备来分发用户请求，将用户请求分发到空闲的服务器上\n2. 服务器返回自己的服务到负载均衡设备\n3. 负载均衡将服务器的服务返回用户\n\n以上的潜台词是：用户和负载均衡设备直接通信，也意味着`用户做服务器域名解析时，解析得到的IP其实是负载均衡的IP，而不是服务器的IP`，这样有一个好处是，当新加入/移走服务器时，仅仅需要修改负载均衡的服务器列表，而不会影响现有的服务。\n\n\n## 正向代理\n正向代理,也就是传说中的代理,他的工作原理就像一个跳板,简单的说,我是一个用户,我访问不了某网站,但是我能访问一个代理服务器，这个代理服务器呢,他能访问那个我不能访问的网站，于是我先连上代理服务器,告诉他我需要那个无法访问网站的内容，代理服务器去取回来,然后返回给我。从网站的角度,只在代理服务器来取内容的时候有一次记录，有时候并不知道是用户的请求,也隐藏了用户的资料,这取决于代理告不告诉网站。\n\n正向代理是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。\n\n### 正向代理的用途\n1. 访问原来无法访问的资源，如google\n2. 可以做缓存，加速访问资源\n3. 对客户端访问授权，上网进行认证\n4. 代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息\n\n为了便于理解，摘自[阿笠博士的回答](https://www.zhihu.com/question/24723688/answer/48369770),\n![代理.jpg](https://upload-images.jianshu.io/upload_images/2952111-a57a95d1c15ae0de.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n正向代理中，proxy和client同属一个LAN，对server透明；反向代理中，proxy和server同属一个LAN，对client透明。实际上proxy在两种代理中做的事都是代为收发请求和响应，不过从结构上来看正好左右互换了下，所以把后出现的那种代理方式叫成了反向代理。\n\n## 正向代理和反向代理的区别\n\n从用途上来讲：正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用缓冲特性减少网络使用率。反向代理的典型用途是将防火墙后面的服务器提供给Internet用户访问。反向代理还可以为后端的多台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。另外，反向代理还可以启用高级URL策略和管理技术，从而使处于不同web服务器系统的web页面同时存在于同一个URL空间下。\n\n从安全性来讲：正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此你必须采取安全措施以确保仅为经过授权的客户端提供服务。反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。\n\n打个比方，a,b,c三个人，正向代理是a通过b向C借钱，a知道c的存在 。反向代理是a向b借钱，b又向C借，a不知道c的存在。\n\n## 参考\n1. https://www.zhihu.com/question/24723688/answer/160252724\n2. https://blog.csdn.net/andyzhaojianhui/article/details/48247969\n3. https://www.cnblogs.com/Anker/p/6056540.html\n","slug":"正向代理和反向代理","published":1,"updated":"2018-03-26T08:26:56.270Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14ozna006k8motq940isqm","content":"<p>正向代理（forward proxy）代理客户端，隐藏真实客户端，<br>反向代理（reverse proxy）代理服务器，隐藏真实服务端。</p>\n<a id=\"more\"></a>\n<h2 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h2><p>举例:用户想访问：”<a href=\"http://ooxx.me/readme&quot;，但ooxx.me上并不存在readme页面，他是偷偷从另外一台服务器上取回来,然后作为自己的内容吐给用户，但用户并不知情，这很正常,用户一般都很笨。这里所提到的ooxx.me\" target=\"_blank\" rel=\"noopener\">http://ooxx.me/readme&quot;，但ooxx.me上并不存在readme页面，他是偷偷从另外一台服务器上取回来,然后作为自己的内容吐给用户，但用户并不知情，这很正常,用户一般都很笨。这里所提到的ooxx.me</a> 这个域名对应的服务器就设置了反向代理功能。</p>\n<p>结论：对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。</p>\n<p>在计算机世界里，由于单个服务器的处理客户端（用户）请求能力有一个极限，当用户的接入请求蜂拥而入时，会造成服务器忙不过来的局面，可以使用多个服务器来共同分担成千上万的用户请求，这些服务器提供相同的服务，对于用户来说，根本感觉不到任何差别。</p>\n<h3 id=\"反向代理用途\"><a href=\"#反向代理用途\" class=\"headerlink\" title=\"反向代理用途\"></a>反向代理用途</h3><ol>\n<li>保证内网的安全，隐藏和保护原始服务器。可以使用反向代理提供WAF功能，阻止web攻击。大型网站，通常将反向代理作为公网访问地址，Web服务器是内网。</li>\n<li>负载均衡，通过反向代理服务器来优化网站的负载</li>\n</ol>\n<h3 id=\"反向代理的实现\"><a href=\"#反向代理的实现\" class=\"headerlink\" title=\"反向代理的实现\"></a>反向代理的实现</h3><ol>\n<li>需要有一个负载均衡设备来分发用户请求，将用户请求分发到空闲的服务器上</li>\n<li>服务器返回自己的服务到负载均衡设备</li>\n<li>负载均衡将服务器的服务返回用户</li>\n</ol>\n<p>以上的潜台词是：用户和负载均衡设备直接通信，也意味着<code>用户做服务器域名解析时，解析得到的IP其实是负载均衡的IP，而不是服务器的IP</code>，这样有一个好处是，当新加入/移走服务器时，仅仅需要修改负载均衡的服务器列表，而不会影响现有的服务。</p>\n<h2 id=\"正向代理\"><a href=\"#正向代理\" class=\"headerlink\" title=\"正向代理\"></a>正向代理</h2><p>正向代理,也就是传说中的代理,他的工作原理就像一个跳板,简单的说,我是一个用户,我访问不了某网站,但是我能访问一个代理服务器，这个代理服务器呢,他能访问那个我不能访问的网站，于是我先连上代理服务器,告诉他我需要那个无法访问网站的内容，代理服务器去取回来,然后返回给我。从网站的角度,只在代理服务器来取内容的时候有一次记录，有时候并不知道是用户的请求,也隐藏了用户的资料,这取决于代理告不告诉网站。</p>\n<p>正向代理是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。</p>\n<h3 id=\"正向代理的用途\"><a href=\"#正向代理的用途\" class=\"headerlink\" title=\"正向代理的用途\"></a>正向代理的用途</h3><ol>\n<li>访问原来无法访问的资源，如google</li>\n<li>可以做缓存，加速访问资源</li>\n<li>对客户端访问授权，上网进行认证</li>\n<li>代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息</li>\n</ol>\n<p>为了便于理解，摘自<a href=\"https://www.zhihu.com/question/24723688/answer/48369770\" target=\"_blank\" rel=\"noopener\">阿笠博士的回答</a>,<br><img src=\"https://upload-images.jianshu.io/upload_images/2952111-a57a95d1c15ae0de.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"代理.jpg\"><br>正向代理中，proxy和client同属一个LAN，对server透明；反向代理中，proxy和server同属一个LAN，对client透明。实际上proxy在两种代理中做的事都是代为收发请求和响应，不过从结构上来看正好左右互换了下，所以把后出现的那种代理方式叫成了反向代理。</p>\n<h2 id=\"正向代理和反向代理的区别\"><a href=\"#正向代理和反向代理的区别\" class=\"headerlink\" title=\"正向代理和反向代理的区别\"></a>正向代理和反向代理的区别</h2><p>从用途上来讲：正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用缓冲特性减少网络使用率。反向代理的典型用途是将防火墙后面的服务器提供给Internet用户访问。反向代理还可以为后端的多台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。另外，反向代理还可以启用高级URL策略和管理技术，从而使处于不同web服务器系统的web页面同时存在于同一个URL空间下。</p>\n<p>从安全性来讲：正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此你必须采取安全措施以确保仅为经过授权的客户端提供服务。反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。</p>\n<p>打个比方，a,b,c三个人，正向代理是a通过b向C借钱，a知道c的存在 。反向代理是a向b借钱，b又向C借，a不知道c的存在。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://www.zhihu.com/question/24723688/answer/160252724\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/24723688/answer/160252724</a></li>\n<li><a href=\"https://blog.csdn.net/andyzhaojianhui/article/details/48247969\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/andyzhaojianhui/article/details/48247969</a></li>\n<li><a href=\"https://www.cnblogs.com/Anker/p/6056540.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/Anker/p/6056540.html</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>正向代理（forward proxy）代理客户端，隐藏真实客户端，<br>反向代理（reverse proxy）代理服务器，隐藏真实服务端。</p>","more":"<h2 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h2><p>举例:用户想访问：”<a href=\"http://ooxx.me/readme&quot;，但ooxx.me上并不存在readme页面，他是偷偷从另外一台服务器上取回来,然后作为自己的内容吐给用户，但用户并不知情，这很正常,用户一般都很笨。这里所提到的ooxx.me\" target=\"_blank\" rel=\"noopener\">http://ooxx.me/readme&quot;，但ooxx.me上并不存在readme页面，他是偷偷从另外一台服务器上取回来,然后作为自己的内容吐给用户，但用户并不知情，这很正常,用户一般都很笨。这里所提到的ooxx.me</a> 这个域名对应的服务器就设置了反向代理功能。</p>\n<p>结论：对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。</p>\n<p>在计算机世界里，由于单个服务器的处理客户端（用户）请求能力有一个极限，当用户的接入请求蜂拥而入时，会造成服务器忙不过来的局面，可以使用多个服务器来共同分担成千上万的用户请求，这些服务器提供相同的服务，对于用户来说，根本感觉不到任何差别。</p>\n<h3 id=\"反向代理用途\"><a href=\"#反向代理用途\" class=\"headerlink\" title=\"反向代理用途\"></a>反向代理用途</h3><ol>\n<li>保证内网的安全，隐藏和保护原始服务器。可以使用反向代理提供WAF功能，阻止web攻击。大型网站，通常将反向代理作为公网访问地址，Web服务器是内网。</li>\n<li>负载均衡，通过反向代理服务器来优化网站的负载</li>\n</ol>\n<h3 id=\"反向代理的实现\"><a href=\"#反向代理的实现\" class=\"headerlink\" title=\"反向代理的实现\"></a>反向代理的实现</h3><ol>\n<li>需要有一个负载均衡设备来分发用户请求，将用户请求分发到空闲的服务器上</li>\n<li>服务器返回自己的服务到负载均衡设备</li>\n<li>负载均衡将服务器的服务返回用户</li>\n</ol>\n<p>以上的潜台词是：用户和负载均衡设备直接通信，也意味着<code>用户做服务器域名解析时，解析得到的IP其实是负载均衡的IP，而不是服务器的IP</code>，这样有一个好处是，当新加入/移走服务器时，仅仅需要修改负载均衡的服务器列表，而不会影响现有的服务。</p>\n<h2 id=\"正向代理\"><a href=\"#正向代理\" class=\"headerlink\" title=\"正向代理\"></a>正向代理</h2><p>正向代理,也就是传说中的代理,他的工作原理就像一个跳板,简单的说,我是一个用户,我访问不了某网站,但是我能访问一个代理服务器，这个代理服务器呢,他能访问那个我不能访问的网站，于是我先连上代理服务器,告诉他我需要那个无法访问网站的内容，代理服务器去取回来,然后返回给我。从网站的角度,只在代理服务器来取内容的时候有一次记录，有时候并不知道是用户的请求,也隐藏了用户的资料,这取决于代理告不告诉网站。</p>\n<p>正向代理是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。</p>\n<h3 id=\"正向代理的用途\"><a href=\"#正向代理的用途\" class=\"headerlink\" title=\"正向代理的用途\"></a>正向代理的用途</h3><ol>\n<li>访问原来无法访问的资源，如google</li>\n<li>可以做缓存，加速访问资源</li>\n<li>对客户端访问授权，上网进行认证</li>\n<li>代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息</li>\n</ol>\n<p>为了便于理解，摘自<a href=\"https://www.zhihu.com/question/24723688/answer/48369770\" target=\"_blank\" rel=\"noopener\">阿笠博士的回答</a>,<br><img src=\"https://upload-images.jianshu.io/upload_images/2952111-a57a95d1c15ae0de.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"代理.jpg\"><br>正向代理中，proxy和client同属一个LAN，对server透明；反向代理中，proxy和server同属一个LAN，对client透明。实际上proxy在两种代理中做的事都是代为收发请求和响应，不过从结构上来看正好左右互换了下，所以把后出现的那种代理方式叫成了反向代理。</p>\n<h2 id=\"正向代理和反向代理的区别\"><a href=\"#正向代理和反向代理的区别\" class=\"headerlink\" title=\"正向代理和反向代理的区别\"></a>正向代理和反向代理的区别</h2><p>从用途上来讲：正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用缓冲特性减少网络使用率。反向代理的典型用途是将防火墙后面的服务器提供给Internet用户访问。反向代理还可以为后端的多台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。另外，反向代理还可以启用高级URL策略和管理技术，从而使处于不同web服务器系统的web页面同时存在于同一个URL空间下。</p>\n<p>从安全性来讲：正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此你必须采取安全措施以确保仅为经过授权的客户端提供服务。反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。</p>\n<p>打个比方，a,b,c三个人，正向代理是a通过b向C借钱，a知道c的存在 。反向代理是a向b借钱，b又向C借，a不知道c的存在。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://www.zhihu.com/question/24723688/answer/160252724\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/24723688/answer/160252724</a></li>\n<li><a href=\"https://blog.csdn.net/andyzhaojianhui/article/details/48247969\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/andyzhaojianhui/article/details/48247969</a></li>\n<li><a href=\"https://www.cnblogs.com/Anker/p/6056540.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/Anker/p/6056540.html</a></li>\n</ol>"},{"title":"浅谈Session和Cookie的区别与联系","date":"2018-03-06T18:27:40.000Z","_content":"\n|      | Cookie                     | Session |\n| :--- | :------------------------- | :------ |\n| 储存位置 | 客户端                        | 服务器端    |\n| 目的   | 跟踪会话，也可以保存用户偏好设置或者保存用户名密码等 | 跟踪会话    |\n| 安全性  | 不安全                        | 安全      |\n\nsession技术是要使用到cookie的，之所以出现session技术，主要是为了安全。\n\n<!-- more -->\n\n## Session的概念\n\nSession 是存放在服务器端的，类似于Session结构来存放用户数据，当浏览器 第一次发送请求时，服务器自动生成了一个Session和一个Session ID用来唯一标识这个Session，并将其通过响应发送到浏览器。当浏览器第二次发送请求，会将前一次服务器响应中的Session ID放在请求中一并发送到服务器上，服务器从请求中提取出Session ID，并和保存的所有Session ID进行对比，找到这个用户对应的Session。\n\n一般情况下，服务器会在一定时间内（默认30分钟）保存这个 Session，过了时间限制，就会销毁这个Session。在销毁之前，程序员可以将用户的一些数据以Key和Value的形式暂时存放在这个 Session中。当然，也有使用数据库将这个Session序列化后保存起来的，这样的好处是没了时间的限制，坏处是随着时间的增加，这个数据 库会急速膨胀，特别是访问量增加的时候。一般还是采取前一种方式，以减轻服务器压力。\n\n## cookie的概念\nCookie意为“甜饼”，是由W3C组织提出，最早由Netscape社区发展的一种机制。目前Cookie已经成为标准，所有的主流浏览器如IE、Netscape、Firefox、Opera等都支持Cookie。\n\n由于HTTP是一种无状态的协议，服务器单从网络连接上无从知道客户身份。怎么办呢？就给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理。\n\nCookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。\n\n## Session的客户端实现形式（即Session ID的保存方法）\n\n一般浏览器提供了两种方式来保存，还有一种是程序员使用html隐藏域的方式自定义实现：\n\n1. 使用Cookie来保存，这是最常见的方法，本文“记住我的登录状态”功能的实现正式基于这种方式的。服务器通过设置Cookie的方式将Session ID发送到浏览器。如果我们不设置这个过期时间，那么这个Cookie将不存放在硬盘上，当浏览器关闭的时候，Cookie就消失了，这个Session ID就丢失了。如果我们设置这个时间为若干天之后，那么这个Cookie会保存在客户端硬盘中，即使浏览器关闭，这个值仍然存在，下次访问相应网站时，同 样会发送到服务器上。\n\n2. 使用URL附加信息的方式，也就是像我们经常看到JSP网站会有`aaa.jsp?JSESSIONID=*`一样的。这种方式和第一种方式里面不设置Cookie过期时间是一样的。\n\n3. 第三种方式是在页面表单里面增加隐藏域，这种方式实际上和第二种方式一样，只不过前者通过GET方式发送数据，后者使用POST方式发送数据。但是明显后者比较麻烦。\n\n## cookie与session的区别\n\ncookie数据保存在客户端，session数据保存在服务器端。\n\n简 单的说，当你登录一个网站的时候，如果web服务器端使用的是session,那么所有的数据都保存在服务器上面，客户端每次请求服务器的时候会发送 当前会话的sessionid，服务器根据当前sessionid判断相应的用户数据标志，以确定用户是否登录，或具有某种权限。由于数据是存储在服务器 上面，所以你不能伪造，但是如果你能够获取某个登录用户的sessionid，用特殊的浏览器伪造该用户的请求也是能够成功的。sessionid是服务 器和客户端链接时候随机分配的，一般来说是不会有重复，但如果有大量的并发请求，也不是没有重复的可能性，我曾经就遇到过一次。登录某个网站，开始显示的 是自己的信息，等一段时间超时了，一刷新，居然显示了别人的信息。\n\n如果浏览器使用的是 cookie，那么所有的数据都保存在浏览器端，比如你登录以后，服务器设置了 cookie用户名(username),那么，当你再次请求服务器的时候，浏览器会将username一块发送给服务器，这些变量有一定的特殊标记。服 务器会解释为 cookie变量。所以只要不关闭浏览器，那么 cookie变量便一直是有效的，所以能够保证长时间不掉线。如果你能够截获某个用户的 cookie变量，然后伪造一个数据包发送过去，那么服务器还是认为你是合法的。所以，使用 cookie被攻击的可能性比较大。如果设置了的有效时间，那么它会将 cookie保存在客户端的硬盘上，下次再访问该网站的时候，浏览器先检查有没有 cookie，如果有的话，就读取该 cookie，然后发送给服务器。如果你在机器上面保存了某个论坛 cookie，有效期是一年，如果有人入侵你的机器，将你的 cookie拷走，然后放在他的浏览器的目录下面，那么他登录该网站的时候就是用你的的身份登录的。所以 cookie是可以伪造的。当然，伪造的时候需要主意，直接copy cookie文件到 cookie目录，浏览器是不认的，他有一个index.dat文件，存储了 cookie文件的建立时间，以及是否有修改，所以你必须先要有该网站的 cookie文件，并且要从保证时间上骗过浏览器，曾经在学校的vbb论坛上面做过试验，copy别人的 cookie登录，冒用了别人的名义发帖子，完全没有问题。\n\nSession是由应用服务器维持的一个服务器端的存储空间，用户在连接服务器时，会由服务器生成一个唯一的SessionID,用该SessionID 为标识符来存取服务器端的Session存储空间。而SessionID这一数据则是保存到客户端，用Cookie保存的，用户提交页面时，会将这一 SessionID提交到服务器端，来存取Session数据。这一过程，是不用开发人员干预的。所以一旦客户端禁用Cookie，那么Session也会失效。\n\n服务器也可以通过URL重写的方式来传递SessionID的值，因此不是完全依赖Cookie。如果客户端Cookie禁用，则服务器可以自动通过重写URL的方式来保存Session的值，并且这个过程对程序员透明。\n\n可以试一下，即使不写Cookie，在使用request.getCookies();取出的Cookie数组的长度也是1，而这个Cookie的名字就是JSESSIONID，还有一个很长的二进制的字符串，是SessionID的值。\n\n## Session与Cookie的应用场景\nCookies是属于Session对象的一种。但有不同，Cookies不会占服务器资源，是存在客服端内存或者一个cookie的文本文件中；而“Session”则会占用服务器资源。所以，尽量不要使用Session，而使用Cookies。但是我们一般认为cookie是不可靠的，session是可靠地，但是目前很多著名的站点也都以来cookie。有时候为了解决禁用cookie后的页面处理，通常采用url重写技术，调用session中大量有用的方法从session中获取数据后置入页面。\n\nCookies与Session的应用场景：\nCookies的安全性能一直是倍受争议的。虽然Cookies是保存在本机上的，但是其信息的完全可见性且易于本地编辑性，往往可以引起很多的安全问题。所以Cookies到底该不该用，到底该怎样用，就有了一个需要给定的底线。\n\n先来看看，网站的敏感数据有哪些。\n\n登陆验证信息。一般采用Session(“Logon”)＝true or false的形式。\n用户的各种私人信息，比如姓名等，某种情况下，需要保存在Session里\n需要在页面间传递的内容信息，比如调查工作需要分好几步。每一步的信息都保存在Session里，最后在统一更新到数据库。\n\n当然还会有很多，这里列举一些比较典型的\n假如，一个人孤僻到不想碰Session，因为他认为，如果用户万一不小心关闭了浏览器，那么之前保存的数据就全部丢失了。所以，他出于好意，决定把这些用Session的地方，都改成用Cookies来存储，这完全是可行的，且基本操作和用Session一模一样。那么，下面就针对以上的3个典型例子，做一个分析\n很显然，只要某个有意非法入侵者，知道该网站验证登陆信息的Session变量是什么，那么他就可以事先编辑好该Cookies，放入到Cookies目录中，这样就可以顺利通过验证了。这是不是很可怕？\nCookies完全是可见的，即使程序员设定了Cookies的生存周期（比如只在用户会话有效期内有效），它也是不安全的。假设，用户忘了关浏览器 或者一个恶意者硬性把用户给打晕，那用户的损失将是巨大的。\n这点如上点一样，很容易被它人窃取重要的私人信息。但，其还有一个问题所在是，可能这些数据信息量太大，而使得Cookies的文件大小剧增。这可不是用户希望所看到的。\n\n显然，Cookies并不是那么一块好啃的小甜饼。但，Cookies的存在，当然有其原因。它给予程序员更多发挥编程才能的空间。所以，使用Cookies该有个底线。这个底线一般来说，遵循以下原则。\n不要保存私人信息。\n任何重要数据，最好通过加密形式来保存数据（最简单的可以用URLEncode，当然也可以用完善的可逆加密方式，遗憾的是，最好不要用md5来加密）。\n是否保存登陆信息，需有用户自行选择。\n长于10K的数据，不要用到Cookies。\n也不要用Cookies来玩点让客户惊喜的小游戏。\n\n## cookie最典型的应用是：\n\n1. 判断用户是否登陆过网站，以便下次登录时能够直接登录。如果我们删除cookie，则每次登录必须从新填写登录的相关信息。\n\n2. 另一个重要的应用是“购物车”中类的处理和设计。用户可能在一段时间内在同一家网站的不同页面选择不同的商品，可以将这些信息都写入cookie，在最后付款时从cookie中提取这些信息，当然这里面有了安全和性能问题需要我们考虑了。\n\n## 参考\n\n1. https://www.cnblogs.com/andy-zhou/p/5360107.html#_caption_1\n2. http://blog.csdn.net/duan1078774504/article/details/51912868\n","source":"_posts/浅谈Session和Cookie的区别与联系.md","raw":"---\ntitle: 浅谈Session和Cookie的区别与联系\ndate: 2018-03-07 02:27:40\ntags:\n  - 网络\ncategories:\n  - 网络\n---\n\n|      | Cookie                     | Session |\n| :--- | :------------------------- | :------ |\n| 储存位置 | 客户端                        | 服务器端    |\n| 目的   | 跟踪会话，也可以保存用户偏好设置或者保存用户名密码等 | 跟踪会话    |\n| 安全性  | 不安全                        | 安全      |\n\nsession技术是要使用到cookie的，之所以出现session技术，主要是为了安全。\n\n<!-- more -->\n\n## Session的概念\n\nSession 是存放在服务器端的，类似于Session结构来存放用户数据，当浏览器 第一次发送请求时，服务器自动生成了一个Session和一个Session ID用来唯一标识这个Session，并将其通过响应发送到浏览器。当浏览器第二次发送请求，会将前一次服务器响应中的Session ID放在请求中一并发送到服务器上，服务器从请求中提取出Session ID，并和保存的所有Session ID进行对比，找到这个用户对应的Session。\n\n一般情况下，服务器会在一定时间内（默认30分钟）保存这个 Session，过了时间限制，就会销毁这个Session。在销毁之前，程序员可以将用户的一些数据以Key和Value的形式暂时存放在这个 Session中。当然，也有使用数据库将这个Session序列化后保存起来的，这样的好处是没了时间的限制，坏处是随着时间的增加，这个数据 库会急速膨胀，特别是访问量增加的时候。一般还是采取前一种方式，以减轻服务器压力。\n\n## cookie的概念\nCookie意为“甜饼”，是由W3C组织提出，最早由Netscape社区发展的一种机制。目前Cookie已经成为标准，所有的主流浏览器如IE、Netscape、Firefox、Opera等都支持Cookie。\n\n由于HTTP是一种无状态的协议，服务器单从网络连接上无从知道客户身份。怎么办呢？就给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理。\n\nCookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。\n\n## Session的客户端实现形式（即Session ID的保存方法）\n\n一般浏览器提供了两种方式来保存，还有一种是程序员使用html隐藏域的方式自定义实现：\n\n1. 使用Cookie来保存，这是最常见的方法，本文“记住我的登录状态”功能的实现正式基于这种方式的。服务器通过设置Cookie的方式将Session ID发送到浏览器。如果我们不设置这个过期时间，那么这个Cookie将不存放在硬盘上，当浏览器关闭的时候，Cookie就消失了，这个Session ID就丢失了。如果我们设置这个时间为若干天之后，那么这个Cookie会保存在客户端硬盘中，即使浏览器关闭，这个值仍然存在，下次访问相应网站时，同 样会发送到服务器上。\n\n2. 使用URL附加信息的方式，也就是像我们经常看到JSP网站会有`aaa.jsp?JSESSIONID=*`一样的。这种方式和第一种方式里面不设置Cookie过期时间是一样的。\n\n3. 第三种方式是在页面表单里面增加隐藏域，这种方式实际上和第二种方式一样，只不过前者通过GET方式发送数据，后者使用POST方式发送数据。但是明显后者比较麻烦。\n\n## cookie与session的区别\n\ncookie数据保存在客户端，session数据保存在服务器端。\n\n简 单的说，当你登录一个网站的时候，如果web服务器端使用的是session,那么所有的数据都保存在服务器上面，客户端每次请求服务器的时候会发送 当前会话的sessionid，服务器根据当前sessionid判断相应的用户数据标志，以确定用户是否登录，或具有某种权限。由于数据是存储在服务器 上面，所以你不能伪造，但是如果你能够获取某个登录用户的sessionid，用特殊的浏览器伪造该用户的请求也是能够成功的。sessionid是服务 器和客户端链接时候随机分配的，一般来说是不会有重复，但如果有大量的并发请求，也不是没有重复的可能性，我曾经就遇到过一次。登录某个网站，开始显示的 是自己的信息，等一段时间超时了，一刷新，居然显示了别人的信息。\n\n如果浏览器使用的是 cookie，那么所有的数据都保存在浏览器端，比如你登录以后，服务器设置了 cookie用户名(username),那么，当你再次请求服务器的时候，浏览器会将username一块发送给服务器，这些变量有一定的特殊标记。服 务器会解释为 cookie变量。所以只要不关闭浏览器，那么 cookie变量便一直是有效的，所以能够保证长时间不掉线。如果你能够截获某个用户的 cookie变量，然后伪造一个数据包发送过去，那么服务器还是认为你是合法的。所以，使用 cookie被攻击的可能性比较大。如果设置了的有效时间，那么它会将 cookie保存在客户端的硬盘上，下次再访问该网站的时候，浏览器先检查有没有 cookie，如果有的话，就读取该 cookie，然后发送给服务器。如果你在机器上面保存了某个论坛 cookie，有效期是一年，如果有人入侵你的机器，将你的 cookie拷走，然后放在他的浏览器的目录下面，那么他登录该网站的时候就是用你的的身份登录的。所以 cookie是可以伪造的。当然，伪造的时候需要主意，直接copy cookie文件到 cookie目录，浏览器是不认的，他有一个index.dat文件，存储了 cookie文件的建立时间，以及是否有修改，所以你必须先要有该网站的 cookie文件，并且要从保证时间上骗过浏览器，曾经在学校的vbb论坛上面做过试验，copy别人的 cookie登录，冒用了别人的名义发帖子，完全没有问题。\n\nSession是由应用服务器维持的一个服务器端的存储空间，用户在连接服务器时，会由服务器生成一个唯一的SessionID,用该SessionID 为标识符来存取服务器端的Session存储空间。而SessionID这一数据则是保存到客户端，用Cookie保存的，用户提交页面时，会将这一 SessionID提交到服务器端，来存取Session数据。这一过程，是不用开发人员干预的。所以一旦客户端禁用Cookie，那么Session也会失效。\n\n服务器也可以通过URL重写的方式来传递SessionID的值，因此不是完全依赖Cookie。如果客户端Cookie禁用，则服务器可以自动通过重写URL的方式来保存Session的值，并且这个过程对程序员透明。\n\n可以试一下，即使不写Cookie，在使用request.getCookies();取出的Cookie数组的长度也是1，而这个Cookie的名字就是JSESSIONID，还有一个很长的二进制的字符串，是SessionID的值。\n\n## Session与Cookie的应用场景\nCookies是属于Session对象的一种。但有不同，Cookies不会占服务器资源，是存在客服端内存或者一个cookie的文本文件中；而“Session”则会占用服务器资源。所以，尽量不要使用Session，而使用Cookies。但是我们一般认为cookie是不可靠的，session是可靠地，但是目前很多著名的站点也都以来cookie。有时候为了解决禁用cookie后的页面处理，通常采用url重写技术，调用session中大量有用的方法从session中获取数据后置入页面。\n\nCookies与Session的应用场景：\nCookies的安全性能一直是倍受争议的。虽然Cookies是保存在本机上的，但是其信息的完全可见性且易于本地编辑性，往往可以引起很多的安全问题。所以Cookies到底该不该用，到底该怎样用，就有了一个需要给定的底线。\n\n先来看看，网站的敏感数据有哪些。\n\n登陆验证信息。一般采用Session(“Logon”)＝true or false的形式。\n用户的各种私人信息，比如姓名等，某种情况下，需要保存在Session里\n需要在页面间传递的内容信息，比如调查工作需要分好几步。每一步的信息都保存在Session里，最后在统一更新到数据库。\n\n当然还会有很多，这里列举一些比较典型的\n假如，一个人孤僻到不想碰Session，因为他认为，如果用户万一不小心关闭了浏览器，那么之前保存的数据就全部丢失了。所以，他出于好意，决定把这些用Session的地方，都改成用Cookies来存储，这完全是可行的，且基本操作和用Session一模一样。那么，下面就针对以上的3个典型例子，做一个分析\n很显然，只要某个有意非法入侵者，知道该网站验证登陆信息的Session变量是什么，那么他就可以事先编辑好该Cookies，放入到Cookies目录中，这样就可以顺利通过验证了。这是不是很可怕？\nCookies完全是可见的，即使程序员设定了Cookies的生存周期（比如只在用户会话有效期内有效），它也是不安全的。假设，用户忘了关浏览器 或者一个恶意者硬性把用户给打晕，那用户的损失将是巨大的。\n这点如上点一样，很容易被它人窃取重要的私人信息。但，其还有一个问题所在是，可能这些数据信息量太大，而使得Cookies的文件大小剧增。这可不是用户希望所看到的。\n\n显然，Cookies并不是那么一块好啃的小甜饼。但，Cookies的存在，当然有其原因。它给予程序员更多发挥编程才能的空间。所以，使用Cookies该有个底线。这个底线一般来说，遵循以下原则。\n不要保存私人信息。\n任何重要数据，最好通过加密形式来保存数据（最简单的可以用URLEncode，当然也可以用完善的可逆加密方式，遗憾的是，最好不要用md5来加密）。\n是否保存登陆信息，需有用户自行选择。\n长于10K的数据，不要用到Cookies。\n也不要用Cookies来玩点让客户惊喜的小游戏。\n\n## cookie最典型的应用是：\n\n1. 判断用户是否登陆过网站，以便下次登录时能够直接登录。如果我们删除cookie，则每次登录必须从新填写登录的相关信息。\n\n2. 另一个重要的应用是“购物车”中类的处理和设计。用户可能在一段时间内在同一家网站的不同页面选择不同的商品，可以将这些信息都写入cookie，在最后付款时从cookie中提取这些信息，当然这里面有了安全和性能问题需要我们考虑了。\n\n## 参考\n\n1. https://www.cnblogs.com/andy-zhou/p/5360107.html#_caption_1\n2. http://blog.csdn.net/duan1078774504/article/details/51912868\n","slug":"浅谈Session和Cookie的区别与联系","published":1,"updated":"2018-03-06T19:01:04.896Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14oznc006m8motn8ihpmk0","content":"<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\">Cookie</th>\n<th style=\"text-align:left\">Session</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">储存位置</td>\n<td style=\"text-align:left\">客户端</td>\n<td style=\"text-align:left\">服务器端</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">目的</td>\n<td style=\"text-align:left\">跟踪会话，也可以保存用户偏好设置或者保存用户名密码等</td>\n<td style=\"text-align:left\">跟踪会话</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">安全性</td>\n<td style=\"text-align:left\">不安全</td>\n<td style=\"text-align:left\">安全</td>\n</tr>\n</tbody>\n</table>\n<p>session技术是要使用到cookie的，之所以出现session技术，主要是为了安全。</p>\n<a id=\"more\"></a>\n<h2 id=\"Session的概念\"><a href=\"#Session的概念\" class=\"headerlink\" title=\"Session的概念\"></a>Session的概念</h2><p>Session 是存放在服务器端的，类似于Session结构来存放用户数据，当浏览器 第一次发送请求时，服务器自动生成了一个Session和一个Session ID用来唯一标识这个Session，并将其通过响应发送到浏览器。当浏览器第二次发送请求，会将前一次服务器响应中的Session ID放在请求中一并发送到服务器上，服务器从请求中提取出Session ID，并和保存的所有Session ID进行对比，找到这个用户对应的Session。</p>\n<p>一般情况下，服务器会在一定时间内（默认30分钟）保存这个 Session，过了时间限制，就会销毁这个Session。在销毁之前，程序员可以将用户的一些数据以Key和Value的形式暂时存放在这个 Session中。当然，也有使用数据库将这个Session序列化后保存起来的，这样的好处是没了时间的限制，坏处是随着时间的增加，这个数据 库会急速膨胀，特别是访问量增加的时候。一般还是采取前一种方式，以减轻服务器压力。</p>\n<h2 id=\"cookie的概念\"><a href=\"#cookie的概念\" class=\"headerlink\" title=\"cookie的概念\"></a>cookie的概念</h2><p>Cookie意为“甜饼”，是由W3C组织提出，最早由Netscape社区发展的一种机制。目前Cookie已经成为标准，所有的主流浏览器如IE、Netscape、Firefox、Opera等都支持Cookie。</p>\n<p>由于HTTP是一种无状态的协议，服务器单从网络连接上无从知道客户身份。怎么办呢？就给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理。</p>\n<p>Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。</p>\n<h2 id=\"Session的客户端实现形式（即Session-ID的保存方法）\"><a href=\"#Session的客户端实现形式（即Session-ID的保存方法）\" class=\"headerlink\" title=\"Session的客户端实现形式（即Session ID的保存方法）\"></a>Session的客户端实现形式（即Session ID的保存方法）</h2><p>一般浏览器提供了两种方式来保存，还有一种是程序员使用html隐藏域的方式自定义实现：</p>\n<ol>\n<li><p>使用Cookie来保存，这是最常见的方法，本文“记住我的登录状态”功能的实现正式基于这种方式的。服务器通过设置Cookie的方式将Session ID发送到浏览器。如果我们不设置这个过期时间，那么这个Cookie将不存放在硬盘上，当浏览器关闭的时候，Cookie就消失了，这个Session ID就丢失了。如果我们设置这个时间为若干天之后，那么这个Cookie会保存在客户端硬盘中，即使浏览器关闭，这个值仍然存在，下次访问相应网站时，同 样会发送到服务器上。</p>\n</li>\n<li><p>使用URL附加信息的方式，也就是像我们经常看到JSP网站会有<code>aaa.jsp?JSESSIONID=*</code>一样的。这种方式和第一种方式里面不设置Cookie过期时间是一样的。</p>\n</li>\n<li><p>第三种方式是在页面表单里面增加隐藏域，这种方式实际上和第二种方式一样，只不过前者通过GET方式发送数据，后者使用POST方式发送数据。但是明显后者比较麻烦。</p>\n</li>\n</ol>\n<h2 id=\"cookie与session的区别\"><a href=\"#cookie与session的区别\" class=\"headerlink\" title=\"cookie与session的区别\"></a>cookie与session的区别</h2><p>cookie数据保存在客户端，session数据保存在服务器端。</p>\n<p>简 单的说，当你登录一个网站的时候，如果web服务器端使用的是session,那么所有的数据都保存在服务器上面，客户端每次请求服务器的时候会发送 当前会话的sessionid，服务器根据当前sessionid判断相应的用户数据标志，以确定用户是否登录，或具有某种权限。由于数据是存储在服务器 上面，所以你不能伪造，但是如果你能够获取某个登录用户的sessionid，用特殊的浏览器伪造该用户的请求也是能够成功的。sessionid是服务 器和客户端链接时候随机分配的，一般来说是不会有重复，但如果有大量的并发请求，也不是没有重复的可能性，我曾经就遇到过一次。登录某个网站，开始显示的 是自己的信息，等一段时间超时了，一刷新，居然显示了别人的信息。</p>\n<p>如果浏览器使用的是 cookie，那么所有的数据都保存在浏览器端，比如你登录以后，服务器设置了 cookie用户名(username),那么，当你再次请求服务器的时候，浏览器会将username一块发送给服务器，这些变量有一定的特殊标记。服 务器会解释为 cookie变量。所以只要不关闭浏览器，那么 cookie变量便一直是有效的，所以能够保证长时间不掉线。如果你能够截获某个用户的 cookie变量，然后伪造一个数据包发送过去，那么服务器还是认为你是合法的。所以，使用 cookie被攻击的可能性比较大。如果设置了的有效时间，那么它会将 cookie保存在客户端的硬盘上，下次再访问该网站的时候，浏览器先检查有没有 cookie，如果有的话，就读取该 cookie，然后发送给服务器。如果你在机器上面保存了某个论坛 cookie，有效期是一年，如果有人入侵你的机器，将你的 cookie拷走，然后放在他的浏览器的目录下面，那么他登录该网站的时候就是用你的的身份登录的。所以 cookie是可以伪造的。当然，伪造的时候需要主意，直接copy cookie文件到 cookie目录，浏览器是不认的，他有一个index.dat文件，存储了 cookie文件的建立时间，以及是否有修改，所以你必须先要有该网站的 cookie文件，并且要从保证时间上骗过浏览器，曾经在学校的vbb论坛上面做过试验，copy别人的 cookie登录，冒用了别人的名义发帖子，完全没有问题。</p>\n<p>Session是由应用服务器维持的一个服务器端的存储空间，用户在连接服务器时，会由服务器生成一个唯一的SessionID,用该SessionID 为标识符来存取服务器端的Session存储空间。而SessionID这一数据则是保存到客户端，用Cookie保存的，用户提交页面时，会将这一 SessionID提交到服务器端，来存取Session数据。这一过程，是不用开发人员干预的。所以一旦客户端禁用Cookie，那么Session也会失效。</p>\n<p>服务器也可以通过URL重写的方式来传递SessionID的值，因此不是完全依赖Cookie。如果客户端Cookie禁用，则服务器可以自动通过重写URL的方式来保存Session的值，并且这个过程对程序员透明。</p>\n<p>可以试一下，即使不写Cookie，在使用request.getCookies();取出的Cookie数组的长度也是1，而这个Cookie的名字就是JSESSIONID，还有一个很长的二进制的字符串，是SessionID的值。</p>\n<h2 id=\"Session与Cookie的应用场景\"><a href=\"#Session与Cookie的应用场景\" class=\"headerlink\" title=\"Session与Cookie的应用场景\"></a>Session与Cookie的应用场景</h2><p>Cookies是属于Session对象的一种。但有不同，Cookies不会占服务器资源，是存在客服端内存或者一个cookie的文本文件中；而“Session”则会占用服务器资源。所以，尽量不要使用Session，而使用Cookies。但是我们一般认为cookie是不可靠的，session是可靠地，但是目前很多著名的站点也都以来cookie。有时候为了解决禁用cookie后的页面处理，通常采用url重写技术，调用session中大量有用的方法从session中获取数据后置入页面。</p>\n<p>Cookies与Session的应用场景：<br>Cookies的安全性能一直是倍受争议的。虽然Cookies是保存在本机上的，但是其信息的完全可见性且易于本地编辑性，往往可以引起很多的安全问题。所以Cookies到底该不该用，到底该怎样用，就有了一个需要给定的底线。</p>\n<p>先来看看，网站的敏感数据有哪些。</p>\n<p>登陆验证信息。一般采用Session(“Logon”)＝true or false的形式。<br>用户的各种私人信息，比如姓名等，某种情况下，需要保存在Session里<br>需要在页面间传递的内容信息，比如调查工作需要分好几步。每一步的信息都保存在Session里，最后在统一更新到数据库。</p>\n<p>当然还会有很多，这里列举一些比较典型的<br>假如，一个人孤僻到不想碰Session，因为他认为，如果用户万一不小心关闭了浏览器，那么之前保存的数据就全部丢失了。所以，他出于好意，决定把这些用Session的地方，都改成用Cookies来存储，这完全是可行的，且基本操作和用Session一模一样。那么，下面就针对以上的3个典型例子，做一个分析<br>很显然，只要某个有意非法入侵者，知道该网站验证登陆信息的Session变量是什么，那么他就可以事先编辑好该Cookies，放入到Cookies目录中，这样就可以顺利通过验证了。这是不是很可怕？<br>Cookies完全是可见的，即使程序员设定了Cookies的生存周期（比如只在用户会话有效期内有效），它也是不安全的。假设，用户忘了关浏览器 或者一个恶意者硬性把用户给打晕，那用户的损失将是巨大的。<br>这点如上点一样，很容易被它人窃取重要的私人信息。但，其还有一个问题所在是，可能这些数据信息量太大，而使得Cookies的文件大小剧增。这可不是用户希望所看到的。</p>\n<p>显然，Cookies并不是那么一块好啃的小甜饼。但，Cookies的存在，当然有其原因。它给予程序员更多发挥编程才能的空间。所以，使用Cookies该有个底线。这个底线一般来说，遵循以下原则。<br>不要保存私人信息。<br>任何重要数据，最好通过加密形式来保存数据（最简单的可以用URLEncode，当然也可以用完善的可逆加密方式，遗憾的是，最好不要用md5来加密）。<br>是否保存登陆信息，需有用户自行选择。<br>长于10K的数据，不要用到Cookies。<br>也不要用Cookies来玩点让客户惊喜的小游戏。</p>\n<h2 id=\"cookie最典型的应用是：\"><a href=\"#cookie最典型的应用是：\" class=\"headerlink\" title=\"cookie最典型的应用是：\"></a>cookie最典型的应用是：</h2><ol>\n<li><p>判断用户是否登陆过网站，以便下次登录时能够直接登录。如果我们删除cookie，则每次登录必须从新填写登录的相关信息。</p>\n</li>\n<li><p>另一个重要的应用是“购物车”中类的处理和设计。用户可能在一段时间内在同一家网站的不同页面选择不同的商品，可以将这些信息都写入cookie，在最后付款时从cookie中提取这些信息，当然这里面有了安全和性能问题需要我们考虑了。</p>\n</li>\n</ol>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://www.cnblogs.com/andy-zhou/p/5360107.html#_caption_1\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/andy-zhou/p/5360107.html#_caption_1</a></li>\n<li><a href=\"http://blog.csdn.net/duan1078774504/article/details/51912868\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/duan1078774504/article/details/51912868</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:left\">Cookie</th>\n<th style=\"text-align:left\">Session</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">储存位置</td>\n<td style=\"text-align:left\">客户端</td>\n<td style=\"text-align:left\">服务器端</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">目的</td>\n<td style=\"text-align:left\">跟踪会话，也可以保存用户偏好设置或者保存用户名密码等</td>\n<td style=\"text-align:left\">跟踪会话</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">安全性</td>\n<td style=\"text-align:left\">不安全</td>\n<td style=\"text-align:left\">安全</td>\n</tr>\n</tbody>\n</table>\n<p>session技术是要使用到cookie的，之所以出现session技术，主要是为了安全。</p>","more":"<h2 id=\"Session的概念\"><a href=\"#Session的概念\" class=\"headerlink\" title=\"Session的概念\"></a>Session的概念</h2><p>Session 是存放在服务器端的，类似于Session结构来存放用户数据，当浏览器 第一次发送请求时，服务器自动生成了一个Session和一个Session ID用来唯一标识这个Session，并将其通过响应发送到浏览器。当浏览器第二次发送请求，会将前一次服务器响应中的Session ID放在请求中一并发送到服务器上，服务器从请求中提取出Session ID，并和保存的所有Session ID进行对比，找到这个用户对应的Session。</p>\n<p>一般情况下，服务器会在一定时间内（默认30分钟）保存这个 Session，过了时间限制，就会销毁这个Session。在销毁之前，程序员可以将用户的一些数据以Key和Value的形式暂时存放在这个 Session中。当然，也有使用数据库将这个Session序列化后保存起来的，这样的好处是没了时间的限制，坏处是随着时间的增加，这个数据 库会急速膨胀，特别是访问量增加的时候。一般还是采取前一种方式，以减轻服务器压力。</p>\n<h2 id=\"cookie的概念\"><a href=\"#cookie的概念\" class=\"headerlink\" title=\"cookie的概念\"></a>cookie的概念</h2><p>Cookie意为“甜饼”，是由W3C组织提出，最早由Netscape社区发展的一种机制。目前Cookie已经成为标准，所有的主流浏览器如IE、Netscape、Firefox、Opera等都支持Cookie。</p>\n<p>由于HTTP是一种无状态的协议，服务器单从网络连接上无从知道客户身份。怎么办呢？就给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理。</p>\n<p>Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。</p>\n<h2 id=\"Session的客户端实现形式（即Session-ID的保存方法）\"><a href=\"#Session的客户端实现形式（即Session-ID的保存方法）\" class=\"headerlink\" title=\"Session的客户端实现形式（即Session ID的保存方法）\"></a>Session的客户端实现形式（即Session ID的保存方法）</h2><p>一般浏览器提供了两种方式来保存，还有一种是程序员使用html隐藏域的方式自定义实现：</p>\n<ol>\n<li><p>使用Cookie来保存，这是最常见的方法，本文“记住我的登录状态”功能的实现正式基于这种方式的。服务器通过设置Cookie的方式将Session ID发送到浏览器。如果我们不设置这个过期时间，那么这个Cookie将不存放在硬盘上，当浏览器关闭的时候，Cookie就消失了，这个Session ID就丢失了。如果我们设置这个时间为若干天之后，那么这个Cookie会保存在客户端硬盘中，即使浏览器关闭，这个值仍然存在，下次访问相应网站时，同 样会发送到服务器上。</p>\n</li>\n<li><p>使用URL附加信息的方式，也就是像我们经常看到JSP网站会有<code>aaa.jsp?JSESSIONID=*</code>一样的。这种方式和第一种方式里面不设置Cookie过期时间是一样的。</p>\n</li>\n<li><p>第三种方式是在页面表单里面增加隐藏域，这种方式实际上和第二种方式一样，只不过前者通过GET方式发送数据，后者使用POST方式发送数据。但是明显后者比较麻烦。</p>\n</li>\n</ol>\n<h2 id=\"cookie与session的区别\"><a href=\"#cookie与session的区别\" class=\"headerlink\" title=\"cookie与session的区别\"></a>cookie与session的区别</h2><p>cookie数据保存在客户端，session数据保存在服务器端。</p>\n<p>简 单的说，当你登录一个网站的时候，如果web服务器端使用的是session,那么所有的数据都保存在服务器上面，客户端每次请求服务器的时候会发送 当前会话的sessionid，服务器根据当前sessionid判断相应的用户数据标志，以确定用户是否登录，或具有某种权限。由于数据是存储在服务器 上面，所以你不能伪造，但是如果你能够获取某个登录用户的sessionid，用特殊的浏览器伪造该用户的请求也是能够成功的。sessionid是服务 器和客户端链接时候随机分配的，一般来说是不会有重复，但如果有大量的并发请求，也不是没有重复的可能性，我曾经就遇到过一次。登录某个网站，开始显示的 是自己的信息，等一段时间超时了，一刷新，居然显示了别人的信息。</p>\n<p>如果浏览器使用的是 cookie，那么所有的数据都保存在浏览器端，比如你登录以后，服务器设置了 cookie用户名(username),那么，当你再次请求服务器的时候，浏览器会将username一块发送给服务器，这些变量有一定的特殊标记。服 务器会解释为 cookie变量。所以只要不关闭浏览器，那么 cookie变量便一直是有效的，所以能够保证长时间不掉线。如果你能够截获某个用户的 cookie变量，然后伪造一个数据包发送过去，那么服务器还是认为你是合法的。所以，使用 cookie被攻击的可能性比较大。如果设置了的有效时间，那么它会将 cookie保存在客户端的硬盘上，下次再访问该网站的时候，浏览器先检查有没有 cookie，如果有的话，就读取该 cookie，然后发送给服务器。如果你在机器上面保存了某个论坛 cookie，有效期是一年，如果有人入侵你的机器，将你的 cookie拷走，然后放在他的浏览器的目录下面，那么他登录该网站的时候就是用你的的身份登录的。所以 cookie是可以伪造的。当然，伪造的时候需要主意，直接copy cookie文件到 cookie目录，浏览器是不认的，他有一个index.dat文件，存储了 cookie文件的建立时间，以及是否有修改，所以你必须先要有该网站的 cookie文件，并且要从保证时间上骗过浏览器，曾经在学校的vbb论坛上面做过试验，copy别人的 cookie登录，冒用了别人的名义发帖子，完全没有问题。</p>\n<p>Session是由应用服务器维持的一个服务器端的存储空间，用户在连接服务器时，会由服务器生成一个唯一的SessionID,用该SessionID 为标识符来存取服务器端的Session存储空间。而SessionID这一数据则是保存到客户端，用Cookie保存的，用户提交页面时，会将这一 SessionID提交到服务器端，来存取Session数据。这一过程，是不用开发人员干预的。所以一旦客户端禁用Cookie，那么Session也会失效。</p>\n<p>服务器也可以通过URL重写的方式来传递SessionID的值，因此不是完全依赖Cookie。如果客户端Cookie禁用，则服务器可以自动通过重写URL的方式来保存Session的值，并且这个过程对程序员透明。</p>\n<p>可以试一下，即使不写Cookie，在使用request.getCookies();取出的Cookie数组的长度也是1，而这个Cookie的名字就是JSESSIONID，还有一个很长的二进制的字符串，是SessionID的值。</p>\n<h2 id=\"Session与Cookie的应用场景\"><a href=\"#Session与Cookie的应用场景\" class=\"headerlink\" title=\"Session与Cookie的应用场景\"></a>Session与Cookie的应用场景</h2><p>Cookies是属于Session对象的一种。但有不同，Cookies不会占服务器资源，是存在客服端内存或者一个cookie的文本文件中；而“Session”则会占用服务器资源。所以，尽量不要使用Session，而使用Cookies。但是我们一般认为cookie是不可靠的，session是可靠地，但是目前很多著名的站点也都以来cookie。有时候为了解决禁用cookie后的页面处理，通常采用url重写技术，调用session中大量有用的方法从session中获取数据后置入页面。</p>\n<p>Cookies与Session的应用场景：<br>Cookies的安全性能一直是倍受争议的。虽然Cookies是保存在本机上的，但是其信息的完全可见性且易于本地编辑性，往往可以引起很多的安全问题。所以Cookies到底该不该用，到底该怎样用，就有了一个需要给定的底线。</p>\n<p>先来看看，网站的敏感数据有哪些。</p>\n<p>登陆验证信息。一般采用Session(“Logon”)＝true or false的形式。<br>用户的各种私人信息，比如姓名等，某种情况下，需要保存在Session里<br>需要在页面间传递的内容信息，比如调查工作需要分好几步。每一步的信息都保存在Session里，最后在统一更新到数据库。</p>\n<p>当然还会有很多，这里列举一些比较典型的<br>假如，一个人孤僻到不想碰Session，因为他认为，如果用户万一不小心关闭了浏览器，那么之前保存的数据就全部丢失了。所以，他出于好意，决定把这些用Session的地方，都改成用Cookies来存储，这完全是可行的，且基本操作和用Session一模一样。那么，下面就针对以上的3个典型例子，做一个分析<br>很显然，只要某个有意非法入侵者，知道该网站验证登陆信息的Session变量是什么，那么他就可以事先编辑好该Cookies，放入到Cookies目录中，这样就可以顺利通过验证了。这是不是很可怕？<br>Cookies完全是可见的，即使程序员设定了Cookies的生存周期（比如只在用户会话有效期内有效），它也是不安全的。假设，用户忘了关浏览器 或者一个恶意者硬性把用户给打晕，那用户的损失将是巨大的。<br>这点如上点一样，很容易被它人窃取重要的私人信息。但，其还有一个问题所在是，可能这些数据信息量太大，而使得Cookies的文件大小剧增。这可不是用户希望所看到的。</p>\n<p>显然，Cookies并不是那么一块好啃的小甜饼。但，Cookies的存在，当然有其原因。它给予程序员更多发挥编程才能的空间。所以，使用Cookies该有个底线。这个底线一般来说，遵循以下原则。<br>不要保存私人信息。<br>任何重要数据，最好通过加密形式来保存数据（最简单的可以用URLEncode，当然也可以用完善的可逆加密方式，遗憾的是，最好不要用md5来加密）。<br>是否保存登陆信息，需有用户自行选择。<br>长于10K的数据，不要用到Cookies。<br>也不要用Cookies来玩点让客户惊喜的小游戏。</p>\n<h2 id=\"cookie最典型的应用是：\"><a href=\"#cookie最典型的应用是：\" class=\"headerlink\" title=\"cookie最典型的应用是：\"></a>cookie最典型的应用是：</h2><ol>\n<li><p>判断用户是否登陆过网站，以便下次登录时能够直接登录。如果我们删除cookie，则每次登录必须从新填写登录的相关信息。</p>\n</li>\n<li><p>另一个重要的应用是“购物车”中类的处理和设计。用户可能在一段时间内在同一家网站的不同页面选择不同的商品，可以将这些信息都写入cookie，在最后付款时从cookie中提取这些信息，当然这里面有了安全和性能问题需要我们考虑了。</p>\n</li>\n</ol>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ol>\n<li><a href=\"https://www.cnblogs.com/andy-zhou/p/5360107.html#_caption_1\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/andy-zhou/p/5360107.html#_caption_1</a></li>\n<li><a href=\"http://blog.csdn.net/duan1078774504/article/details/51912868\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/duan1078774504/article/details/51912868</a></li>\n</ol>"},{"title":"用户密码保存的方式有哪些","date":"2018-03-07T18:03:43.000Z","_content":"1. 明文保存\n2. 明文hash后保存,如md5\n3. MD5+Salt方式,这个salt可以随机\n4. 知乎使用了Bcrypy(好像)加密\n","source":"_posts/用户密码保存的方式有哪些.md","raw":"---\ntitle: 用户密码保存的方式有哪些\ndate: 2018-03-08 02:03:43\ntags:\n  - 加密\n---\n1. 明文保存\n2. 明文hash后保存,如md5\n3. MD5+Salt方式,这个salt可以随机\n4. 知乎使用了Bcrypy(好像)加密\n","slug":"用户密码保存的方式有哪些","published":1,"updated":"2018-03-07T18:05:08.274Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14oznf006r8motx8fgjcl7","content":"<ol>\n<li>明文保存</li>\n<li>明文hash后保存,如md5</li>\n<li>MD5+Salt方式,这个salt可以随机</li>\n<li>知乎使用了Bcrypy(好像)加密</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>明文保存</li>\n<li>明文hash后保存,如md5</li>\n<li>MD5+Salt方式,这个salt可以随机</li>\n<li>知乎使用了Bcrypy(好像)加密</li>\n</ol>\n"},{"title":"浅谈TCP和UDP的区别以及应用","date":"2018-03-06T18:28:32.000Z","_content":"## TCP和UDP区别\n\nTCP(`Transmission Control Protocol`)---`传输控制协议`,`提供的是面向连接、可靠的字节流服务`。当客户和服务器彼此交换数据前，必须先在双方之间建立一个TCP连接，之后才能传输数据。TCP提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。\nUDP(`User Data Protocol`)---`用户数据报协议`，`是一个简单的面向数据报的运输层协议`。在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快。\n\n## 应用   \n1. HTTP协议在运输层采用的就是`TCP协议`，在浏览器中输入IP地址后，与服务器建立连接，采用的就是TCP协议，是一种面向连接、可靠的字节流服务。\n\n2. 当强调传输性能而不是传输的完整性时，如：音频、多媒体应用和视频会议时，`UDP`是最好的选择。另外，腾讯QQ采用也是UDP协议。\n","source":"_posts/浅谈TCP和UDP的区别以及应用.md","raw":"---\ntitle: 浅谈TCP和UDP的区别以及应用\ndate: 2018-03-07 02:28:32\ntags:\n  - 网络\ncategories:\n  - 网络\n---\n## TCP和UDP区别\n\nTCP(`Transmission Control Protocol`)---`传输控制协议`,`提供的是面向连接、可靠的字节流服务`。当客户和服务器彼此交换数据前，必须先在双方之间建立一个TCP连接，之后才能传输数据。TCP提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。\nUDP(`User Data Protocol`)---`用户数据报协议`，`是一个简单的面向数据报的运输层协议`。在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快。\n\n## 应用   \n1. HTTP协议在运输层采用的就是`TCP协议`，在浏览器中输入IP地址后，与服务器建立连接，采用的就是TCP协议，是一种面向连接、可靠的字节流服务。\n\n2. 当强调传输性能而不是传输的完整性时，如：音频、多媒体应用和视频会议时，`UDP`是最好的选择。另外，腾讯QQ采用也是UDP协议。\n","slug":"浅谈TCP和UDP的区别以及应用","published":1,"updated":"2018-03-07T04:10:12.333Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14oznh006u8motg6h39nuh","content":"<h2 id=\"TCP和UDP区别\"><a href=\"#TCP和UDP区别\" class=\"headerlink\" title=\"TCP和UDP区别\"></a>TCP和UDP区别</h2><p>TCP(<code>Transmission Control Protocol</code>)—<code>传输控制协议</code>,<code>提供的是面向连接、可靠的字节流服务</code>。当客户和服务器彼此交换数据前，必须先在双方之间建立一个TCP连接，之后才能传输数据。TCP提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。<br>UDP(<code>User Data Protocol</code>)—<code>用户数据报协议</code>，<code>是一个简单的面向数据报的运输层协议</code>。在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快。</p>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><ol>\n<li><p>HTTP协议在运输层采用的就是<code>TCP协议</code>，在浏览器中输入IP地址后，与服务器建立连接，采用的就是TCP协议，是一种面向连接、可靠的字节流服务。</p>\n</li>\n<li><p>当强调传输性能而不是传输的完整性时，如：音频、多媒体应用和视频会议时，<code>UDP</code>是最好的选择。另外，腾讯QQ采用也是UDP协议。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"TCP和UDP区别\"><a href=\"#TCP和UDP区别\" class=\"headerlink\" title=\"TCP和UDP区别\"></a>TCP和UDP区别</h2><p>TCP(<code>Transmission Control Protocol</code>)—<code>传输控制协议</code>,<code>提供的是面向连接、可靠的字节流服务</code>。当客户和服务器彼此交换数据前，必须先在双方之间建立一个TCP连接，之后才能传输数据。TCP提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。<br>UDP(<code>User Data Protocol</code>)—<code>用户数据报协议</code>，<code>是一个简单的面向数据报的运输层协议</code>。在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快。</p>\n<h2 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h2><ol>\n<li><p>HTTP协议在运输层采用的就是<code>TCP协议</code>，在浏览器中输入IP地址后，与服务器建立连接，采用的就是TCP协议，是一种面向连接、可靠的字节流服务。</p>\n</li>\n<li><p>当强调传输性能而不是传输的完整性时，如：音频、多媒体应用和视频会议时，<code>UDP</code>是最好的选择。另外，腾讯QQ采用也是UDP协议。</p>\n</li>\n</ol>\n"},{"title":"简谈爬虫攻与防","date":"2018-02-27T04:44:38.000Z","_content":"\n\n## 封锁间隔时间破解\n\nScrapy在两次请求之间的时间设置是DOWNLOAD_DELAY。如果不考虑反爬虫的因素，该值当然越小越好。如果DOWNLOAD_DELAY设为0.001，也就是每1毫秒请求一次网页，这简直非人类干的事情。有些网站会检测一个ip的访问时间，异常情况下会封锁该ip。\n\n<!--more-->\n\n## 封锁Cookies\n众所周知，网站是通过Cookie来确定用户身份的，Scrapy在爬取数据时使用同一个Cookies发起请求。该做法和把DOWNLOAD_DELAY设为0.001没有本质区别。在scrapy中，直接设禁用Cookies就可以了。在settings.py中设置\n```python\n# Disable cookies (enabled by default)\nCOOKIES_ENABLED = False\n```\n\n## 封锁user-agent和proxy破解\nuser-agent是浏览器的身份标识。网站通过UA来确定浏览器类型。很多浏览器拒绝不符合一定标准的UA请求网页。同一个UA高频率的访问网站会有被网站列入黑名单的危险。破解的方法很简单，可以准备一个**UA池**，每次请求时随机挑选一个进行请求。\n\n在middlewares.py同级目录下创建UAResource.py,文件内容如下：\n\n```python\n#-*- coding: utf-8 -*-\n\nUserAgents = [\n  \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; AcooBrowser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)\",\n  \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)\",\n  \"Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.35; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)\",\n  \"Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US)\",\n  \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)\",\n  \"Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)\",\n  \"Mozilla/4.0 (compatible; MSIE 7.0b; Windows NT 5.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.2; .NET CLR 3.0.04506.30)\",\n  \"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3) Arora/0.3 (Change: 287 c9dfb30)\",\n  \"Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6\",\n  \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko/20070215 K-Ninja/2.1.1\",\n  \"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko/20080705 Firefox/3.0 Kapiko/3.0\",\n  \"Mozilla/5.0 (X11; Linux i686; U;) Gecko/20070322 Kazehakase/0.4.5\",\n  \"Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora/1.9.0.8-1.fc10 Kazehakase/0.5.6\",\n  \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11\",\n  \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.20 (KHTML, like Gecko) Chrome/19.0.1036.7 Safari/535.20\",\n  \"Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto/2.9.168 Version/11.52\",\n]\n\nProxies = [\n'http://122.114.31.177:808',\n'http://1.2.3.4:80',\n]\n```\n\n修改middlewares.py，添加内容为\n```python\nfrom .UAResource import UserAgents\nfrom .UAResource import Proxies\nimport random\n\nclass RandomProxy(object):\n    def process_request(self, request, spider):\n        proxy = random.choice(Proxies)\n        request.meta['proxy'] = proxy\n\nclass RandomUserAgent(object):\n    \"\"\"docstring for RandomUerAgent.\"\"\"\n    def process_request(self, request, spider):\n        ua = random.choice(UserAgents)\n        request.headers.setdefault('User-Agent', ua)\n```\n\n最后修改setting.py,将RandomUserAgent和RandomProxy添加到DOWNLOADER_MIDDLEWARES中，注意RandomProxy要放到RandomUserAgent之前，即将RandomProxy的值比RandomUserAgent后的值小\n```python\nDOWNLOADER_MIDDLEWARES = {\n   # 'meijutt.middlewares.MeijuttDownloaderMiddleware': 543,\n   'meijutt.middlewares.RandomProxy': 10,\n   'meijutt.middlewares.RandomUserAgent': 30,\n\n   # 禁止内置的(在 DOWNLOADER_MIDDLEWARES_BASE 中设置并默认启用的)中间件\n   'scrapy.downloadermiddlewares.useragent.UserAgentMiddleware': None,\n}\n\n```\n\n免费代理不够稳定，如果不想用proxy，设置RandomProxy为None,即禁止使用\n```python\n'meijutt.middlewares.RandomProxy': None,\n```\n## 补充\n### Referer\n当浏览器发送请求时，请求头header一般都会带上这个，这个可以让网站管理者知道我是通过哪个链接访问到这个网站的，上面就说明我是从网易云音乐的主页来访问到这个页面的，若你是用python来直接请求是，就没有访问来源，那么管理者就轻而易举地判断你是机器在操作。对于scrapy爬虫\n```python\n# Override the default request headers:\nDEFAULT_REQUEST_HEADERS = {\n  # 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n  # 'Accept-Language': 'en',\n  'Referer':'http://artso.artron.net/auction/search_auction.php?keyword=%E8%B1%A1%E7%89%99&page=' + str(randrange(100)),\n}\n\n```\n\n### authorization:\n有的网站还会有这个请求头，这个是在用户在访问该网站的时候就会分配一个id给用户，然后在后台验证该id有没有访问权限从而来进行发爬虫。\n","source":"_posts/简谈爬虫攻与防.md","raw":"---\ntitle: 简谈爬虫攻与防\ndate: 2018-02-27 12:44:38\ntags:\n  - Scrapy\n  - Spider\ncategories:\n  - Spider\n  - Scrapy\n---\n\n\n## 封锁间隔时间破解\n\nScrapy在两次请求之间的时间设置是DOWNLOAD_DELAY。如果不考虑反爬虫的因素，该值当然越小越好。如果DOWNLOAD_DELAY设为0.001，也就是每1毫秒请求一次网页，这简直非人类干的事情。有些网站会检测一个ip的访问时间，异常情况下会封锁该ip。\n\n<!--more-->\n\n## 封锁Cookies\n众所周知，网站是通过Cookie来确定用户身份的，Scrapy在爬取数据时使用同一个Cookies发起请求。该做法和把DOWNLOAD_DELAY设为0.001没有本质区别。在scrapy中，直接设禁用Cookies就可以了。在settings.py中设置\n```python\n# Disable cookies (enabled by default)\nCOOKIES_ENABLED = False\n```\n\n## 封锁user-agent和proxy破解\nuser-agent是浏览器的身份标识。网站通过UA来确定浏览器类型。很多浏览器拒绝不符合一定标准的UA请求网页。同一个UA高频率的访问网站会有被网站列入黑名单的危险。破解的方法很简单，可以准备一个**UA池**，每次请求时随机挑选一个进行请求。\n\n在middlewares.py同级目录下创建UAResource.py,文件内容如下：\n\n```python\n#-*- coding: utf-8 -*-\n\nUserAgents = [\n  \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; AcooBrowser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)\",\n  \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)\",\n  \"Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.35; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)\",\n  \"Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US)\",\n  \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)\",\n  \"Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)\",\n  \"Mozilla/4.0 (compatible; MSIE 7.0b; Windows NT 5.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.2; .NET CLR 3.0.04506.30)\",\n  \"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3) Arora/0.3 (Change: 287 c9dfb30)\",\n  \"Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6\",\n  \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko/20070215 K-Ninja/2.1.1\",\n  \"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko/20080705 Firefox/3.0 Kapiko/3.0\",\n  \"Mozilla/5.0 (X11; Linux i686; U;) Gecko/20070322 Kazehakase/0.4.5\",\n  \"Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora/1.9.0.8-1.fc10 Kazehakase/0.5.6\",\n  \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11\",\n  \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.20 (KHTML, like Gecko) Chrome/19.0.1036.7 Safari/535.20\",\n  \"Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto/2.9.168 Version/11.52\",\n]\n\nProxies = [\n'http://122.114.31.177:808',\n'http://1.2.3.4:80',\n]\n```\n\n修改middlewares.py，添加内容为\n```python\nfrom .UAResource import UserAgents\nfrom .UAResource import Proxies\nimport random\n\nclass RandomProxy(object):\n    def process_request(self, request, spider):\n        proxy = random.choice(Proxies)\n        request.meta['proxy'] = proxy\n\nclass RandomUserAgent(object):\n    \"\"\"docstring for RandomUerAgent.\"\"\"\n    def process_request(self, request, spider):\n        ua = random.choice(UserAgents)\n        request.headers.setdefault('User-Agent', ua)\n```\n\n最后修改setting.py,将RandomUserAgent和RandomProxy添加到DOWNLOADER_MIDDLEWARES中，注意RandomProxy要放到RandomUserAgent之前，即将RandomProxy的值比RandomUserAgent后的值小\n```python\nDOWNLOADER_MIDDLEWARES = {\n   # 'meijutt.middlewares.MeijuttDownloaderMiddleware': 543,\n   'meijutt.middlewares.RandomProxy': 10,\n   'meijutt.middlewares.RandomUserAgent': 30,\n\n   # 禁止内置的(在 DOWNLOADER_MIDDLEWARES_BASE 中设置并默认启用的)中间件\n   'scrapy.downloadermiddlewares.useragent.UserAgentMiddleware': None,\n}\n\n```\n\n免费代理不够稳定，如果不想用proxy，设置RandomProxy为None,即禁止使用\n```python\n'meijutt.middlewares.RandomProxy': None,\n```\n## 补充\n### Referer\n当浏览器发送请求时，请求头header一般都会带上这个，这个可以让网站管理者知道我是通过哪个链接访问到这个网站的，上面就说明我是从网易云音乐的主页来访问到这个页面的，若你是用python来直接请求是，就没有访问来源，那么管理者就轻而易举地判断你是机器在操作。对于scrapy爬虫\n```python\n# Override the default request headers:\nDEFAULT_REQUEST_HEADERS = {\n  # 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n  # 'Accept-Language': 'en',\n  'Referer':'http://artso.artron.net/auction/search_auction.php?keyword=%E8%B1%A1%E7%89%99&page=' + str(randrange(100)),\n}\n\n```\n\n### authorization:\n有的网站还会有这个请求头，这个是在用户在访问该网站的时候就会分配一个id给用户，然后在后台验证该id有没有访问权限从而来进行发爬虫。\n","slug":"简谈爬虫攻与防","published":1,"updated":"2018-04-11T12:58:39.795Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14oznj006z8mot7yfi20nt","content":"<h2 id=\"封锁间隔时间破解\"><a href=\"#封锁间隔时间破解\" class=\"headerlink\" title=\"封锁间隔时间破解\"></a>封锁间隔时间破解</h2><p>Scrapy在两次请求之间的时间设置是DOWNLOAD_DELAY。如果不考虑反爬虫的因素，该值当然越小越好。如果DOWNLOAD_DELAY设为0.001，也就是每1毫秒请求一次网页，这简直非人类干的事情。有些网站会检测一个ip的访问时间，异常情况下会封锁该ip。</p>\n<a id=\"more\"></a>\n<h2 id=\"封锁Cookies\"><a href=\"#封锁Cookies\" class=\"headerlink\" title=\"封锁Cookies\"></a>封锁Cookies</h2><p>众所周知，网站是通过Cookie来确定用户身份的，Scrapy在爬取数据时使用同一个Cookies发起请求。该做法和把DOWNLOAD_DELAY设为0.001没有本质区别。在scrapy中，直接设禁用Cookies就可以了。在settings.py中设置<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Disable cookies (enabled by default)</span></span><br><span class=\"line\">COOKIES_ENABLED = <span class=\"keyword\">False</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"封锁user-agent和proxy破解\"><a href=\"#封锁user-agent和proxy破解\" class=\"headerlink\" title=\"封锁user-agent和proxy破解\"></a>封锁user-agent和proxy破解</h2><p>user-agent是浏览器的身份标识。网站通过UA来确定浏览器类型。很多浏览器拒绝不符合一定标准的UA请求网页。同一个UA高频率的访问网站会有被网站列入黑名单的危险。破解的方法很简单，可以准备一个<strong>UA池</strong>，每次请求时随机挑选一个进行请求。</p>\n<p>在middlewares.py同级目录下创建UAResource.py,文件内容如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#-*- coding: utf-8 -*-</span></span><br><span class=\"line\"></span><br><span class=\"line\">UserAgents = [</span><br><span class=\"line\">  <span class=\"string\">\"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; AcooBrowser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.35; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US)\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Mozilla/4.0 (compatible; MSIE 7.0b; Windows NT 5.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.2; .NET CLR 3.0.04506.30)\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3) Arora/0.3 (Change: 287 c9dfb30)\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko/20070215 K-Ninja/2.1.1\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko/20080705 Firefox/3.0 Kapiko/3.0\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Mozilla/5.0 (X11; Linux i686; U;) Gecko/20070322 Kazehakase/0.4.5\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora/1.9.0.8-1.fc10 Kazehakase/0.5.6\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.20 (KHTML, like Gecko) Chrome/19.0.1036.7 Safari/535.20\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto/2.9.168 Version/11.52\"</span>,</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">Proxies = [</span><br><span class=\"line\"><span class=\"string\">'http://122.114.31.177:808'</span>,</span><br><span class=\"line\"><span class=\"string\">'http://1.2.3.4:80'</span>,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>修改middlewares.py，添加内容为<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> .UAResource <span class=\"keyword\">import</span> UserAgents</span><br><span class=\"line\"><span class=\"keyword\">from</span> .UAResource <span class=\"keyword\">import</span> Proxies</span><br><span class=\"line\"><span class=\"keyword\">import</span> random</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RandomProxy</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">process_request</span><span class=\"params\">(self, request, spider)</span>:</span></span><br><span class=\"line\">        proxy = random.choice(Proxies)</span><br><span class=\"line\">        request.meta[<span class=\"string\">'proxy'</span>] = proxy</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RandomUserAgent</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"docstring for RandomUerAgent.\"\"\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">process_request</span><span class=\"params\">(self, request, spider)</span>:</span></span><br><span class=\"line\">        ua = random.choice(UserAgents)</span><br><span class=\"line\">        request.headers.setdefault(<span class=\"string\">'User-Agent'</span>, ua)</span><br></pre></td></tr></table></figure></p>\n<p>最后修改setting.py,将RandomUserAgent和RandomProxy添加到DOWNLOADER_MIDDLEWARES中，注意RandomProxy要放到RandomUserAgent之前，即将RandomProxy的值比RandomUserAgent后的值小<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DOWNLOADER_MIDDLEWARES = &#123;</span><br><span class=\"line\">   <span class=\"comment\"># 'meijutt.middlewares.MeijuttDownloaderMiddleware': 543,</span></span><br><span class=\"line\">   <span class=\"string\">'meijutt.middlewares.RandomProxy'</span>: <span class=\"number\">10</span>,</span><br><span class=\"line\">   <span class=\"string\">'meijutt.middlewares.RandomUserAgent'</span>: <span class=\"number\">30</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\"># 禁止内置的(在 DOWNLOADER_MIDDLEWARES_BASE 中设置并默认启用的)中间件</span></span><br><span class=\"line\">   <span class=\"string\">'scrapy.downloadermiddlewares.useragent.UserAgentMiddleware'</span>: <span class=\"keyword\">None</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>免费代理不够稳定，如果不想用proxy，设置RandomProxy为None,即禁止使用<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'meijutt.middlewares.RandomProxy'</span>: <span class=\"keyword\">None</span>,</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><h3 id=\"Referer\"><a href=\"#Referer\" class=\"headerlink\" title=\"Referer\"></a>Referer</h3><p>当浏览器发送请求时，请求头header一般都会带上这个，这个可以让网站管理者知道我是通过哪个链接访问到这个网站的，上面就说明我是从网易云音乐的主页来访问到这个页面的，若你是用python来直接请求是，就没有访问来源，那么管理者就轻而易举地判断你是机器在操作。对于scrapy爬虫<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Override the default request headers:</span></span><br><span class=\"line\">DEFAULT_REQUEST_HEADERS = &#123;</span><br><span class=\"line\">  <span class=\"comment\"># 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',</span></span><br><span class=\"line\">  <span class=\"comment\"># 'Accept-Language': 'en',</span></span><br><span class=\"line\">  <span class=\"string\">'Referer'</span>:<span class=\"string\">'http://artso.artron.net/auction/search_auction.php?keyword=%E8%B1%A1%E7%89%99&amp;page='</span> + str(randrange(<span class=\"number\">100</span>)),</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"authorization\"><a href=\"#authorization\" class=\"headerlink\" title=\"authorization:\"></a>authorization:</h3><p>有的网站还会有这个请求头，这个是在用户在访问该网站的时候就会分配一个id给用户，然后在后台验证该id有没有访问权限从而来进行发爬虫。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"封锁间隔时间破解\"><a href=\"#封锁间隔时间破解\" class=\"headerlink\" title=\"封锁间隔时间破解\"></a>封锁间隔时间破解</h2><p>Scrapy在两次请求之间的时间设置是DOWNLOAD_DELAY。如果不考虑反爬虫的因素，该值当然越小越好。如果DOWNLOAD_DELAY设为0.001，也就是每1毫秒请求一次网页，这简直非人类干的事情。有些网站会检测一个ip的访问时间，异常情况下会封锁该ip。</p>","more":"<h2 id=\"封锁Cookies\"><a href=\"#封锁Cookies\" class=\"headerlink\" title=\"封锁Cookies\"></a>封锁Cookies</h2><p>众所周知，网站是通过Cookie来确定用户身份的，Scrapy在爬取数据时使用同一个Cookies发起请求。该做法和把DOWNLOAD_DELAY设为0.001没有本质区别。在scrapy中，直接设禁用Cookies就可以了。在settings.py中设置<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Disable cookies (enabled by default)</span></span><br><span class=\"line\">COOKIES_ENABLED = <span class=\"keyword\">False</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"封锁user-agent和proxy破解\"><a href=\"#封锁user-agent和proxy破解\" class=\"headerlink\" title=\"封锁user-agent和proxy破解\"></a>封锁user-agent和proxy破解</h2><p>user-agent是浏览器的身份标识。网站通过UA来确定浏览器类型。很多浏览器拒绝不符合一定标准的UA请求网页。同一个UA高频率的访问网站会有被网站列入黑名单的危险。破解的方法很简单，可以准备一个<strong>UA池</strong>，每次请求时随机挑选一个进行请求。</p>\n<p>在middlewares.py同级目录下创建UAResource.py,文件内容如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#-*- coding: utf-8 -*-</span></span><br><span class=\"line\"></span><br><span class=\"line\">UserAgents = [</span><br><span class=\"line\">  <span class=\"string\">\"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; AcooBrowser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.35; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US)\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Mozilla/4.0 (compatible; MSIE 7.0b; Windows NT 5.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.2; .NET CLR 3.0.04506.30)\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3) Arora/0.3 (Change: 287 c9dfb30)\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko/20070215 K-Ninja/2.1.1\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko/20080705 Firefox/3.0 Kapiko/3.0\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Mozilla/5.0 (X11; Linux i686; U;) Gecko/20070322 Kazehakase/0.4.5\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora/1.9.0.8-1.fc10 Kazehakase/0.5.6\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.20 (KHTML, like Gecko) Chrome/19.0.1036.7 Safari/535.20\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto/2.9.168 Version/11.52\"</span>,</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">Proxies = [</span><br><span class=\"line\"><span class=\"string\">'http://122.114.31.177:808'</span>,</span><br><span class=\"line\"><span class=\"string\">'http://1.2.3.4:80'</span>,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>修改middlewares.py，添加内容为<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> .UAResource <span class=\"keyword\">import</span> UserAgents</span><br><span class=\"line\"><span class=\"keyword\">from</span> .UAResource <span class=\"keyword\">import</span> Proxies</span><br><span class=\"line\"><span class=\"keyword\">import</span> random</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RandomProxy</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">process_request</span><span class=\"params\">(self, request, spider)</span>:</span></span><br><span class=\"line\">        proxy = random.choice(Proxies)</span><br><span class=\"line\">        request.meta[<span class=\"string\">'proxy'</span>] = proxy</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RandomUserAgent</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">\"\"\"docstring for RandomUerAgent.\"\"\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">process_request</span><span class=\"params\">(self, request, spider)</span>:</span></span><br><span class=\"line\">        ua = random.choice(UserAgents)</span><br><span class=\"line\">        request.headers.setdefault(<span class=\"string\">'User-Agent'</span>, ua)</span><br></pre></td></tr></table></figure></p>\n<p>最后修改setting.py,将RandomUserAgent和RandomProxy添加到DOWNLOADER_MIDDLEWARES中，注意RandomProxy要放到RandomUserAgent之前，即将RandomProxy的值比RandomUserAgent后的值小<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DOWNLOADER_MIDDLEWARES = &#123;</span><br><span class=\"line\">   <span class=\"comment\"># 'meijutt.middlewares.MeijuttDownloaderMiddleware': 543,</span></span><br><span class=\"line\">   <span class=\"string\">'meijutt.middlewares.RandomProxy'</span>: <span class=\"number\">10</span>,</span><br><span class=\"line\">   <span class=\"string\">'meijutt.middlewares.RandomUserAgent'</span>: <span class=\"number\">30</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\"># 禁止内置的(在 DOWNLOADER_MIDDLEWARES_BASE 中设置并默认启用的)中间件</span></span><br><span class=\"line\">   <span class=\"string\">'scrapy.downloadermiddlewares.useragent.UserAgentMiddleware'</span>: <span class=\"keyword\">None</span>,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>免费代理不够稳定，如果不想用proxy，设置RandomProxy为None,即禁止使用<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'meijutt.middlewares.RandomProxy'</span>: <span class=\"keyword\">None</span>,</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><h3 id=\"Referer\"><a href=\"#Referer\" class=\"headerlink\" title=\"Referer\"></a>Referer</h3><p>当浏览器发送请求时，请求头header一般都会带上这个，这个可以让网站管理者知道我是通过哪个链接访问到这个网站的，上面就说明我是从网易云音乐的主页来访问到这个页面的，若你是用python来直接请求是，就没有访问来源，那么管理者就轻而易举地判断你是机器在操作。对于scrapy爬虫<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Override the default request headers:</span></span><br><span class=\"line\">DEFAULT_REQUEST_HEADERS = &#123;</span><br><span class=\"line\">  <span class=\"comment\"># 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',</span></span><br><span class=\"line\">  <span class=\"comment\"># 'Accept-Language': 'en',</span></span><br><span class=\"line\">  <span class=\"string\">'Referer'</span>:<span class=\"string\">'http://artso.artron.net/auction/search_auction.php?keyword=%E8%B1%A1%E7%89%99&amp;page='</span> + str(randrange(<span class=\"number\">100</span>)),</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"authorization\"><a href=\"#authorization\" class=\"headerlink\" title=\"authorization:\"></a>authorization:</h3><p>有的网站还会有这个请求头，这个是在用户在访问该网站的时候就会分配一个id给用户，然后在后台验证该id有没有访问权限从而来进行发爬虫。</p>"},{"title":"终端格式化打印json数据的方法","date":"2018-04-25T03:26:54.000Z","_content":"命令行调试API很方便，对于返回数据是JSON格式的，打印出来的内容超级痛苦。有一种解决方法如下：\n```bash\necho '{\"status\":200,\"data\":[{\"id\":1000,\"name\":\"John\"},{\"id\":1004,\"name\":\"Tom\"}]}' | python -m json.tool\n```\n\n即终端打印的json数据通过管道符号经过python json工具格式化输出，搞定!\n","source":"_posts/终端格式化打印json数据的方法.md","raw":"---\ntitle: 终端格式化打印json数据的方法\ndate: 2018-04-25 11:26:54\ntags:\n  - Linux/Mac OS\ncategories:\n  - Linux/Mac OS\n---\n命令行调试API很方便，对于返回数据是JSON格式的，打印出来的内容超级痛苦。有一种解决方法如下：\n```bash\necho '{\"status\":200,\"data\":[{\"id\":1000,\"name\":\"John\"},{\"id\":1004,\"name\":\"Tom\"}]}' | python -m json.tool\n```\n\n即终端打印的json数据通过管道符号经过python json工具格式化输出，搞定!\n","slug":"终端格式化打印json数据的方法","published":1,"updated":"2018-05-05T15:30:58.502Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14oznl00728mot3e14gcja","content":"<p>命令行调试API很方便，对于返回数据是JSON格式的，打印出来的内容超级痛苦。有一种解决方法如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">'&#123;\"status\":200,\"data\":[&#123;\"id\":1000,\"name\":\"John\"&#125;,&#123;\"id\":1004,\"name\":\"Tom\"&#125;]&#125;'</span> | python -m json.tool</span><br></pre></td></tr></table></figure></p>\n<p>即终端打印的json数据通过管道符号经过python json工具格式化输出，搞定!</p>\n","site":{"data":{}},"excerpt":"","more":"<p>命令行调试API很方便，对于返回数据是JSON格式的，打印出来的内容超级痛苦。有一种解决方法如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">'&#123;\"status\":200,\"data\":[&#123;\"id\":1000,\"name\":\"John\"&#125;,&#123;\"id\":1004,\"name\":\"Tom\"&#125;]&#125;'</span> | python -m json.tool</span><br></pre></td></tr></table></figure></p>\n<p>即终端打印的json数据通过管道符号经过python json工具格式化输出，搞定!</p>\n"},{"title":"进程、线程、协程","date":"2018-03-03T17:20:18.000Z","_content":"\n## 进程\n\n电脑里运行的应用程序，都是进程，假设我们用的电脑是单核的，CPU同时只能执行一个进程。当程序处于I/O阻塞的时候，CPU如果和程序一起等待，那就太浪费了，CPU会去执行其他的程序，此时就涉及到切换，切换前要保存上一个程序运行的状态，才能恢复，所以就需要有个东西来记录这个东西，就可以引出进程的概念了。\n\n进程就是`一个程序在一个数据集上的一次动态执行过程`。进程是一个动态概念，是竟争计算机系统资源的基本单位。进程由`程序`，`数据集`，`进程控制块`三部分组成。`程序`用来描述进程哪些功能以及如何完成；`数据集`是程序执行过程中所使用的资源；`进程控制块`用来保存程序运行的状态.\n\n`进程是系统进行资源分配和调度的一个独立单位`。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。\n\n<!-- more -->\n## 线程\n\n在网络或多用户环境下，一个服务器通常需要接收大量且不确定数量用户的并发请求，为每一个请求都创建一个进程显然是行不通的，——无论是从系统资源开销方面或是响应用户请求的效率方面来看。因此，操作系统中`线程`的概念便被引进了。线程，是进程的一部分，`一个没有线程的进程可以被看作是单线程的`。线程有时又被称为`轻权进程`或`轻量级进程`，是一个基本的cpu执行单元，也是程序执行过程中的最小单元。一个进程最少也会有一个主线程，在主线程中通过threading模块，再开子线程。\n\n线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。\n\n**进程拥有一个完整的虚拟地址空间，不依赖于线程而独立存在；反之，线程是进程的一部分，没有自己的地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。**\n\n**进程的状态有就绪，运行，等待三个状态；线程的状态有新建-就绪-（阻塞）-运行–死亡四个基本状态**\n\n线程全局锁GIL(Global Interpreter Lock),即Python为了保证线程安全而采取的`独立线程运行的限制`,说白了就是一个核只能在同一时间运行一个线程.对于io密集型任务，python的多线程起到作用，但对于cpu密集型任务，python的多线程几乎占不到任何优势，还有可能因为争夺资源而变慢。\n\n## 进程、线程的关系\n\n1. 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程\n2. 资源分配给进程，进程是程序的主体，同一进程的所有线程共享该进程的所有资源\n3. CPU分配给线程，即真正在CPU上运行的是线程\n4. 线程是最小的执行单元，进程是最小的资源管理单元\n\n## 协程Coroutine\n\n协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。\n\n`进程`拥有自己独立的堆和栈，既不共享堆，亦不共享栈，`进程由操作系统调度`。\n`线程`拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。\n协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。\n进程和其他两个的区别还是很明显的。\n`协程和线程的区别是`：协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，`协程也失去了标准线程使用多CPU的能力。`\n\n举个例子：\n假设有一个操作系统，是单核的，系统上没有其他的程序需要运行，有两个线程 A 和 B ，A 和 B 在单独运行时都需要 10 秒来完成自己的任务，而且任务都是运算操作，A B 之间也没有竞争和共享数据的问题。现在 A B 两个线程并行，操作系统会不停的在 A B 两个线程之间切换，达到一种伪并行的效果，假设切换的频率是每秒一次，切换的成本是 0.1 秒(主要是栈切换)，总共需要 20 + 19 * 0.1 = 21.9 秒。如果使用协程的方式，可以先运行协程 A ，A 结束的时候让位给协程 B ，只发生一次切换，总时间是 20 + 1 * 0.1 = 20.1 秒。如果系统是双核的，而且线程是标准线程，那么 A B 两个线程就可以真并行，总时间只需要 10 秒，而协程的方案仍然需要 20.1 秒。\n\n人们通常将协程和子程序（函数）比较着理解。\n子程序调用总是一个入口，一次返回，一旦退出即完成了子程序的执行。\n协程的起始处是第一个入口点，在协程里，返回点之后是接下来的入口点。在python中，协程可以通过yield来调用其它协程。通过yield方式转移执行权的协程之间不是调用者与被调用者的关系，而是彼此对称、平等的，通过相互协作共同完成任务。其运行的大致流程如下：\n\n1. 第一步，协程A开始执行。\n2. 第二步，协程A执行到一半，进入暂停，通过yield命令将执行权转移到协程B。\n3. 第三步，（一段时间后）协程B交还执行权。\n4. 第四步，协程A恢复执行。\n\n协程的特点在于是`一个线程执行`，与多线程相比，其优势体现在：\n\n协程的执行效率非常高。因为子程序切换不是线程切换，而是由程序自身控制，因此，`没有线程切换的开销`，和多线程比，线程数量越多，协程的性能优势就越明显。\n协程不需要多线程的锁机制。在协程中控制共享资源不加锁，只需要判断状态就好了。\nTips:利用多核CPU最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。\n\n## 总结\n\n### 进程与线程比较\n\n线程是指进程内的一个执行单元,也是进程内的可调度实体。线程与进程的区别:\n1. 地址空间:线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间，而进程有自己独立的地址空间\n2. 资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源\n3. 线程是处理器调度的基本单位,但进程不是\n4. 二者均可并发执行\n\n5. 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制\n\n### 协程与线程进行比较\n\n1. 一个线程可以多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核CPU。\n2. 线程进程都是同步机制，而协程则是异步\n3. 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态\n","source":"_posts/进程、线程、协程.md","raw":"---\ntitle: 进程、线程、协程\ndate: 2018-03-04 01:20:18\ntags:\n  - 操作系统\ncategories:\n  - 操作系统\n  - 多任务处理\n---\n\n## 进程\n\n电脑里运行的应用程序，都是进程，假设我们用的电脑是单核的，CPU同时只能执行一个进程。当程序处于I/O阻塞的时候，CPU如果和程序一起等待，那就太浪费了，CPU会去执行其他的程序，此时就涉及到切换，切换前要保存上一个程序运行的状态，才能恢复，所以就需要有个东西来记录这个东西，就可以引出进程的概念了。\n\n进程就是`一个程序在一个数据集上的一次动态执行过程`。进程是一个动态概念，是竟争计算机系统资源的基本单位。进程由`程序`，`数据集`，`进程控制块`三部分组成。`程序`用来描述进程哪些功能以及如何完成；`数据集`是程序执行过程中所使用的资源；`进程控制块`用来保存程序运行的状态.\n\n`进程是系统进行资源分配和调度的一个独立单位`。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。\n\n<!-- more -->\n## 线程\n\n在网络或多用户环境下，一个服务器通常需要接收大量且不确定数量用户的并发请求，为每一个请求都创建一个进程显然是行不通的，——无论是从系统资源开销方面或是响应用户请求的效率方面来看。因此，操作系统中`线程`的概念便被引进了。线程，是进程的一部分，`一个没有线程的进程可以被看作是单线程的`。线程有时又被称为`轻权进程`或`轻量级进程`，是一个基本的cpu执行单元，也是程序执行过程中的最小单元。一个进程最少也会有一个主线程，在主线程中通过threading模块，再开子线程。\n\n线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。\n\n**进程拥有一个完整的虚拟地址空间，不依赖于线程而独立存在；反之，线程是进程的一部分，没有自己的地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。**\n\n**进程的状态有就绪，运行，等待三个状态；线程的状态有新建-就绪-（阻塞）-运行–死亡四个基本状态**\n\n线程全局锁GIL(Global Interpreter Lock),即Python为了保证线程安全而采取的`独立线程运行的限制`,说白了就是一个核只能在同一时间运行一个线程.对于io密集型任务，python的多线程起到作用，但对于cpu密集型任务，python的多线程几乎占不到任何优势，还有可能因为争夺资源而变慢。\n\n## 进程、线程的关系\n\n1. 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程\n2. 资源分配给进程，进程是程序的主体，同一进程的所有线程共享该进程的所有资源\n3. CPU分配给线程，即真正在CPU上运行的是线程\n4. 线程是最小的执行单元，进程是最小的资源管理单元\n\n## 协程Coroutine\n\n协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。\n\n`进程`拥有自己独立的堆和栈，既不共享堆，亦不共享栈，`进程由操作系统调度`。\n`线程`拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。\n协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。\n进程和其他两个的区别还是很明显的。\n`协程和线程的区别是`：协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，`协程也失去了标准线程使用多CPU的能力。`\n\n举个例子：\n假设有一个操作系统，是单核的，系统上没有其他的程序需要运行，有两个线程 A 和 B ，A 和 B 在单独运行时都需要 10 秒来完成自己的任务，而且任务都是运算操作，A B 之间也没有竞争和共享数据的问题。现在 A B 两个线程并行，操作系统会不停的在 A B 两个线程之间切换，达到一种伪并行的效果，假设切换的频率是每秒一次，切换的成本是 0.1 秒(主要是栈切换)，总共需要 20 + 19 * 0.1 = 21.9 秒。如果使用协程的方式，可以先运行协程 A ，A 结束的时候让位给协程 B ，只发生一次切换，总时间是 20 + 1 * 0.1 = 20.1 秒。如果系统是双核的，而且线程是标准线程，那么 A B 两个线程就可以真并行，总时间只需要 10 秒，而协程的方案仍然需要 20.1 秒。\n\n人们通常将协程和子程序（函数）比较着理解。\n子程序调用总是一个入口，一次返回，一旦退出即完成了子程序的执行。\n协程的起始处是第一个入口点，在协程里，返回点之后是接下来的入口点。在python中，协程可以通过yield来调用其它协程。通过yield方式转移执行权的协程之间不是调用者与被调用者的关系，而是彼此对称、平等的，通过相互协作共同完成任务。其运行的大致流程如下：\n\n1. 第一步，协程A开始执行。\n2. 第二步，协程A执行到一半，进入暂停，通过yield命令将执行权转移到协程B。\n3. 第三步，（一段时间后）协程B交还执行权。\n4. 第四步，协程A恢复执行。\n\n协程的特点在于是`一个线程执行`，与多线程相比，其优势体现在：\n\n协程的执行效率非常高。因为子程序切换不是线程切换，而是由程序自身控制，因此，`没有线程切换的开销`，和多线程比，线程数量越多，协程的性能优势就越明显。\n协程不需要多线程的锁机制。在协程中控制共享资源不加锁，只需要判断状态就好了。\nTips:利用多核CPU最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。\n\n## 总结\n\n### 进程与线程比较\n\n线程是指进程内的一个执行单元,也是进程内的可调度实体。线程与进程的区别:\n1. 地址空间:线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间，而进程有自己独立的地址空间\n2. 资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源\n3. 线程是处理器调度的基本单位,但进程不是\n4. 二者均可并发执行\n\n5. 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制\n\n### 协程与线程进行比较\n\n1. 一个线程可以多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核CPU。\n2. 线程进程都是同步机制，而协程则是异步\n3. 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态\n","slug":"进程、线程、协程","published":1,"updated":"2018-03-07T06:32:41.417Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14oznn00768motzpgbirm9","content":"<h2 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h2><p>电脑里运行的应用程序，都是进程，假设我们用的电脑是单核的，CPU同时只能执行一个进程。当程序处于I/O阻塞的时候，CPU如果和程序一起等待，那就太浪费了，CPU会去执行其他的程序，此时就涉及到切换，切换前要保存上一个程序运行的状态，才能恢复，所以就需要有个东西来记录这个东西，就可以引出进程的概念了。</p>\n<p>进程就是<code>一个程序在一个数据集上的一次动态执行过程</code>。进程是一个动态概念，是竟争计算机系统资源的基本单位。进程由<code>程序</code>，<code>数据集</code>，<code>进程控制块</code>三部分组成。<code>程序</code>用来描述进程哪些功能以及如何完成；<code>数据集</code>是程序执行过程中所使用的资源；<code>进程控制块</code>用来保存程序运行的状态.</p>\n<p><code>进程是系统进行资源分配和调度的一个独立单位</code>。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。</p>\n<a id=\"more\"></a>\n<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><p>在网络或多用户环境下，一个服务器通常需要接收大量且不确定数量用户的并发请求，为每一个请求都创建一个进程显然是行不通的，——无论是从系统资源开销方面或是响应用户请求的效率方面来看。因此，操作系统中<code>线程</code>的概念便被引进了。线程，是进程的一部分，<code>一个没有线程的进程可以被看作是单线程的</code>。线程有时又被称为<code>轻权进程</code>或<code>轻量级进程</code>，是一个基本的cpu执行单元，也是程序执行过程中的最小单元。一个进程最少也会有一个主线程，在主线程中通过threading模块，再开子线程。</p>\n<p>线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。</p>\n<p><strong>进程拥有一个完整的虚拟地址空间，不依赖于线程而独立存在；反之，线程是进程的一部分，没有自己的地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。</strong></p>\n<p><strong>进程的状态有就绪，运行，等待三个状态；线程的状态有新建-就绪-（阻塞）-运行–死亡四个基本状态</strong></p>\n<p>线程全局锁GIL(Global Interpreter Lock),即Python为了保证线程安全而采取的<code>独立线程运行的限制</code>,说白了就是一个核只能在同一时间运行一个线程.对于io密集型任务，python的多线程起到作用，但对于cpu密集型任务，python的多线程几乎占不到任何优势，还有可能因为争夺资源而变慢。</p>\n<h2 id=\"进程、线程的关系\"><a href=\"#进程、线程的关系\" class=\"headerlink\" title=\"进程、线程的关系\"></a>进程、线程的关系</h2><ol>\n<li>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程</li>\n<li>资源分配给进程，进程是程序的主体，同一进程的所有线程共享该进程的所有资源</li>\n<li>CPU分配给线程，即真正在CPU上运行的是线程</li>\n<li>线程是最小的执行单元，进程是最小的资源管理单元</li>\n</ol>\n<h2 id=\"协程Coroutine\"><a href=\"#协程Coroutine\" class=\"headerlink\" title=\"协程Coroutine\"></a>协程Coroutine</h2><p>协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p>\n<p><code>进程</code>拥有自己独立的堆和栈，既不共享堆，亦不共享栈，<code>进程由操作系统调度</code>。<br><code>线程</code>拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。<br>协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。<br>进程和其他两个的区别还是很明显的。<br><code>协程和线程的区别是</code>：协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，<code>协程也失去了标准线程使用多CPU的能力。</code></p>\n<p>举个例子：<br>假设有一个操作系统，是单核的，系统上没有其他的程序需要运行，有两个线程 A 和 B ，A 和 B 在单独运行时都需要 10 秒来完成自己的任务，而且任务都是运算操作，A B 之间也没有竞争和共享数据的问题。现在 A B 两个线程并行，操作系统会不停的在 A B 两个线程之间切换，达到一种伪并行的效果，假设切换的频率是每秒一次，切换的成本是 0.1 秒(主要是栈切换)，总共需要 20 + 19 <em> 0.1 = 21.9 秒。如果使用协程的方式，可以先运行协程 A ，A 结束的时候让位给协程 B ，只发生一次切换，总时间是 20 + 1 </em> 0.1 = 20.1 秒。如果系统是双核的，而且线程是标准线程，那么 A B 两个线程就可以真并行，总时间只需要 10 秒，而协程的方案仍然需要 20.1 秒。</p>\n<p>人们通常将协程和子程序（函数）比较着理解。<br>子程序调用总是一个入口，一次返回，一旦退出即完成了子程序的执行。<br>协程的起始处是第一个入口点，在协程里，返回点之后是接下来的入口点。在python中，协程可以通过yield来调用其它协程。通过yield方式转移执行权的协程之间不是调用者与被调用者的关系，而是彼此对称、平等的，通过相互协作共同完成任务。其运行的大致流程如下：</p>\n<ol>\n<li>第一步，协程A开始执行。</li>\n<li>第二步，协程A执行到一半，进入暂停，通过yield命令将执行权转移到协程B。</li>\n<li>第三步，（一段时间后）协程B交还执行权。</li>\n<li>第四步，协程A恢复执行。</li>\n</ol>\n<p>协程的特点在于是<code>一个线程执行</code>，与多线程相比，其优势体现在：</p>\n<p>协程的执行效率非常高。因为子程序切换不是线程切换，而是由程序自身控制，因此，<code>没有线程切换的开销</code>，和多线程比，线程数量越多，协程的性能优势就越明显。<br>协程不需要多线程的锁机制。在协程中控制共享资源不加锁，只需要判断状态就好了。<br>Tips:利用多核CPU最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h3 id=\"进程与线程比较\"><a href=\"#进程与线程比较\" class=\"headerlink\" title=\"进程与线程比较\"></a>进程与线程比较</h3><p>线程是指进程内的一个执行单元,也是进程内的可调度实体。线程与进程的区别:</p>\n<ol>\n<li>地址空间:线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间，而进程有自己独立的地址空间</li>\n<li>资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源</li>\n<li>线程是处理器调度的基本单位,但进程不是</li>\n<li><p>二者均可并发执行</p>\n</li>\n<li><p>每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制</p>\n</li>\n</ol>\n<h3 id=\"协程与线程进行比较\"><a href=\"#协程与线程进行比较\" class=\"headerlink\" title=\"协程与线程进行比较\"></a>协程与线程进行比较</h3><ol>\n<li>一个线程可以多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核CPU。</li>\n<li>线程进程都是同步机制，而协程则是异步</li>\n<li>协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h2><p>电脑里运行的应用程序，都是进程，假设我们用的电脑是单核的，CPU同时只能执行一个进程。当程序处于I/O阻塞的时候，CPU如果和程序一起等待，那就太浪费了，CPU会去执行其他的程序，此时就涉及到切换，切换前要保存上一个程序运行的状态，才能恢复，所以就需要有个东西来记录这个东西，就可以引出进程的概念了。</p>\n<p>进程就是<code>一个程序在一个数据集上的一次动态执行过程</code>。进程是一个动态概念，是竟争计算机系统资源的基本单位。进程由<code>程序</code>，<code>数据集</code>，<code>进程控制块</code>三部分组成。<code>程序</code>用来描述进程哪些功能以及如何完成；<code>数据集</code>是程序执行过程中所使用的资源；<code>进程控制块</code>用来保存程序运行的状态.</p>\n<p><code>进程是系统进行资源分配和调度的一个独立单位</code>。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。</p>","more":"<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><p>在网络或多用户环境下，一个服务器通常需要接收大量且不确定数量用户的并发请求，为每一个请求都创建一个进程显然是行不通的，——无论是从系统资源开销方面或是响应用户请求的效率方面来看。因此，操作系统中<code>线程</code>的概念便被引进了。线程，是进程的一部分，<code>一个没有线程的进程可以被看作是单线程的</code>。线程有时又被称为<code>轻权进程</code>或<code>轻量级进程</code>，是一个基本的cpu执行单元，也是程序执行过程中的最小单元。一个进程最少也会有一个主线程，在主线程中通过threading模块，再开子线程。</p>\n<p>线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。</p>\n<p><strong>进程拥有一个完整的虚拟地址空间，不依赖于线程而独立存在；反之，线程是进程的一部分，没有自己的地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。</strong></p>\n<p><strong>进程的状态有就绪，运行，等待三个状态；线程的状态有新建-就绪-（阻塞）-运行–死亡四个基本状态</strong></p>\n<p>线程全局锁GIL(Global Interpreter Lock),即Python为了保证线程安全而采取的<code>独立线程运行的限制</code>,说白了就是一个核只能在同一时间运行一个线程.对于io密集型任务，python的多线程起到作用，但对于cpu密集型任务，python的多线程几乎占不到任何优势，还有可能因为争夺资源而变慢。</p>\n<h2 id=\"进程、线程的关系\"><a href=\"#进程、线程的关系\" class=\"headerlink\" title=\"进程、线程的关系\"></a>进程、线程的关系</h2><ol>\n<li>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程</li>\n<li>资源分配给进程，进程是程序的主体，同一进程的所有线程共享该进程的所有资源</li>\n<li>CPU分配给线程，即真正在CPU上运行的是线程</li>\n<li>线程是最小的执行单元，进程是最小的资源管理单元</li>\n</ol>\n<h2 id=\"协程Coroutine\"><a href=\"#协程Coroutine\" class=\"headerlink\" title=\"协程Coroutine\"></a>协程Coroutine</h2><p>协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p>\n<p><code>进程</code>拥有自己独立的堆和栈，既不共享堆，亦不共享栈，<code>进程由操作系统调度</code>。<br><code>线程</code>拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。<br>协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。<br>进程和其他两个的区别还是很明显的。<br><code>协程和线程的区别是</code>：协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，<code>协程也失去了标准线程使用多CPU的能力。</code></p>\n<p>举个例子：<br>假设有一个操作系统，是单核的，系统上没有其他的程序需要运行，有两个线程 A 和 B ，A 和 B 在单独运行时都需要 10 秒来完成自己的任务，而且任务都是运算操作，A B 之间也没有竞争和共享数据的问题。现在 A B 两个线程并行，操作系统会不停的在 A B 两个线程之间切换，达到一种伪并行的效果，假设切换的频率是每秒一次，切换的成本是 0.1 秒(主要是栈切换)，总共需要 20 + 19 <em> 0.1 = 21.9 秒。如果使用协程的方式，可以先运行协程 A ，A 结束的时候让位给协程 B ，只发生一次切换，总时间是 20 + 1 </em> 0.1 = 20.1 秒。如果系统是双核的，而且线程是标准线程，那么 A B 两个线程就可以真并行，总时间只需要 10 秒，而协程的方案仍然需要 20.1 秒。</p>\n<p>人们通常将协程和子程序（函数）比较着理解。<br>子程序调用总是一个入口，一次返回，一旦退出即完成了子程序的执行。<br>协程的起始处是第一个入口点，在协程里，返回点之后是接下来的入口点。在python中，协程可以通过yield来调用其它协程。通过yield方式转移执行权的协程之间不是调用者与被调用者的关系，而是彼此对称、平等的，通过相互协作共同完成任务。其运行的大致流程如下：</p>\n<ol>\n<li>第一步，协程A开始执行。</li>\n<li>第二步，协程A执行到一半，进入暂停，通过yield命令将执行权转移到协程B。</li>\n<li>第三步，（一段时间后）协程B交还执行权。</li>\n<li>第四步，协程A恢复执行。</li>\n</ol>\n<p>协程的特点在于是<code>一个线程执行</code>，与多线程相比，其优势体现在：</p>\n<p>协程的执行效率非常高。因为子程序切换不是线程切换，而是由程序自身控制，因此，<code>没有线程切换的开销</code>，和多线程比，线程数量越多，协程的性能优势就越明显。<br>协程不需要多线程的锁机制。在协程中控制共享资源不加锁，只需要判断状态就好了。<br>Tips:利用多核CPU最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><h3 id=\"进程与线程比较\"><a href=\"#进程与线程比较\" class=\"headerlink\" title=\"进程与线程比较\"></a>进程与线程比较</h3><p>线程是指进程内的一个执行单元,也是进程内的可调度实体。线程与进程的区别:</p>\n<ol>\n<li>地址空间:线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间，而进程有自己独立的地址空间</li>\n<li>资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源</li>\n<li>线程是处理器调度的基本单位,但进程不是</li>\n<li><p>二者均可并发执行</p>\n</li>\n<li><p>每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制</p>\n</li>\n</ol>\n<h3 id=\"协程与线程进行比较\"><a href=\"#协程与线程进行比较\" class=\"headerlink\" title=\"协程与线程进行比较\"></a>协程与线程进行比较</h3><ol>\n<li>一个线程可以多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核CPU。</li>\n<li>线程进程都是同步机制，而协程则是异步</li>\n<li>协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态</li>\n</ol>"},{"title":"进程间的通信方式(IPC)","date":"2018-03-07T15:47:10.000Z","_content":"\n1. `管道`（Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。\n2. `命名管道`（named pipe）：命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。\n3. `信号`（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。\n4. `消息（Message）队列`：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺\n5. `共享内存`：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。\n6. `内存映射`（mapped memory）：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。\n7. `信号量`（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。\n8. `套接口`（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。\n","source":"_posts/进程间的通信方式-IPC.md","raw":"---\ntitle: 进程间的通信方式(IPC)\ndate: 2018-03-07 23:47:10\ntags:\n  - 操作系统\ncategories:\n  - 操作系统\n---\n\n1. `管道`（Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。\n2. `命名管道`（named pipe）：命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。\n3. `信号`（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。\n4. `消息（Message）队列`：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺\n5. `共享内存`：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。\n6. `内存映射`（mapped memory）：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。\n7. `信号量`（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。\n8. `套接口`（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。\n","slug":"进程间的通信方式-IPC","published":1,"updated":"2018-03-07T15:49:17.891Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjk14oznp007a8motx7fz0ktq","content":"<ol>\n<li><code>管道</code>（Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。</li>\n<li><code>命名管道</code>（named pipe）：命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。</li>\n<li><code>信号</code>（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。</li>\n<li><code>消息（Message）队列</code>：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺</li>\n<li><code>共享内存</code>：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。</li>\n<li><code>内存映射</code>（mapped memory）：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。</li>\n<li><code>信号量</code>（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。</li>\n<li><code>套接口</code>（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><code>管道</code>（Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。</li>\n<li><code>命名管道</code>（named pipe）：命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。</li>\n<li><code>信号</code>（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。</li>\n<li><code>消息（Message）队列</code>：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺</li>\n<li><code>共享内存</code>：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。</li>\n<li><code>内存映射</code>（mapped memory）：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。</li>\n<li><code>信号量</code>（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。</li>\n<li><code>套接口</code>（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。</li>\n</ol>\n"},{"title":"UDP 套接字编程","date":"2018-07-25T11:31:29.000Z","_content":"\n![Screen Shot 2018-07-25 at 19.54.43.png](https://upload-images.jianshu.io/upload_images/2952111-0d1e97d91078ff77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n<!-- more -->\n\n## UDPClient.py\n```python\nfrom socket import *\n\n# serverName = '140.143.38.125'\nserverName = 'server.kunxiang.wang'\nserverPort = 12000\n\n\nclientSocket = socket(AF_INET, SOCK_DGRAM)\n\n# 如果不绑定客户端进程端口，则自动选择端口\nclientSocket.bind(('', 34567))\n\nmsg = input('please input lowercase sentence: ').encode()\nclientSocket.sendto(msg, (serverName, serverPort))\n\nmodifiedMsg, serverAddress = clientSocket.recvfrom(2048)\n\nprint(modifiedMsg, serverAddress, end='\\n')\n\nclientSocket.close()\n```\n\n\n## UDPServer.py\n```python\nfrom socket import *\nserverPort = 12000\nserverSocket = socket(AF_INET, SOCK_DGRAM)\nserverSocket.bind(('', serverPort))\nprint('The server is ready to receive')\nwhile True:\n    message, clientAddress = serverSocket.recvfrom(2048)\n    print(message)\n    print(clientAddress)\n    modifiedMessage = message.upper()\n    serverSocket.sendto(modifiedMessage, clientAddress)\n\n```\n","source":"_posts/UDP-套接字编程.md","raw":"---\ntitle: UDP 套接字编程\ndate: 2018-07-25 19:31:29\ntags:\n  - 网络\ncategories:\n  - 网络\n---\n\n![Screen Shot 2018-07-25 at 19.54.43.png](https://upload-images.jianshu.io/upload_images/2952111-0d1e97d91078ff77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n<!-- more -->\n\n## UDPClient.py\n```python\nfrom socket import *\n\n# serverName = '140.143.38.125'\nserverName = 'server.kunxiang.wang'\nserverPort = 12000\n\n\nclientSocket = socket(AF_INET, SOCK_DGRAM)\n\n# 如果不绑定客户端进程端口，则自动选择端口\nclientSocket.bind(('', 34567))\n\nmsg = input('please input lowercase sentence: ').encode()\nclientSocket.sendto(msg, (serverName, serverPort))\n\nmodifiedMsg, serverAddress = clientSocket.recvfrom(2048)\n\nprint(modifiedMsg, serverAddress, end='\\n')\n\nclientSocket.close()\n```\n\n\n## UDPServer.py\n```python\nfrom socket import *\nserverPort = 12000\nserverSocket = socket(AF_INET, SOCK_DGRAM)\nserverSocket.bind(('', serverPort))\nprint('The server is ready to receive')\nwhile True:\n    message, clientAddress = serverSocket.recvfrom(2048)\n    print(message)\n    print(clientAddress)\n    modifiedMessage = message.upper()\n    serverSocket.sendto(modifiedMessage, clientAddress)\n\n```\n","slug":"UDP-套接字编程","published":1,"updated":"2018-07-28T06:49:20.474Z","_id":"cjk14oznr007e8motff70j69s","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"https://upload-images.jianshu.io/upload_images/2952111-0d1e97d91078ff77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Screen Shot 2018-07-25 at 19.54.43.png\"></p>\n<a id=\"more\"></a>\n<h2 id=\"UDPClient-py\"><a href=\"#UDPClient-py\" class=\"headerlink\" title=\"UDPClient.py\"></a>UDPClient.py</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> socket <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># serverName = '140.143.38.125'</span></span><br><span class=\"line\">serverName = <span class=\"string\">'server.kunxiang.wang'</span></span><br><span class=\"line\">serverPort = <span class=\"number\">12000</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">clientSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果不绑定客户端进程端口，则自动选择端口</span></span><br><span class=\"line\">clientSocket.bind((<span class=\"string\">''</span>, <span class=\"number\">34567</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">msg = input(<span class=\"string\">'please input lowercase sentence: '</span>).encode()</span><br><span class=\"line\">clientSocket.sendto(msg, (serverName, serverPort))</span><br><span class=\"line\"></span><br><span class=\"line\">modifiedMsg, serverAddress = clientSocket.recvfrom(<span class=\"number\">2048</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">print(modifiedMsg, serverAddress, end=<span class=\"string\">'\\n'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">clientSocket.close()</span><br></pre></td></tr></table></figure>\n<h2 id=\"UDPServer-py\"><a href=\"#UDPServer-py\" class=\"headerlink\" title=\"UDPServer.py\"></a>UDPServer.py</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> socket <span class=\"keyword\">import</span> *</span><br><span class=\"line\">serverPort = <span class=\"number\">12000</span></span><br><span class=\"line\">serverSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class=\"line\">serverSocket.bind((<span class=\"string\">''</span>, serverPort))</span><br><span class=\"line\">print(<span class=\"string\">'The server is ready to receive'</span>)</span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">    message, clientAddress = serverSocket.recvfrom(<span class=\"number\">2048</span>)</span><br><span class=\"line\">    print(message)</span><br><span class=\"line\">    print(clientAddress)</span><br><span class=\"line\">    modifiedMessage = message.upper()</span><br><span class=\"line\">    serverSocket.sendto(modifiedMessage, clientAddress)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p><img src=\"https://upload-images.jianshu.io/upload_images/2952111-0d1e97d91078ff77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Screen Shot 2018-07-25 at 19.54.43.png\"></p>","more":"<h2 id=\"UDPClient-py\"><a href=\"#UDPClient-py\" class=\"headerlink\" title=\"UDPClient.py\"></a>UDPClient.py</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> socket <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># serverName = '140.143.38.125'</span></span><br><span class=\"line\">serverName = <span class=\"string\">'server.kunxiang.wang'</span></span><br><span class=\"line\">serverPort = <span class=\"number\">12000</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">clientSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 如果不绑定客户端进程端口，则自动选择端口</span></span><br><span class=\"line\">clientSocket.bind((<span class=\"string\">''</span>, <span class=\"number\">34567</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">msg = input(<span class=\"string\">'please input lowercase sentence: '</span>).encode()</span><br><span class=\"line\">clientSocket.sendto(msg, (serverName, serverPort))</span><br><span class=\"line\"></span><br><span class=\"line\">modifiedMsg, serverAddress = clientSocket.recvfrom(<span class=\"number\">2048</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">print(modifiedMsg, serverAddress, end=<span class=\"string\">'\\n'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">clientSocket.close()</span><br></pre></td></tr></table></figure>\n<h2 id=\"UDPServer-py\"><a href=\"#UDPServer-py\" class=\"headerlink\" title=\"UDPServer.py\"></a>UDPServer.py</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> socket <span class=\"keyword\">import</span> *</span><br><span class=\"line\">serverPort = <span class=\"number\">12000</span></span><br><span class=\"line\">serverSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class=\"line\">serverSocket.bind((<span class=\"string\">''</span>, serverPort))</span><br><span class=\"line\">print(<span class=\"string\">'The server is ready to receive'</span>)</span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">    message, clientAddress = serverSocket.recvfrom(<span class=\"number\">2048</span>)</span><br><span class=\"line\">    print(message)</span><br><span class=\"line\">    print(clientAddress)</span><br><span class=\"line\">    modifiedMessage = message.upper()</span><br><span class=\"line\">    serverSocket.sendto(modifiedMessage, clientAddress)</span><br></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjk14ozjj00048motwdysh1nq","category_id":"cjk14ozjq00078motq1gluzpk","_id":"cjk14ozjz000h8motz9c3ukph"},{"post_id":"cjk14ozjo00068motsp4ev1qz","category_id":"cjk14ozjv000d8motm0c0y42k","_id":"cjk14ozk6000o8motyh6lr7nm"},{"post_id":"cjk14ozjq00088motcgcfj1bk","category_id":"cjk14ozjv000d8motm0c0y42k","_id":"cjk14ozk9000s8motr4t5k4io"},{"post_id":"cjk14ozjr00098moty6exboj5","category_id":"cjk14ozk6000n8motnwneek62","_id":"cjk14ozkd000z8mot64zqtbgf"},{"post_id":"cjk14ozjt000c8motji1fu16c","category_id":"cjk14ozk9000u8motc4ty2yex","_id":"cjk14ozkg00168motu1w1a2im"},{"post_id":"cjk14ozkd00118motvc4evwmn","category_id":"cjk14ozjq00078motq1gluzpk","_id":"cjk14ozki001b8motxpii7wlg"},{"post_id":"cjk14ozjw000e8mot9zwnq51f","category_id":"cjk14ozk6000n8motnwneek62","_id":"cjk14ozkk001f8mot2cn2m0j7"},{"post_id":"cjk14ozkf00138mot7db0b7aj","category_id":"cjk14ozjq00078motq1gluzpk","_id":"cjk14ozkl001i8mot3ke7kq6g"},{"post_id":"cjk14ozkg00178mot83822igp","category_id":"cjk14ozjq00078motq1gluzpk","_id":"cjk14ozkn001m8motr3wcd6yt"},{"post_id":"cjk14ozjy000g8mot9sbmbr17","category_id":"cjk14ozk6000n8motnwneek62","_id":"cjk14ozko001q8mot850jg92u"},{"post_id":"cjk14ozkj001e8motoqsr86qu","category_id":"cjk14ozjq00078motq1gluzpk","_id":"cjk14ozkq001u8mot2lvnc9ef"},{"post_id":"cjk14ozk5000m8motg8ruodzq","category_id":"cjk14ozkn001n8motnjtxcvwu","_id":"cjk14ozkv00228motxpvr4p6x"},{"post_id":"cjk14ozk7000p8motk1qvez51","category_id":"cjk14ozkn001n8motnjtxcvwu","_id":"cjk14ozky00298mot0z8ndyuf"},{"post_id":"cjk14ozkw00248motr86gq0fl","category_id":"cjk14ozjq00078motq1gluzpk","_id":"cjk14ozl6002f8mot8d2mxdpi"},{"post_id":"cjk14ozk8000r8motrifojd5i","category_id":"cjk14ozkn001n8motnjtxcvwu","_id":"cjk14ozl8002j8motus0z3t7v"},{"post_id":"cjk14ozkx00278mot03aw0gag","category_id":"cjk14ozjq00078motq1gluzpk","_id":"cjk14ozla002n8mot421i2q97"},{"post_id":"cjk14ozka000v8motiuea1xet","category_id":"cjk14ozkn001n8motnjtxcvwu","_id":"cjk14ozlc002r8motijwxe40g"},{"post_id":"cjk14ozl5002e8motohhds8x9","category_id":"cjk14ozjq00078motq1gluzpk","_id":"cjk14ozld002v8mot9tje1u6r"},{"post_id":"cjk14ozkc000y8mot8x0q4e2d","category_id":"cjk14ozl7002g8mot2ku9ltie","_id":"cjk14ozlg002z8mottvy17j3f"},{"post_id":"cjk14ozlb002q8mot9x1hrsjd","category_id":"cjk14ozjq00078motq1gluzpk","_id":"cjk14ozli00338mote5cs03w9"},{"post_id":"cjk14ozki001a8mot7wlppxm0","category_id":"cjk14ozjq00078motq1gluzpk","_id":"cjk14ozlk00368mot4hxnimkn"},{"post_id":"cjk14ozki001a8mot7wlppxm0","category_id":"cjk14ozla002p8mott910z7tk","_id":"cjk14ozln003b8motpbymx0c6"},{"post_id":"cjk14ozlh00328motwclnq96n","category_id":"cjk14ozjq00078motq1gluzpk","_id":"cjk14ozlp003e8motedqitbyy"},{"post_id":"cjk14ozkl001h8motnm9grrgq","category_id":"cjk14ozjq00078motq1gluzpk","_id":"cjk14ozlq003i8mote120bdj0"},{"post_id":"cjk14ozkl001h8motnm9grrgq","category_id":"cjk14ozlf002x8motctpcbv3v","_id":"cjk14ozls003m8motd1d1jpix"},{"post_id":"cjk14ozlm003a8motw5c5aydo","category_id":"cjk14ozjq00078motq1gluzpk","_id":"cjk14ozlu003q8mot868wvvna"},{"post_id":"cjk14ozk1000k8mot56mf2f1x","category_id":"cjk14ozkj001d8motqsd5vrg8","_id":"cjk14ozlw003u8motuujk0xab"},{"post_id":"cjk14ozk1000k8mot56mf2f1x","category_id":"cjk14ozll00378motoeqk66j8","_id":"cjk14ozm0003y8motxkybgq1n"},{"post_id":"cjk14ozkm001l8motbav7nhtm","category_id":"cjk14ozjq00078motq1gluzpk","_id":"cjk14ozm100428motk5t2hgud"},{"post_id":"cjk14ozkm001l8motbav7nhtm","category_id":"cjk14ozlp003f8mot90brewg7","_id":"cjk14ozm200458mott4ix3mau"},{"post_id":"cjk14ozlz003x8motswhhziq2","category_id":"cjk14ozjq00078motq1gluzpk","_id":"cjk14ozm4004a8mot83mpv48b"},{"post_id":"cjk14ozkp001t8motdi3vkuwd","category_id":"cjk14ozjq00078motq1gluzpk","_id":"cjk14ozm6004d8motc3zmj1ea"},{"post_id":"cjk14ozkp001t8motdi3vkuwd","category_id":"cjk14ozly003w8mot04di4o2z","_id":"cjk14ozm8004h8mot9kt3gz37"},{"post_id":"cjk14ozm200448mot342vlmrx","category_id":"cjk14ozjq00078motq1gluzpk","_id":"cjk14ozm9004l8mot24np3ga3"},{"post_id":"cjk14ozm200448mot342vlmrx","category_id":"cjk14ozla002p8mott910z7tk","_id":"cjk14ozmb004p8motjpvl19b4"},{"post_id":"cjk14ozkr001x8motdmsoyy18","category_id":"cjk14ozjq00078motq1gluzpk","_id":"cjk14ozmd004t8motqwlxg1f8"},{"post_id":"cjk14ozkr001x8motdmsoyy18","category_id":"cjk14ozm200468motn2b096if","_id":"cjk14ozmf004x8motyumcmcw1"},{"post_id":"cjk14ozkt00208mota6p8ex1w","category_id":"cjk14ozjq00078motq1gluzpk","_id":"cjk14ozmg00518motuwbonwcz"},{"post_id":"cjk14ozkt00208mota6p8ex1w","category_id":"cjk14ozm6004e8motorm9f7z7","_id":"cjk14ozmi00558motmij9jobw"},{"post_id":"cjk14ozm8004k8motbvrjtfuc","category_id":"cjk14ozjq00078motq1gluzpk","_id":"cjk14ozml00598motrpxjoks4"},{"post_id":"cjk14ozkz002b8motlie8pwot","category_id":"cjk14ozma004n8motc8bcsd6z","_id":"cjk14ozmn005d8mot3m0lt1p4"},{"post_id":"cjk14ozmc004s8motq1neez2l","category_id":"cjk14ozjq00078motq1gluzpk","_id":"cjk14ozmp005h8motfr68nm4w"},{"post_id":"cjk14ozmf00508mot4oppl5m7","category_id":"cjk14ozjq00078motq1gluzpk","_id":"cjk14ozmr005l8motiuyz28if"},{"post_id":"cjk14ozl7002i8mot3xjwbxqh","category_id":"cjk14ozmd004v8motl85ik1bv","_id":"cjk14ozmu005p8mot54er4acs"},{"post_id":"cjk14ozl9002m8motoefx8src","category_id":"cjk14ozmd004v8motl85ik1bv","_id":"cjk14ozmw005t8motuo4whibp"},{"post_id":"cjk14ozld002u8mot7n9mdngz","category_id":"cjk14ozma004n8motc8bcsd6z","_id":"cjk14ozmy005x8motvnqls2w2"},{"post_id":"cjk14ozmq005j8motcuxlvndo","category_id":"cjk14ozkj001d8motqsd5vrg8","_id":"cjk14ozmz00618motsi85e6fu"},{"post_id":"cjk14ozmq005j8motcuxlvndo","category_id":"cjk14ozll00378motoeqk66j8","_id":"cjk14ozn100658motqbl5ndh8"},{"post_id":"cjk14ozlg002y8mot4wgat9yu","category_id":"cjk14ozmd004v8motl85ik1bv","_id":"cjk14ozn300698mota8ga1t4b"},{"post_id":"cjk14ozlj00358mot3kjfp6vz","category_id":"cjk14ozma004n8motc8bcsd6z","_id":"cjk14ozn7006d8mot2k07noa5"},{"post_id":"cjk14ozlo003d8motzvwpzpyr","category_id":"cjk14ozma004n8motc8bcsd6z","_id":"cjk14ozn9006g8mot2ip8beg1"},{"post_id":"cjk14ozlp003h8mottwz5gpp0","category_id":"cjk14ozjq00078motq1gluzpk","_id":"cjk14oznd006n8motdvvbnhzt"},{"post_id":"cjk14ozlp003h8mottwz5gpp0","category_id":"cjk14ozn300688moti96xdj5e","_id":"cjk14oznh006s8mot9opdtyel"},{"post_id":"cjk14ozn8006f8moty751uial","category_id":"cjk14ozkj001d8motqsd5vrg8","_id":"cjk14ozni006v8motm9bjaewx"},{"post_id":"cjk14ozn8006f8moty751uial","category_id":"cjk14ozll00378motoeqk66j8","_id":"cjk14oznk00708mot467rhsrd"},{"post_id":"cjk14ozlr003l8mot1kcygkuq","category_id":"cjk14ozjq00078motq1gluzpk","_id":"cjk14oznn00738motgizjwcvc"},{"post_id":"cjk14ozlr003l8mot1kcygkuq","category_id":"cjk14ozn9006h8motjhimgsk5","_id":"cjk14oznp00788motbejtsq6j"},{"post_id":"cjk14ozlt003p8motflgws4wq","category_id":"cjk14ozjq00078motq1gluzpk","_id":"cjk14oznq007b8mota7gz3pc4"},{"post_id":"cjk14ozlt003p8motflgws4wq","category_id":"cjk14oznd006p8motrd1a25nf","_id":"cjk14ozns007g8mot3jpme51y"},{"post_id":"cjk14oznl00728mot3e14gcja","category_id":"cjk14ozkn001n8motnjtxcvwu","_id":"cjk14oznt007i8mot9wx1mcmt"},{"post_id":"cjk14ozko001p8motm68arqt0","category_id":"cjk14ozls003o8motav8zorcc","_id":"cjk14oznt007l8motkpkp0owl"},{"post_id":"cjk14ozko001p8motm68arqt0","category_id":"cjk14oznj006y8mot974rij2g","_id":"cjk14oznu007o8mots40jiagw"},{"post_id":"cjk14oznn00768motzpgbirm9","category_id":"cjk14ozkj001d8motqsd5vrg8","_id":"cjk14oznv007r8mota4nq65vz"},{"post_id":"cjk14oznn00768motzpgbirm9","category_id":"cjk14ozll00378motoeqk66j8","_id":"cjk14oznw007u8motvr9tc520"},{"post_id":"cjk14oznp007a8motx7fz0ktq","category_id":"cjk14ozkj001d8motqsd5vrg8","_id":"cjk14oznx007x8mothyj6oazj"},{"post_id":"cjk14ozlv003t8motpkxkvdig","category_id":"cjk14ozjq00078motq1gluzpk","_id":"cjk14ozny00808mot6ezsu76y"},{"post_id":"cjk14ozlv003t8motpkxkvdig","category_id":"cjk14ozno00778motba4cz9zf","_id":"cjk14ozny00838motb2a7tlu4"},{"post_id":"cjk14ozm000418motvcq8ftjk","category_id":"cjk14ozjq00078motq1gluzpk","_id":"cjk14oznz00868motsbpw3nyb"},{"post_id":"cjk14ozm000418motvcq8ftjk","category_id":"cjk14ozns007f8motcof8nmb1","_id":"cjk14ozo000888motw30neh16"},{"post_id":"cjk14ozm300498moty3gibzpi","category_id":"cjk14ozjq00078motq1gluzpk","_id":"cjk14ozo1008b8motp9ji8gdr"},{"post_id":"cjk14ozm300498moty3gibzpi","category_id":"cjk14oznu007n8motgded839r","_id":"cjk14ozo2008e8motfjnvefnk"},{"post_id":"cjk14ozm5004c8motij15owur","category_id":"cjk14oznv007t8motunnf17fe","_id":"cjk14ozo3008h8mot3d1ww36m"},{"post_id":"cjk14ozm7004g8motuo5msz5b","category_id":"cjk14ozny007z8moto5lnfyvz","_id":"cjk14ozo4008k8mot4vdhdpu1"},{"post_id":"cjk14ozme004w8mot6tx3r0jw","category_id":"cjk14ozjq00078motq1gluzpk","_id":"cjk14ozo5008n8motwjffem4s"},{"post_id":"cjk14ozme004w8mot6tx3r0jw","category_id":"cjk14oznz00858motee1mngl0","_id":"cjk14ozo6008q8mot20ltn9rk"},{"post_id":"cjk14ozmh00538mot92upklck","category_id":"cjk14ozjq00078motq1gluzpk","_id":"cjk14ozo7008t8motzz65v0ms"},{"post_id":"cjk14ozmh00538mot92upklck","category_id":"cjk14ozo1008d8mot5h3mo1ym","_id":"cjk14ozo7008w8motuhih07kq"},{"post_id":"cjk14ozmj00588motcpty3qh1","category_id":"cjk14oznv007t8motunnf17fe","_id":"cjk14ozo8008z8motfq9v3jwe"},{"post_id":"cjk14ozmm005b8motouwfxma6","category_id":"cjk14ozo5008p8motsnihxbdm","_id":"cjk14ozoa00928motq8tv4n6r"},{"post_id":"cjk14ozmo005g8motcbu4u0fv","category_id":"cjk14oznv007t8motunnf17fe","_id":"cjk14ozoc00978motedg0jula"},{"post_id":"cjk14ozmt005o8mots35911q9","category_id":"cjk14oznv007t8motunnf17fe","_id":"cjk14ozoe009b8mothsc12ouh"},{"post_id":"cjk14ozmu005r8mot74g4ezwb","category_id":"cjk14ozls003o8motav8zorcc","_id":"cjk14ozog009h8motf9sv3f45"},{"post_id":"cjk14ozmu005r8mot74g4ezwb","category_id":"cjk14ozoc00968motozkx5m8p","_id":"cjk14ozoh009k8motnrnvww1u"},{"post_id":"cjk14ozmx005w8motqp87dch1","category_id":"cjk14ozls003o8motav8zorcc","_id":"cjk14ozoi009n8motr0wwwaol"},{"post_id":"cjk14ozmx005w8motqp87dch1","category_id":"cjk14ozoc00968motozkx5m8p","_id":"cjk14ozoj009q8motytfmzp9q"},{"post_id":"cjk14ozmy005z8mot78iu9n0c","category_id":"cjk14ozls003o8motav8zorcc","_id":"cjk14ozol009t8motgglvj8ph"},{"post_id":"cjk14ozmy005z8mot78iu9n0c","category_id":"cjk14ozoc00968motozkx5m8p","_id":"cjk14ozol009v8moti9axw755"},{"post_id":"cjk14ozn100648motvfam25zy","category_id":"cjk14ozls003o8motav8zorcc","_id":"cjk14ozom009y8motelcl2cbx"},{"post_id":"cjk14ozn100648motvfam25zy","category_id":"cjk14ozoc00968motozkx5m8p","_id":"cjk14ozon00a08mot2es83u60"},{"post_id":"cjk14ozn200678motl18h4w8a","category_id":"cjk14ozls003o8motav8zorcc","_id":"cjk14ozon00a38mot8ycflz66"},{"post_id":"cjk14ozn200678motl18h4w8a","category_id":"cjk14ozoc00968motozkx5m8p","_id":"cjk14ozoo00a58motgfxof130"},{"post_id":"cjk14ozna006k8motq940isqm","category_id":"cjk14oznv007t8motunnf17fe","_id":"cjk14ozoo00a88motmi8cgloy"},{"post_id":"cjk14oznc006m8motn8ihpmk0","category_id":"cjk14oznv007t8motunnf17fe","_id":"cjk14ozop00ac8mot5589seyi"},{"post_id":"cjk14oznh006u8motg6h39nuh","category_id":"cjk14oznv007t8motunnf17fe","_id":"cjk14ozoq00af8motxd3lnp9j"},{"post_id":"cjk14oznj006z8mot7yfi20nt","category_id":"cjk14ozls003o8motav8zorcc","_id":"cjk14ozor00ai8moteohzue6n"},{"post_id":"cjk14oznj006z8mot7yfi20nt","category_id":"cjk14ozop00ab8motrff2g4ac","_id":"cjk14ozor00aj8motpnsipxta"},{"post_id":"cjk14oznr007e8motff70j69s","category_id":"cjk14oznv007t8motunnf17fe","_id":"cjk14ozor00ak8motbgq1dk1z"}],"PostTag":[{"post_id":"cjk14ozje00028motb6jf1qb7","tag_id":"cjk14ozjm00058mot4n62u721","_id":"cjk14ozjt000b8motvsfkwet1"},{"post_id":"cjk14ozjj00048motwdysh1nq","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14ozjz000i8motx4hgmymm"},{"post_id":"cjk14ozjo00068motsp4ev1qz","tag_id":"cjk14ozjx000f8motkolxvt7n","_id":"cjk14ozk9000t8mot15mufnsn"},{"post_id":"cjk14ozjo00068motsp4ev1qz","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14ozkb000w8mot1zm1vpk6"},{"post_id":"cjk14ozjq00088motcgcfj1bk","tag_id":"cjk14ozjx000f8motkolxvt7n","_id":"cjk14ozkg00148motg2oahagd"},{"post_id":"cjk14ozjq00088motcgcfj1bk","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14ozkh00188motdb1rd7e9"},{"post_id":"cjk14ozkd00118motvc4evwmn","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14ozkj001c8mot3mc79eqd"},{"post_id":"cjk14ozkf00138mot7db0b7aj","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14ozkk001g8mot46h5rpr2"},{"post_id":"cjk14ozkg00178mot83822igp","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14ozkm001k8motz05l6kxk"},{"post_id":"cjk14ozki001a8mot7wlppxm0","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14ozkn001o8mot69piua54"},{"post_id":"cjk14ozkj001e8motoqsr86qu","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14ozkp001s8motgafthzwr"},{"post_id":"cjk14ozjr00098moty6exboj5","tag_id":"cjk14ozke00128moti10z3d61","_id":"cjk14ozkr001w8mot001klp7c"},{"post_id":"cjk14ozjr00098moty6exboj5","tag_id":"cjk14ozki00198motddjmgrgc","_id":"cjk14ozkt001z8motvhcry664"},{"post_id":"cjk14ozkl001h8motnm9grrgq","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14ozkv00238motbtipf37m"},{"post_id":"cjk14ozkm001l8motbav7nhtm","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14ozkx00268motgwqu6sia"},{"post_id":"cjk14ozjt000c8motji1fu16c","tag_id":"cjk14ozkl001j8mot1jtljuap","_id":"cjk14ozky002a8motonjin9nm"},{"post_id":"cjk14ozkp001t8motdi3vkuwd","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14ozl5002c8mote4otnwpj"},{"post_id":"cjk14ozjw000e8mot9zwnq51f","tag_id":"cjk14ozke00128moti10z3d61","_id":"cjk14ozl7002h8motfmdmnmol"},{"post_id":"cjk14ozkr001x8motdmsoyy18","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14ozl8002k8mot40tlmaur"},{"post_id":"cjk14ozkt00208mota6p8ex1w","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14ozla002o8motwh55udsa"},{"post_id":"cjk14ozjy000g8mot9sbmbr17","tag_id":"cjk14ozke00128moti10z3d61","_id":"cjk14ozlc002s8mot0t7sdyb9"},{"post_id":"cjk14ozkx00278mot03aw0gag","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14ozlf002w8mot8c40z8f2"},{"post_id":"cjk14ozk1000k8mot56mf2f1x","tag_id":"cjk14ozkx00258motojwswtfi","_id":"cjk14ozlh00308mot5yebj0b9"},{"post_id":"cjk14ozl5002e8motohhds8x9","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14ozlj00348mothta5iypb"},{"post_id":"cjk14ozk5000m8motg8ruodzq","tag_id":"cjk14ozl5002d8motxkgjnlzc","_id":"cjk14ozll00388motc9g7hd6r"},{"post_id":"cjk14ozk7000p8motk1qvez51","tag_id":"cjk14ozl5002d8motxkgjnlzc","_id":"cjk14ozln003c8motm3eb0w9r"},{"post_id":"cjk14ozlb002q8mot9x1hrsjd","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14ozlp003g8motrie3ow4k"},{"post_id":"cjk14ozk8000r8motrifojd5i","tag_id":"cjk14ozl5002d8motxkgjnlzc","_id":"cjk14ozlr003k8motoadt2xma"},{"post_id":"cjk14ozlh00328motwclnq96n","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14ozls003n8mot7krw217x"},{"post_id":"cjk14ozka000v8motiuea1xet","tag_id":"cjk14ozl5002d8motxkgjnlzc","_id":"cjk14ozlv003s8motldsy03r9"},{"post_id":"cjk14ozkc000y8mot8x0q4e2d","tag_id":"cjk14ozll00398mot9t9s8orx","_id":"cjk14ozly003v8motek3avij6"},{"post_id":"cjk14ozlp003h8mottwz5gpp0","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14ozm0003z8motwiquaf9k"},{"post_id":"cjk14ozlr003l8mot1kcygkuq","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14ozm100438motksjvnriz"},{"post_id":"cjk14ozlt003p8motflgws4wq","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14ozm300478mote6i5h3yr"},{"post_id":"cjk14ozlv003t8motpkxkvdig","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14ozm4004b8mota2oxonsv"},{"post_id":"cjk14ozlz003x8motswhhziq2","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14ozm6004f8motmnwptrgs"},{"post_id":"cjk14ozm000418motvcq8ftjk","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14ozm8004j8motitxitzx6"},{"post_id":"cjk14ozko001p8motm68arqt0","tag_id":"cjk14ozlq003j8motpnjx4zxm","_id":"cjk14ozma004m8motu1g9qxll"},{"post_id":"cjk14ozko001p8motm68arqt0","tag_id":"cjk14ozlu003r8motoofuzdlv","_id":"cjk14ozmb004r8motf0vqggvr"},{"post_id":"cjk14ozko001p8motm68arqt0","tag_id":"cjk14ozm000408motw7lxv392","_id":"cjk14ozmd004u8motdwo77mhv"},{"post_id":"cjk14ozko001p8motm68arqt0","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14ozmf004z8motguqt09iq"},{"post_id":"cjk14ozm200448mot342vlmrx","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14ozmg00528motprnuntzz"},{"post_id":"cjk14ozm300498moty3gibzpi","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14ozmi00568motebdd1cgs"},{"post_id":"cjk14ozkw00248motr86gq0fl","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14ozml005a8mot7gvzm5zu"},{"post_id":"cjk14ozkw00248motr86gq0fl","tag_id":"cjk14ozm300488motwmmr7omn","_id":"cjk14ozmo005e8motrprivy6d"},{"post_id":"cjk14ozm8004k8motbvrjtfuc","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14ozmp005i8motio0fcigg"},{"post_id":"cjk14ozkz002b8motlie8pwot","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14ozms005m8mot455dwqrn"},{"post_id":"cjk14ozkz002b8motlie8pwot","tag_id":"cjk14ozm8004i8motgvufnos0","_id":"cjk14ozmu005q8mot5fb60mg1"},{"post_id":"cjk14ozmc004s8motq1neez2l","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14ozmw005u8mothgkn2fm1"},{"post_id":"cjk14ozme004w8mot6tx3r0jw","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14ozmy005y8motly1t38nk"},{"post_id":"cjk14ozmf00508mot4oppl5m7","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14ozn000628motd6wxdfrc"},{"post_id":"cjk14ozl7002i8mot3xjwbxqh","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14ozn200668motlmht5gla"},{"post_id":"cjk14ozl7002i8mot3xjwbxqh","tag_id":"cjk14ozm8004i8motgvufnos0","_id":"cjk14ozn4006a8mot7gtzzg0a"},{"post_id":"cjk14ozl7002i8mot3xjwbxqh","tag_id":"cjk14ozmf004y8moto7y35lfc","_id":"cjk14ozn7006e8motqa8sv2ut"},{"post_id":"cjk14ozmh00538mot92upklck","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14ozn9006i8motns58sxc8"},{"post_id":"cjk14ozmm005b8motouwfxma6","tag_id":"cjk14ozki00198motddjmgrgc","_id":"cjk14oznb006l8motmba44ney"},{"post_id":"cjk14ozl9002m8motoefx8src","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14oznd006o8motuh3t4ght"},{"post_id":"cjk14ozl9002m8motoefx8src","tag_id":"cjk14ozm8004i8motgvufnos0","_id":"cjk14oznh006t8motfo04gyto"},{"post_id":"cjk14ozl9002m8motoefx8src","tag_id":"cjk14ozmf004y8moto7y35lfc","_id":"cjk14ozni006w8mot3bgi9boa"},{"post_id":"cjk14ozmq005j8motcuxlvndo","tag_id":"cjk14ozkx00258motojwswtfi","_id":"cjk14oznk00718mot33knpjfn"},{"post_id":"cjk14ozld002u8mot7n9mdngz","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14oznn00748motbls3rasu"},{"post_id":"cjk14ozld002u8mot7n9mdngz","tag_id":"cjk14ozm8004i8motgvufnos0","_id":"cjk14oznp00798motyd2lzoxg"},{"post_id":"cjk14ozlg002y8mot4wgat9yu","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14oznq007c8motkzeknsoz"},{"post_id":"cjk14ozlg002y8mot4wgat9yu","tag_id":"cjk14ozm8004i8motgvufnos0","_id":"cjk14ozns007h8motbxfud4io"},{"post_id":"cjk14ozlg002y8mot4wgat9yu","tag_id":"cjk14ozmf004y8moto7y35lfc","_id":"cjk14oznt007j8motlpyd7sqc"},{"post_id":"cjk14ozn8006f8moty751uial","tag_id":"cjk14ozkx00258motojwswtfi","_id":"cjk14oznt007m8motyl7kivv7"},{"post_id":"cjk14ozlj00358mot3kjfp6vz","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14oznu007p8mot141nywyi"},{"post_id":"cjk14ozlj00358mot3kjfp6vz","tag_id":"cjk14ozm8004i8motgvufnos0","_id":"cjk14oznv007s8motl8dyjfg1"},{"post_id":"cjk14ozlj00358mot3kjfp6vz","tag_id":"cjk14ozmf004y8moto7y35lfc","_id":"cjk14oznw007v8motca4bvuud"},{"post_id":"cjk14ozlm003a8motw5c5aydo","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14oznx007y8mot573tphoy"},{"post_id":"cjk14ozlm003a8motw5c5aydo","tag_id":"cjk14ozm8004i8motgvufnos0","_id":"cjk14ozny00818motm01w2qxu"},{"post_id":"cjk14ozlo003d8motzvwpzpyr","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14oznz00848motz0ejgms4"},{"post_id":"cjk14ozlo003d8motzvwpzpyr","tag_id":"cjk14ozm8004i8motgvufnos0","_id":"cjk14oznz00878mot8vqhiax1"},{"post_id":"cjk14oznl00728mot3e14gcja","tag_id":"cjk14ozl5002d8motxkgjnlzc","_id":"cjk14ozo0008a8motszpo03i7"},{"post_id":"cjk14oznn00768motzpgbirm9","tag_id":"cjk14ozkx00258motojwswtfi","_id":"cjk14ozo1008c8mot9nj82lab"},{"post_id":"cjk14ozm5004c8motij15owur","tag_id":"cjk14oznn00758mot36egohxw","_id":"cjk14ozo2008g8motxt3als6g"},{"post_id":"cjk14oznp007a8motx7fz0ktq","tag_id":"cjk14ozkx00258motojwswtfi","_id":"cjk14ozo3008i8motmtzj5qu0"},{"post_id":"cjk14oznr007e8motff70j69s","tag_id":"cjk14oznn00758mot36egohxw","_id":"cjk14ozo4008m8motnutvtznf"},{"post_id":"cjk14ozm7004g8motuo5msz5b","tag_id":"cjk14oznq007d8motn8jg1pcd","_id":"cjk14ozo5008o8mot4jnfm9to"},{"post_id":"cjk14ozmj00588motcpty3qh1","tag_id":"cjk14oznn00758mot36egohxw","_id":"cjk14ozo6008s8mot97pqhlx3"},{"post_id":"cjk14ozmo005g8motcbu4u0fv","tag_id":"cjk14oznn00758mot36egohxw","_id":"cjk14ozo7008u8motrh7k1g76"},{"post_id":"cjk14ozmt005o8mots35911q9","tag_id":"cjk14oznn00758mot36egohxw","_id":"cjk14ozo8008y8mot46k7l0xy"},{"post_id":"cjk14ozmu005r8mot74g4ezwb","tag_id":"cjk14ozlq003j8motpnjx4zxm","_id":"cjk14ozo800908motfql9h97g"},{"post_id":"cjk14ozmu005r8mot74g4ezwb","tag_id":"cjk14ozny00828mothift25wh","_id":"cjk14ozoa00938mot7gpcubip"},{"post_id":"cjk14ozmu005r8mot74g4ezwb","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14ozob00958motq4d5xsur"},{"post_id":"cjk14ozmx005w8motqp87dch1","tag_id":"cjk14ozlq003j8motpnjx4zxm","_id":"cjk14ozod00988motca42bg55"},{"post_id":"cjk14ozmx005w8motqp87dch1","tag_id":"cjk14ozny00828mothift25wh","_id":"cjk14ozoe009a8mot1g2x72hn"},{"post_id":"cjk14ozmx005w8motqp87dch1","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14ozoe009d8mot4c195cqx"},{"post_id":"cjk14ozmy005z8mot78iu9n0c","tag_id":"cjk14ozlq003j8motpnjx4zxm","_id":"cjk14ozof009f8motf7ekxe6k"},{"post_id":"cjk14ozmy005z8mot78iu9n0c","tag_id":"cjk14ozny00828mothift25wh","_id":"cjk14ozog009i8motbuq0k8lr"},{"post_id":"cjk14ozmy005z8mot78iu9n0c","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14ozoh009l8motn9q4i835"},{"post_id":"cjk14ozn100648motvfam25zy","tag_id":"cjk14ozlq003j8motpnjx4zxm","_id":"cjk14ozoi009o8motp7jemv4i"},{"post_id":"cjk14ozn100648motvfam25zy","tag_id":"cjk14ozny00828mothift25wh","_id":"cjk14ozoj009r8motqhch4itk"},{"post_id":"cjk14ozn100648motvfam25zy","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14ozol009u8motm6k145ek"},{"post_id":"cjk14ozn200678motl18h4w8a","tag_id":"cjk14ozlq003j8motpnjx4zxm","_id":"cjk14ozom009w8mot6smljpp3"},{"post_id":"cjk14ozn200678motl18h4w8a","tag_id":"cjk14ozny00828mothift25wh","_id":"cjk14ozom009z8mot0j5jcmn9"},{"post_id":"cjk14ozn200678motl18h4w8a","tag_id":"cjk14ozjs000a8motvcv5zlcu","_id":"cjk14ozon00a18motim04bgy2"},{"post_id":"cjk14ozn6006c8motaz4gv2kh","tag_id":"cjk14ozo8008x8motpj4amyz4","_id":"cjk14ozon00a48motbuxbk5yz"},{"post_id":"cjk14ozna006k8motq940isqm","tag_id":"cjk14oznn00758mot36egohxw","_id":"cjk14ozoo00a68mot7va4pxoa"},{"post_id":"cjk14oznc006m8motn8ihpmk0","tag_id":"cjk14oznn00758mot36egohxw","_id":"cjk14ozoo00a98motrv6udiw7"},{"post_id":"cjk14oznf006r8motx8fgjcl7","tag_id":"cjk14ozof009e8motrbj011hp","_id":"cjk14ozop00aa8mot5g87ska0"},{"post_id":"cjk14oznh006u8motg6h39nuh","tag_id":"cjk14oznn00758mot36egohxw","_id":"cjk14ozop00ad8motb1hjb19l"},{"post_id":"cjk14oznj006z8mot7yfi20nt","tag_id":"cjk14ozoj009p8mot2gihhzez","_id":"cjk14ozoq00ae8motjggge234"},{"post_id":"cjk14oznj006z8mot7yfi20nt","tag_id":"cjk14ozlq003j8motpnjx4zxm","_id":"cjk14ozoq00ag8motxw1nsrlj"}],"Tag":[{"name":"Web服务器","_id":"cjk14ozjm00058mot4n62u721"},{"name":"Python3","_id":"cjk14ozjs000a8motvcv5zlcu"},{"name":"Django","_id":"cjk14ozjx000f8motkolxvt7n"},{"name":"Hexo","_id":"cjk14ozke00128moti10z3d61"},{"name":"Git","_id":"cjk14ozki00198motddjmgrgc"},{"name":"Frontend","_id":"cjk14ozkl001j8mot1jtljuap"},{"name":"操作系统","_id":"cjk14ozkx00258motojwswtfi"},{"name":"Linux/Mac OS","_id":"cjk14ozl5002d8motxkgjnlzc"},{"name":"Markdown","_id":"cjk14ozll00398mot9t9s8orx"},{"name":"Spider","_id":"cjk14ozlq003j8motpnjx4zxm"},{"name":"Selenium","_id":"cjk14ozlu003r8motoofuzdlv"},{"name":"PhantomJS","_id":"cjk14ozm000408motw7lxv392"},{"name":"设计模式","_id":"cjk14ozm300488motwmmr7omn"},{"name":"Algorithm","_id":"cjk14ozm8004i8motgvufnos0"},{"name":"Data Structures","_id":"cjk14ozmf004y8moto7y35lfc"},{"name":"网络","_id":"cjk14oznn00758mot36egohxw"},{"name":"Tesseract","_id":"cjk14oznq007d8motn8jg1pcd"},{"name":"Urllib","_id":"cjk14ozny00828mothift25wh"},{"name":"计算机基础","_id":"cjk14ozo8008x8motpj4amyz4"},{"name":"加密","_id":"cjk14ozof009e8motrbj011hp"},{"name":"Scrapy","_id":"cjk14ozoj009p8mot2gihhzez"}]}}