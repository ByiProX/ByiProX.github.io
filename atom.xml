<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Quentin&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kunxiang.wang/"/>
  <updated>2018-09-25T02:39:17.893Z</updated>
  <id>http://kunxiang.wang/</id>
  
  <author>
    <name>ByiProX</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DHCP续租过程</title>
    <link href="http://kunxiang.wang/2018/09/25/DHCP%E7%BB%AD%E7%A7%9F%E8%BF%87%E7%A8%8B/"/>
    <id>http://kunxiang.wang/2018/09/25/DHCP续租过程/</id>
    <published>2018-09-25T02:27:21.000Z</published>
    <updated>2018-09-25T02:39:17.893Z</updated>
    
    <content type="html"><![CDATA[<p>计算机网络发展的早些时候，当一台设备想要在网络上通信的时候，它需要被手动分配一个地址。随着网络的发展，手动方式变得烦琐，为了解决这个问题，<code>BOOTY协议(Bootstrap Protocol)</code>被创建出来给链接到网络的设备自动分配地址。BOOTY协议后来被更加复杂的<code>动态主机配置协议DHCP(Dynamic Host Configuration Protocol)</code>取代。</p><h4 id="DHCP续租过程"><a href="#DHCP续租过程" class="headerlink" title="DHCP续租过程"></a>DHCP续租过程</h4><table><thead><tr><th>DHCP客户端</th><th>DORA过程</th><th>DHCP服务器</th></tr></thead><tbody><tr><td>→</td><td>发现Discover  →</td><td>→</td></tr><tr><td>←</td><td>提供Offer    ←</td><td>←</td></tr><tr><td>→</td><td>请求Request   →</td><td>→</td></tr><tr><td>←</td><td>确认Acknowledgement  ←</td><td>←</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;计算机网络发展的早些时候，当一台设备想要在网络上通信的时候，它需要被手动分配一个地址。随着网络的发展，手动方式变得烦琐，为了解决这个问题，&lt;code&gt;BOOTY协议(Bootstrap Protocol)&lt;/code&gt;被创建出来给链接到网络的设备自动分配地址。BOOTY协议
      
    
    </summary>
    
      <category term="网络" scheme="http://kunxiang.wang/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://kunxiang.wang/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络各层协议</title>
    <link href="http://kunxiang.wang/2018/09/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%90%84%E5%B1%82%E5%8D%8F%E8%AE%AE/"/>
    <id>http://kunxiang.wang/2018/09/19/计算机网络各层协议/</id>
    <published>2018-09-19T15:54:15.000Z</published>
    <updated>2018-09-22T05:01:19.709Z</updated>
    
    <content type="html"><![CDATA[<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层:"></a>应用层:</h3><p>典型设备:应用程序，如FTP，SMTP ，HTTP</p><ul><li><p>DHCP (Dynamic Host Configuration Protocol)动态主机分配协议，使用 UDP 协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配 IP 地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。实 现即插即用连网。</p></li><li><p>BOOTP (BOOTstrapProtocol) 引导程序协议/ 自举协议，使用UDP 来使 一个无盘工作站自动获取配置信息。静态的配置协议  DNS    （Domain Name System ）域名解析&lt;端口号53&gt;</p></li><li><p>FTP   （File Transfer Protocol ）文件传输协议&lt;端口号21&gt;减少或消除不同操作系统下处理文件的不兼容性。</p><a id="more"></a></li><li><p>Gopher   （The Internet Gopher Protocol ）网际Gopher 协议</p></li><li><p>HTTP    （Hypertext Transfer Protocol ）超文本传输协议 &lt;端口号 80&gt;， 面向事务的应用层协议。</p></li><li><p>IMAP4 (Internet Message Access Protocol 4) Internet 信息访问协议的第 4 版本</p></li><li><p>IRC   （Internet Relay Chat ）网络聊天协议</p></li><li><p>NNTP    （Network News Transport Protocol ）网络新闻传输协议</p></li><li><p>XMPP 可扩展消息处理现场协议</p></li><li><p>POP3 (Post Office Protocol 3) 即邮局协议的第3 个版本，用于接受邮件。</p></li><li><p>SIP()信令控制协议</p></li><li><p>SMTP （Simple Mail Transfer Protocol ）简单邮件传输协议 &lt;端口号25&gt; 用于发送邮件。</p></li><li><p>SNMP (Simple Network Management Protocol),简单网络管理协议</p></li><li><p>SSH   （Secure Shell ）安全外壳协议</p></li><li><p>TELNET     远程登录协议 &lt;端口号23&gt;</p></li><li><p>RPC   （Remote Procedure Call Protocol ）（RFC- 1831）远程过程调用协 议</p></li><li><p>RTCP    （RTP Control Protocol ）RTP   控制协议</p></li><li><p>RTSP   （Real Time Streaming Protocol ）实时流传输协议</p></li><li><p>TLS   （Transport Layer Security Protocol ）安全传输层协议</p></li><li><p>SDP( Session Description Protocol ）会话描述协议</p></li><li><p>SOAP   （Simple Object Access Protocol ）简单对象访问协议</p></li><li><p>GTP 通用数据传输平台</p></li><li><p>STUN   （Simple Traversal of UDP over NATs ，NAT的UDP 简单穿越） 是一种网络协议</p></li><li><p>NTP   （Network Time Protocol ）网络校时协议。</p></li></ul><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层:"></a>传输层:</h3><p>典型设备:  进程和端口<br>数据单元：数据段 （Segment）</p><ul><li><p>TCP  （Transmission Control Protocol ）传输控制协议提供可靠的面向连接的服务，传输数据前须先建立连接，结束后释放。可靠的全双工信道。可靠、有序、无丢失、不重复。</p></li><li><p>UDP (User Datagram Protocol ）用户数据报协议发送数据前无需建立连接，不使用拥塞控制，不保证可靠交付，最大努力交付。</p></li><li><p>DCCP    （Datagram Congestion Control Protocol ）数据报拥塞控制协议</p></li><li><p>SCTP  （STREAM CONTROL TRANSMISSION PROTOCOL ）流控制传 输协议</p></li><li><p>RTP(Real-time Transport Protocol ）实时传送协议</p></li><li><p>RSVP   （Resource ReSer Vation Protocol ）资源预留协议</p></li><li><p>PPTP ( Point to Point Tunneling Protocol ）点对点隧道协议</p></li></ul><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>典型设备:路由器，防火墙、多层交换机<br>数据单元：数据包（Packet）</p><ul><li><p>IP (IPv4 · IPv6) (Internet Protocol) 网络之间互连的协议</p></li><li><p>ARP (Address Resolution Protocol) 即地址解析协议，实现通过IP 地址得 知其物理地址。</p></li><li><p>RARP (Reverse Address Resolution Protocol)反向地址转换协议允许局域 网的物理机器从网关服务器的 ARP 表或者缓存上请求其 IP地址。</p></li><li><p>ICMP (Internet Control Message Protocol ）Internet 控制报文协议。它是TCP/IP 协议族的一个子协议，用于在IP 主机、路由器之间传递控制消息。</p></li><li><p>ICMPv6 : IGMP (Internet Group Management Protocol) Internet 组管理协议,是因特 网协议家族中的一个组播协议，用于 IP  主机向任一个直接相邻的路由器报 告他们的组成员情况。</p></li><li><p>RIP (Router information protocol) 路由信息协议是一种在网关与主机之间交换路由选择信息的标准。</p></li><li><p>OSPF (Open Shortest Path Firs)开放式最短路径优先,分布式链路状态协议。</p></li><li><p>BGP（Border Gateway Protocol ）边界网关协议，用来连接Internet 上独立系统的路由选择协议.采用路径向量路由选择协议。</p></li><li><p>IS-IS （Intermediate System to Intermediate System Routing Protocol ）中间系统到中间系统的路由选择协议.</p></li></ul><ul><li>IPsec (IP Secure) “Internet  协议安全性”是一种开放标准的框架结构，通过使用加密的安全服务以确保在 Internet  协议 (IP)  网络上进行保密而安全的通讯。</li></ul><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>典型设备:  网卡，网桥，交换机<br>数据单元：帧 （Frame）</p><ul><li><p>ARQ（Automatic Repeat-reQuest ）自动重传请求协议，错误纠正协议之一，包括停止等待ARQ 协议和连续ARQ 协议，错误侦测、正面确认、逾时重传与负面确认继以重传等机制。</p></li><li><p>停止等待协议：<br>CSMA/CD(Carrrier Sense Multiple Access with Collision Detection)载波监听多点接入/碰撞检测协议。总线型网络，协议的实质是载波监听和碰撞检测。载波监听即发数据前先检测总线上是否有其他计算机在发送数据，如暂时不发数据，避免碰撞。碰撞检测为计算机边发送数据边检测信道上的信号电压大小。</p></li><li><p>PPP(Point-to-Ponit Protocol)点对点协议面向字节，由三部分组成：一个将IP 数据报封装到串行链路的方法；一个用于建立、配置和测试数据链路连接的链路控制协议</p></li><li><p>LCP(Link Control Protocol) ：一套网络控制协议NCP 。</p></li><li><p>HDLC  （High-Level Data Link Control ）高级数据链路控制同步网上传输数据、面向比特的数据链路层协议。</p></li><li><p>ATM  （Asynchronous Transfer Mode ）异步传递方式，建立在电路交换和分组交换的基础上的一种面向连接的快速分组交换技术。 “异步”是指将ATM 信元“异步插入”到同步的 SDH 比特流中。如同步插入则用户在每帧中所占的时隙相对位置固定不变。“同步”是指网络中各链路上的比特流都是受同一非常精确的主时钟的控制。Wi-Fi 、WiMAX 、DTM 、令牌环、以太网、FDDI 、帧中继、 GPRS 、 EVDO 、HSPA 、L2TP 、ISDN</p></li></ul><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>典型设备：中继器，集线器、网线、HUB<br>数据单元：比特 （Bit）</p><p>以太网物理层、调制解调器、PLC 、SONET/SDH 、G.709 、光导纤维、 同轴电缆、双绞线</p><p>最后附上一张各层协议图：<br><img src="https://upload-images.jianshu.io/upload_images/2952111-99ac991e14642231.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="计算机网络协议拓扑.jpg"></p><p>参考：<br><a href="https://www.cnblogs.com/maowang1991/archive/2013/04/16/3024393.html" target="_blank" rel="noopener">https://www.cnblogs.com/maowang1991/archive/2013/04/16/3024393.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;应用层&quot;&gt;&lt;a href=&quot;#应用层&quot; class=&quot;headerlink&quot; title=&quot;应用层:&quot;&gt;&lt;/a&gt;应用层:&lt;/h3&gt;&lt;p&gt;典型设备:应用程序，如FTP，SMTP ，HTTP&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;DHCP (Dynamic Host Configuration Protocol)动态主机分配协议，使用 UDP 协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配 IP 地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。实 现即插即用连网。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;BOOTP (BOOTstrapProtocol) 引导程序协议/ 自举协议，使用UDP 来使 一个无盘工作站自动获取配置信息。静态的配置协议  DNS    （Domain Name System ）域名解析&amp;lt;端口号53&amp;gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;FTP   （File Transfer Protocol ）文件传输协议&amp;lt;端口号21&amp;gt;减少或消除不同操作系统下处理文件的不兼容性。&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="http://kunxiang.wang/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://kunxiang.wang/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>maven约定目录配置</title>
    <link href="http://kunxiang.wang/2018/09/19/maven%E7%BA%A6%E5%AE%9A%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE/"/>
    <id>http://kunxiang.wang/2018/09/19/maven约定目录配置/</id>
    <published>2018-09-19T05:36:26.000Z</published>
    <updated>2018-09-22T08:15:16.195Z</updated>
    
    <content type="html"><![CDATA[<p>Maven 提倡使用一个共同的标准目录结构，Maven 使用约定优于配置的原则，大家尽可能的遵守这样的目录结构。</p><table><thead><tr><th>目录</th><th>目的</th></tr></thead><tbody><tr><td>${basedir}</td><td>存放pom.xml和所有的子目录</td></tr><tr><td>${basedir}/src/main/java</td><td>项目的java源代码</td></tr><tr><td>${basedir}/src/main/resources</td><td>项目的资源，比如说property文件，springmvc.xml</td></tr><tr><td>${basedir}/src/test/java</td><td>项目的测试类，比如说Junit代码</td></tr><tr><td>${basedir}/src/test/resources</td><td>测试用用的资源</td></tr><tr><td>${basedir}/src/main/webapp/WEB-INF</td><td>web应用文件目录，web项目的信息，比如存放web.xml、本地图片、jsp视图页面</td></tr><tr><td>${basedir}/target</td><td>打包输出目录</td></tr><tr><td>${basedir}/target/classes</td><td>编译输出目录</td></tr><tr><td>${basedir}/target/test-classes</td><td>测试编译输出目录</td></tr><tr><td>Test.java</td><td>Maven只会自动运行符合该命名规则的测试类</td></tr><tr><td>~/.m2/repository</td><td>Maven默认的本地仓库目录位置</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Maven 提倡使用一个共同的标准目录结构，Maven 使用约定优于配置的原则，大家尽可能的遵守这样的目录结构。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;目录&lt;/th&gt;
&lt;th&gt;目的&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td
      
    
    </summary>
    
      <category term="Java" scheme="http://kunxiang.wang/categories/Java/"/>
    
    
      <category term="Java" scheme="http://kunxiang.wang/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Mac Dock栏分组</title>
    <link href="http://kunxiang.wang/2018/09/18/Mac-Dock%E6%A0%8F%E5%88%86%E7%BB%84/"/>
    <id>http://kunxiang.wang/2018/09/18/Mac-Dock栏分组/</id>
    <published>2018-09-18T05:42:06.000Z</published>
    <updated>2018-09-19T08:46:40.235Z</updated>
    
    <content type="html"><![CDATA[<h4 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h4><p>终端下输入如下命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~ defaults write com.apple.dock persistent-apps -array-add <span class="string">'&#123; "tile-type" = "spacer-tile"; &#125;'</span></span><br><span class="line"></span><br><span class="line">~ killall Dock</span><br></pre></td></tr></table></figure></p><p>实际上在docker中添加了空白的icon，如需删除只需右键移除即可。</p><a id="more"></a><h4 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h4><p><a href="https://github.com/DeromirNeves/VerticalBar" target="_blank" rel="noopener">https://github.com/DeromirNeves/VerticalBar</a></p><p><a href="https://github.com/DeromirNeves/VerticalBar.git" target="_blank" rel="noopener">https://github.com/DeromirNeves/VerticalBar.git</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;方法1&quot;&gt;&lt;a href=&quot;#方法1&quot; class=&quot;headerlink&quot; title=&quot;方法1&quot;&gt;&lt;/a&gt;方法1&lt;/h4&gt;&lt;p&gt;终端下输入如下命令&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;~ defaults write com.apple.dock persistent-apps -array-add &lt;span class=&quot;string&quot;&gt;&#39;&amp;#123; &quot;tile-type&quot; = &quot;spacer-tile&quot;; &amp;#125;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;~ killall Dock&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;实际上在docker中添加了空白的icon，如需删除只需右键移除即可。&lt;/p&gt;
    
    </summary>
    
      <category term="玩转苹果" scheme="http://kunxiang.wang/categories/%E7%8E%A9%E8%BD%AC%E8%8B%B9%E6%9E%9C/"/>
    
    
      <category term="玩转苹果" scheme="http://kunxiang.wang/tags/%E7%8E%A9%E8%BD%AC%E8%8B%B9%E6%9E%9C/"/>
    
  </entry>
  
  <entry>
    <title>Java 方法设置默认参数</title>
    <link href="http://kunxiang.wang/2018/09/09/Java-%E6%96%B9%E6%B3%95%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0/"/>
    <id>http://kunxiang.wang/2018/09/09/Java-方法设置默认参数/</id>
    <published>2018-09-09T10:59:52.000Z</published>
    <updated>2018-09-09T11:01:22.550Z</updated>
    
    <content type="html"><![CDATA[<p>Java本身不支持设置默认值，需要用重载间接实现。</p><p>因为“默认参数”和“方法重载”同时支持的话有二义性的问题，Java可能为了简单就不要“默认参数”了。使用“方法重载”可以间接实现”默认参数“的效果，而且避免了代码过于hack（乱）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doA</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doA</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.doA(<span class="number">0</span>);<span class="comment">//这里默认传入0，可以近似与通过这个方法重载，实现了默认值</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java本身不支持设置默认值，需要用重载间接实现。&lt;/p&gt;
&lt;p&gt;因为“默认参数”和“方法重载”同时支持的话有二义性的问题，Java可能为了简单就不要“默认参数”了。使用“方法重载”可以间接实现”默认参数“的效果，而且避免了代码过于hack（乱）。&lt;/p&gt;
&lt;figure 
      
    
    </summary>
    
      <category term="Java" scheme="http://kunxiang.wang/categories/Java/"/>
    
    
      <category term="Java" scheme="http://kunxiang.wang/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 关键字this和super</title>
    <link href="http://kunxiang.wang/2018/09/07/Java-%E5%85%B3%E9%94%AE%E5%AD%97this%E5%92%8Csuper/"/>
    <id>http://kunxiang.wang/2018/09/07/Java-关键字this和super/</id>
    <published>2018-09-07T02:32:12.000Z</published>
    <updated>2018-09-07T02:40:51.608Z</updated>
    
    <content type="html"><![CDATA[<p>关键字this有两个用途：</p><ol><li>引用隐式参数</li><li>调用该类其他的构造器</li></ol><p>关键字super也有两个用途：</p><ol><li>调用超类的方法</li><li>调用超类的构造器</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关键字this有两个用途：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;引用隐式参数&lt;/li&gt;
&lt;li&gt;调用该类其他的构造器&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关键字super也有两个用途：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用超类的方法&lt;/li&gt;
&lt;li&gt;调用超类的构造器&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
      <category term="Java" scheme="http://kunxiang.wang/categories/Java/"/>
    
    
      <category term="Java" scheme="http://kunxiang.wang/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Linux 使用su和su -切换用户的区别</title>
    <link href="http://kunxiang.wang/2018/09/06/Linux-%E4%BD%BF%E7%94%A8su%E5%92%8Csu-%E5%88%87%E6%8D%A2%E7%94%A8%E6%88%B7%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://kunxiang.wang/2018/09/06/Linux-使用su和su-切换用户的区别/</id>
    <published>2018-09-06T14:37:27.000Z</published>
    <updated>2018-09-06T14:48:13.502Z</updated>
    
    <content type="html"><![CDATA[<p>假设原来我们以<code>root</code>身份登录在终端，那么环境变量包含<code>/usr/sbin</code>。</p><ul><li>若使用<code>su -</code>切换到普通用户后，环境变量<strong>不包含</strong><code>/usr/sbin</code>。</li><li>若使用<code>su</code>切换到普通用户，环境变量<strong>包含</strong><code>/usr/sbin</code>。</li></ul><p>简单总结为，</p><ul><li><code>su -</code>相当于重新登录，环境变量随用户的身份变为登录后用户的环境变量。登陆后的位置为用户home目录下。</li><li><code>su</code>环境变量不随切换后的用户的环境变量而变化。而且登陆后所在位置与登录前一致，对于从root切换而言，当前目录为<code>/root</code>。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;假设原来我们以&lt;code&gt;root&lt;/code&gt;身份登录在终端，那么环境变量包含&lt;code&gt;/usr/sbin&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若使用&lt;code&gt;su -&lt;/code&gt;切换到普通用户后，环境变量&lt;strong&gt;不包含&lt;/strong&gt;&lt;code&gt;/
      
    
    </summary>
    
      <category term="Linux/Mac OS" scheme="http://kunxiang.wang/categories/Linux-Mac-OS/"/>
    
    
      <category term="Linux/Mac OS" scheme="http://kunxiang.wang/tags/Linux-Mac-OS/"/>
    
  </entry>
  
  <entry>
    <title>Java类属性和方法的可见性</title>
    <link href="http://kunxiang.wang/2018/09/06/Java%E7%B1%BB%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7/"/>
    <id>http://kunxiang.wang/2018/09/06/Java类属性和方法的可见性/</id>
    <published>2018-09-06T02:33:20.000Z</published>
    <updated>2018-09-19T12:11:57.334Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>作用域</th><th>当前类</th><th>同一package</th><th>子孙类</th><th>其他package</th></tr></thead><tbody><tr><td>public</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>protected</td><td>Y</td><td>Y</td><td>Y</td><td>N</td></tr><tr><td>friendly(default)</td><td>Y</td><td>Y</td><td>N</td><td>N</td></tr><tr><td>private</td><td>Y</td><td>N</td><td>N</td><td>N</td></tr></tbody></table><p>不写时默认为<code>friendly</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;作用域&lt;/th&gt;
&lt;th&gt;当前类&lt;/th&gt;
&lt;th&gt;同一package&lt;/th&gt;
&lt;th&gt;子孙类&lt;/th&gt;
&lt;th&gt;其他package&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;public&lt;/td
      
    
    </summary>
    
      <category term="Java" scheme="http://kunxiang.wang/categories/Java/"/>
    
    
      <category term="Java" scheme="http://kunxiang.wang/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Linux文件名查找</title>
    <link href="http://kunxiang.wang/2018/09/05/Linux%E6%96%87%E4%BB%B6%E5%90%8D%E6%9F%A5%E6%89%BE/"/>
    <id>http://kunxiang.wang/2018/09/05/Linux文件名查找/</id>
    <published>2018-09-05T11:43:59.000Z</published>
    <updated>2018-09-05T12:57:05.845Z</updated>
    
    <content type="html"><![CDATA[<p>通常情况下<code>find</code>不是很常用，因为速度较慢。一般都是先使用<code>whereis</code>或者是<code>locate</code>来检查，如果真找不到，才使用<code>find</code>来查找。因为<code>whereis</code>与<code>locate</code>是利用数据库来查找数据，所以速度相当快，而且并没有实际去查询硬盘，比较节省时间;<code>find</code>直接打查找硬盘，所以查询速度要慢。</p><a id="more"></a><h4 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h4><blockquote><p>whereis [-bmsu] 文件或者目录名</p></blockquote><p>Linux系统会将系统内的所有文件都记录在一个数据库文件里面，而当使用<code>whereis</code>或者下面的<code>locate</code>命令时，都会以此数据库文件内容为准。因此有时候还会发现使用这两个命令查找文件时，会找到已经删掉的文件。而且有可能找不到最新刚刚创建的文件。</p><h4 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h4><blockquote><p>locate [-ir] keyword</p></blockquote><p>locate使用更简单，直接在后面输入<code>文件的部分名称</code>后就能得到结果。被搜索的数据库默认是每天执行一次，该数据库的位置为<code>/var/lib/mlocate/</code>。我们可以选择手动更新数据库，直接命令行输入<code>updatedb</code> 即可。</p><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><blockquote><p>find [path] [option] [option]</p></blockquote><p>示例1：将过去24小时内有改动的文件列出<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find / -mtime 0</span><br><span class="line"></span><br><span class="line">find / -mtime 3 &lt;==表示三天前的24小时</span><br></pre></td></tr></table></figure></p><p>示例2：寻找/etc下面的文件，如果文件日期比/etc/passwd新就列出<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /etc -newer /etc/passwd</span><br></pre></td></tr></table></figure></p><p>示例3：查找/home下属于wkx的文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home -user wkx</span><br></pre></td></tr></table></figure></p><p>示例4：查找系统中不属于任何人的文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -nouser</span><br></pre></td></tr></table></figure></p><p>示例5：找出文件名为passwd的文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name passwd</span><br></pre></td></tr></table></figure></p><p>示例6：找出/var目录下文件类型为socket的文件名有哪些<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /var -<span class="built_in">type</span> s</span><br></pre></td></tr></table></figure></p><p>示例7：找出含有SGID或者SUID或者SBIT的属性文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find / -perm +7000</span><br><span class="line"><span class="comment"># 文件权限只要含有s或者t就列出</span></span><br></pre></td></tr></table></figure></p><ul><li>-perm  mode: 文件权限刚好等于mode的文件</li><li>-perm -mode: 文件权限<code>全部包括mode</code>的文件</li><li>-perm +mode: 文件权限<code>包含任意mode</code>的文件</li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通常情况下&lt;code&gt;find&lt;/code&gt;不是很常用，因为速度较慢。一般都是先使用&lt;code&gt;whereis&lt;/code&gt;或者是&lt;code&gt;locate&lt;/code&gt;来检查，如果真找不到，才使用&lt;code&gt;find&lt;/code&gt;来查找。因为&lt;code&gt;whereis&lt;/code&gt;与&lt;code&gt;locate&lt;/code&gt;是利用数据库来查找数据，所以速度相当快，而且并没有实际去查询硬盘，比较节省时间;&lt;code&gt;find&lt;/code&gt;直接打查找硬盘，所以查询速度要慢。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux/Mac OS" scheme="http://kunxiang.wang/categories/Linux-Mac-OS/"/>
    
    
      <category term="Linux/Mac OS" scheme="http://kunxiang.wang/tags/Linux-Mac-OS/"/>
    
  </entry>
  
  <entry>
    <title>Linux切割命令split</title>
    <link href="http://kunxiang.wang/2018/09/05/Linux%E5%88%87%E5%89%B2%E5%91%BD%E4%BB%A4split/"/>
    <id>http://kunxiang.wang/2018/09/05/Linux切割命令split/</id>
    <published>2018-09-05T10:06:09.000Z</published>
    <updated>2018-09-05T10:31:12.495Z</updated>
    
    <content type="html"><![CDATA[<p>如果文件太大，导致一些携带设备无法复制问题。利用<code>split</code>就可以了。它可以帮助我们将一个大文件依据文件大小或者行数来切割成小文件，快速而有效。</p><a id="more"></a><p>具体使用方法可以通过<code>man split</code>查看。</p><p>范例1：一部复仇者联盟的电影，大小为1.7G,现将他们分割为每一份512M。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">split -b 512m Avengers.mp4 AvengerSplit</span><br><span class="line"></span><br><span class="line">ll</span><br><span class="line">-rw-r--r--  1 Dhyana  staff   512M Sep  5 18:19 AvengerSplitaa</span><br><span class="line">-rw-r--r--  1 Dhyana  staff   512M Sep  5 18:19 AvengerSplitab</span><br><span class="line">-rw-r--r--  1 Dhyana  staff   512M Sep  5 18:19 AvengerSplitac</span><br><span class="line">-rw-r--r--  1 Dhyana  staff   171M Sep  5 18:19 AvengerSplitad</span><br></pre></td></tr></table></figure></p><p>如果需要将文件合并，使用命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat AvengerSplit* &gt;&gt; AvengerBack.mp4</span><br></pre></td></tr></table></figure></p><p>即可。</p><p>范例2：使用<code>ls -al /</code>输出的信息中，每10行记录成一个文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ls -al / | split -l 10 - lsroot</span><br><span class="line"></span><br><span class="line">wc -l lsroot*</span><br><span class="line">10 lsrootaa</span><br><span class="line">10 lsrootab</span><br><span class="line"> 7 lsrootac</span><br><span class="line">27 total</span><br></pre></td></tr></table></figure></p><p>重点在那个<code>-</code>。一般来讲，如果需要stdin/stdout,但是没有相应的文件，此时<code>-</code>就代表了stdin/stdout。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果文件太大，导致一些携带设备无法复制问题。利用&lt;code&gt;split&lt;/code&gt;就可以了。它可以帮助我们将一个大文件依据文件大小或者行数来切割成小文件，快速而有效。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux/Mac OS" scheme="http://kunxiang.wang/categories/Linux-Mac-OS/"/>
    
    
      <category term="Linux/Mac OS" scheme="http://kunxiang.wang/tags/Linux-Mac-OS/"/>
    
  </entry>
  
  <entry>
    <title>Linux 命令回传码与 &amp;&amp; 或 ||</title>
    <link href="http://kunxiang.wang/2018/09/05/Linux-%E5%91%BD%E4%BB%A4%E5%9B%9E%E4%BC%A0%E7%A0%81%E4%B8%8E-%E6%88%96/"/>
    <id>http://kunxiang.wang/2018/09/05/Linux-命令回传码与-或/</id>
    <published>2018-09-05T06:46:14.000Z</published>
    <updated>2018-09-05T07:12:41.791Z</updated>
    
    <content type="html"><![CDATA[<p>Linux中，若前一个命令执行的结果是正确的，那么在Linux中会回传一个<code>$?=0</code>,即 <code>echo $?</code> 显示为0。</p><table><thead><tr><th style="text-align:center">命令执行情况</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>cmd1 &amp;&amp; cmd2</code></td><td style="text-align:center">若<code>cmd1</code>执行完毕且正确执行（<code>$?=0</code>）,则执行<code>cmd2</code>;  若<code>cmd1</code>执行完毕且为错误（<code>$?≠0</code>）,则<code>cmd2</code>不被执行</td></tr><tr><td style="text-align:center"><code>cmd1 11 cmd2</code></td><td style="text-align:center">若<code>cmd1</code>执行完毕且正确执行（<code>$?=0</code>）,则<code>cmd2</code>不被执行;  若<code>cmd1</code>执行完毕且为错误（<code>$?≠0</code>）,则执行<code>cmd2</code></td></tr></tbody></table><a id="more"></a><p>示例：以ls测试<code>/tmp/wkx</code>执行后，若存在则显示”exits”,若不存在，则显示”not exits”。</p><h4 id="错误答案"><a href="#错误答案" class="headerlink" title="错误答案"></a>错误答案</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /tmp/vvv || <span class="built_in">echo</span> <span class="string">"not exits"</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">"exits"</span></span><br></pre></td></tr></table></figure><p>以上答案执行后的结果同时出现not exits和exits。具体问题可以尝试分析。</p><h4 id="正确答案"><a href="#正确答案" class="headerlink" title="正确答案"></a>正确答案</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /tmp/vvv &amp;&amp; <span class="built_in">echo</span> <span class="string">"exits"</span> || <span class="built_in">echo</span> <span class="string">"not exits"</span></span><br></pre></td></tr></table></figure><p>通过该练习，了解到由于命令时一个接着一个去执行的，因此，如果真要使用判断，那么这个<code>&amp;&amp;和||</code>的顺序就不能搞错。一般来说，假设判断公式有三个，也就是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd1 &amp;&amp; cmd2 || cmd3</span><br></pre></td></tr></table></figure></p><p>而且顺序通常不会变。因为一般来讲，cmd2和cmd3会放置肯定可以执行成功的命令，因此依据上面的逻辑分析，我们就可以知道为什么要如此放置，这是很有用的，而且考试也很常考。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux中，若前一个命令执行的结果是正确的，那么在Linux中会回传一个&lt;code&gt;$?=0&lt;/code&gt;,即 &lt;code&gt;echo $?&lt;/code&gt; 显示为0。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;命令执行情况&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;cmd1 &amp;amp;&amp;amp; cmd2&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;若&lt;code&gt;cmd1&lt;/code&gt;执行完毕且正确执行（&lt;code&gt;$?=0&lt;/code&gt;）,则执行&lt;code&gt;cmd2&lt;/code&gt;;  若&lt;code&gt;cmd1&lt;/code&gt;执行完毕且为错误（&lt;code&gt;$?≠0&lt;/code&gt;）,则&lt;code&gt;cmd2&lt;/code&gt;不被执行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;code&gt;cmd1 11 cmd2&lt;/code&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;若&lt;code&gt;cmd1&lt;/code&gt;执行完毕且正确执行（&lt;code&gt;$?=0&lt;/code&gt;）,则&lt;code&gt;cmd2&lt;/code&gt;不被执行;  若&lt;code&gt;cmd1&lt;/code&gt;执行完毕且为错误（&lt;code&gt;$?≠0&lt;/code&gt;）,则执行&lt;code&gt;cmd2&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="Linux/Mac OS" scheme="http://kunxiang.wang/categories/Linux-Mac-OS/"/>
    
    
      <category term="Linux/Mac OS" scheme="http://kunxiang.wang/tags/Linux-Mac-OS/"/>
    
  </entry>
  
  <entry>
    <title>Linux Bash 默认的组合键汇总</title>
    <link href="http://kunxiang.wang/2018/09/05/Linux-Bash-%E9%BB%98%E8%AE%A4%E7%9A%84%E7%BB%84%E5%90%88%E9%94%AE%E6%B1%87%E6%80%BB/"/>
    <id>http://kunxiang.wang/2018/09/05/Linux-Bash-默认的组合键汇总/</id>
    <published>2018-09-05T05:44:51.000Z</published>
    <updated>2018-09-05T05:51:26.843Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th style="text-align:center">案件组合</th><th style="text-align:center">执行结果</th></tr></thead><tbody><tr><td style="text-align:center">Ctrl + C</td><td style="text-align:center">终止目前命令</td></tr><tr><td style="text-align:center">Ctrl + D</td><td style="text-align:center">输入结束（EOF）,例如邮件结束的时候</td></tr><tr><td style="text-align:center">Ctrl + M</td><td style="text-align:center">就是Enter</td></tr><tr><td style="text-align:center">Ctrl + S</td><td style="text-align:center">暂停屏幕的输出</td></tr><tr><td style="text-align:center">Ctrl + Q</td><td style="text-align:center">恢复屏幕输出</td></tr><tr><td style="text-align:center">Ctrl + U</td><td style="text-align:center">在提示符下，将整行命令删除</td></tr><tr><td style="text-align:center">Ctrl + Z</td><td style="text-align:center">暂停目前的命令</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;案件组合&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;执行结果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;
      
    
    </summary>
    
      <category term="Linux/Mac OS" scheme="http://kunxiang.wang/categories/Linux-Mac-OS/"/>
    
    
      <category term="Linux/Mac OS" scheme="http://kunxiang.wang/tags/Linux-Mac-OS/"/>
    
  </entry>
  
  <entry>
    <title>Linux数据流重定向</title>
    <link href="http://kunxiang.wang/2018/09/05/Linux%E6%95%B0%E6%8D%AE%E6%B5%81%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <id>http://kunxiang.wang/2018/09/05/Linux数据流重定向/</id>
    <published>2018-09-05T03:58:25.000Z</published>
    <updated>2018-09-05T09:01:52.918Z</updated>
    
    <content type="html"><![CDATA[<p><code>标准输出(standard output)</code>指的是命令执行所回传的正确的信息，而<code>标准错误输出(standard error output)</code>可以理解为命令执行失败后，所回传的错误信息。<br>一般情况下，不管正确还是错误信息数据默认的是输出到屏幕上，所以屏幕上是很混乱的。可以通过数据流重定向将stdout和stderr分别传送到其他的文件或者设备去，而分别传送所用的特殊字符如下所示：</p><a id="more"></a><ol><li>标准输入（stdin）：代码为<code>0</code>，使用<code>&lt;</code>或者<code>&lt;&lt;</code></li><li>标准输出（stdout）：代码为<code>1</code>，使用<code>&gt;</code>或者<code>&gt;&gt;</code></li><li>标准错误输出（stderr）：代码为<code>2</code>，使用<code>&gt;</code>或者<code>&gt;&gt;</code></li></ol><h4 id="标准输出和标准错误输出"><a href="#标准输出和标准错误输出" class="headerlink" title="标准输出和标准错误输出"></a>标准输出和标准错误输出</h4><p>如果仅存在<code>&gt;</code>，则代表默认代码为1。</p><ul><li><code>1&gt;</code>:以<code>覆盖</code>的方法将<code>正确</code>的数据输出到指定的文件或者设备上</li><li><code>1&gt;&gt;</code>:以<code>累加</code>的方法将<code>正确</code>的数据输出到指定的文件或者设备上</li><li><code>2&gt;</code>:以<code>覆盖</code>的方法将<code>错误</code>的数据输出到指定的文件或者设备上</li><li><code>2&gt;&gt;</code>:以<code>累加</code>的方法将<code>错误</code>的数据输出到指定的文件或者设备上</li></ul><p>示例1：将stdout和stderr分别存到不同的文件中去。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home -name .bashrc &gt; list_right 2&gt; list_error</span><br></pre></td></tr></table></figure></p><p>示例2：将错误的数据丢弃，屏幕上显示正确的数据<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home -name .bashrc 2&gt; /dev/null</span><br></pre></td></tr></table></figure></p><p>/dev/null垃圾黑洞设备</p><p>示例3：将正确和错误的数据全部写入一个文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">find /home -name .bashrc &gt;list 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">find /home -name .bashrc &amp;&gt; list</span><br></pre></td></tr></table></figure></p><h4 id="标准输入"><a href="#标准输入" class="headerlink" title="标准输入"></a>标准输入</h4><p><code>&lt;</code>意味着将原本需要由键盘输入的数据改由文件内容来替代。</p><p>示例1：利用<code>cat</code>命令来创建一个文件的简单流程，了解一下什么是<code>键盘输入</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; catfile</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">&lt;==此处按下ctrl+c或者ctrl+d来离开</span><br></pre></td></tr></table></figure></p><p>示例2：利用<code>stdin</code>替代键盘的输入来创建新文件的流程<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; catfile &lt; ~/.bashrc</span><br><span class="line">--------------------------</span><br><span class="line">ll catfile ~/.bashrc</span><br><span class="line">-rw-r--r--  1 root root 176 Sep  5 14:10 catfile</span><br><span class="line">-rw-r--r--. 1 root root 176 Dec 29  2013 /root/.bashrc</span><br><span class="line"><span class="comment"># 注意到两个文件大小几一模一样，几乎是使用cp命令复制一份</span></span><br></pre></td></tr></table></figure></p><p>理解了<code>&lt;</code>后，再来看<code>&lt;&lt;</code>。<code>&lt;&lt;</code>：<code>代表的是结束输入的意思</code>。举例来讲，我要用cat直接将输入的信息输出到catfile中，且当由键盘输入eof时，本次输入就结束，可以按照如下方式进行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; catfile &lt;&lt; <span class="string">"eof"</span></span><br><span class="line">&gt;1</span><br><span class="line">&gt;2</span><br><span class="line">&gt;3</span><br><span class="line">&gt;eof  &lt;==输入该关键字后，立刻就结束输入而不需要输入ctrl + d/c</span><br></pre></td></tr></table></figure><h4 id="双向重定向tee"><a href="#双向重定向tee" class="headerlink" title="双向重定向tee"></a>双向重定向<code>tee</code></h4><p>tee命令实现了手动跟踪命令的输出内容，同时又将输出的内容写入文件，确保之后可以用来参考。<br>例如:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list | tee last.list | cut -d <span class="string">' '</span> -f1</span><br><span class="line"><span class="comment"># 该范例可以让我们将last的输出存一份到last.list文件中。</span></span><br><span class="line"></span><br><span class="line">ls -l / | tee -a ~/homefile | more</span><br><span class="line"><span class="comment"># tee 后直接接文件会被覆盖，如果加以 -a 这个参数则能将信息累加</span></span><br></pre></td></tr></table></figure></p><p>总结，<code>tee</code>可以让standard output转存一份到文件内并将同样的数据继续送到屏幕上去处理显示。这样，除了可以让我们同时分析一份数据并记录下来之外，还可以作为处理一份数据的中间暂存盘记录只用。</p><p>另：<code>tee</code>在很多认证考试中有考察。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;标准输出(standard output)&lt;/code&gt;指的是命令执行所回传的正确的信息，而&lt;code&gt;标准错误输出(standard error output)&lt;/code&gt;可以理解为命令执行失败后，所回传的错误信息。&lt;br&gt;一般情况下，不管正确还是错误信息数据默认的是输出到屏幕上，所以屏幕上是很混乱的。可以通过数据流重定向将stdout和stderr分别传送到其他的文件或者设备去，而分别传送所用的特殊字符如下所示：&lt;/p&gt;
    
    </summary>
    
      <category term="Linux/Mac OS" scheme="http://kunxiang.wang/categories/Linux-Mac-OS/"/>
    
    
      <category term="Linux/Mac OS" scheme="http://kunxiang.wang/tags/Linux-Mac-OS/"/>
    
  </entry>
  
  <entry>
    <title>java平台结构</title>
    <link href="http://kunxiang.wang/2018/09/04/java%E5%B9%B3%E5%8F%B0%E7%BB%93%E6%9E%84/"/>
    <id>http://kunxiang.wang/2018/09/04/java平台结构/</id>
    <published>2018-09-04T02:09:58.000Z</published>
    <updated>2018-09-04T02:29:52.474Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/2952111-f55b3fb6121e758c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="java平台结构"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2952111-f55b3fb6121e758c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;
      
    
    </summary>
    
      <category term="Java" scheme="http://kunxiang.wang/categories/Java/"/>
    
    
      <category term="Java" scheme="http://kunxiang.wang/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>java入门小知识</title>
    <link href="http://kunxiang.wang/2018/09/02/java%E5%85%A5%E9%97%A8%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    <id>http://kunxiang.wang/2018/09/02/java入门小知识/</id>
    <published>2018-09-02T15:38:12.000Z</published>
    <updated>2018-09-03T16:26:33.272Z</updated>
    
    <content type="html"><![CDATA[<ol><li>关键字<code>public</code>称为<code>访问修饰符(access modifier)</code>,这些修饰符用于控制程序的其他部分对这段代码的访问级别。</li><li>Java的命名规范为<code>大驼峰</code>命名。</li><li>源代码的文件名必须与公共类的名字相同，并用<code>.java</code>作为扩展名。</li><li>根据Java语言规范，<code>main方法必须声明为public</code>,java的main方法必须有一个外壳类。</li><li>在一个源文件中,只能有一个公有类，但可以有任意数目的非公有类。</li><li>构造器与类同名，在构造类对象时，构造器会运行，以便将实例域初始化为所需要的状态。构造器与一般的对象方法不同，构造器总是伴随着new操作符的执行被调用，而不能对一个已经存在的对象调用构造器来达到重新设置实例域的目的。<ul><li>构造器与类同名</li><li>每个类可以有一个以上的构造器</li><li>构造器可以有0个或多个参数</li><li>构造器没有返回值</li><li>构造器总是伴随着new使用</li></ul></li></ol><a id="more"></a><ol><li>main方法不对任何对象进行操作。事实上，在启动程序时还没有任何一个对象。静态的main方法将执行并创建程序所需的对象。</li><li>如果在构造器中没有显式的给域赋初始值，那么就会被自动地赋为默认值：<code>数值为0，布尔值为false，对象引用为null</code>。然而，只有缺少程序设计经验的人才会这样做。</li><li>对于<code>访问修饰符public和private</code>，标记为public的部分可以被任意的类使用，标记为private的部分只能被定义它们的类使用。如果没有指定public或者private，那么这个部分(类、方法、变量)可以被同一个包中的所有方法访问。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;关键字&lt;code&gt;public&lt;/code&gt;称为&lt;code&gt;访问修饰符(access modifier)&lt;/code&gt;,这些修饰符用于控制程序的其他部分对这段代码的访问级别。&lt;/li&gt;
&lt;li&gt;Java的命名规范为&lt;code&gt;大驼峰&lt;/code&gt;命名。&lt;/li&gt;
&lt;li&gt;源代码的文件名必须与公共类的名字相同，并用&lt;code&gt;.java&lt;/code&gt;作为扩展名。&lt;/li&gt;
&lt;li&gt;根据Java语言规范，&lt;code&gt;main方法必须声明为public&lt;/code&gt;,java的main方法必须有一个外壳类。&lt;/li&gt;
&lt;li&gt;在一个源文件中,只能有一个公有类，但可以有任意数目的非公有类。&lt;/li&gt;
&lt;li&gt;构造器与类同名，在构造类对象时，构造器会运行，以便将实例域初始化为所需要的状态。构造器与一般的对象方法不同，构造器总是伴随着new操作符的执行被调用，而不能对一个已经存在的对象调用构造器来达到重新设置实例域的目的。&lt;ul&gt;
&lt;li&gt;构造器与类同名&lt;/li&gt;
&lt;li&gt;每个类可以有一个以上的构造器&lt;/li&gt;
&lt;li&gt;构造器可以有0个或多个参数&lt;/li&gt;
&lt;li&gt;构造器没有返回值&lt;/li&gt;
&lt;li&gt;构造器总是伴随着new使用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java" scheme="http://kunxiang.wang/categories/Java/"/>
    
    
      <category term="Java" scheme="http://kunxiang.wang/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Jet Brains(IDE)常用快捷键</title>
    <link href="http://kunxiang.wang/2018/09/02/Jet-Brains-IDE-%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://kunxiang.wang/2018/09/02/Jet-Brains-IDE-常用快捷键/</id>
    <published>2018-09-02T04:32:47.000Z</published>
    <updated>2018-09-08T06:18:38.732Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Mac键盘符号和修饰键说明"><a href="#Mac键盘符号和修饰键说明" class="headerlink" title="Mac键盘符号和修饰键说明"></a>Mac键盘符号和修饰键说明</h4><ul><li>⌘ Command</li><li>⇧ Shift</li><li>⌥ Option</li><li>⌃ Control</li><li>↩︎ Return/Enter</li><li>⌫ Delete</li><li>⌦ 向前删除键（Fn+Delete）</li><li>↑ 上箭头</li><li>↓ 下箭头</li><li>← 左箭头</li><li>→ 右箭头</li><li>⇞ Page Up（Fn+↑）</li><li>⇟ Page Down（Fn+↓）</li><li>Home Fn + ←</li><li>End Fn + →</li><li>⇥ 右制表符（Tab键）</li><li>⇤ 左制表符（Shift+Tab）</li><li>⎋ Escape (Esc)</li></ul><a id="more"></a><h4 id="Editing（编辑）"><a href="#Editing（编辑）" class="headerlink" title="Editing（编辑）"></a>Editing（编辑）</h4><ul><li>⌘⌥ + ← 或 → 光标跳到上一个文件编辑处，很重要！！！！！！！！！！！</li><li>⌃Space 基本的代码补全（补全任何类、方法、变量）</li><li>⌃⇧Space 智能代码补全（过滤器方法列表和变量的预期类型）</li><li>⌘⇧↩ 自动结束代码，行末自动添加分号</li><li>⌘P 显示方法的参数信息</li><li>⌃J, Mid. button click 快速查看文档</li><li>⇧F1 查看外部文档（在某些代码上会触发打开浏览器显示相关文档）</li><li>⌘+鼠标放在代码上 显示代码简要信息</li><li>⌘F1 在错误或警告处显示具体描述信息</li><li>⌘N, ⌃↩, ⌃N 生成代码（getter、setter、构造函数、hashCode/equals,toString）</li><li>⌃O 覆盖方法（重写父类方法）</li><li>⌃I 实现方法（实现接口中的方法）</li><li>⌘⌥T 包围代码（使用if..else, try..catch, for, synchronized等包围选中的代码）</li><li>⌘/ 注释/取消注释与行注释</li><li>⌘⌥/ 注释/取消注释与块注释</li><li>⌥↑ 连续选中代码块</li><li>⌥↓ 减少当前选中的代码块</li><li>⌃⇧Q 显示上下文信息</li><li>⌥↩ 显示意向动作和快速修复代码</li><li>⌘⌥L 格式化代码</li><li>⌃⌥O 优化import</li><li>⌃⌥I 自动缩进线</li><li>⇥ / ⇧⇥ 缩进代码 / 反缩进代码</li><li>⌘X 剪切当前行或选定的块到剪贴板</li><li>⌘C 复制当前行或选定的块到剪贴板</li><li>⌘V 从剪贴板粘贴</li><li>⌘⇧V 从最近的缓冲区粘贴</li><li>⌘D 复制当前行或选定的块</li><li>⌘⌫ 删除当前行或选定的块的行</li><li>⌃⇧J 智能的将代码拼接成一行</li><li>⌘↩ 智能的拆分拼接的行</li><li>⇧↩ 开始新的一行</li><li>⌘⇧U 大小写切换</li><li>⌘⇧] / ⌘⇧[ 选择直到代码块结束/开始</li><li>⌥⌦ 删除到单词的末尾（⌦键为Fn+Delete）</li><li>⌥⌫ 删除到单词的开头</li><li>⌘+ / ⌘- 展开 / 折叠代码块</li><li>⌘⇧+ 展开所以代码块</li><li>⌘⇧- 折叠所有代码块</li><li>⌘W 关闭活动的编辑器选项卡</li></ul><h4 id="Search-Replace（查询-替换）"><a href="#Search-Replace（查询-替换）" class="headerlink" title="Search/Replace（查询/替换）"></a>Search/Replace（查询/替换）</h4><ul><li>Double ⇧ 查询任何东西</li><li>⌘F 文件内查找</li><li>⌘G 查找模式下，向下查找</li><li>⌘⇧G 查找模式下，向上查找</li><li>⌘R 文件内替换</li><li>⌘⇧F 全局查找（根据路径）</li><li>⌘⇧R 全局替换（根据路径）</li><li>⌘⇧S 查询结构（Ultimate Edition 版专用，需要在Keymap中设置）</li><li>⌘⇧M 替换结构（Ultimate Edition 版专用，需要在Keymap中设置）</li></ul><h4 id="Usage-Search（使用查询）"><a href="#Usage-Search（使用查询）" class="headerlink" title="Usage Search（使用查询）"></a>Usage Search（使用查询）</h4><ul><li>⌥F7 / ⌘F7 在文件中查找用法 / 在类中查找用法</li><li>⌘⇧F7 在文件中突出显示的用法</li><li>⌘⌥F7 显示用法</li></ul><h4 id="Compile-and-Run（编译和运行）"><a href="#Compile-and-Run（编译和运行）" class="headerlink" title="Compile and Run（编译和运行）"></a>Compile and Run（编译和运行）</h4><ul><li>⌘F9 编译Project</li><li>⌘⇧F9 编译选择的文件、包或模块</li><li>⌃⌥R 弹出 Run 的可选择菜单</li><li>⌃⌥D 弹出 Debug 的可选择菜单</li><li>⌃R 运行</li><li>⌃D 调试</li><li>⌃⇧R, ⌃⇧D 从编辑器运行上下文环境配置</li></ul><h4 id="Debugging（调试）"><a href="#Debugging（调试）" class="headerlink" title="Debugging（调试）"></a>Debugging（调试）</h4><ul><li>F8 进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</li><li>F7 进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中</li><li>⇧F7 智能步入，断点所在行上有多个方法调用，会弹出进入哪个方法</li><li>⇧F8 跳出</li><li>⌥F9 运行到光标处，如果光标前有其他断点会进入到该断点</li><li>⌥F8 计算表达式（可以更改变量值使其生效）</li><li>⌘⌥R 恢复程序运行，如果该断点下面代码还有断点则停在下一个断点上</li><li>⌘F8 切换断点（若光标当前行有断点则取消断点，没有则加上断点）</li><li>⌘⇧F8 查看断点信息</li></ul><h4 id="Navigation（导航）"><a href="#Navigation（导航）" class="headerlink" title="Navigation（导航）"></a>Navigation（导航）</h4><ul><li>⌘O 查找类文件</li><li>⌘⇧O 查找所有类型文件、打开文件、打开目录，打开目录需要在输入的内容前面或后面加一个反斜杠/</li><li>⌘⌥O 前往指定的变量 / 方法</li><li>⌃← / ⌃→ 左右切换打开的编辑tab页</li><li>F12 返回到前一个工具窗口</li><li>⎋ 从工具窗口进入代码文件窗口</li><li>⇧⎋ 隐藏当前或最后一个活动的窗口，且光标进入代码文件窗口</li><li>⌘⇧F4 关闭活动run/messages/find/… tab</li><li>⌘L 在当前文件跳转到某一行的指定处</li><li>⌘E 显示最近打开的文件记录列表</li><li>⌘⌥← / ⌘⌥→ 退回 / 前进到上一个操作的地方</li><li>⌘⇧⌫ 跳转到最后一个编辑的地方</li><li>⌥F1 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择(如在代码编辑窗口可以选择显示该文件的Finder)</li><li>⌘B / ⌘ 鼠标点击 进入光标所在的方法/变量的接口或是定义处</li><li>⌘⌥B 跳转到实现处，在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口</li><li>⌥ Space, ⌘Y 快速打开光标所在方法、类的定义</li><li>⌃⇧B 跳转到类型声明处</li><li>⌘U 前往当前光标所在方法的父类的方法 / 接口定义</li><li>⌃↓ / ⌃↑ 当前光标跳转到当前文件的前一个/后一个方法名位置</li><li>⌘] / ⌘[ 移动光标到当前所在代码的花括号开始/结束位置</li><li>⌘F12 弹出当前文件结构层，可以在弹出的层上直接输入进行筛选（可用于搜索类中的方法）</li><li>⌃H 显示当前类的层次结构</li><li>⌘⇧H 显示方法层次结构</li><li>⌃⌥H 显示调用层次结构</li><li>F2 / ⇧F2 跳转到下一个/上一个突出错误或警告的位置</li><li>F4 / ⌘↓ 编辑/查看代码源</li><li>⌥ Home 显示到当前文件的导航条</li><li>F3选中文件/文件夹/代码行，添加/取消书签</li><li>⌥F3 选中文件/文件夹/代码行，使用助记符添加/取消书签</li><li>⌃0…⌃9 定位到对应数值的书签位置</li><li>⌘F3 显示所有书签</li></ul><h4 id="Refactoring（重构）"><a href="#Refactoring（重构）" class="headerlink" title="Refactoring（重构）"></a>Refactoring（重构）</h4><ul><li>F5 复制文件到指定目录</li><li>F6 移动文件到指定目录</li><li>⌘⌫ 在文件上为安全删除文件，弹出确认框</li><li>⇧F6 重命名文件</li><li>⌘F6 更改签名</li><li>⌘⌥N 一致性</li><li>⌘⌥M 将选中的代码提取为方法</li><li>⌘⌥V 提取变量</li><li>⌘⌥F 提取字段</li><li>⌘⌥C 提取常量</li><li>⌘⌥P 提取参数</li></ul><h4 id="VCS-Local-History（版本控制-本地历史记录）"><a href="#VCS-Local-History（版本控制-本地历史记录）" class="headerlink" title="VCS/Local History（版本控制/本地历史记录）"></a>VCS/Local History（版本控制/本地历史记录）</h4><ul><li>⌘K 提交代码到版本控制器</li><li>⌘T 从版本控制器更新代码</li><li>⌥⇧C 查看最近的变更记录</li><li>⌃C 快速弹出版本控制器操作面板</li></ul><h4 id="Live-Templates（动态代码模板）"><a href="#Live-Templates（动态代码模板）" class="headerlink" title="Live Templates（动态代码模板）"></a>Live Templates（动态代码模板）</h4><ul><li>⌘⌥J 弹出模板选择窗口，将选定的代码使用动态模板包住</li><li>⌘J 插入自定义动态代码模板</li></ul><h4 id="General（通用）"><a href="#General（通用）" class="headerlink" title="General（通用）"></a>General（通用）</h4><ul><li>⌘1…⌘9 打开相应编号的工具窗口</li><li>⌘S 保存所有</li><li>⌘⌥Y 同步、刷新</li><li>⌃⌘F 切换全屏模式</li><li>⌘⇧F12 切换最大化编辑器</li><li>⌥⇧F 添加到收藏夹</li><li>⌥⇧I 检查当前文件与当前的配置文件</li><li>⌘, 打开IDEA系统设置</li><li>⌘; 打开项目结构对话框</li><li>⇧⌘A 查找动作（可设置相关选项）</li><li>⌃⇥ 编辑窗口标签和工具窗口之间切换（如果在切换的过程加按上delete，则是关闭对应选中的窗口）</li></ul><p>Other（一些官方文档上没有体现的快捷键）</p><ul><li>⌘⇧8 竖编辑模式</li></ul><p>导航</p><ul><li>⌘O 查找类文件 Ctrl + N</li><li>⌘⌥O 前往指定的变量 / 方法 Ctrl + Shift + Alt + N</li><li>⌃← / ⌃→ 左右切换打开的编辑tab页Alt←/Alt→</li><li>⎋ 从工具窗口进入代码文件窗口 ESC</li><li>⌘L 在当前文件跳转到某一行的指定处 Ctrl + G</li><li>⌘E 显示最近打开的文件记录列表 Ctrl + E</li><li>⌘⌥←/ ⌘⌥→退回 / 前进到上一个操作的地方 Ctrl + Alt + ←/Ctrl + Alt + →</li><li>⌘⇧⌫ 跳转到最后一个编辑的地方</li><li>⌃H 显示当前类的层次结构Ctrl + H</li><li>⌘⇧H 显示方法层次结构</li><li>⌃⌥H 显示调用层次结构</li><li>F4 /⌘↓ 编辑/查看代码源</li><li>⌘⌥U 显示类UML图</li><li>⌃J 查看注释</li></ul><p>编辑</p><ul><li>⌥⌦ 删除到单词的末尾（⌦键为Fn+Delete）</li><li>⌥⌫ 删除到单词的开头</li><li>⌘+ /⌘- 展开 / 折叠代码块</li><li>⌘F1 在错误或警告处显示具体描述信息</li><li>⌘⌥L 格式化代码</li><li>⌃⌥O 优化import</li><li>⇧↩ 开始新的一行</li><li>⌘⇧↩ 自动结束代码，行末自动添加分号</li><li>⌃I 实现方法（实现接口中的方法）</li><li>⇧F6 重命名文件或者变量</li><li>⌘N,⌃↩,⌃N 生成代码（getter、setter、构造函数、hashCode/equals,toString）</li><li>⌘P 显示方法的参数信息</li></ul><p>查找</p><ul><li>Double⇧ 查找任何东西</li><li>⌘⇧F 全局查找（根据路径）</li><li>⌘F 文件内查找</li><li>⌘G 查找模式下，向下查找</li><li>⌘⇧G 查找模式下，向上查找</li></ul><p>导航</p><ul><li>⌘⌥B 跳转到接口的实现</li><li>⌘U 查看接口定义</li><li>⌘⌥← /⌘⌥→ 退回 / 前进到上一个操作的地方</li><li>⌘B /⌘ 鼠标点击 进入光标所在的方法/变量的接口或是定义处</li><li>⌃⇧B 跳转到类型声明处</li><li>⌥ Space,⌘Y 快速打开光标所在方法、类的定义</li><li>⌘O 查找类文件</li><li>⌘⇧O 查找所有类型文件、打开文件、打开目录，打开目录需要在输入的内容前面或后面加一个反斜杠/</li><li>F12 返回到前一个工具窗口</li><li>⎋ 从工具窗口进入代码文件窗口</li><li>⇧⎋ 隐藏当前或最后一个活动的窗口，且光标进入代码文件窗口</li><li>F3选中文件/文件夹/代码行，添加/取消书签</li><li>⌥F3 选中文件/文件夹/代码行，使用助记符添加/取消书签</li><li>⌃0…⌃9 定位到对应数值的书签位置</li><li>⌘F3 显示所有书签</li><li>⌥F1 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择(如在代码编辑窗口可以选择显示该文件的Finder)</li><li>⌘F12 弹出当前文件结构层，可以在弹出的层上直接输入进行筛选（可用于搜索类中的方法）</li></ul><p>通用</p><ul><li>⌃⌘F 切换全屏模式</li></ul><p>自动代码</p><p>⚠注：⌘+J可以调出所有提供的代码补全↩即可，下面仅列举常用的几个</p><p>原文地址：<a href="https://linmi.cc/836" target="_blank" rel="noopener">https://linmi.cc/836</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Mac键盘符号和修饰键说明&quot;&gt;&lt;a href=&quot;#Mac键盘符号和修饰键说明&quot; class=&quot;headerlink&quot; title=&quot;Mac键盘符号和修饰键说明&quot;&gt;&lt;/a&gt;Mac键盘符号和修饰键说明&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;⌘ Command&lt;/li&gt;
&lt;li&gt;⇧ Shift&lt;/li&gt;
&lt;li&gt;⌥ Option&lt;/li&gt;
&lt;li&gt;⌃ Control&lt;/li&gt;
&lt;li&gt;↩︎ Return/Enter&lt;/li&gt;
&lt;li&gt;⌫ Delete&lt;/li&gt;
&lt;li&gt;⌦ 向前删除键（Fn+Delete）&lt;/li&gt;
&lt;li&gt;↑ 上箭头&lt;/li&gt;
&lt;li&gt;↓ 下箭头&lt;/li&gt;
&lt;li&gt;← 左箭头&lt;/li&gt;
&lt;li&gt;→ 右箭头&lt;/li&gt;
&lt;li&gt;⇞ Page Up（Fn+↑）&lt;/li&gt;
&lt;li&gt;⇟ Page Down（Fn+↓）&lt;/li&gt;
&lt;li&gt;Home Fn + ←&lt;/li&gt;
&lt;li&gt;End Fn + →&lt;/li&gt;
&lt;li&gt;⇥ 右制表符（Tab键）&lt;/li&gt;
&lt;li&gt;⇤ 左制表符（Shift+Tab）&lt;/li&gt;
&lt;li&gt;⎋ Escape (Esc)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="IDE" scheme="http://kunxiang.wang/categories/IDE/"/>
    
    
      <category term="IDE" scheme="http://kunxiang.wang/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>子网掩码的作用(详细介绍)</title>
    <link href="http://kunxiang.wang/2018/09/01/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E7%9A%84%E4%BD%9C%E7%94%A8-%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/"/>
    <id>http://kunxiang.wang/2018/09/01/子网掩码的作用-详细介绍/</id>
    <published>2018-09-01T05:18:00.000Z</published>
    <updated>2018-09-21T08:11:52.911Z</updated>
    
    <content type="html"><![CDATA[<p>子网掩码的作用是什么?掩码用于说明子网域在一个IP地址中的位置。子网掩码主要用于说明如何进行子网的划分。掩码是由32位组成的，很像IP地址。对于三类IP地址来说，有一些自然的或缺省的固定掩码。下面详细来看看吧。</p><p>IP地址和网络掩码为了简便起见，通常会被写成<code>无类型域间选路(Classless-Inter-Domain-Routing, CIDR)</code>。在这种形势下，一个完整的IP地址后面会有一个左斜杠<code>/</code>，以及一个用来表示IP地址中<code>网路部分位数</code>的数字。举例说明，IP地址<code>10.10.1.22</code>和网络掩码<code>255.255.0.0</code>，在CIDR表示法下就会被写成<code>10.10.1.22/16</code>的形式。</p><a id="more"></a><p><img src="http://www.dngsw.cn/uploads/allimg/150823/2-150R316262Ta.jpg" alt=""></p><h4 id="子网掩码的作用一-分割网络"><a href="#子网掩码的作用一-分割网络" class="headerlink" title="子网掩码的作用一: 分割网络"></a>子网掩码的作用一: 分割网络</h4><p>但由于计算机数量不断增加，人们发展IP地址数量很快要不够用了，而有类IP的IP分类方法会造成许多IP地址的浪费，如某公司申请到一个A类IP地址范围，其有效IP数量可达2^24-2，即1600万之多，而公司中不可能有什么多电脑。于是人们想把着能不能把一个大的网络分割为若干个小网络。那如何来区别不同IP地址是否在同一网络呢?这里就需要使用子网掩码了，子网掩码与IP地址一样也是一个32位的二进制数，每个IP都规定一定子网掩码，把IP地址与子网掩码进行二进位的<code>与</code>，得到的就是网络号，如果网络号相同就表示二台电脑在同一网段，可以直接通讯，不需要路由器帮忙。这时的IP地址由于需要靠子网掩码来计算网络号，已经不再存在A、B、C类网络的概念了，这时的网络叫无类网络。我们也可以这样理解，需要靠IP地址的第一个字节数据的范围来区别网络号的称有类网络，靠子网掩码来计算得到网络号的叫无类网络。目前我的WINXP和LINUX在指定IP的同时都必须要指定一个子网掩码，所以都属于有类网络。</p><p><img src="http://www.dngsw.cn/uploads/allimg/150823/2-150R3162A3b0.jpg" alt=""></p><h4 id="子网掩码的作用二-计算网络号"><a href="#子网掩码的作用二-计算网络号" class="headerlink" title="子网掩码的作用二: 计算网络号"></a>子网掩码的作用二: 计算网络号</h4><ul><li><p>例1：A电脑IP地址为192.168.1.1，子网掩码为255.255.255.0;B电脑IP地址为192.168.1.2，子网掩码为255.255.225.0。大家都知道这二台电脑在同一网段，相互能PING通。</p></li><li><p>例2：A电脑的IP地址为192.168.1.1，子网掩码为255.255.255.0;B电脑的IP地址为192.168.2.1，子网掩码为255.255.0.0。大家分析一下二台电脑能相互PING通吗?</p></li></ul><p><img src="http://www.dngsw.cn/uploads/allimg/150823/2-150R3162G3R1.jpg" alt=""></p><p>分析：这个问题需要大家理解子网掩码在网络通讯时的作用。不能简单的认为A电脑处在192.168.1.0网段，B电脑处在192.168.0.0网段，所以不能PING通。正确的分析应该如下：</p><ul><li><p>⑴　每台电脑事先会把自己IP和自己的子网掩码进行“与”操作，得到自己的网段号，如A电脑处在192.168.1.0网段，B电脑处在192.168.0.0网段。</p></li><li><p>⑵　B电脑向A电脑发数据包时，会把A电脑的IP与B电脑的子网掩码进行“与”操作，得到网络号是192.168.0.0，B电脑会认为A电脑与自己在同一网段，所以数据包会顺利发出。</p></li><li><p>⑶　A电脑由于与B电脑在同一网段，肯定能收到B电脑发出的数据包，由于PING操作要求A电脑回应一个响应包。这样A电脑会把B电脑的IP与A电脑的子网掩码进行“与”操作，得到网络号192.168.2.0，A电脑发现网络号与自己所处的192.168.1.0不在同一网段，由于A电脑目前没有设置默认网关，所以对该数据包将进行丢弃操作，结果B电脑当然就无法收到A电脑的回应包，所以B电脑上会显示“Request timed out”，即网络超时。</p></li><li><p>⑷　如果在A电脑上去PING　B电脑，根据前面的分析，A电脑会认为B电脑与A电脑不在网段，而A电脑又没有设置默认网关，所以会显示“Destination host unreachable”，即目标主机不可达。</p></li></ul><p><a href="http://www.dngsw.cn/news/jq-1751.html" target="_blank" rel="noopener">转载：子网掩码的作用(详细介绍)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;子网掩码的作用是什么?掩码用于说明子网域在一个IP地址中的位置。子网掩码主要用于说明如何进行子网的划分。掩码是由32位组成的，很像IP地址。对于三类IP地址来说，有一些自然的或缺省的固定掩码。下面详细来看看吧。&lt;/p&gt;
&lt;p&gt;IP地址和网络掩码为了简便起见，通常会被写成&lt;code&gt;无类型域间选路(Classless-Inter-Domain-Routing, CIDR)&lt;/code&gt;。在这种形势下，一个完整的IP地址后面会有一个左斜杠&lt;code&gt;/&lt;/code&gt;，以及一个用来表示IP地址中&lt;code&gt;网路部分位数&lt;/code&gt;的数字。举例说明，IP地址&lt;code&gt;10.10.1.22&lt;/code&gt;和网络掩码&lt;code&gt;255.255.0.0&lt;/code&gt;，在CIDR表示法下就会被写成&lt;code&gt;10.10.1.22/16&lt;/code&gt;的形式。&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="http://kunxiang.wang/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://kunxiang.wang/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络之子网(掩码)</title>
    <link href="http://kunxiang.wang/2018/08/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B9%8B%E5%AD%90%E7%BD%91-%E6%8E%A9%E7%A0%81/"/>
    <id>http://kunxiang.wang/2018/08/31/计算机网络之子网-掩码/</id>
    <published>2018-08-31T03:31:28.000Z</published>
    <updated>2018-08-31T16:37:28.307Z</updated>
    
    <content type="html"><![CDATA[<p>子网掩码是用来判断任意两台计算机的IP地址是否属于同一子网络的根据。</p><p>最为简单的理解就是两台计算机各自的IP地址与子网掩码进行AND运算后，如果得出的结果是相同的，则说明这两台计算机是处于同一个子网络上的，可以进行直接的通讯。</p><p>假设IP编址为某个子网分配一个地位：<code>223.1.1.0/24</code>,其中的<code>/24</code>计法，成为子网掩码（network mask），指示了<code>32位比特中的最左侧24比特定义了子网地址</code>。</p><p>子网掩码通常有以下2种格式的表示方法：</p><ol><li>通过与IP地址格式相同的点分十进制表示<br>如：255.0.0.0 或255.255.255.128</li><li>在IP地址后加上”/“符号以及1-32的数字，其中1-32的数字表示子网掩码中网络标识位的长度<br>如：192.168.1.1/24 的子网掩码也可以表示为255.255.255.0<br>子网掩码一般为255.255.255.0</li></ol><p>子网掩码——屏蔽一个IP地址的网络部分的“全1”比特模式。对于A类地址来说，默认的子网掩码是255.0.0.0；对于B类地址来说默认的子网掩码是255.255.0.0；对于C类地址来说默认的子网掩码是255.255.255.0。</p><p>子网掩码的设定必须遵循一定的规则。与二进制IP地址相同，子网掩码由1和0组成，且1和0分别连续。子网掩码的长度也是32位，左边是网络位，用二进制数字“1”表示，1的数目等于网络位的长度；右边是主机位，用二进制数字“0”表示，0的数目等于主机位的长度。这样做的目的是为了让掩码与ip地址做按位与运算时用0遮住原主机数，而不改变原网络段数字，而且很容易通过0的位数确定子网的主机数（主机号全为1时表示该网络广播地址，全为0时表示该网络的网络号，这是两个特殊地址）。只有通过子网掩码，才能表明一台主机所在的子网与其他子网的关系，使网络正常工作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;子网掩码是用来判断任意两台计算机的IP地址是否属于同一子网络的根据。&lt;/p&gt;
&lt;p&gt;最为简单的理解就是两台计算机各自的IP地址与子网掩码进行AND运算后，如果得出的结果是相同的，则说明这两台计算机是处于同一个子网络上的，可以进行直接的通讯。&lt;/p&gt;
&lt;p&gt;假设IP编址为某个
      
    
    </summary>
    
      <category term="网络" scheme="http://kunxiang.wang/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://kunxiang.wang/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令英文缩写</title>
    <link href="http://kunxiang.wang/2018/08/30/Linux%E5%91%BD%E4%BB%A4%E8%8B%B1%E6%96%87%E7%BC%A9%E5%86%99/"/>
    <id>http://kunxiang.wang/2018/08/30/Linux命令英文缩写/</id>
    <published>2018-08-30T01:35:47.000Z</published>
    <updated>2018-09-04T01:17:52.243Z</updated>
    
    <content type="html"><![CDATA[<h2 id="命令缩写"><a href="#命令缩写" class="headerlink" title="命令缩写"></a>命令缩写</h2><ul><li>ls: list(列出目录内容)</li><li>cd: Change Directory（改变目录）</li><li>su: switch user 切换用户</li><li>rpm: redhat package manager 红帽子打包管理器</li><li>pwd: print work directory 打印当前目录 显示出当前工作目录的绝对路径</li><li>ps:  process status(进程状态，类似于windows的任务管理器) 常用参数: －auxf <code>ps auxf</code> 显示进程状态</li><li>df:  disk free 其功能是显示磁盘可用空间数目信息及空间结点信息。换句话说，就是报告在任何安装的设备或目录中，还剩多少自由的空间。</li><li>rpm:  即RedHat Package Management，是RedHat的发明之一</li><li>rmdir: Remove Directory（删除目录）</li><li>rm: Remove（删除目录或文件）</li><li>cat:  concatenate连锁 <code>cat file1 file2 &gt;&gt; file3</code>把文件1和文件2的内容联合起来放到file3中</li><li>insmod:  install module,载入模块</li><li>ln -s :  link -soft 创建一个软链接，相当于创建一个快捷方式</li><li>mkdir: Make Directory</li><li>ps: Process Status</li><li>uname: Unix name</li><li>tar: Tape Archive</li><li>grep: General Regular Expression Print</li></ul><a id="more"></a><h2 id="目录名"><a href="#目录名" class="headerlink" title="目录名"></a>目录名</h2><ul><li>/boot: 顾名思义</li><li>/root : 同上</li><li>/lost+found: 同上</li><li>/run: 同上</li><li>/home: 同上</li><li>/etc: ETCetera</li><li>/bin: BINaries</li><li>/dev: DEVices</li><li>/lib: LIBraries</li><li>/mnt: MouNT</li><li>/proc: PROCesses</li><li>/tmp: TeMPorary</li><li>/var: VARiable</li><li>/srv: SeRVices</li><li>/opt: OPTion</li><li>/sbin: Super BINaries（又作Superuser BINaries）</li><li>/sys: SYStem</li><li>/usr: 一鼓而作Unix System Resources，再而作Unix Software Resources,三而作Unix Shared Resources（这个很重要，很多人会认为这个是user）</li></ul><h2 id="软件及软件包管理"><a href="#软件及软件包管理" class="headerlink" title="软件及软件包管理"></a>软件及软件包管理</h2><ul><li>man – MANual</li><li>apt – Advanced Packaging Tool</li><li>dpkg – Debian PacKaGe</li><li>yum – Yellow dog Updater, Modified</li><li>rpm – RPM Package Manager（又作Redhat Package Manager，不过我比较喜欢前者，因为魔性）</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>SELinux – Security Enhanced Linux, 安全强化的Linux</li><li>daemon – Disk And Execution MONitor</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;命令缩写&quot;&gt;&lt;a href=&quot;#命令缩写&quot; class=&quot;headerlink&quot; title=&quot;命令缩写&quot;&gt;&lt;/a&gt;命令缩写&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;ls: list(列出目录内容)&lt;/li&gt;
&lt;li&gt;cd: Change Directory（改变目录）&lt;/li&gt;
&lt;li&gt;su: switch user 切换用户&lt;/li&gt;
&lt;li&gt;rpm: redhat package manager 红帽子打包管理器&lt;/li&gt;
&lt;li&gt;pwd: print work directory 打印当前目录 显示出当前工作目录的绝对路径&lt;/li&gt;
&lt;li&gt;ps:  process status(进程状态，类似于windows的任务管理器) 常用参数: －auxf &lt;code&gt;ps auxf&lt;/code&gt; 显示进程状态&lt;/li&gt;
&lt;li&gt;df:  disk free 其功能是显示磁盘可用空间数目信息及空间结点信息。换句话说，就是报告在任何安装的设备或目录中，还剩多少自由的空间。&lt;/li&gt;
&lt;li&gt;rpm:  即RedHat Package Management，是RedHat的发明之一&lt;/li&gt;
&lt;li&gt;rmdir: Remove Directory（删除目录）&lt;/li&gt;
&lt;li&gt;rm: Remove（删除目录或文件）&lt;/li&gt;
&lt;li&gt;cat:  concatenate连锁 &lt;code&gt;cat file1 file2 &amp;gt;&amp;gt; file3&lt;/code&gt;把文件1和文件2的内容联合起来放到file3中&lt;/li&gt;
&lt;li&gt;insmod:  install module,载入模块&lt;/li&gt;
&lt;li&gt;ln -s :  link -soft 创建一个软链接，相当于创建一个快捷方式&lt;/li&gt;
&lt;li&gt;mkdir: Make Directory&lt;/li&gt;
&lt;li&gt;ps: Process Status&lt;/li&gt;
&lt;li&gt;uname: Unix name&lt;/li&gt;
&lt;li&gt;tar: Tape Archive&lt;/li&gt;
&lt;li&gt;grep: General Regular Expression Print&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux/Mac OS" scheme="http://kunxiang.wang/categories/Linux-Mac-OS/"/>
    
    
      <category term="Linux/Mac OS" scheme="http://kunxiang.wang/tags/Linux-Mac-OS/"/>
    
  </entry>
  
  <entry>
    <title>SQL语法练习(一)</title>
    <link href="http://kunxiang.wang/2018/08/28/SQL%E8%AF%AD%E6%B3%95%E7%BB%83%E4%B9%A0-%E4%B8%80/"/>
    <id>http://kunxiang.wang/2018/08/28/SQL语法练习-一/</id>
    <published>2018-08-27T16:32:31.000Z</published>
    <updated>2018-08-28T08:52:37.974Z</updated>
    
    <content type="html"><![CDATA[<ol><li>查询学习课程”python”比课程 “java” 成绩高的学生的学号;<br>– 思路：<br>– 获取所有有python课程的人（学号，成绩） - 临时表<br>– 获取所有有java课程的人（学号，成绩） - 临时表<br>– 根据学号连接两个临时表：<br>– 学号 | 物理成绩 | 生物成绩<br>– 然后再进行筛选<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> A.s_id <span class="keyword">from</span></span><br><span class="line">(<span class="keyword">select</span> s_id, <span class="keyword">num</span> <span class="keyword">as</span> python <span class="keyword">from</span> score <span class="keyword">left</span> <span class="keyword">join</span> course <span class="keyword">on</span> score.c_id = course.c_id <span class="keyword">where</span> course.c_name = <span class="string">'python'</span>) <span class="keyword">as</span> A</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span></span><br><span class="line">(<span class="keyword">select</span> s_id, <span class="keyword">num</span> <span class="keyword">as</span> <span class="keyword">java</span>   <span class="keyword">from</span> score <span class="keyword">left</span> <span class="keyword">join</span> course <span class="keyword">on</span> score.c_id = course.c_id <span class="keyword">where</span> course.c_name = <span class="string">'java'</span>)   <span class="keyword">as</span> B</span><br><span class="line"><span class="keyword">on</span> A.s_id = B.s_id <span class="keyword">where</span> A.python &gt; B.java;</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><ol><li><p>查询平均成绩大于65分的同学的姓名和平均成绩(保留两位小数);</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student.s_name <span class="keyword">as</span> <span class="keyword">names</span>, <span class="keyword">round</span>(<span class="keyword">AVG</span>(score.num), <span class="number">2</span>) <span class="keyword">as</span> average</span><br><span class="line"><span class="keyword">FROM</span> student, score</span><br><span class="line"><span class="keyword">WHERE</span> student.s_id = score.s_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> student.s_name</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">AVG</span>(score.num) &gt; <span class="number">65</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询所有同学的姓名、选课数、总成绩</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> student.s_name, <span class="keyword">COUNT</span>(score.s_id) <span class="keyword">as</span> course_num, <span class="keyword">SUM</span>(score.num) <span class="keyword">as</span> total_grades</span><br><span class="line"><span class="keyword">FROM</span> student, score</span><br><span class="line"><span class="keyword">WHERE</span> student.s_id = score.s_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> student.s_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> student.s_name;</span><br></pre></td></tr></table></figure></li><li><p>查询所有的课程的名称以及对应的任课老师姓名;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> course.c_name, teacher.t_name  </span><br><span class="line"><span class="keyword">FROM</span> course, teacher</span><br><span class="line"><span class="keyword">WHERE</span> course.t_id = teacher.t_id;</span><br></pre></td></tr></table></figure></li><li><p>查询没学过“alex”老师课的同学的姓名;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s_name</span><br><span class="line"><span class="keyword">FROM</span> student</span><br><span class="line"><span class="keyword">WHERE</span> student.s_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> score.s_id</span><br><span class="line"><span class="keyword">FROM</span> score, course, teacher</span><br><span class="line"><span class="keyword">WHERE</span> course.c_id = score.c_id <span class="keyword">AND</span> teacher.t_id = course.t_id <span class="keyword">AND</span> teacher.t_name = <span class="string">'alex'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>查询学过’python’并且也学过编号’java’课程的同学的姓名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s_name <span class="keyword">FROM</span></span><br><span class="line">(<span class="keyword">SELECT</span> score.s_id <span class="keyword">as</span> <span class="keyword">sid</span>, score.c_id <span class="keyword">as</span> cid</span><br><span class="line"> <span class="keyword">FROM</span> score, course</span><br><span class="line"> <span class="keyword">WHERE</span> score.c_id = course.c_id <span class="keyword">AND</span> (course.c_name = <span class="string">'python'</span> <span class="keyword">OR</span> course.c_name = <span class="string">'java'</span>)) <span class="keyword">as</span> B</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> student <span class="keyword">ON</span> B.sid = student.s_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> s_name</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(s_name) &gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询学过“alex”老师所教的全部课程的同学的姓名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s_name <span class="keyword">FROM</span></span><br><span class="line">(<span class="keyword">SELECT</span> score.s_id <span class="keyword">as</span> <span class="keyword">sid</span>, score.c_id <span class="keyword">as</span> cid</span><br><span class="line"> <span class="keyword">FROM</span> score, course, teacher</span><br><span class="line"> <span class="keyword">WHERE</span> score.c_id = course.c_id <span class="keyword">AND</span> teacher.t_id = course.t_id <span class="keyword">AND</span> teacher.t_name = <span class="string">'alex'</span>) <span class="keyword">as</span> B</span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> student <span class="keyword">ON</span> B.sid = student.s_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> s_name</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(s_name) = (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(course.c_id) <span class="keyword">FROM</span></span><br><span class="line">course, teacher</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">teacher.t_id = course.t_id <span class="keyword">AND</span> teacher.t_name=<span class="string">'alex'</span>);</span><br></pre></td></tr></table></figure></li><li><p>查询挂科超过两门(包括两门)的学生姓名;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s_name <span class="keyword">FROM</span></span><br><span class="line">(<span class="keyword">SELECT</span> score.s_id <span class="keyword">as</span> <span class="keyword">sid</span>, score.c_id <span class="keyword">as</span> cid</span><br><span class="line"> <span class="keyword">FROM</span> score, course</span><br><span class="line"> <span class="keyword">WHERE</span> score.c_id = course.c_id  <span class="keyword">AND</span> (score.num &lt; <span class="number">60</span> <span class="keyword">OR</span> score.num <span class="keyword">ISNULL</span>)) <span class="keyword">as</span> B</span><br><span class="line">     <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> student <span class="keyword">ON</span> B.sid = student.s_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> s_name</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(s_name) &gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询有课程成绩小于60分的同学的姓名;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s_name <span class="keyword">FROM</span></span><br><span class="line">(<span class="keyword">SELECT</span> score.s_id <span class="keyword">as</span> <span class="keyword">sid</span>, score.c_id <span class="keyword">as</span> cid</span><br><span class="line"> <span class="keyword">FROM</span> score, course</span><br><span class="line"> <span class="keyword">WHERE</span> score.c_id = course.c_id  <span class="keyword">AND</span> score.num &lt; <span class="number">60</span>) <span class="keyword">as</span> B</span><br><span class="line">     <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> student <span class="keyword">ON</span> B.sid = student.s_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> s_name;</span><br></pre></td></tr></table></figure></li><li><p>查询选修了全部课程的学生姓名;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s_name <span class="keyword">FROM</span></span><br><span class="line">(<span class="keyword">SELECT</span> score.s_id <span class="keyword">as</span> <span class="keyword">sid</span>, score.c_id <span class="keyword">as</span> cid</span><br><span class="line"> <span class="keyword">FROM</span> score, course</span><br><span class="line"> <span class="keyword">WHERE</span> score.c_id = course.c_id) <span class="keyword">as</span> B</span><br><span class="line">     <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> student <span class="keyword">ON</span> B.sid = student.s_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> s_name</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(s_name) = (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> course);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> s_name <span class="keyword">FROM</span></span><br><span class="line">student</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> score <span class="keyword">ON</span> student.s_id = score.s_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> s_name</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(s_name) = (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> course)</span><br></pre></td></tr></table></figure></li><li><p>查询至少有一门课程与“貂蝉”同学所学课程相同的同学姓名；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s_name</span><br><span class="line"><span class="keyword">FROM</span> student, score</span><br><span class="line"><span class="keyword">WHERE</span> student.s_id = score.s_id <span class="keyword">AND</span> student.s_name != <span class="string">'貂蝉'</span> <span class="keyword">AND</span> score.c_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> c_id <span class="keyword">FROM</span> score, student</span><br><span class="line"> <span class="keyword">WHERE</span> score.s_id = student.s_id <span class="keyword">AND</span> student.s_name = <span class="string">'貂蝉'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> s_name;</span><br></pre></td></tr></table></figure></li><li><p>查询学过’貂蝉’同学全部课程的其他同学姓名；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s_name <span class="keyword">FROM</span></span><br><span class="line">(<span class="keyword">SELECT</span> score.s_id <span class="keyword">as</span> <span class="keyword">sid</span>, score.c_id <span class="keyword">as</span> cid</span><br><span class="line"> <span class="keyword">FROM</span> score, course, student</span><br><span class="line"> <span class="keyword">WHERE</span></span><br><span class="line">     score.c_id = course.c_id <span class="keyword">AND</span></span><br><span class="line"> student.s_id = score.s_id <span class="keyword">AND</span></span><br><span class="line"> student.s_name != <span class="string">'貂蝉'</span> <span class="keyword">AND</span></span><br><span class="line"> score.c_id <span class="keyword">in</span> (<span class="keyword">SELECT</span> c_id <span class="keyword">FROM</span> score, student <span class="keyword">WHERE</span> student.s_name = <span class="string">'貂蝉'</span> <span class="keyword">AND</span> student.s_id = score.s_id)</span><br><span class="line">) <span class="keyword">as</span> B</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> student <span class="keyword">ON</span> B.sid = student.s_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> s_name</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(s_name) &gt;= (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(score.c_id) <span class="keyword">FROM</span> score, student <span class="keyword">WHERE</span> student.s_name = <span class="string">'貂蝉'</span> <span class="keyword">AND</span> student.s_id = score.s_id);</span><br></pre></td></tr></table></figure></li></ol><p>– ——————————————————————————————————————————————————————————————<br>– INSERT INTO student VALUES (1, ‘鲁班’, 12, ‘男’);<br>– INSERT INTO student VALUES (2, ‘貂蝉’, 20, ‘女’);<br>– INSERT INTO student VALUES (3, ‘刘备’, 35, ‘男’);<br>– INSERT INTO student VALUES (4, ‘关羽’, 34, ‘男’);</p><h2 id="–-INSERT-INTO-student-VALUES-5-‘张飞’-33-‘女’"><a href="#–-INSERT-INTO-student-VALUES-5-‘张飞’-33-‘女’" class="headerlink" title="– INSERT INTO student VALUES (5, ‘张飞’, 33, ‘女’);"></a>– INSERT INTO student VALUES (5, ‘张飞’, 33, ‘女’);</h2><p>–</p><p>–<br>– INSERT INTO teacher VALUES (1, ‘大王’);<br>– INSERT INTO teacher VALUES (2, ‘alex’);<br>– INSERT INTO teacher VALUES (3, ‘egon’);</p><h2 id="–-INSERT-INTO-teacher-VALUES-4-‘peiqi’"><a href="#–-INSERT-INTO-teacher-VALUES-4-‘peiqi’" class="headerlink" title="– INSERT INTO teacher VALUES (4, ‘peiqi’);"></a>– INSERT INTO teacher VALUES (4, ‘peiqi’);</h2><p>– INSERT INTO course VALUES (1, ‘python’, 1);<br>– INSERT INTO course VALUES (2, ‘java’, 2);<br>– INSERT INTO course VALUES (3, ‘linux’, 3);<br>– INSERT INTO course VALUES (4, ‘go’, 2);</p><p>– INSERT INTO score VALUES (1, 1, 1, 79);<br>– INSERT INTO score VALUES (2, 1, 2, 77);<br>– INSERT INTO score VALUES (3, 1, 3, 58);<br>– INSERT INTO score VALUES (4, 2, 2, 66);<br>– INSERT INTO score VALUES (5, 2, 3, 77);<br>– INSERT INTO score VALUES (6, 3, 1, 61);<br>– INSERT INTO score VALUES (7, 3, 2, 64);</p><h2 id="–-INSERT-INTO-score-VALUES-8-4-3-70"><a href="#–-INSERT-INTO-score-VALUES-8-4-3-70" class="headerlink" title="– INSERT INTO score VALUES (8, 4, 3, 70);"></a>– INSERT INTO score VALUES (8, 4, 3, 70);</h2>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;查询学习课程”python”比课程 “java” 成绩高的学生的学号;&lt;br&gt;– 思路：&lt;br&gt;– 获取所有有python课程的人（学号，成绩） - 临时表&lt;br&gt;– 获取所有有java课程的人（学号，成绩） - 临时表&lt;br&gt;– 根据学号连接两个临时表：&lt;br&gt;– 学号 | 物理成绩 | 生物成绩&lt;br&gt;– 然后再进行筛选&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; A.s_id &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		(&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; s_id, &lt;span class=&quot;keyword&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; python &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; score &lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;join&lt;/span&gt; course &lt;span class=&quot;keyword&quot;&gt;on&lt;/span&gt; score.c_id = course.c_id &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; course.c_name = &lt;span class=&quot;string&quot;&gt;&#39;python&#39;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; A&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;join&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		(&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; s_id, &lt;span class=&quot;keyword&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;java&lt;/span&gt;   &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; score &lt;span class=&quot;keyword&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;join&lt;/span&gt; course &lt;span class=&quot;keyword&quot;&gt;on&lt;/span&gt; score.c_id = course.c_id &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; course.c_name = &lt;span class=&quot;string&quot;&gt;&#39;java&#39;&lt;/span&gt;)   &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; B&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;on&lt;/span&gt; A.s_id = B.s_id &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; A.python &amp;gt; B.java;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="SQL" scheme="http://kunxiang.wang/categories/SQL/"/>
    
    
      <category term="SQL" scheme="http://kunxiang.wang/tags/SQL/"/>
    
  </entry>
  
</feed>
