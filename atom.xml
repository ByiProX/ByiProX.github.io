<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Quentin&#39;s Blog</title>
  
  <subtitle>每天进步一点点</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-16T15:03:41.305Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ByiProX</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python3 实现二叉树前、中、后序遍历及按层遍历</title>
    <link href="http://yoursite.com/2018/03/15/Python3-%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E3%80%81%E4%B8%AD%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%8F%8A%E6%8C%89%E5%B1%82%E9%81%8D%E5%8E%86/"/>
    <id>http://yoursite.com/2018/03/15/Python3-实现二叉树前、中、后序遍历及按层遍历/</id>
    <published>2018-03-15T15:57:26.000Z</published>
    <updated>2018-03-16T15:03:41.305Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Data Structures" scheme="http://yoursite.com/categories/Data-Structures/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="Data Structures" scheme="http://yoursite.com/tags/Data-Structures/"/>
    
  </entry>
  
  <entry>
    <title>什么是Socket(转)</title>
    <link href="http://yoursite.com/2018/03/13/%E4%BB%80%E4%B9%88%E6%98%AFSocket-%E8%BD%AC/"/>
    <id>http://yoursite.com/2018/03/13/什么是Socket-转/</id>
    <published>2018-03-12T16:49:26.000Z</published>
    <updated>2018-03-12T17:03:47.890Z</updated>
    
    <content type="html"><![CDATA[<p>对TCP/IP、UDP、Socket编程这些词你不会很陌生吧？随着网络技术的发展，这些词充斥着我们的耳朵。那么我想问：</p><ol><li>什么是TCP/IP、UDP？</li><li>Socket在哪里呢？</li><li>Socket是什么呢？</li><li>你会使用它们吗？</li></ol><h2 id="什么是TCP-IP、UDP"><a href="#什么是TCP-IP、UDP" class="headerlink" title="什么是TCP/IP、UDP"></a>什么是TCP/IP、UDP</h2><p>TCP/IP（Transmission Control Protocol/Internet Protocol）即传输控制协议/网间协议，是一个工业标准的协议集，它是为广域网（WANs）设计的。<br>UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是属于TCP/IP协议族中的一种。</p><p><img src="https://upload-images.jianshu.io/upload_images/2952111-571c60b933d42028.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.jpg"></p><a id="more"></a><p>TCP/IP协议族包括运输层、网络层、链路层。由上图可以知道TCP/IP与UDP的关系。</p><h2 id="Socket在哪里"><a href="#Socket在哪里" class="headerlink" title="Socket在哪里"></a>Socket在哪里</h2><p><img src="https://upload-images.jianshu.io/upload_images/2952111-1dd2ce6b61d08816.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.jpg"></p><h2 id="Socket是什么"><a href="#Socket是什么" class="headerlink" title="Socket是什么"></a>Socket是什么</h2><p>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>前人已经给我们做了好多的事了，网络间的通信也就简单了许多，但毕竟还是有挺多工作要做的。以前听到Socket编程，觉得它是比较高深的编程知识，但是只要弄清Socket编程的工作原理，神秘的面纱也就揭开了。<br>一个生活中的场景。你要打电话给一个朋友，先拨号，朋友听到电话铃声后提起电话，这时你和你的朋友就建立起了连接，就可以讲话了。等交流结束，挂断电话结束此次交谈。<br>生活中的场景就解释了这工作原理，也许TCP/IP协议族就是诞生于生活中，这也不一定。</p><p><img src="https://upload-images.jianshu.io/upload_images/2952111-99ebc49204f5b380.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.jpg"></p><p>先从服务器端说起。服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。</p><p>在这里我就举个简单的例子，我们走的是TCP协议这条路（见图2）。例子用MFC编写，运行的界面如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/2952111-36073682cf397e4f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/2952111-61b92a5dbbb8bf69.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.jpg"></p><p>在客户端输入服务器端的IP地址和发送的数据，然后按发送按钮，服务器端接收到数据，然后回应客户端。客户端读取回应的数据，显示在界面上。</p><p>客户端就一个函数完成了一次通信。在这里IP地址为何用127.0.0.1呢？使用这个IP地址，服务器端和客户端就能运行在同一台机器上，这样调试方便多了。当然你可以在你朋友的机器上运行Server程序(本人在局域网中测试过)，在自己的机器上运行Client程序，当然输入的IP地址就该是你朋友机器的IP地址了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对TCP/IP、UDP、Socket编程这些词你不会很陌生吧？随着网络技术的发展，这些词充斥着我们的耳朵。那么我想问：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;什么是TCP/IP、UDP？&lt;/li&gt;
&lt;li&gt;Socket在哪里呢？&lt;/li&gt;
&lt;li&gt;Socket是什么呢？&lt;/li&gt;
&lt;li&gt;你会使用它们吗？&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;什么是TCP-IP、UDP&quot;&gt;&lt;a href=&quot;#什么是TCP-IP、UDP&quot; class=&quot;headerlink&quot; title=&quot;什么是TCP/IP、UDP&quot;&gt;&lt;/a&gt;什么是TCP/IP、UDP&lt;/h2&gt;&lt;p&gt;TCP/IP（Transmission Control Protocol/Internet Protocol）即传输控制协议/网间协议，是一个工业标准的协议集，它是为广域网（WANs）设计的。&lt;br&gt;UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是属于TCP/IP协议族中的一种。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2952111-571c60b933d42028.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Python3 实现遍历目录与子目录，并抓取.py文件</title>
    <link href="http://yoursite.com/2018/03/12/Python3-%E5%AE%9E%E7%8E%B0%E9%81%8D%E5%8E%86%E7%9B%AE%E5%BD%95%E4%B8%8E%E5%AD%90%E7%9B%AE%E5%BD%95%EF%BC%8C%E5%B9%B6%E6%8A%93%E5%8F%96-py%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/03/12/Python3-实现遍历目录与子目录，并抓取-py文件/</id>
    <published>2018-03-12T08:54:54.000Z</published>
    <updated>2018-03-12T09:04:15.759Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tree <span class="built_in">test</span></span><br><span class="line">.</span><br><span class="line">├── subtest1</span><br><span class="line">│   ├── subsubdir</span><br><span class="line">│   │   └── sub.py</span><br><span class="line">│   └── test1.py</span><br><span class="line">├── subtest2</span><br><span class="line">│   └── test2.py</span><br><span class="line">└── subtest3</span><br><span class="line">    └── test3.py</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. for-in dir/subdir to get the filesname  </span></span><br><span class="line"><span class="comment"># 2. splitext filename to filter  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getFiles</span><span class="params">(dir, suffix)</span>:</span>  </span><br><span class="line"></span><br><span class="line">    res = []  </span><br><span class="line">    <span class="keyword">for</span> root, directory, files <span class="keyword">in</span> os.walk(dir):  </span><br><span class="line">        <span class="keyword">for</span> filename <span class="keyword">in</span> files:  </span><br><span class="line">            name, suf = os.path.splitext(filename)  </span><br><span class="line">            <span class="keyword">if</span> suf == suffix:  </span><br><span class="line">                res.append(os.path.join(root, filename))  </span><br><span class="line">    <span class="keyword">return</span> res  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> getFiles(<span class="string">"./"</span>, <span class="string">'.py'</span>):  </span><br><span class="line">    print(file)</span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># ./walkdir.py</span></span><br><span class="line"><span class="comment"># ./subtest2/test2.py</span></span><br><span class="line"><span class="comment"># ./subtest3/test3.py</span></span><br><span class="line"><span class="comment"># ./subtest1/test1.py</span></span><br><span class="line"><span class="comment"># ./subtest1/subsubdir/sub.py</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Python3 os和sys模块的作用，以及常用的模块方法</title>
    <link href="http://yoursite.com/2018/03/12/Python3-os%E5%92%8Csys%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E6%A8%A1%E5%9D%97%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/03/12/Python3-os和sys模块的作用，以及常用的模块方法/</id>
    <published>2018-03-12T08:43:03.000Z</published>
    <updated>2018-03-12T08:49:03.868Z</updated>
    
    <content type="html"><![CDATA[<p>官方解释：</p><blockquote><p>os： This module provides a portable way of using operating system dependent functionality.</p></blockquote><p>翻译：提供一种方便的使用<code>操作系统函数</code>的方法。</p><blockquote><p>sys：This module provides access to some variables used or maintained by the interpreter and to functions that interact strongly with the interpreter.</p></blockquote><p>翻译：提供访问由<code>解释器</code>使用或维护的变量和在与<code>解释器交互</code>使用到的函数。</p><a id="more"></a><h2 id="os-常用方法"><a href="#os-常用方法" class="headerlink" title="os 常用方法"></a>os 常用方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">os.remove()  <span class="comment"># 删除文件  </span></span><br><span class="line">os.rename()  <span class="comment"># 重命名文件  </span></span><br><span class="line">os.walk()  <span class="comment"># 生成目录树下的所有文件名  </span></span><br><span class="line">os.chdir()  <span class="comment"># 改变目录  </span></span><br><span class="line">os.mkdir/makedirs  <span class="comment"># 创建目录/多层目录  </span></span><br><span class="line">os.rmdir/removedirs  <span class="comment"># 删除目录/多层目录  </span></span><br><span class="line">os.listdir()  <span class="comment"># 列出指定目录的文件  </span></span><br><span class="line">os.getcwd()  <span class="comment"># 取得当前工作目录  </span></span><br><span class="line">os.chmod()  <span class="comment"># 改变目录权限  </span></span><br><span class="line">os.path.basename()  <span class="comment"># 去掉目录路径，返回文件名  </span></span><br><span class="line">os.path.dirname()  <span class="comment"># 去掉文件名，返回目录路径  </span></span><br><span class="line">os.path.join()  <span class="comment"># 将分离的各部分组合成一个路径名  </span></span><br><span class="line">os.path.split()  <span class="comment"># 返回（dirname(),basename())元组  </span></span><br><span class="line">os.path.splitext()  <span class="comment"># 返回(filename,extension)元组  </span></span><br><span class="line">os.path.getatime|ctime|mtime   <span class="comment"># 分别返回最近访问、创建、修改时间  </span></span><br><span class="line">os.path.getsize()  <span class="comment"># 返回文件大小  </span></span><br><span class="line">os.path.exists()  <span class="comment"># 是否存在  </span></span><br><span class="line">os.path.isabs()  <span class="comment"># 是否为绝对路径  </span></span><br><span class="line">os.path.isdir()  <span class="comment"># 是否为目录  </span></span><br><span class="line">os.path.isfile()  <span class="comment"># 是否为文件</span></span><br></pre></td></tr></table></figure><h2 id="sys-常用方法"><a href="#sys-常用方法" class="headerlink" title="sys 常用方法"></a>sys 常用方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sys.argv           <span class="comment"># 命令行参数List，第一个元素是程序本身路径    </span></span><br><span class="line">sys.modules.keys() <span class="comment"># 返回所有已经导入的模块列表    </span></span><br><span class="line">sys.exc_info()     <span class="comment"># 获取当前正在处理的异常类,exc_type、exc_value、exc_traceback当前处理的异常详细信息    </span></span><br><span class="line">sys.exit(n)        <span class="comment"># 退出程序，正常退出时exit(0)    </span></span><br><span class="line">sys.hexversion     <span class="comment"># 获取Python解释程序的版本值，16进制格式如：0x020403F0    </span></span><br><span class="line">sys.version        <span class="comment"># 获取Python解释程序的版本信息    </span></span><br><span class="line">sys.maxint         <span class="comment"># 最大的Int值    </span></span><br><span class="line">sys.maxunicode     <span class="comment"># 最大的Unicode值    </span></span><br><span class="line">sys.modules        <span class="comment"># 返回系统导入的模块字段，key是模块名，value是模块    </span></span><br><span class="line">sys.path           <span class="comment"># 返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值    </span></span><br><span class="line">sys.platform       <span class="comment"># 返回操作系统平台名称    </span></span><br><span class="line">sys.stdout         <span class="comment"># 标准输出   </span></span><br><span class="line">sys.stdin          <span class="comment"># 标准输入   </span></span><br><span class="line">sys.stderr         <span class="comment"># 错误输出   </span></span><br><span class="line">sys.exc_clear()    <span class="comment"># 用来清除当前线程所出现的当前的或最近的错误信息   </span></span><br><span class="line">sys.exec_prefix    <span class="comment"># 返回平台独立的python文件安装的位置   </span></span><br><span class="line">sys.byteorder      <span class="comment"># 本地字节规则的指示器，big-endian平台的值是'big',little-endian平台的值是'little'   </span></span><br><span class="line">sys.copyright      <span class="comment"># 记录python版权相关的东西   </span></span><br><span class="line">sys.api_version    <span class="comment"># 解释器的C的API版本   </span></span><br><span class="line">sys.version_info</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;官方解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;os： This module provides a portable way of using operating system dependent functionality.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;翻译：提供一种方便的使用&lt;code&gt;操作系统函数&lt;/code&gt;的方法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sys：This module provides access to some variables used or maintained by the interpreter and to functions that interact strongly with the interpreter.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;翻译：提供访问由&lt;code&gt;解释器&lt;/code&gt;使用或维护的变量和在与&lt;code&gt;解释器交互&lt;/code&gt;使用到的函数。&lt;/p&gt;
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Tesseract的使用</title>
    <link href="http://yoursite.com/2018/03/12/Tesseract%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/03/12/Tesseract的使用/</id>
    <published>2018-03-12T04:35:36.000Z</published>
    <updated>2018-03-12T06:34:34.885Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Running-Tesseract-with-command-line"><a href="#Running-Tesseract-with-command-line" class="headerlink" title="Running Tesseract with command-line"></a>Running Tesseract with command-line</h2><p>Tesseract is a command-line program, so first open a terminal or command prompt. The command is used like this:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tesseract imagename outputbase [-l lang] [-psm pagesegmode] [configfile...]</span><br></pre></td></tr></table></figure></p><p>So basic usage to do OCR on an image called ‘myscan.png’ and save the result to ‘out.txt’ would be:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tesseract myscan.png out</span><br></pre></td></tr></table></figure></p><p>Or to do the same with German:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tesseract myscan.png out -l deu</span><br></pre></td></tr></table></figure></p><p>It can even be used with multiple languages traineddata at a time eg. English and German:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tesseract myscan.png out -l eng+deu</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>Tesseract also includes a hOCR mode, which produces a special HTML file with the coordinates of each word. This can be used to create a searchable pdf, using a tool such as <a href="https://exactcode.com/opensource/exactimage/" target="_blank" rel="noopener">Hocr2PDF</a>. To use it, use the ‘hocr’ config option, like this:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tesseract myscan.png out hocr</span><br></pre></td></tr></table></figure></p><p>You can also create a searchable pdf directly from tesseract ( versions &gt;=3.03):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tesseract myscan.png out pdf</span><br></pre></td></tr></table></figure></p><p>More information about the various options is available in the <a href="https://github.com/tesseract-ocr/tesseract/blob/master/doc/tesseract.1.asc" target="_blank" rel="noopener">Tesseract manpage</a>.</p><h3 id="Other-Languages"><a href="#Other-Languages" class="headerlink" title="Other Languages"></a>Other Languages</h3><p>Tesseract has been trained for <a href="https://github.com/tesseract-ocr/tesseract/blob/master/doc/tesseract.1.asc#languages" target="_blank" rel="noopener">many languages</a>, check for your language in the <a href="https://github.com/tesseract-ocr/tessdata" target="_blank" rel="noopener">Tessdata repository</a>.</p><p>For example, if we want Tesseract support Chinese language, just put <code>chi_sim.traineddata</code> into the path <code>/usr/local/Cellar/tesseract/3.05.01/share/tessdata/</code>。</p><p>It can also be trained to support other languages and scripts; for more details see <a href="https://github.com/tesseract-ocr/tesseract/wiki/TrainingTesseract" target="_blank" rel="noopener">TrainingTesseract</a>.</p><h2 id="Running-Tesseract-with-Python"><a href="#Running-Tesseract-with-Python" class="headerlink" title="Running Tesseract with Python"></a>Running Tesseract with Python</h2><p>Python-tesseract is an optical character recognition (OCR) tool for python. That is, it will recognize and “read” the text embedded in images.</p><h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><p><strong> Quick start </strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> pytesseract</span><br><span class="line"></span><br><span class="line">pytesseract.pytesseract.tesseract_cmd = <span class="string">'&lt;full_path_to_your_tesseract_executable&gt;'</span></span><br><span class="line"><span class="comment"># Include the above line, if you don't have tesseract executable in your PATH</span></span><br><span class="line"><span class="comment"># Example tesseract_cmd: 'C:\\Program Files (x86)\\Tesseract-OCR\\tesseract'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Simple image to string</span></span><br><span class="line">print(pytesseract.image_to_string(Image.open(<span class="string">'test.png'</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># French text image to string</span></span><br><span class="line">print(pytesseract.image_to_string(Image.open(<span class="string">'test-european.jpg'</span>), lang=<span class="string">'fra'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get bounding box estimates</span></span><br><span class="line">print(pytesseract.image_to_boxes(Image.open(<span class="string">'test.png'</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get verbose data including boxes, confidences, line and page numbers</span></span><br><span class="line">print(pytesseract.image_to_data(Image.open(<span class="string">'test.png'</span>)))</span><br></pre></td></tr></table></figure></p><p>Support for OpenCV image/NumPy array objects<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'/**path_to_image**/digits.png'</span>)</span><br><span class="line">print(pytesseract.image_to_string(img))</span><br><span class="line"><span class="comment"># OR explicit beforehand converting</span></span><br><span class="line">print(pytesseract.image_to_string(Image.fromarray(img))</span><br></pre></td></tr></table></figure></p><p>Add the following config, if you have tessdata error like: “Error opening data file…”<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tessdata_dir_config = <span class="string">'--tessdata-dir "&lt;replace_with_your_tessdata_dir_path&gt;"'</span></span><br><span class="line"><span class="comment"># Example config: '--tessdata-dir "C:\\Program Files (x86)\\Tesseract-OCR\\tessdata"'</span></span><br><span class="line"><span class="comment"># It's important to add double quotes around the dir path.</span></span><br><span class="line"></span><br><span class="line">pytesseract.image_to_string(image, lang=<span class="string">'chi_sim'</span>, config=tessdata_dir_config)</span><br></pre></td></tr></table></figure></p><p><strong>Functions</strong></p><ul><li><strong>image_to_string</strong> Returns the result of a Tesseract OCR run on the image to string</li><li><strong>image_to_boxes</strong> Returns result containing recognized characters and their box boundaries</li><li><strong>image_to_data</strong> Returns result containing box boundaries, confidences, and other information. Requires Tesseract 3.05+. For more information, please check the <a href="https://github.com/tesseract-ocr/tesseract/wiki/Command-Line-Usage#tsv-output-currently-available-in-305-dev-in-master-branch-on-github" target="_blank" rel="noopener">Tesseract TSV documentation</a></li></ul><p><strong>Parameters</strong></p><p><code>image_to_data(image, lang=None, config=&#39;&#39;, nice=0, output_type=Output.STRING)</code></p><ul><li><strong>image</strong> Object, PIL Image/NumPy array of the image to be processed by Tesseract</li><li><strong>lang</strong> String, Tesseract language code string</li><li><strong>config</strong> String, Any additional configurations as a string, ex: <code>config=&#39;--psm 6&#39;</code></li><li><strong>nice</strong> Integer, modifies the processor priority for the Tesseract run. Not supported on Windows. Nice adjusts the niceness of unix-like processes.</li><li><strong>output_type</strong> Class attribute, specifies the type of the output, defaults to <code>string</code>. For the full list of all supported types, please check the definition of <a href="https://github.com/madmaze/pytesseract/blob/master/src/pytesseract.py" target="_blank" rel="noopener">pytesseract.Output</a> class.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Running-Tesseract-with-command-line&quot;&gt;&lt;a href=&quot;#Running-Tesseract-with-command-line&quot; class=&quot;headerlink&quot; title=&quot;Running Tesseract with command-line&quot;&gt;&lt;/a&gt;Running Tesseract with command-line&lt;/h2&gt;&lt;p&gt;Tesseract is a command-line program, so first open a terminal or command prompt. The command is used like this:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;tesseract imagename outputbase [-l lang] [-psm pagesegmode] [configfile...]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;So basic usage to do OCR on an image called ‘myscan.png’ and save the result to ‘out.txt’ would be:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;tesseract myscan.png out&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Or to do the same with German:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;tesseract myscan.png out -l deu&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;It can even be used with multiple languages traineddata at a time eg. English and German:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;tesseract myscan.png out -l eng+deu&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Tesseract" scheme="http://yoursite.com/categories/Tesseract/"/>
    
    
      <category term="Tesseract" scheme="http://yoursite.com/tags/Tesseract/"/>
    
  </entry>
  
  <entry>
    <title>Python3 将两个排好序的列表合并成一个有序列表</title>
    <link href="http://yoursite.com/2018/03/12/Python3-%E5%B0%86%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%A5%BD%E5%BA%8F%E7%9A%84%E5%88%97%E8%A1%A8%E5%90%88%E5%B9%B6%E6%88%90%E4%B8%80%E4%B8%AA%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/03/12/Python3-将两个排好序的列表合并成一个有序列表/</id>
    <published>2018-03-11T16:11:27.000Z</published>
    <updated>2018-03-11T17:59:27.116Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_list</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> a:</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> b:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    a_index = b_index = <span class="number">0</span></span><br><span class="line">    ret = []</span><br><span class="line">    <span class="keyword">while</span> a_index &lt; len(a) <span class="keyword">and</span> b_index &lt; len(b):</span><br><span class="line">        <span class="keyword">if</span> a[a_index] &lt;= b[b_index]:</span><br><span class="line">            ret.append(a[a_index])</span><br><span class="line">            a_index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ret.append(b[b_index])</span><br><span class="line">            b_index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> a_index &lt; len(a):</span><br><span class="line">        ret.extend(a[a_index:])</span><br><span class="line">    <span class="keyword">if</span> b_index &lt; len(b):</span><br><span class="line">        ret.extend(b[b_index:])</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line">    b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line">    print(merge_list(a, b))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Python3 实现常见的各种排序方法</title>
    <link href="http://yoursite.com/2018/03/09/Python3-%E5%AE%9E%E7%8E%B0%E5%B8%B8%E8%A7%81%E7%9A%84%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/03/09/Python3-实现常见的各种排序方法/</id>
    <published>2018-03-09T07:56:09.000Z</published>
    <updated>2018-03-14T16:00:34.768Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序的思路：</p><ol><li>先从数列中取出一个数作为基准数。</li><li>分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边(假定从小到大排序)。</li><li>再对左右区间重复第二步，直到各区间只有一个数</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="string">"""快速排序"""</span></span><br><span class="line">    <span class="keyword">if</span> len(array) &lt; <span class="number">2</span>:  <span class="comment"># 基线条件：为空或者只有一个元素的数组是有序的</span></span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pivot = array[<span class="number">0</span>]  <span class="comment"># 递归条件,基准值</span></span><br><span class="line">        less = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i &lt;= pivot]  <span class="comment"># 所有小于基准值的元素组成的子数组</span></span><br><span class="line">        greater = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i &gt; pivot]  <span class="comment"># 所有大于基准值的元素组成的子数组</span></span><br><span class="line">        <span class="keyword">return</span> quicksort(less) + [pivot] + quicksort(greater)</span><br><span class="line"></span><br><span class="line">print(quicksort([<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">3</span>]))</span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="http://upload-images.jianshu.io/upload_images/2952111-d52e0c914f7272a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="快速排序"></p><p><img src="http://upload-images.jianshu.io/upload_images/2952111-03cf1024e51c6dee.gif?imageMogr2/auto-orient/strip" alt="20170801013540271.gif"></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序原理即：从数组下标为0的位置开始，比较下标位置为0和1的数据，如果0号位置的大，则交换位置，如果1号位置大，则什么也不做，然后右移一个位置，比较1号和2号的数据，和刚才的一样，如果1号的大，则交换位置，以此类推直至最后一个位置结束，到此数组中最大的元素就被排到了最后，之后再根据之前的步骤开始排前面的数据，直至全部数据都排序完成。</p><p>就是传说中的大的沉到底原则，适用于小量数据</p><p>冒泡排序思路: 每一趟只能将一个数归位, 如果有n个数进行排序,只需将n-1个数归位, 也就是说要进行n-1趟操作(已经归位的数不用再比较)</p><p>缺点: 冒泡排序解决了桶排序浪费空间的问题, 但是冒泡排序的效率特别低<br><img src="http://upload-images.jianshu.io/upload_images/2952111-020fcd7b86279da7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="冒泡排序"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span><span class="params">(relist)</span>:</span></span><br><span class="line">    <span class="string">"""冒泡排序"""</span></span><br><span class="line">    len_ = len(relist)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len_ - <span class="number">1</span>):  <span class="comment"># 这个循环负责设置冒泡排序进行的次数</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,len_-i<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> relist[j] &gt; relist[j+<span class="number">1</span>]:</span><br><span class="line">                relist[j+<span class="number">1</span>], relist[j] = relist[j], relist[j+<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> relist</span><br><span class="line"></span><br><span class="line">print(bubbleSort([<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">3</span>]))</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/2952111-e421e0f31170cb93.gif?imageMogr2/auto-orient/strip" alt="冒泡排序"></p><p>由上图看出最大的数一直沉到底部</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序基本原理：</p><ol><li>第1趟，在待排序记录r1 ~ r[n]中选出最小的记录，将它与r1交换；</li><li>第2趟，在待排序记录r2 ~ r[n]中选出最小的记录，将它与r2交换；</li><li>以此类推，第i趟在待排序记录r[i] ~ r[n]中选出最小的记录，将它与r[i]交换，使有序序列不断增长直到全部排序完毕。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectSort</span><span class="params">(relist)</span>:</span></span><br><span class="line">    len_ = len(relist)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len_):</span><br><span class="line">        min_index = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len_):  <span class="comment"># 这个循环会找到值比第i个索引所代表值小的索引</span></span><br><span class="line">            <span class="keyword">if</span> relist[j] &lt; relist[min_index]:</span><br><span class="line">                min_index = j</span><br><span class="line">        relist[i] ,relist[min_index] = relist[min_index], relist[i]  <span class="comment"># 互换两个索引位置</span></span><br><span class="line">    <span class="keyword">return</span> relist</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> selectSort([<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findSmallest</span><span class="params">(arr)</span>:</span></span><br><span class="line">    smallest = arr[<span class="number">0</span>]</span><br><span class="line">    smallest_index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(arr)):</span><br><span class="line">        <span class="keyword">if</span> arr[i] &lt; smallest:</span><br><span class="line">            smallest = arr[i]</span><br><span class="line">            smallest_index = i</span><br><span class="line">    <span class="keyword">return</span> smallest_index</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectionSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    newArr = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">        smallest = findSmallest(arr)</span><br><span class="line">        newArr.append(arr.pop(smallest))</span><br><span class="line">    <span class="keyword">return</span> newArr</span><br><span class="line"></span><br><span class="line">print(selectionSort([<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">8</span>]))</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/2952111-3b59aac6b772ddf0.gif?imageMogr2/auto-orient/strip" alt="选择排序"></p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><code>所谓归并是指将若干个已排好序的部分合并成一个有序的部分。</code></p><p>假设我们有一个没有排好序的序列(14,12,15,13,11,16)，那么首先我们使用分割的办法将这个序列分割成一个个已经排好序的子序列。然后再利用归并的方法将一个个的子序列合并成排序好的序列。分割和归并的过程可以看下面的图例。这样通过先递归的分解数列，再合并数列就完成了归并排序。</p><p><img src="https://upload-images.jianshu.io/upload_images/2952111-b7ca2aad908df253.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MergeSort.jpg"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left, right)</span>:</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">        result.append(left.pop(<span class="number">0</span>) <span class="keyword">if</span> left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>] <span class="keyword">else</span> right.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">while</span> left:</span><br><span class="line">        result.append(left.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">while</span> right:</span><br><span class="line">        result.append(right.pop(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">(relist)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(relist) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> relist</span><br><span class="line">    mid_index = math.floor(len(relist)/<span class="number">2</span>)</span><br><span class="line">    left = mergeSort(relist[:mid_index])  <span class="comment"># 递归拆解的过程</span></span><br><span class="line">    right = mergeSort(relist[mid_index:])</span><br><span class="line">    <span class="keyword">return</span> merge(left, right)  <span class="comment"># 合并的过程</span></span><br><span class="line"></span><br><span class="line">print(mergeSort([<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">3</span>]))</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/2952111-8ee3d2a2a81eab80.gif?imageMogr2/auto-orient/strip" alt="归并排序"></p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><ol><li>创建最大堆:将堆所有数据重新排序，使其成为最大堆</li><li>最大堆调整:作用是保持最大堆的性质，是创建最大堆的核心子程序</li><li>堆排序:移除位在第一个数据的根节点，并做最大堆调整的递归运算</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/2952111-5903c9ca1e9a0473.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="堆排序.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># code from -http://blog.csdn.net/minxihou/article/details/51850001</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MAX_Heapify</span><span class="params">(heap,HeapSize,root)</span>:</span><span class="comment">#在堆中做结构调整使得父节点的值大于子节点</span></span><br><span class="line"></span><br><span class="line">    left = <span class="number">2</span>*root + <span class="number">1</span></span><br><span class="line">    right = left + <span class="number">1</span></span><br><span class="line">    larger = root</span><br><span class="line">    <span class="keyword">if</span> left &lt; HeapSize <span class="keyword">and</span> heap[larger] &lt; heap[left]:</span><br><span class="line">        larger = left</span><br><span class="line">    <span class="keyword">if</span> right &lt; HeapSize <span class="keyword">and</span> heap[larger] &lt; heap[right]:</span><br><span class="line">        larger = right</span><br><span class="line">    <span class="keyword">if</span> larger != root:<span class="comment">#如果做了堆调整则larger的值等于左节点或者右节点的，这个时候做对调值操作</span></span><br><span class="line">        heap[larger],heap[root] = heap[root],heap[larger]</span><br><span class="line">        MAX_Heapify(heap, HeapSize, larger)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Build_MAX_Heap</span><span class="params">(heap)</span>:</span><span class="comment">#构造一个堆，将堆中所有数据重新排序</span></span><br><span class="line">    HeapSize = len(heap)<span class="comment">#将堆的长度当独拿出来方便</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range((HeapSize <span class="number">-2</span>)//<span class="number">2</span>,<span class="number">-1</span>,<span class="number">-1</span>):<span class="comment">#从后往前出数</span></span><br><span class="line">        MAX_Heapify(heap,HeapSize,i)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">HeapSort</span><span class="params">(heap)</span>:</span><span class="comment">#将根节点取出与最后一位做对调，对前面len-1个节点继续进行对调整过程。</span></span><br><span class="line">    Build_MAX_Heap(heap)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(heap)<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        heap[<span class="number">0</span>],heap[i] = heap[i],heap[<span class="number">0</span>]</span><br><span class="line">        MAX_Heapify(heap, i, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> heap</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">30</span>,<span class="number">50</span>,<span class="number">57</span>,<span class="number">77</span>,<span class="number">62</span>,<span class="number">78</span>,<span class="number">94</span>,<span class="number">80</span>,<span class="number">84</span>]</span><br><span class="line">    print(a)</span><br><span class="line">    HeapSort(a)</span><br><span class="line">    print(a)</span><br><span class="line">    b = [random.randint(<span class="number">1</span>,<span class="number">1000</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>)]</span><br><span class="line">    <span class="comment">#print b</span></span><br><span class="line">    HeapSort(b)</span><br><span class="line">    print(b)</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/2952111-d80509464c38434d.gif?imageMogr2/auto-orient/strip" alt="堆排序.gif"></p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><table><thead><tr><th style="text-align:left">排序法</th><th style="text-align:left">最差时间</th><th style="text-align:left">平均时间复杂度</th><th style="text-align:left">稳定度</th><th style="text-align:left">空间复杂度</th></tr></thead><tbody><tr><td style="text-align:left">冒泡排序</td><td style="text-align:left">O(n^2)</td><td style="text-align:left">O(n^2)</td><td style="text-align:left">稳定</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">快速排序</td><td style="text-align:left">O(n^2)</td><td style="text-align:left">O(n*log n)</td><td style="text-align:left">不稳定</td><td style="text-align:left">O(log2n)~O(n)</td></tr><tr><td style="text-align:left">选择排序</td><td style="text-align:left">O(n^2)</td><td style="text-align:left">O(n^2)</td><td style="text-align:left">不稳定</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">二叉树排序</td><td style="text-align:left">O(n^2)</td><td style="text-align:left">O(n*log n)</td><td style="text-align:left">不一定</td><td style="text-align:left">O(n)</td></tr><tr><td style="text-align:left">插入排序</td><td style="text-align:left">O(n^2)</td><td style="text-align:left">O(n^2)</td><td style="text-align:left">稳定</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">堆排序</td><td style="text-align:left">O(n*log n)</td><td style="text-align:left">O(n*log n)</td><td style="text-align:left">不稳定</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">希尔排序</td><td style="text-align:left">O</td><td style="text-align:left">O</td><td style="text-align:left">不稳定</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">归并排序</td><td style="text-align:left">O(n*log n)</td><td style="text-align:left">O(n*log n)</td><td style="text-align:left">稳定</td><td style="text-align:left">?</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://blog.csdn.net/mrlevo520/article/details/77829204" target="_blank" rel="noopener">http://blog.csdn.net/mrlevo520/article/details/77829204</a></li><li><a href="http://blog.csdn.net/minxihou/article/details/51850001" target="_blank" rel="noopener">http://blog.csdn.net/minxihou/article/details/51850001</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h2&gt;&lt;p&gt;快速排序的思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先从数列中取出一个数作为基准数。&lt;/li&gt;
&lt;li&gt;分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边(假定从小到大排序)。&lt;/li&gt;
&lt;li&gt;再对左右区间重复第二步，直到各区间只有一个数&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;quicksort&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(array)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;&quot;&quot;快速排序&quot;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; len(array) &amp;lt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;:  &lt;span class=&quot;comment&quot;&gt;# 基线条件：为空或者只有一个元素的数组是有序的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; array&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        pivot = array[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]  &lt;span class=&quot;comment&quot;&gt;# 递归条件,基准值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        less = [i &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; array[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:] &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; i &amp;lt;= pivot]  &lt;span class=&quot;comment&quot;&gt;# 所有小于基准值的元素组成的子数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        greater = [i &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; array[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:] &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; i &amp;gt; pivot]  &lt;span class=&quot;comment&quot;&gt;# 所有大于基准值的元素组成的子数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; quicksort(less) + [pivot] + quicksort(greater)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(quicksort([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="Data Structures" scheme="http://yoursite.com/tags/Data-Structures/"/>
    
  </entry>
  
  <entry>
    <title>Python3 实现二分查找</title>
    <link href="http://yoursite.com/2018/03/09/Python3-%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>http://yoursite.com/2018/03/09/Python3-实现二分查找/</id>
    <published>2018-03-09T06:32:16.000Z</published>
    <updated>2018-03-09T07:26:37.282Z</updated>
    
    <content type="html"><![CDATA[<p>二分查找,给出一个已经排好序的列表,<code>注意是已经排好序的</code>,查找指定元素在列表中的位置<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(my_list, item)</span>:</span></span><br><span class="line">    <span class="string">"""从list中查找item"""</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = len(my_list) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        mid = math.floor((low + high)/<span class="number">2</span>)</span><br><span class="line">        guess = my_list[mid]</span><br><span class="line">        <span class="keyword">if</span> guess &gt; item:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> guess &lt; item:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">my_list = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line">item = <span class="number">1</span></span><br><span class="line">print(binary_search(my_list, item))</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;二分查找,给出一个已经排好序的列表,&lt;code&gt;注意是已经排好序的&lt;/code&gt;,查找指定元素在列表中的位置&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Python3 向上取整ceil|向下取整floor|四舍五入round</title>
    <link href="http://yoursite.com/2018/03/09/Python3-%E5%90%91%E4%B8%8A%E5%8F%96%E6%95%B4ceil-%E5%90%91%E4%B8%8B%E5%8F%96%E6%95%B4floor-%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5round/"/>
    <id>http://yoursite.com/2018/03/09/Python3-向上取整ceil-向下取整floor-四舍五入round/</id>
    <published>2018-03-09T06:21:35.000Z</published>
    <updated>2018-03-09T06:27:14.992Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="comment">#向上取整</span></span><br><span class="line">print(<span class="string">"math.ceil---向上取整"</span>)  </span><br><span class="line">print(<span class="string">"math.ceil(2.3) =&gt; "</span>, math.ceil(<span class="number">2.3</span>))  <span class="comment"># 3</span></span><br><span class="line">print(<span class="string">"math.ceil(2.6) =&gt; "</span>, math.ceil(<span class="number">2.6</span>))  <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#向下取整</span></span><br><span class="line">print(<span class="string">"\nmath.floor---向下取整"</span>)</span><br><span class="line">print(<span class="string">"math.floor(2.3) =&gt; "</span>, math.floor(<span class="number">2.3</span>)) <span class="comment"># 2</span></span><br><span class="line">print(<span class="string">"math.floor(2.6) =&gt; "</span>, math.floor(<span class="number">2.6</span>)) <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#四舍五入</span></span><br><span class="line">print(<span class="string">"\nround---四舍五入"</span>)</span><br><span class="line">print(<span class="string">"round(2.3) =&gt; "</span>, round(<span class="number">2.3</span>)) <span class="comment"># 2</span></span><br><span class="line">print(<span class="string">"round(2.6) =&gt; "</span>, round(<span class="number">2.6</span>)) <span class="comment"># 3</span></span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">math.ceil---向上取整</span><br><span class="line">math.ceil(2.3) =&gt;  3</span><br><span class="line">math.ceil(2.6) =&gt;  3</span><br><span class="line"></span><br><span class="line">math.floor---向下取整</span><br><span class="line">math.floor(2.3) =&gt;  2</span><br><span class="line">math.floor(2.6) =&gt;  2</span><br><span class="line"></span><br><span class="line">round---四舍五入</span><br><span class="line">round(2.3) =&gt;  2</span><br><span class="line">round(2.6) =&gt;  3</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; math&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#向上取整&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&lt;span class=&quot;string&quot;&gt;&quot;math.ceil---向上取整&quot;&lt;/span&gt;)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&lt;span class=&quot;string&quot;&gt;&quot;math.ceil(2.3) =&amp;gt; &quot;&lt;/span&gt;, math.ceil(&lt;span class=&quot;number&quot;&gt;2.3&lt;/span&gt;))  &lt;span class=&quot;comment&quot;&gt;# 3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&lt;span class=&quot;string&quot;&gt;&quot;math.ceil(2.6) =&amp;gt; &quot;&lt;/span&gt;, math.ceil(&lt;span class=&quot;number&quot;&gt;2.6&lt;/span&gt;))  &lt;span class=&quot;comment&quot;&gt;# 3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#向下取整&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&lt;span class=&quot;string&quot;&gt;&quot;\nmath.floor---向下取整&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&lt;span class=&quot;string&quot;&gt;&quot;math.floor(2.3) =&amp;gt; &quot;&lt;/span&gt;, math.floor(&lt;span class=&quot;number&quot;&gt;2.3&lt;/span&gt;)) &lt;span class=&quot;comment&quot;&gt;# 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&lt;span class=&quot;string&quot;&gt;&quot;math.floor(2.6) =&amp;gt; &quot;&lt;/span&gt;, math.floor(&lt;span class=&quot;number&quot;&gt;2.6&lt;/span&gt;)) &lt;span class=&quot;comment&quot;&gt;# 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#四舍五入&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&lt;span class=&quot;string&quot;&gt;&quot;\nround---四舍五入&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&lt;span class=&quot;string&quot;&gt;&quot;round(2.3) =&amp;gt; &quot;&lt;/span&gt;, round(&lt;span class=&quot;number&quot;&gt;2.3&lt;/span&gt;)) &lt;span class=&quot;comment&quot;&gt;# 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&lt;span class=&quot;string&quot;&gt;&quot;round(2.6) =&amp;gt; &quot;&lt;/span&gt;, round(&lt;span class=&quot;number&quot;&gt;2.6&lt;/span&gt;)) &lt;span class=&quot;comment&quot;&gt;# 3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Apache和Nginx的对比</title>
    <link href="http://yoursite.com/2018/03/08/Apache%E5%92%8CNginx%E7%9A%84%E5%AF%B9%E6%AF%94/"/>
    <id>http://yoursite.com/2018/03/08/Apache和Nginx的对比/</id>
    <published>2018-03-07T18:11:57.000Z</published>
    <updated>2018-03-07T18:31:50.268Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h2><ol><li>apache 的 rewrite 比 nginx 强大，在 rewrite 频繁的情况下，用 apache</li><li>apache 发展到现在，模块超多，基本想到的都可以找到</li><li>apache 更为成熟，少 bug ，nginx 的 bug 相对较多</li><li>apache 超稳定</li><li>apache 对 PHP 支持比较简单，nginx 需要配合其他后端用</li><li>apache 在处理动态请求有优势，nginx 在这方面是鸡肋，一般动态请求要 apache 去做，nginx 适合静态和反向。</li><li>apache 仍然是目前的主流，拥有丰富的特性，成熟的技术和开发社区</li></ol><a id="more"></a><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><ol><li>轻量级，采用 C 进行编写，同样的 web 服务，会占用更少的内存及资源</li><li>抗并发，nginx 以 epoll and kqueue 作为开发模型，处理请求是异步非阻塞的，负载能力比 apache 高很多，而 apache 则是阻塞型的。在高并发下 nginx 能保持低资源低消耗高性能 ，而 apache 在 PHP 处理慢或者前端压力很大的情况下，很容易出现进程数飙升，从而拒绝服务的现象。</li><li>nginx 处理静态文件好，静态处理性能比 apache 高三倍以上</li><li>nginx 的设计高度模块化，编写模块相对简单</li><li>nginx 配置简洁，正则配置让很多事情变得简单，而且改完配置能使用 -t 测试配置有没有问题，apache 配置复杂 ，重启的时候发现配置出错了，会很崩溃</li><li>nginx 作为负载均衡服务器，支持 7 层负载均衡</li><li>nginx 本身就是一个反向代理服务器，而且可以作为非常优秀的邮件代理服务器</li><li>启动特别容易, 并且几乎可以做到 7*24 不间断运行，即使运行数个月也不需要重新启动，还能够不间断服务的情况下进行软件版本的升级</li><li>社区活跃，各种高性能模块出品迅速</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>nginx 相对 apache 的优点：</p><ul><li>轻量级，同样起web 服务，比apache 占用更少的内存及资源</li><li>抗并发，<code>nginx 处理请求是异步非阻塞的</code>，支持更多的并发连接，而<code>apache 则是阻塞型的</code>，在高并发下nginx 能保持低资源低消耗高性能</li><li>配置简洁</li><li>高度模块化的设计，编写模块相对简单</li><li>社区活跃</li></ul><p>apache 相对nginx 的优点：</p><ul><li>rewrite ，比nginx 的rewrite 强大</li><li>模块超多，基本想到的都可以找到</li><li>少bug ，nginx 的bug 相对较多</li><li>超稳定</li></ul><p>两者最核心的区别在于 <code>apache 是同步多进程模型，一个连接对应一个进程</code>，而 <code>nginx 是异步的，多个连接（万级别）可以对应一个进程</code></p><p>一般来说，需要性能的 web 服务，用 nginx 。如果不需要性能只求稳定，更考虑 apache ，后者的各种功能模块实现得比前者，例如 ssl 的模块就比前者好，可配置项多。epoll(freebsd 上是 kqueue ) 网络 IO 模型是 nginx 处理性能高的根本理由，但并不是所有的情况下都是 epoll 大获全胜的，如果本身提供静态服务的就只有寥寥几个文件，apache 的 select 模型或许比 epoll 更高性能。当然，这只是根据网络 IO 模型的原理作的一个假设，真正的应用还是需要实测了再说的。</p><p>更为通用的方案是，前端 nginx 抗并发，后端 apache 集群，配合起来会更好。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Apache&quot;&gt;&lt;a href=&quot;#Apache&quot; class=&quot;headerlink&quot; title=&quot;Apache&quot;&gt;&lt;/a&gt;Apache&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;apache 的 rewrite 比 nginx 强大，在 rewrite 频繁的情况下，用 apache&lt;/li&gt;
&lt;li&gt;apache 发展到现在，模块超多，基本想到的都可以找到&lt;/li&gt;
&lt;li&gt;apache 更为成熟，少 bug ，nginx 的 bug 相对较多&lt;/li&gt;
&lt;li&gt;apache 超稳定&lt;/li&gt;
&lt;li&gt;apache 对 PHP 支持比较简单，nginx 需要配合其他后端用&lt;/li&gt;
&lt;li&gt;apache 在处理动态请求有优势，nginx 在这方面是鸡肋，一般动态请求要 apache 去做，nginx 适合静态和反向。&lt;/li&gt;
&lt;li&gt;apache 仍然是目前的主流，拥有丰富的特性，成熟的技术和开发社区&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Web服务器" scheme="http://yoursite.com/tags/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>用户密码保存的方式有哪些</title>
    <link href="http://yoursite.com/2018/03/08/%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E4%BF%9D%E5%AD%98%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B/"/>
    <id>http://yoursite.com/2018/03/08/用户密码保存的方式有哪些/</id>
    <published>2018-03-07T18:03:43.000Z</published>
    <updated>2018-03-07T18:05:08.274Z</updated>
    
    <content type="html"><![CDATA[<ol><li>明文保存</li><li>明文hash后保存,如md5</li><li>MD5+Salt方式,这个salt可以随机</li><li>知乎使用了Bcrypy(好像)加密</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;明文保存&lt;/li&gt;
&lt;li&gt;明文hash后保存,如md5&lt;/li&gt;
&lt;li&gt;MD5+Salt方式,这个salt可以随机&lt;/li&gt;
&lt;li&gt;知乎使用了Bcrypy(好像)加密&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
    
      <category term="加密" scheme="http://yoursite.com/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>进程间的通信方式(IPC)</title>
    <link href="http://yoursite.com/2018/03/07/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F-IPC/"/>
    <id>http://yoursite.com/2018/03/07/进程间的通信方式-IPC/</id>
    <published>2018-03-07T15:47:10.000Z</published>
    <updated>2018-03-07T15:49:17.891Z</updated>
    
    <content type="html"><![CDATA[<ol><li><code>管道</code>（Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。</li><li><code>命名管道</code>（named pipe）：命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。</li><li><code>信号</code>（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。</li><li><code>消息（Message）队列</code>：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺</li><li><code>共享内存</code>：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。</li><li><code>内存映射</code>（mapped memory）：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。</li><li><code>信号量</code>（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。</li><li><code>套接口</code>（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;code&gt;管道&lt;/code&gt;（Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;命名管道&lt;/code&gt;（named pipe）：命名管道克服了管道没有名字的限制，因此，除具有管
      
    
    </summary>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Django运行方式以及处理流程简介(转载)</title>
    <link href="http://yoursite.com/2018/03/07/Django%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E7%AE%80%E4%BB%8B-%E8%BD%AC%E8%BD%BD/"/>
    <id>http://yoursite.com/2018/03/07/Django运行方式以及处理流程简介-转载/</id>
    <published>2018-03-07T11:07:58.000Z</published>
    <updated>2018-03-07T12:09:44.924Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Django的运行方式"><a href="#Django的运行方式" class="headerlink" title="Django的运行方式"></a>Django的运行方式</h2><p>运行Django项目的方法很多，这里主要介绍一下常用的方法。一种是在开发和调试中经常用到<code>runserver</code>方法，使用Django自己的web server(WSGI Server)；另外一种就是使用<code>fastcgi，uWSGIt</code>等协议运行Django项目。</p><a id="more"></a><h3 id="runserver方法"><a href="#runserver方法" class="headerlink" title="runserver方法"></a>runserver方法</h3><p>runserver方法是调试Django时经常用到的运行方式，它使用Django自带的WSGI Server运行，主要在测试和开发中使用，使用方法如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Usage: manage.py runserver [options] [optional port number, <span class="keyword">or</span> ipaddr:port]</span><br><span class="line"><span class="comment"># python manager.py runserver    # default port is 8000</span></span><br><span class="line"><span class="comment"># python manager.py runserver 8080</span></span><br><span class="line"><span class="comment"># python manager.py runserver 127.0.0.1:9090</span></span><br></pre></td></tr></table></figure></p><p>看一下manager.py的源码，你会发现上面的命令其实是通过Django的execute_from_command_line方法执行了内部实现的runserver命令，那么现在看一下runserver具体做了什么。。</p><p>看了源码之后，可以发现runserver命令主要做了两件事情：</p><pre><code>1). 解析参数，并通过django.core.servers.basehttp.get_internal_wsgi_application方法获取wsgi handler;2). 根据ip_address和port生成一个WSGIServer对象，接受用户请求</code></pre><p>get_internal_wsgi_application的源码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_internal_wsgi_application</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Loads and returns the WSGI application as configured by the user in</span></span><br><span class="line"><span class="string">    ``settings.WSGI_APPLICATION``. With the default ``startproject`` layout,</span></span><br><span class="line"><span class="string">    this will be the ``application`` object in ``projectname/wsgi.py``.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This function, and the ``WSGI_APPLICATION`` setting itself, are only useful</span></span><br><span class="line"><span class="string">    for Django's internal servers (runserver, runfcgi); external WSGI servers</span></span><br><span class="line"><span class="string">    should just be configured to point to the correct application object</span></span><br><span class="line"><span class="string">    directly.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If settings.WSGI_APPLICATION is not set (is ``None``), we just return</span></span><br><span class="line"><span class="string">    whatever ``django.core.wsgi.get_wsgi_application`` returns.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line">    app_path = getattr(settings, <span class="string">'WSGI_APPLICATION'</span>)</span><br><span class="line">    <span class="keyword">if</span> app_path <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> get_wsgi_application()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> import_by_path(</span><br><span class="line">        app_path,</span><br><span class="line">        error_prefix=<span class="string">"WSGI application '%s' could not be loaded; "</span> % app_path</span><br><span class="line">    )</span><br></pre></td></tr></table></figure></p><p>通过上面的代码我们可以知道，Django会先根据settings中的WSGI_APPLICATION来获取handler；在创建project的时候，Django会默认创建一个wsgi.py文件，而settings中的WSGI_APPLICATION配置也会默认指向这个文件。看一下这个wsgi.py文件，其实它也和上面的逻辑一样，最终调用get_wsgi_application实现。</p><h2 id="uWSGI方法"><a href="#uWSGI方法" class="headerlink" title="uWSGI方法"></a>uWSGI方法</h2><p>uWSGI + Nginx的方法是现在最常见的在生产环境中运行Django的方法，要了解这种方法，首先要了解一下WSGI和uWSGI协议。</p><p>WSGI，全称<code>Web Server Gateway Interface</code>，或者<code>Python Web Server Gateway Interface</code>，是为Python语言定义的Web服务器和Web应用程序或框架之间的一种简单而通用的接口，基于现存的<code>CGI标准</code>而设计的。WSGI其实就是一个网关(Gateway)，其作用就是在协议之间进行转换。(PS: 这里只对WSGI做简单介绍，想要了解更多的内容可自行搜索)</p><p><code>uWSGI是一个Web服务器</code>，它实现了WSGI协议、uwsgi、http等协议。<code>注意!</code>uwsgi是一种通信协议，而uWSGI是实现uwsgi协议和WSGI协议的Web服务器。uWSGI具有超快的性能、低内存占用和多app管理等优点。以我的博客为例，uWSGI的xml配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uwsgi</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 端口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">socket</span>&gt;</span>:7600<span class="tag">&lt;/<span class="name">socket</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">stats</span>&gt;</span>:40000<span class="tag">&lt;/<span class="name">stats</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 系统环境变量 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">env</span>&gt;</span>DJANGO_SETTINGS_MODULE=geek_blog.settings<span class="tag">&lt;/<span class="name">env</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定的python WSGI模块 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>django.core.handlers.wsgi:WSGIHandler()<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">processes</span>&gt;</span>6<span class="tag">&lt;/<span class="name">processes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">master</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">master-as-root</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 超时设置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">harakiri</span>&gt;</span>60<span class="tag">&lt;/<span class="name">harakiri</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">harakiri-verbose</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">daemonize</span>&gt;</span>/var/app/log/blog/uwsgi.log<span class="tag">&lt;/<span class="name">daemonize</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- socket的监听队列大小 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listen</span>&gt;</span>32768<span class="tag">&lt;/<span class="name">listen</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 内部超时时间 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">socket-timeout</span>&gt;</span>60<span class="tag">&lt;/<span class="name">socket-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">uwsgi</span>&gt;</span></span><br></pre></td></tr></table></figure><p>uWSGI和Nginx一起使用的配置方法就不在这里说明了，网上教程很多，需要的可以自行搜索。</p><h2 id="HTTP请求处理流程"><a href="#HTTP请求处理流程" class="headerlink" title="HTTP请求处理流程"></a>HTTP请求处理流程</h2><p>Django和其他Web框架一样，HTTP的处理流程基本类似：接受request，返回response内容。Django的具体处理流程大致如下图所示：</p><p><strong>1. 加载project settings</strong></p><p>在通过django-admin.py创建project的时候，Django会自动生成默认的settings文件和manager.py等文件，在创建WSGIServer之前会执行下面的引用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br></pre></td></tr></table></figure></p><p>上面引用在执行时，会读取os.environ中的DJANGO_SETTINGS_MODULE配置，加载项目配置文件，生成settings对象。所以，在manager.py文件中你可以看到，在获取WSGIServer之前，会先将project的settings路径加到os路径中。</p><p><strong>2. 创建WSGIServer</strong></p><p>不管是使用runserver还是uWSGI运行Django项目，在启动时都会调用django.core.servers.basehttp中的run()方法，创建一个django.core.servers.basehttp.WSGIServer类的实例，之后调用其serve_forever()方法启动HTTP服务。run方法的源码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(addr, port, wsgi_handler, ipv6=False, threading=False)</span>:</span></span><br><span class="line">    server_address = (addr, port)</span><br><span class="line">    <span class="keyword">if</span> threading:</span><br><span class="line">        httpd_cls = type(str(<span class="string">'WSGIServer'</span>), (socketserver.ThreadingMixIn, WSGIServer), &#123;&#125;)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        httpd_cls = WSGIServer</span><br><span class="line">    httpd = httpd_cls(server_address, WSGIRequestHandler, ipv6=ipv6)</span><br><span class="line">    <span class="comment"># Sets the callable application as the WSGI application that will receive requests</span></span><br><span class="line">    httpd.set_app(wsgi_handler)</span><br><span class="line">    httpd.serve_forever()</span><br></pre></td></tr></table></figure></p><p>如上，我们可以看到：在创建WSGIServer实例的时候会指定HTTP请求的Handler，上述代码使用WSGIRequestHandler。当用户的HTTP请求到达服务器时，WSGIServer会创建WSGIRequestHandler实例，使用其handler方法来处理HTTP请求(其实最终是调用wsgiref.handlers.BaseHandler中的run方法处理)。WSGIServer通过set_app方法设置一个可调用(callable)的对象作为application，上面提到的handler方法最终会调用设置的application处理request，并返回response。</p><p>其中，WSGIServer继承自wsgiref.simple_server.WSGIServer，而WSGIRequestHandler继承自wsgiref.simple_server.WSGIRequestHandler，wsgiref是Python标准库给出的WSGI的参考实现。其源码可自行到<a href="https://pypi.python.org/pypi/wsgiref" target="_blank" rel="noopener">wsgiref</a>参看，这里不再细说.</p><p><strong>3. 处理Request</strong></p><p>第二步中说到的application，在Django中一般是django.core.handlers.wsgi.WSGIHandler对象，WSGIHandler继承自django.core.handlers.base.BaseHandler，这个是Django处理request的核心逻辑，它会创建一个WSGIRequest实例，而WSGIRequest是从http.HttpRequest继承而来</p><p><strong>4. 返回Response</strong></p><p>上面提到的BaseHandler中有个get_response方法，该方法会先加载Django项目的ROOT_URLCONF，然后根据url规则找到对应的view方法(类)，view逻辑会根据request实例生成并返回具体的response。</p><p>在Django返回结果之后，第二步中提到wsgiref.handlers.BaseHandler.run方法会调用finish_response结束请求，并将内容返回给用户。</p><h2 id="Django处理Request的详细流程"><a href="#Django处理Request的详细流程" class="headerlink" title="Django处理Request的详细流程"></a>Django处理Request的详细流程</h2><p>上述的第三步和第四步逻辑只是大致说了一下处理过程，Django在处理request的时候其实做了很多事情，下面我们详细的过一下。首先给大家分享两个网上看到的Django流程图：<br><img src="http://upload-images.jianshu.io/upload_images/2952111-5e684abfea788d78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="django.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/2952111-f72ffe64a49bd4d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="django_flow.png"></p><p>上面的两张流程图可以大致描述Django处理request的流程，按照流程图2的标注，可以分为以下几个步骤：</p><pre><code>1. 用户通过浏览器请求一个页面2. 请求到达Request Middlewares，中间件对request做一些预处理或者直接response请求3. URLConf通过urls.py文件和请求的URL找到相应的View4. View Middlewares被访问，它同样可以对request做一些处理或者直接返回response5. 调用View中的函数6. View中的方法可以选择性的通过Models访问底层的数据7. 所有的Model-to-DB的交互都是通过manager完成的8. 如果需要，Views可以使用一个特殊的Context9. Context被传给Template用来生成页面a. Template使用Filters和Tags去渲染输出b. 输出被返回到Viewc. HTTPResponse被发送到Response Middlewaresd. 任何Response Middlewares都可以丰富response或者返回一个完全不同的responsee. Response返回到浏览器，呈现给用户</code></pre><p>上述流程中最主要的几个部分分别是：Middleware(中间件，包括request, view, exception, response)，URLConf(url映射关系)，Template(模板系统)，下面一一介绍一下。</p><p><strong>1. Middleware(中间件)</strong></p><p>Middleware并不是Django所独有的东西，在其他的Web框架中也有这种概念。在Django中，Middleware可以渗入处理流程的四个阶段：request，view，response和exception，相应的，在每个Middleware类中都有rocess_request，process_view， process_response 和 process_exception这四个方法。你可以定义其中任意一个或多个方法，这取决于你希望该Middleware作用于哪个处理阶段。每个方法都可以直接返回response对象。</p><p>Middleware是在Django BaseHandler的load_middleware方法执行时加载的，加载之后会建立四个列表作为处理器的实例变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_request_middleware：process_request方法的列表</span><br><span class="line"></span><br><span class="line">_view_middleware：process_view方法的列表</span><br><span class="line"></span><br><span class="line">_response_middleware：process_response方法的列表</span><br><span class="line"></span><br><span class="line">_exception_middleware：process_exception方法的列表</span><br></pre></td></tr></table></figure></p><p>Django的中间件是在其配置文件(settings.py)的MIDDLEWARE_CLASSES元组中定义的。在MIDDLEWARE_CLASSES中，中间件组件用字符串表示：指向中间件类名的完整Python路径。例如GeekBlog项目的配置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MIDDLEWARE_CLASSES = (</span><br><span class="line">    <span class="string">'django.middleware.cache.UpdateCacheMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.common.CommonMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.cache.FetchFromCacheMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.sessions.middleware.SessionMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.csrf.CsrfViewMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.auth.middleware.AuthenticationMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.messages.middleware.MessageMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.locale.LocaleMiddleware'</span>,</span><br><span class="line">    <span class="string">'geek_blog.middlewares.MobileDetectionMiddleware'</span>,    <span class="comment"># 自定义的Middleware</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>Django项目的安装并不强制要求任何中间件，如果你愿意，MIDDLEWARE_CLASSES可以为空。中间件出现的顺序非常重要：在request和view的处理阶段，Django按照MIDDLEWARE_CLASSES中出现的顺序来应用中间件，而在response和exception异常处理阶段，Django则按逆序来调用它们。也就是说，Django将MIDDLEWARE_CLASSES视为view函数外层的顺序包装子：在request阶段按顺序从上到下穿过，而在response则反过来。</p><p>以下两张图可以更好地帮助你理解：</p><p><img src="http://xianglong.qiniudn.com/django_middleware_flow.png" alt="Django Middleware流程1"></p><p><img src="http://xianglong.qiniudn.com/django_middleware_flow2.png" alt="Django Middleware流程图2"></p><p><strong>2. URLConf(URL映射)</strong></p><p>如果处理request的中间件都没有直接返回response，那么Django会去解析用户请求的URL。URLconf就是Django所支撑网站的目录。它的本质是URL模式以及要为该URL模式调用的视图函数之间的映射表。通过这种方式可以告诉Django，对于这个URL调用这段代码，对于那个URL调用那段代码。具体的，在Django项目的配置文件中有ROOT_URLCONF常量，这个常量加上根目录”/“，作为参数来创建django.core.urlresolvers.RegexURLResolver的实例，然后通过它的resolve方法解析用户请求的URL，找到第一个匹配的view。</p><p>其他有关URLConf的内容，这里不再具体介绍，大家可以看<a href="http://djangobook.py3k.cn/2.0/chapter03/" target="_blank" rel="noopener">DjangoBook</a>了解。</p><p><strong>3. Template(模板)</strong></p><p>大部分web框架都有自己的Template(模板)系统，Django也是。但是，Django模板不同于Mako模板和jinja2模板，在Django模板不能直接写Python代码，只能通过额外的定义filter和template tag实现。由于本文主要介绍Django流程，模板内容就不过多介绍。</p><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><ol><li><a href="http://www.nowamagic.net/academy/detail/1330328" target="_blank" rel="noopener">uWSGI Web服务器介绍</a>  </li><li><a href="http://blog.csdn.net/on_1y/article/details/18818081" target="_blank" rel="noopener">wsgiref源码分析</a>  </li><li><a href="http://www.tuicool.com/articles/aYBRBz" target="_blank" rel="noopener">用Python写一个简单的Web框架</a>  </li><li><a href="http://my.oschina.net/tenking/blog/29439" target="_blank" rel="noopener">Django 结构及处理流程分析</a></li><li><a href="http://blog.csdn.net/yongche_shi/article/details/49513431" target="_blank" rel="noopener">Django运行方式及处理流程总结</a> </li></ol><p>PS: 以上代码和内容都是基于Django 1.6.5版本，其他版本可能与其不同，请参考阅读。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Django的运行方式&quot;&gt;&lt;a href=&quot;#Django的运行方式&quot; class=&quot;headerlink&quot; title=&quot;Django的运行方式&quot;&gt;&lt;/a&gt;Django的运行方式&lt;/h2&gt;&lt;p&gt;运行Django项目的方法很多，这里主要介绍一下常用的方法。一种是在开发和调试中经常用到&lt;code&gt;runserver&lt;/code&gt;方法，使用Django自己的web server(WSGI Server)；另外一种就是使用&lt;code&gt;fastcgi，uWSGIt&lt;/code&gt;等协议运行Django项目。&lt;/p&gt;
    
    </summary>
    
      <category term="Django" scheme="http://yoursite.com/categories/Django/"/>
    
    
      <category term="Django" scheme="http://yoursite.com/tags/Django/"/>
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>三种多路复用IO实现方式：select，poll，epoll</title>
    <link href="http://yoursite.com/2018/03/07/%E4%B8%89%E7%A7%8D%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8IO%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9Aselect%EF%BC%8Cpoll%EF%BC%8Cepoll/"/>
    <id>http://yoursite.com/2018/03/07/三种多路复用IO实现方式：select，poll，epoll/</id>
    <published>2018-03-07T07:43:44.000Z</published>
    <updated>2018-03-07T10:40:20.981Z</updated>
    
    <content type="html"><![CDATA[<p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p><p>在linux 没有实现epoll事件驱动机制之前，我们一般选择用select或者poll等IO多路复用的方法来实现并发服务程序。在大数据、高并发、集群等一些名词唱得火热之年代，select和poll的用武之地越来越有限，风头已经被epoll占尽。</p><p>简单来讲<br>select有3个缺点:</p><ol><li>连接数受限</li><li>查找配对速度慢</li><li>数据由内核拷贝到用户态</li></ol><p>poll改善了第一个缺点<br>epoll改了三个缺点.</p><a id="more"></a><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合：</p><ol><li><p>当客户处理多个描述符时（一般是交互式输入和网络套接口），必须使用I/O复用。</p></li><li><p>当一个客户同时处理多个套接口时，这种情况是可能的，但很少出现。</p></li><li><p>如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。</p></li><li><p>如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。</p></li><li><p>如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。</p></li></ol><h2 id="select、poll、epoll简介"><a href="#select、poll、epoll简介" class="headerlink" title="select、poll、epoll简介"></a>select、poll、epoll简介</h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p><strong>基本原理：</strong>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</p><p><strong>基本流程，如图所示：</strong></p><p><strong><img src="https://images2015.cnblogs.com/blog/667911/201604/667911-20160426172125064-1263315531.png" alt=""></strong></p><p>　　select目前几乎在所有的平台上支持，<code>其良好跨平台支持也是它的一个优点</code>。<code>select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制</code>，在Linux上一般为1024，<code>可以通过修改宏定义甚至重新编译内核的方式提升这一限制</code>，但是这样也会造成效率的降低。</p><p><code>select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理</code>。这样所带来的缺点是：</p><p>1、select最大的缺陷就是单个进程所打开的FD是有一定限制的，它由FD_SETSIZE设置，默认值是1024。</p><p>　　一般来说这个数目和系统内存关系很大，<code>具体数目可以cat /proc/sys/fs/file-max察看</code>。32位机默认是1024个。64位机默认是2048.</p><p>2、对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低。</p><p>　　当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。这会浪费很多CPU时间。<code>如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询</code>，这正是epoll与kqueue做的。</p><p><code>3、需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。</code></p><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p><strong>基本原理：</strong><code>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间</code>，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。</p><p><strong>它没有最大连接数的限制，<code>原因是它是基于链表来存储的</code>，但是同样有一个缺点：</strong></p><p><code>1）大量的fd的数组被整体复制于用户态和内核地址空间之间</code>，而不管这样的复制是不是有意义。</p><p><code>2）poll还有一个特点是“水平触发”</code>，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</p><p><strong>注意：</strong>从上面看，select和poll都需要在返回后，<code>通过遍历文件描述符来获取已经就绪的socket</code>。事实上，<code>同时连接的大量客户端在一时刻可能只有很少的处于就绪状态</code>，因此随着监视的描述符数量的增长，其效率也会线性下降。</p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>　　epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。<code>epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次</code>。</p><p><strong>基本原理：</strong><code>epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次</code>。还有一个特点是，<code>epoll使用“事件”的就绪通知方式</code>，通过epoll_ctl注册fd，<code>一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd</code>，epoll_wait便可以收到通知。</p><p><strong>epoll的优点：</strong></p><p><code>1、没有最大并发连接的限制</code>，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。</p><p><code>2、效率提升，不是轮询的方式，不会随着FD数目的增加效率下降</code>。</p><p>　　只有活跃可用的FD才会调用callback函数；<code>即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关</code>，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</p><p><code>3、内存拷贝</code>，利用mmap()文件映射内存加速与内核空间的消息传递；<code>即epoll使用mmap减少复制开销</code>。</p><p>epoll对文件描述符的操作有两种模式：<code>LT（level trigger）和ET（edge trigger）</code>。LT模式是默认模式，LT模式与ET模式的区别如下：</p><p>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序可以不立即处理该事件</code>。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</p><p>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序必须立即处理该事件</code>。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p><h2 id="select、poll、epoll对比"><a href="#select、poll、epoll对比" class="headerlink" title="select、poll、epoll对比"></a>select、poll、epoll对比</h2><h3 id="1、支持一个进程所能打开的最大连接数"><a href="#1、支持一个进程所能打开的最大连接数" class="headerlink" title="1、支持一个进程所能打开的最大连接数"></a><strong>1、支持一个进程所能打开的最大连接数</strong></h3><p><img src="https://images2015.cnblogs.com/blog/667911/201604/667911-20160426172727142-152295964.png" alt=""></p><h3 id="2、FD剧增后带来的IO效率问题"><a href="#2、FD剧增后带来的IO效率问题" class="headerlink" title="2、FD剧增后带来的IO效率问题"></a><strong>2、FD剧增后带来的IO效率问题</strong></h3><p><img src="https://images2015.cnblogs.com/blog/667911/201604/667911-20160426173035611-62395960.png" alt=""></p><h3 id="3、消息传递方式"><a href="#3、消息传递方式" class="headerlink" title="3、消息传递方式"></a><strong>3、消息传递方式</strong></h3><p><img src="https://images2015.cnblogs.com/blog/667911/201604/667911-20160426172915283-1257843409.png" alt=""></p><p>综上，在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点：</p><p>1、表面上看epoll的性能最好，<code>但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好</code>，毕竟epoll的通知机制需要很多函数回调。</p><p><code>2、select低效是因为每次它都需要轮询</code>。但低效也是相对的，视情况而定，也可通过良好的设计改善。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.cnblogs.com/jeakeven/p/5435916.html" target="_blank" rel="noopener">https://www.cnblogs.com/jeakeven/p/5435916.html</a></li><li><a href="http://blog.csdn.net/davidsguo008/article/details/73556811" target="_blank" rel="noopener">http://blog.csdn.net/davidsguo008/article/details/73556811</a></li><li><a href="https://www.cnblogs.com/wangyufu/p/6593515.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangyufu/p/6593515.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。&lt;/p&gt;
&lt;p&gt;在linux 没有实现epoll事件驱动机制之前，我们一般选择用select或者poll等IO多路复用的方法来实现并发服务程序。在大数据、高并发、集群等一些名词唱得火热之年代，select和poll的用武之地越来越有限，风头已经被epoll占尽。&lt;/p&gt;
&lt;p&gt;简单来讲&lt;br&gt;select有3个缺点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;连接数受限&lt;/li&gt;
&lt;li&gt;查找配对速度慢&lt;/li&gt;
&lt;li&gt;数据由内核拷贝到用户态&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;poll改善了第一个缺点&lt;br&gt;epoll改了三个缺点.&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="多任务处理" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>浅谈TCP和UDP的区别以及应用</title>
    <link href="http://yoursite.com/2018/03/07/%E6%B5%85%E8%B0%88TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2018/03/07/浅谈TCP和UDP的区别以及应用/</id>
    <published>2018-03-06T18:28:32.000Z</published>
    <updated>2018-03-07T04:10:12.333Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="TCP和UDP区别"></a>TCP和UDP区别</h2><p>TCP(<code>Transmission Control Protocol</code>)—<code>传输控制协议</code>,<code>提供的是面向连接、可靠的字节流服务</code>。当客户和服务器彼此交换数据前，必须先在双方之间建立一个TCP连接，之后才能传输数据。TCP提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。<br>UDP(<code>User Data Protocol</code>)—<code>用户数据报协议</code>，<code>是一个简单的面向数据报的运输层协议</code>。在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol><li><p>HTTP协议在运输层采用的就是<code>TCP协议</code>，在浏览器中输入IP地址后，与服务器建立连接，采用的就是TCP协议，是一种面向连接、可靠的字节流服务。</p></li><li><p>当强调传输性能而不是传输的完整性时，如：音频、多媒体应用和视频会议时，<code>UDP</code>是最好的选择。另外，腾讯QQ采用也是UDP协议。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;TCP和UDP区别&quot;&gt;&lt;a href=&quot;#TCP和UDP区别&quot; class=&quot;headerlink&quot; title=&quot;TCP和UDP区别&quot;&gt;&lt;/a&gt;TCP和UDP区别&lt;/h2&gt;&lt;p&gt;TCP(&lt;code&gt;Transmission Control Protocol&lt;/c
      
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Session和Cookie的区别与联系</title>
    <link href="http://yoursite.com/2018/03/07/%E6%B5%85%E8%B0%88Session%E5%92%8CCookie%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB/"/>
    <id>http://yoursite.com/2018/03/07/浅谈Session和Cookie的区别与联系/</id>
    <published>2018-03-06T18:27:40.000Z</published>
    <updated>2018-03-06T19:01:04.896Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th style="text-align:left"></th><th style="text-align:left">Cookie</th><th style="text-align:left">Session</th></tr></thead><tbody><tr><td style="text-align:left">储存位置</td><td style="text-align:left">客户端</td><td style="text-align:left">服务器端</td></tr><tr><td style="text-align:left">目的</td><td style="text-align:left">跟踪会话，也可以保存用户偏好设置或者保存用户名密码等</td><td style="text-align:left">跟踪会话</td></tr><tr><td style="text-align:left">安全性</td><td style="text-align:left">不安全</td><td style="text-align:left">安全</td></tr></tbody></table><p>session技术是要使用到cookie的，之所以出现session技术，主要是为了安全。</p><a id="more"></a><h2 id="Session的概念"><a href="#Session的概念" class="headerlink" title="Session的概念"></a>Session的概念</h2><p>Session 是存放在服务器端的，类似于Session结构来存放用户数据，当浏览器 第一次发送请求时，服务器自动生成了一个Session和一个Session ID用来唯一标识这个Session，并将其通过响应发送到浏览器。当浏览器第二次发送请求，会将前一次服务器响应中的Session ID放在请求中一并发送到服务器上，服务器从请求中提取出Session ID，并和保存的所有Session ID进行对比，找到这个用户对应的Session。</p><p>一般情况下，服务器会在一定时间内（默认30分钟）保存这个 Session，过了时间限制，就会销毁这个Session。在销毁之前，程序员可以将用户的一些数据以Key和Value的形式暂时存放在这个 Session中。当然，也有使用数据库将这个Session序列化后保存起来的，这样的好处是没了时间的限制，坏处是随着时间的增加，这个数据 库会急速膨胀，特别是访问量增加的时候。一般还是采取前一种方式，以减轻服务器压力。</p><h2 id="cookie的概念"><a href="#cookie的概念" class="headerlink" title="cookie的概念"></a>cookie的概念</h2><p>Cookie意为“甜饼”，是由W3C组织提出，最早由Netscape社区发展的一种机制。目前Cookie已经成为标准，所有的主流浏览器如IE、Netscape、Firefox、Opera等都支持Cookie。</p><p>由于HTTP是一种无状态的协议，服务器单从网络连接上无从知道客户身份。怎么办呢？就给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理。</p><p>Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。</p><h2 id="Session的客户端实现形式（即Session-ID的保存方法）"><a href="#Session的客户端实现形式（即Session-ID的保存方法）" class="headerlink" title="Session的客户端实现形式（即Session ID的保存方法）"></a>Session的客户端实现形式（即Session ID的保存方法）</h2><p>一般浏览器提供了两种方式来保存，还有一种是程序员使用html隐藏域的方式自定义实现：</p><ol><li><p>使用Cookie来保存，这是最常见的方法，本文“记住我的登录状态”功能的实现正式基于这种方式的。服务器通过设置Cookie的方式将Session ID发送到浏览器。如果我们不设置这个过期时间，那么这个Cookie将不存放在硬盘上，当浏览器关闭的时候，Cookie就消失了，这个Session ID就丢失了。如果我们设置这个时间为若干天之后，那么这个Cookie会保存在客户端硬盘中，即使浏览器关闭，这个值仍然存在，下次访问相应网站时，同 样会发送到服务器上。</p></li><li><p>使用URL附加信息的方式，也就是像我们经常看到JSP网站会有<code>aaa.jsp?JSESSIONID=*</code>一样的。这种方式和第一种方式里面不设置Cookie过期时间是一样的。</p></li><li><p>第三种方式是在页面表单里面增加隐藏域，这种方式实际上和第二种方式一样，只不过前者通过GET方式发送数据，后者使用POST方式发送数据。但是明显后者比较麻烦。</p></li></ol><h2 id="cookie与session的区别"><a href="#cookie与session的区别" class="headerlink" title="cookie与session的区别"></a>cookie与session的区别</h2><p>cookie数据保存在客户端，session数据保存在服务器端。</p><p>简 单的说，当你登录一个网站的时候，如果web服务器端使用的是session,那么所有的数据都保存在服务器上面，客户端每次请求服务器的时候会发送 当前会话的sessionid，服务器根据当前sessionid判断相应的用户数据标志，以确定用户是否登录，或具有某种权限。由于数据是存储在服务器 上面，所以你不能伪造，但是如果你能够获取某个登录用户的sessionid，用特殊的浏览器伪造该用户的请求也是能够成功的。sessionid是服务 器和客户端链接时候随机分配的，一般来说是不会有重复，但如果有大量的并发请求，也不是没有重复的可能性，我曾经就遇到过一次。登录某个网站，开始显示的 是自己的信息，等一段时间超时了，一刷新，居然显示了别人的信息。</p><p>如果浏览器使用的是 cookie，那么所有的数据都保存在浏览器端，比如你登录以后，服务器设置了 cookie用户名(username),那么，当你再次请求服务器的时候，浏览器会将username一块发送给服务器，这些变量有一定的特殊标记。服 务器会解释为 cookie变量。所以只要不关闭浏览器，那么 cookie变量便一直是有效的，所以能够保证长时间不掉线。如果你能够截获某个用户的 cookie变量，然后伪造一个数据包发送过去，那么服务器还是认为你是合法的。所以，使用 cookie被攻击的可能性比较大。如果设置了的有效时间，那么它会将 cookie保存在客户端的硬盘上，下次再访问该网站的时候，浏览器先检查有没有 cookie，如果有的话，就读取该 cookie，然后发送给服务器。如果你在机器上面保存了某个论坛 cookie，有效期是一年，如果有人入侵你的机器，将你的 cookie拷走，然后放在他的浏览器的目录下面，那么他登录该网站的时候就是用你的的身份登录的。所以 cookie是可以伪造的。当然，伪造的时候需要主意，直接copy cookie文件到 cookie目录，浏览器是不认的，他有一个index.dat文件，存储了 cookie文件的建立时间，以及是否有修改，所以你必须先要有该网站的 cookie文件，并且要从保证时间上骗过浏览器，曾经在学校的vbb论坛上面做过试验，copy别人的 cookie登录，冒用了别人的名义发帖子，完全没有问题。</p><p>Session是由应用服务器维持的一个服务器端的存储空间，用户在连接服务器时，会由服务器生成一个唯一的SessionID,用该SessionID 为标识符来存取服务器端的Session存储空间。而SessionID这一数据则是保存到客户端，用Cookie保存的，用户提交页面时，会将这一 SessionID提交到服务器端，来存取Session数据。这一过程，是不用开发人员干预的。所以一旦客户端禁用Cookie，那么Session也会失效。</p><p>服务器也可以通过URL重写的方式来传递SessionID的值，因此不是完全依赖Cookie。如果客户端Cookie禁用，则服务器可以自动通过重写URL的方式来保存Session的值，并且这个过程对程序员透明。</p><p>可以试一下，即使不写Cookie，在使用request.getCookies();取出的Cookie数组的长度也是1，而这个Cookie的名字就是JSESSIONID，还有一个很长的二进制的字符串，是SessionID的值。</p><h2 id="Session与Cookie的应用场景"><a href="#Session与Cookie的应用场景" class="headerlink" title="Session与Cookie的应用场景"></a>Session与Cookie的应用场景</h2><p>Cookies是属于Session对象的一种。但有不同，Cookies不会占服务器资源，是存在客服端内存或者一个cookie的文本文件中；而“Session”则会占用服务器资源。所以，尽量不要使用Session，而使用Cookies。但是我们一般认为cookie是不可靠的，session是可靠地，但是目前很多著名的站点也都以来cookie。有时候为了解决禁用cookie后的页面处理，通常采用url重写技术，调用session中大量有用的方法从session中获取数据后置入页面。</p><p>Cookies与Session的应用场景：<br>Cookies的安全性能一直是倍受争议的。虽然Cookies是保存在本机上的，但是其信息的完全可见性且易于本地编辑性，往往可以引起很多的安全问题。所以Cookies到底该不该用，到底该怎样用，就有了一个需要给定的底线。</p><p>先来看看，网站的敏感数据有哪些。</p><p>登陆验证信息。一般采用Session(“Logon”)＝true or false的形式。<br>用户的各种私人信息，比如姓名等，某种情况下，需要保存在Session里<br>需要在页面间传递的内容信息，比如调查工作需要分好几步。每一步的信息都保存在Session里，最后在统一更新到数据库。</p><p>当然还会有很多，这里列举一些比较典型的<br>假如，一个人孤僻到不想碰Session，因为他认为，如果用户万一不小心关闭了浏览器，那么之前保存的数据就全部丢失了。所以，他出于好意，决定把这些用Session的地方，都改成用Cookies来存储，这完全是可行的，且基本操作和用Session一模一样。那么，下面就针对以上的3个典型例子，做一个分析<br>很显然，只要某个有意非法入侵者，知道该网站验证登陆信息的Session变量是什么，那么他就可以事先编辑好该Cookies，放入到Cookies目录中，这样就可以顺利通过验证了。这是不是很可怕？<br>Cookies完全是可见的，即使程序员设定了Cookies的生存周期（比如只在用户会话有效期内有效），它也是不安全的。假设，用户忘了关浏览器 或者一个恶意者硬性把用户给打晕，那用户的损失将是巨大的。<br>这点如上点一样，很容易被它人窃取重要的私人信息。但，其还有一个问题所在是，可能这些数据信息量太大，而使得Cookies的文件大小剧增。这可不是用户希望所看到的。</p><p>显然，Cookies并不是那么一块好啃的小甜饼。但，Cookies的存在，当然有其原因。它给予程序员更多发挥编程才能的空间。所以，使用Cookies该有个底线。这个底线一般来说，遵循以下原则。<br>不要保存私人信息。<br>任何重要数据，最好通过加密形式来保存数据（最简单的可以用URLEncode，当然也可以用完善的可逆加密方式，遗憾的是，最好不要用md5来加密）。<br>是否保存登陆信息，需有用户自行选择。<br>长于10K的数据，不要用到Cookies。<br>也不要用Cookies来玩点让客户惊喜的小游戏。</p><h2 id="cookie最典型的应用是："><a href="#cookie最典型的应用是：" class="headerlink" title="cookie最典型的应用是："></a>cookie最典型的应用是：</h2><ol><li><p>判断用户是否登陆过网站，以便下次登录时能够直接登录。如果我们删除cookie，则每次登录必须从新填写登录的相关信息。</p></li><li><p>另一个重要的应用是“购物车”中类的处理和设计。用户可能在一段时间内在同一家网站的不同页面选择不同的商品，可以将这些信息都写入cookie，在最后付款时从cookie中提取这些信息，当然这里面有了安全和性能问题需要我们考虑了。</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.cnblogs.com/andy-zhou/p/5360107.html#_caption_1" target="_blank" rel="noopener">https://www.cnblogs.com/andy-zhou/p/5360107.html#_caption_1</a></li><li><a href="http://blog.csdn.net/duan1078774504/article/details/51912868" target="_blank" rel="noopener">http://blog.csdn.net/duan1078774504/article/details/51912868</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;Cookie&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;Session&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;储存位置&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;客户端&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;服务器端&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;目的&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;跟踪会话，也可以保存用户偏好设置或者保存用户名密码等&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;跟踪会话&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;安全性&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;不安全&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;安全&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;session技术是要使用到cookie的，之所以出现session技术，主要是为了安全。&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>如何理解操作系统中的同步和异步、阻塞和非阻塞</title>
    <link href="http://yoursite.com/2018/03/07/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E3%80%81%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E/"/>
    <id>http://yoursite.com/2018/03/07/如何理解操作系统中的同步和异步、阻塞和非阻塞/</id>
    <published>2018-03-06T17:29:38.000Z</published>
    <updated>2018-03-09T06:28:47.749Z</updated>
    
    <content type="html"><![CDATA[<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。按照这个定义，其实绝大多数函数都是同步调用（例如sin, isdigit等）。但是一般而言，我们在说同步、异步的时候，特指那些需要其他部件协作或者需要一定时间完成的任务。</p><p>同步，可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是出于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。</p><p>最常见的例子就是 SendMessage。该函数发送一个消息给某个窗口，在对方处理完消息之前，这个函数不返回。当对方处理完毕以后，该函数才把消息处理函数所返回的 LRESULT值返回给调用者。</p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。由另外的并行程序执行这段代码，处理完这个调用的部件在完成后，通过状态、通知和回调来通知调用者。以CAsycSocket类为例（注意，CSocket从CAsyncSocket派生，但是起功能已经由异步转化为同步），当一个客户端通过调用 Connect函数发出一个连接请求后，调用者线程立刻可以朝下运行。当连接真正建立起来以后，socket底层会发送一个消息通知该对象。</p><p>这里提到执行部件和调用者通过三种途径返回结果：<code>状态、通知和回调</code>。可以使用哪一种依赖于执行部件的实现，除非执行部件提供多种选择，否则不受调用者控制。如果执行部件用状态来通知，那么调用者就需要每隔一定时间检查一次，效率就很低（有些初学多线程编程的人，总喜欢用一个循环去检查某个变量的值，这其实是一种很严重的错误）。如果是使用<code>通知</code>的方式，效率则很高，因为执行部件几乎不需要做额外的操作。至于回调函数，其实和通知没太多区别。</p><p>异步，执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。</p><a id="more"></a><h2 id="同步和异步类比"><a href="#同步和异步类比" class="headerlink" title="同步和异步类比"></a>同步和异步类比</h2><p>同步，就是实时处理，比如服务器一接收客户端请求，马上响应，这样客户端可以在最短的时间内得到结果，但是如果多个客户端，或者一个客户端发出的请求很频繁，服务器无法同步处理，就会造成涌塞。同步如打电话，通信双方不能断（我们是同时进行，同步），你一句我一句，这样的好处是，对方想表达的信息我马上能收到，但是，我在打着电话，我无法做别的事情。</p><p>异步，就是分时处理，服务器接收到客户端请求后并不是立即处理，而是等待服务器比较空闲的时候加以处理，可以避免涌塞。异步如收发收短信，对比打电话，打电话我一定要在电话的旁边听着，保证双方都在线，而收发短信，对方不用保证此刻我一定在手机旁，同时，我也不用时刻留意手机有没有来短信。这样的话，我看着视频，然后来了短信，我就处理短信（也可以不处理），接着再看视频。</p><p>对于写程序，同步往往会阻塞，没有数据过来，我就等着，异步则不会阻塞，没数据来我干别的事，有数据来去处理这些数据。</p><p>同步在一定程度上可以看做是单线程，这个线程请求一个方法后就待这个方法给他回复，否则他不往下执行（死心眼）。<br>异步在一定程度上可以看做是多线程的（废话，一个线程怎么叫异步），请求一个方法后，就不管了，继续执行其他的方法。</p><h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p>阻塞调用是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后才会返回。</p><p>有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。例如，我们在CSocket中调用Receive函数，如果缓冲区中没有数据，这个函数就会一直等待，直到有数据才返回。而此时，当前线程还会继续处理各种各样的消息。如果主窗口和调用函数在同一个线程中，除非你在特殊的界面操作函数中调用，其实主界面还是应该可以刷新。</p><p>socket接收数据的另外一个函数recv则是一个阻塞调用的例子。当socket工作在阻塞模式的时候，如果没有数据的情况下调用该函数，则当前线程就会被挂起，直到有数据为止。</p><h2 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h2><p>非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</p><h3 id="对象的阻塞模式和阻塞函数调用"><a href="#对象的阻塞模式和阻塞函数调用" class="headerlink" title="对象的阻塞模式和阻塞函数调用"></a>对象的阻塞模式和阻塞函数调用</h3><p>对象是否处于阻塞模式和函数是不是阻塞调用有很强的相关性，但是并不是一一对应的。阻塞对象上可以有非阻塞的调用方式，我们可以通过一定的API去轮询状态，在适当的时候调用阻塞函数，就可以避免阻塞。而对于非阻塞对象，调用特殊的函数也可以进入阻塞调用。函数select就是这样的一个例子。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;同步&quot;&gt;&lt;a href=&quot;#同步&quot; class=&quot;headerlink&quot; title=&quot;同步&quot;&gt;&lt;/a&gt;同步&lt;/h2&gt;&lt;p&gt;所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。按照这个定义，其实绝大多数函数都是同步调用（例如sin, isdigit等）。但是一般而言，我们在说同步、异步的时候，特指那些需要其他部件协作或者需要一定时间完成的任务。&lt;/p&gt;
&lt;p&gt;同步，可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是出于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。&lt;/p&gt;
&lt;p&gt;最常见的例子就是 SendMessage。该函数发送一个消息给某个窗口，在对方处理完消息之前，这个函数不返回。当对方处理完毕以后，该函数才把消息处理函数所返回的 LRESULT值返回给调用者。&lt;/p&gt;
&lt;h2 id=&quot;异步&quot;&gt;&lt;a href=&quot;#异步&quot; class=&quot;headerlink&quot; title=&quot;异步&quot;&gt;&lt;/a&gt;异步&lt;/h2&gt;&lt;p&gt;异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。由另外的并行程序执行这段代码，处理完这个调用的部件在完成后，通过状态、通知和回调来通知调用者。以CAsycSocket类为例（注意，CSocket从CAsyncSocket派生，但是起功能已经由异步转化为同步），当一个客户端通过调用 Connect函数发出一个连接请求后，调用者线程立刻可以朝下运行。当连接真正建立起来以后，socket底层会发送一个消息通知该对象。&lt;/p&gt;
&lt;p&gt;这里提到执行部件和调用者通过三种途径返回结果：&lt;code&gt;状态、通知和回调&lt;/code&gt;。可以使用哪一种依赖于执行部件的实现，除非执行部件提供多种选择，否则不受调用者控制。如果执行部件用状态来通知，那么调用者就需要每隔一定时间检查一次，效率就很低（有些初学多线程编程的人，总喜欢用一个循环去检查某个变量的值，这其实是一种很严重的错误）。如果是使用&lt;code&gt;通知&lt;/code&gt;的方式，效率则很高，因为执行部件几乎不需要做额外的操作。至于回调函数，其实和通知没太多区别。&lt;/p&gt;
&lt;p&gt;异步，执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="多任务处理" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Python3 nonlocal声明</title>
    <link href="http://yoursite.com/2018/03/06/Python3-nonlocal%E5%A3%B0%E6%98%8E/"/>
    <id>http://yoursite.com/2018/03/06/Python3-nonlocal声明/</id>
    <published>2018-03-06T06:58:07.000Z</published>
    <updated>2018-03-06T07:23:38.494Z</updated>
    
    <content type="html"><![CDATA[<p>前一节讲闭包时用到以下代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line">    series = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        series.append(new_value)</span><br><span class="line">        total = sum(series)</span><br><span class="line">        <span class="keyword">return</span> total/len(series)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> averager</span><br></pre></td></tr></table></figure></p><p>以上实现make_averager函数的方法效率不高。在如下示例中,我们把所有值存储在历史数列中，然后在每次调用averager时使用sum求和。更好的实现方式是，只存储目前的总和以及元素个数，然后使用这两个值计算平均数。以下是实现方式，这种实现方式存在缺陷，只是为了引出<code>nonlocal声明</code>。<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        total += new_value</span><br><span class="line">        <span class="keyword">return</span> total/count</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> averager</span><br></pre></td></tr></table></figure></p><p>尝试使用以上定义的函数，得到如下结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg = make_averager()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">10</span>)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">UnboundLocalError                         Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="number">-42</span>-ace390caaa2e&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; 1 avg(10)</span><br><span class="line"></span><br><span class="line">&lt;ipython-input<span class="number">-38</span><span class="number">-371</span>a27b41829&gt; <span class="keyword">in</span> averager(new_value)</span><br><span class="line">      <span class="number">3</span>     total = <span class="number">0</span></span><br><span class="line">      <span class="number">4</span>     <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">----&gt; 5         count += 1</span><br><span class="line">      <span class="number">6</span>         total += new_value</span><br><span class="line">      <span class="number">7</span>         <span class="keyword">return</span> total/count</span><br><span class="line"></span><br><span class="line">UnboundLocalError: local variable <span class="string">'count'</span> referenced before assignment</span><br></pre></td></tr></table></figure></p><p>问题是，当count是数字或任何不可变类型时，<code>count += 1</code>语句的作用其实与<code>count = count + 1</code>一样，因此我们在averager的定义体中为count赋值了，这样会把count变量变为局部变量，而不是自由变量。total变量也会受到这样的影响。</p><p>示例2 中没有遇到这样的问题是因为我们没有给series赋值，我们只是调用<code>series.append</code>，并把它传给sum和len。也就是说，我们利用了列表是可变的对象这一事实。</p><p>但是对数字和字符串、元组等不可变类型来说，只能读取，不能更新。如果尝试重新绑定，例如count += 1,其实会隐式的创建局部变量count。<code>这样count就不是自由变量了，也就不会保存在闭包中</code>。</p><p>为了解决这个问题，python3引入了<code>nonlocal声明</code>。他的作用是把变量标记为自由变量，即使在函数中变量赋予新值，也会变成自由变量。如果为nonlocal声明的变量赋予新值，闭包中保存的绑定会更新。正确版的make_averager的正确实现如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> count, total</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        total += new_value</span><br><span class="line">        <span class="keyword">return</span> total/count</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> averager</span><br></pre></td></tr></table></figure></p><p>这样一来，上面的错误就没有了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一节讲闭包时用到以下代码：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 示例2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;make_averager&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    series = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;averager&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(new_value)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        series.append(new_value)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        total = sum(series)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; total/len(series)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; averager&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;以上实现make_averager函数的方法效率不高。在如下示例中,我们把所有值存储在历史数列中，然后在每次调用averager时使用sum求和。更好的实现方式是，只存储目前的总和以及元素个数，然后使用这两个值计算平均数。以下是实现方式，这种实现方式存在缺陷，只是为了引出&lt;code&gt;nonlocal声明&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
      <category term="Python3 闭包" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/Python3-%E9%97%AD%E5%8C%85/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Python3 闭包</title>
    <link href="http://yoursite.com/2018/03/06/Python3-%E9%97%AD%E5%8C%85/"/>
    <id>http://yoursite.com/2018/03/06/Python3-闭包/</id>
    <published>2018-03-06T06:04:56.000Z</published>
    <updated>2018-03-06T06:56:44.733Z</updated>
    
    <content type="html"><![CDATA[<p>闭包是指延伸了作用域的函数，其中包含函数定义体中引用、但是不在定义体中定义的非全局变量。<br>闭包(closure)是函数式编程的重要的语法结构。闭包也是一种组织代码的结构，它同样提高了代码的可重复使用性。</p><p>当一个内嵌函数引用其外部作用域的变量,我们就会得到一个闭包. 总结一下,创建一个闭包必须满足以下几点:</p><ol><li>必须有一个内嵌函数</li><li>内嵌函数必须引用外部函数中的变量</li><li>外部函数的返回值必须是内嵌函数</li></ol><p>闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，这样调用函数时虽然定义作用域不可用了，但仍能使用那些绑定。<br><a id="more"></a></p><p>闭包的概念难以掌握，最好通过示例理解。</p><p>假如有个名为avg的函数，他的作用是计算不断增加的系列值得平均数。起初，avg是这样使用的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">10</span>)</span><br><span class="line"><span class="number">10.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">11</span>)</span><br><span class="line"><span class="number">10.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">12</span>)</span><br><span class="line"><span class="number">11.0</span></span><br></pre></td></tr></table></figure></p><p>初学者可能会用类来实现，如示例1<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Averager</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""docstring for Average."""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.series = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, new_value)</span>:</span></span><br><span class="line">        self.series.append(new_value)</span><br><span class="line">        total = sum(self.series)</span><br><span class="line">        <span class="keyword">return</span> total/len(self.series)</span><br></pre></td></tr></table></figure></p><p>Average的实例是可调用对象：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg = Averager()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">10</span>)</span><br><span class="line"><span class="number">10.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">11</span>)</span><br><span class="line"><span class="number">10.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">12</span>)</span><br><span class="line"><span class="number">11.0</span></span><br></pre></td></tr></table></figure></p><p>下面使用函数式实现，如示例2：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line">    series = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        series.append(new_value)</span><br><span class="line">        total = sum(series)</span><br><span class="line">        <span class="keyword">return</span> total/len(series)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> averager</span><br></pre></td></tr></table></figure></p><p>调用make_averager时，返回一个averager函数对象。每次调用averager时，他会把参数添加到系列值中，然后计算当前平均值，如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg = make_averager()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">10</span>)</span><br><span class="line"><span class="number">10.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">11</span>)</span><br><span class="line"><span class="number">10.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">12</span>)</span><br><span class="line"><span class="number">11.0</span></span><br></pre></td></tr></table></figure></p><p>注意，以上两个示例有共通之处：调用Averager()或make_averager()得到一个可调用对象avg，他会更新历史值，然后计算当前均值。示例1中，avg是Averager的实例；实例2中是内部函数averager。不管怎样，我们都只需要调用avg(n),把n放入系列值中，然后重新计算均值。</p><p>Averager()类的实例avg在哪里存储历史值很明显：self.series实例属性；但是第二个示例中的avg函数在哪里寻找series呢？</p><p>注意，series是make_averager函数的局部变量，因为那个函数的定义体中初始化了series：series = []。可是，调用avg(10)时，make_averager函数已经返回了，而他的本地作用域也一去不复返了。</p><p>在averager函数中，series是自由变量。这是一个技术术语，指未在本地作用域中绑定的变量，如图：</p><p><img src="http://upload-images.jianshu.io/upload_images/2952111-039ebc44d7803bbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="闭包"></p><p><strong>averager的闭包延伸到那个函数的作用域之外，包含自由变量series的绑定</strong></p><p>我们可以审查返回的averager对象，发现Python在<code>__code__</code>属性（表示编译后的函数定义体）中保存局部变量和自由变量的名称，如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 审查make_averager创建的函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.__code__.co_varnames</span><br><span class="line">(<span class="string">'new_value'</span>, <span class="string">'total'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.__code__.co_freevars</span><br><span class="line">(<span class="string">'series'</span>,)</span><br></pre></td></tr></table></figure><p>series绑定在返回的avg函数的<code>__closure__</code>属性中。<code>avg.__closure__</code>中各个元素对应于<code>avg.__code__.co_freevars</code>中的一个名称。这些元素是cell对象，有个<code>cell_content</code>属性，保存着真正的值。这些属性的值如示例所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.__code__.co_freevars</span><br><span class="line">(<span class="string">'series'</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.__closure__</span><br><span class="line">(&lt;cell at <span class="number">0x108b89828</span>: list object at <span class="number">0x108ae96c8</span>&gt;,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.__closure__[<span class="number">0</span>].cell_contents</span><br><span class="line">[<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]</span><br></pre></td></tr></table></figure></p><p>综上，闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，这样调用函数时虽然定义作用域不可用了，但仍能使用那些绑定。</p><p>注意，只有嵌套在其他函数中的函数才可能需要处理不在全局作用域中的外部变量。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;闭包是指延伸了作用域的函数，其中包含函数定义体中引用、但是不在定义体中定义的非全局变量。&lt;br&gt;闭包(closure)是函数式编程的重要的语法结构。闭包也是一种组织代码的结构，它同样提高了代码的可重复使用性。&lt;/p&gt;
&lt;p&gt;当一个内嵌函数引用其外部作用域的变量,我们就会得到一个闭包. 总结一下,创建一个闭包必须满足以下几点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;必须有一个内嵌函数&lt;/li&gt;
&lt;li&gt;内嵌函数必须引用外部函数中的变量&lt;/li&gt;
&lt;li&gt;外部函数的返回值必须是内嵌函数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，这样调用函数时虽然定义作用域不可用了，但仍能使用那些绑定。&lt;br&gt;
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
      <category term="Python3 闭包" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/Python3-%E9%97%AD%E5%8C%85/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Python3 让字典保持有序</title>
    <link href="http://yoursite.com/2018/03/06/Python3-%E8%AE%A9%E5%AD%97%E5%85%B8%E4%BF%9D%E6%8C%81%E6%9C%89%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/03/06/Python3-让字典保持有序/</id>
    <published>2018-03-06T04:02:36.000Z</published>
    <updated>2018-03-06T04:55:57.785Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>想创建一个字典，同时当对字典做迭代或序列化操作时，也能控制其中元素的顺序。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>要控制字典中元素的顺序，可以使用<code>collections模块</code>中的<code>OrderDict类</code>。当对字典做迭代时，他会严格按照元素初始添加的顺序执行。例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line">d = OrderedDict()</span><br><span class="line">d[<span class="string">'foo'</span>] = <span class="number">1</span></span><br><span class="line">d[<span class="string">'bar'</span>] = <span class="number">2</span></span><br><span class="line">d[<span class="string">'spam'</span>] = <span class="number">3</span></span><br><span class="line">d[<span class="string">'qrok'</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d:</span><br><span class="line">    print(key, d[key])</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># foo 1</span></span><br><span class="line"><span class="comment"># bar 2</span></span><br><span class="line"><span class="comment"># spam 3</span></span><br><span class="line"><span class="comment"># qrok 4</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>当想创建一个映射结构以便稍后对其做序列化或编码成另一种格式时，OrderedDict就显得特别有用。例如，如果想在进行json编码时精确控制各个字段的顺序，那么只要首先在OrderedDict中构建数据就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.dumps(d)</span><br><span class="line"><span class="string">'&#123;"foo":1,"bar":2,"spam":3,"qrok":4&#125;'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><p>OrderedDict内部维护了一个双向链表，他会根据元素加入的顺序来排列键的位置。第一个加入的元素被放置的链表的末尾。接下来对已存在的键做重新赋值不会改变键的顺序。</p><p>注意OrderedDict的大小是普通字典的两倍多，这是由于它额外创建的链表所致。因此，如果打算构建一个涉及大量OrderedDict实例的数据结构（例如从CSV文件中读取100000行内容到OrderedDict列表中），那么需要认真对应用做需求分析，从而判断使用OrderedDict所带来的好处是否能够超越额外的内存开销带来的缺点。</p><p>a</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;想创建一个字典，同时当对字典做迭代或序列化操作时，也能控制其中元素的顺序。&lt;/p&gt;
&lt;h2 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;解决方案&lt;/h2&gt;&lt;p&gt;要控制字典中元素的顺序，可以使用&lt;code&gt;collections模块&lt;/code&gt;中的&lt;code&gt;OrderDict类&lt;/code&gt;。当对字典做迭代时，他会严格按照元素初始添加的顺序执行。例如：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; collections &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; OrderedDict&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;d = OrderedDict()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;d[&lt;span class=&quot;string&quot;&gt;&#39;foo&#39;&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;d[&lt;span class=&quot;string&quot;&gt;&#39;bar&#39;&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;d[&lt;span class=&quot;string&quot;&gt;&#39;spam&#39;&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;d[&lt;span class=&quot;string&quot;&gt;&#39;qrok&#39;&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; key &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; d:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(key, d[key])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# output:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# foo 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# bar 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# spam 3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# qrok 4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
      <category term="Python3 字典" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/Python3-%E5%AD%97%E5%85%B8/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
</feed>
