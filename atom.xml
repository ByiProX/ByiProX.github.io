<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Quentin&#39;s Blog</title>
  
  <subtitle>每天进步一点点</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-02T18:22:01.607Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ByiProX</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python3 鸭子类型</title>
    <link href="http://yoursite.com/2018/03/03/python3-%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/03/03/python3-鸭子类型/</id>
    <published>2018-03-02T17:52:21.000Z</published>
    <updated>2018-03-02T18:22:01.607Z</updated>
    
    <content type="html"><![CDATA[<h2 id="来源和解释"><a href="#来源和解释" class="headerlink" title="来源和解释"></a>来源和解释</h2><p>这是程序设计中的一种类型推断风格，这种风格适用于动态语言(比如PHP、Python、Ruby、Typescript、Perl、Objective-C、Lua、Julia、JavaScript、Java、Groovy、C#等)和某些静态语言(比如Golang,一般来说，静态类型语言在编译时便已确定了变量的类型，但是Golang的实现是：在编译时推断变量的类型)，支持”鸭子类型”的语言的解释器/编译器将会在解析(Parse)或编译时，推断对象的类型。</p><p><code>在鸭子类型中，关注的不是对象的类型本身，而是它是如何使用的。</code> 例如，在不使用鸭子类型的语言中，我们可以编写一个函数，它接受一个类型为鸭的对象，并调用它的走和叫方法。在使用鸭子类型的语言中，这样的一个函数可以接受一个任意类型的对象，并调用它的走和叫方法。如果这些需要被调用的方法不存在，那么将引发一个运行时错误。任何拥有这样的正确的走和叫方法的对象都可被函数接受的这种行为引出了以上表述，这种决定类型的方式因此得名。</p><p><code>鸭子类型通常得益于不测试方法和函数中参数的类型，而是依赖文档、清晰的代码和测试来确保正确使用。</code>从静态类型语言转向动态类型语言的用户通常试图添加一些静态的（在运行之前的）类型检查，从而影响了鸭子类型的益处和可伸缩性，并约束了语言的动态特性。</p><p>Duck typing 这个概念来源于美国印第安纳州的诗人詹姆斯·惠特科姆·莱利（James Whitcomb Riley,1849-1916）的诗句：</p><blockquote><p>“ When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.”</p></blockquote><p>中文：</p><blockquote><p>“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”</p></blockquote><p>“鸭子类型”的语言是这么推断的：一只鸟走起来像鸭子、游起泳来像鸭子、叫起来也像鸭子，那它就可以被当做鸭子。也就是说，它不关注对象的类型，而是关注对象具有的行为(方法)。</p><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><p>“鸭子类型”没有任何静态检查，如类型检查、属性检查、方法签名检查等。</p><p>“鸭子类型”语言的程序可能会在运行时因为不具备某种特定的方法而抛出异常：如果一只小狗(对象)想加入合唱团(以对象会不会嘎嘎嘎叫的方法为检验标准)，也学鸭子那么嘎嘎嘎叫，好吧，它加入了，可是加入之后，却不会像鸭子那样走路，那么，迟早要出问题的。</p><p>再举个例子：一只小老鼠被猫盯上了，情急之下，它学了狗叫，猫撤了之后，小老鼠的妈妈不无感叹的对它说：看吧，我让你学的这门儿外语多么重要啊。这虽然是个段子，但是，由于猫在思考时，使用了 “鸭子测试”，它以为会叫的就是狗，会对自己产生威胁，所以撤退了，也正是因为这个错误的判断，它误失了一次进食机会。</p><h2 id="静态类型语言和动态类型语言的区别"><a href="#静态类型语言和动态类型语言的区别" class="headerlink" title="静态类型语言和动态类型语言的区别"></a>静态类型语言和动态类型语言的区别</h2><p>静态类型语言在编译时便已确定变量的类型，而动态类型语言的变量类型要到程序运行的时候，待变量被赋予某个值之后，才会具有某种类型。  </p><p><code>静态类型语言的优点</code>首先是在编译时就能发现类型不匹配的错误，编辑器可以帮助我们提前避免程序在运行期间有可能发生的一些错误。其次，如果在程序中明确地规定了数据类型，编译器还可以针对这些信息对程序进行一些优化工作，提高程序执行速度。  </p><p><code>静态类型语言的缺点</code>首先是迫使程序员依照强契约来编写程序，为每个变量规定数据类型，归根结底只是辅助我们编写可靠性高程序的一种手段，而不是编写程序的目的，毕竟大部分人编写程序的目的是为了完成需求交付生产。其次，类型的声明也会增加更多的代码，在程序编写过程中，这些细节会让程序员的精力从思考业务逻辑上分散开来。  </p><p><code>动态类型语言的优点</code>是编写的代码数量更少，看起来也更加简洁，程序员可以把精力更多地放在业务逻辑上面。虽然不区分类型在某些情况下会让程序变得难以理解，但整体而言，代码量越少，越专注于逻辑表达，对阅读程序是越有帮助的。<br><code>动态类型语言的缺点</code>是无法保证变量的类型，从而在程序的运行期有可能发生跟类型相关的错误。</p><p><strong>动态类型语言对变量类型的宽容给实际编码带来了很大的灵活性。由于无需进行类型检测，我们可以尝试调用任何对象的任意方法，而无需去考虑它原本是否被设计为拥有该方法。</strong></p><h2 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a>面向接口编程</h2><p>动态类型语言的面向对象设计中，鸭子类型的概念至关重要。利用鸭子类型的思想，我们不必借助<code>超类型</code>的帮助，就能轻松地在动态类型语言中实现一个原则：“面向接口编程，而不是面向实现编程”。<br>例如,</p><ol><li>一个对象若有push和pop方法，并且这些方法提供了正确的实现，它就可以被当作栈来使用。</li><li>一个对象如果有length属性，也可以依照下标来存取属性（最好还要拥有slice和splice等方法），这个对象就可以被当作数组来使用。</li><li>比如在python中，有很多file-like的东西，比如StringIO,GzipFile,socket。它们有很多相同的方法，我们把它们当作文件使用。</li><li>又比如list.extend()方法中,我们并不关心它的参数是不是list,只要它是可迭代的,所以它的参数可以是list/tuple/dict/字符串/生成器等.</li></ol><p>鸭子类型在动态语言中经常使用，非常灵活，使得python不想java那样专门去弄一大堆的设计模式。</p><p>在静态类型语言中，要实现“面向接口编程”并不是一件容易的事情，往往要通过抽象类或者接口等将对象进行<code>向上转型</code>。当对象的真正类型被隐藏在它的超类型身后，这些对象才能在<code>类型检查系统</code>的“监视”之下互相被替换使用。只有当对象能够被互相替换使用，才能体现出对象多态性的价值。</p><h2 id="Python中的多态"><a href="#Python中的多态" class="headerlink" title="Python中的多态"></a>Python中的多态</h2><p><strong>Python中的鸭子类型允许我们使用任何提供所需方法的对象，而不需要迫使它成为一个子类。</strong><br>由于python属于动态语言，当你定义了一个基类和基类中的方法，并编写几个继承该基类的子类时，由于python在定义变量时不指定变量的类型，而是由解释器根据变量内容推断变量类型的（也就是说变量的类型取决于所关联的对象），这就使得python的多态不像是c++或java中那样—定义一个基类类型变量而隐藏了具体子类的细节。</p><p>请看下面的例子和说明：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AudioFile</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filename)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> filename.endswith(self.ext):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Invalid file format"</span>)</span><br><span class="line">        self.filename = filename</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MP3File</span><span class="params">(AudioFile)</span>:</span></span><br><span class="line">    ext = <span class="string">"mp3"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">play</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Playing &#123;&#125; as mp3"</span>.format(self.filename))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WavFile</span><span class="params">(AudioFile)</span>:</span></span><br><span class="line">    ext = <span class="string">"wav"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">play</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Playing &#123;&#125; as wav"</span>.format(self.filename))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OggFile</span><span class="params">(AudioFile)</span>:</span></span><br><span class="line">    ext = <span class="string">"ogg"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">play</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Playing &#123;&#125; as ogg"</span>.format(self.filename))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlacFile</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Though FlacFile class doesn't inherit AudioFile class,</span></span><br><span class="line"><span class="string">    it also has the same interface as three subclass of AudioFile.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    It is called duck typing.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filename)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> filename.endswith(<span class="string">".flac"</span>):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Invalid file format"</span>)</span><br><span class="line">        self.filename = filename</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">play</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Playing &#123;&#125; as flac"</span>.format(self.filename))</span><br></pre></td></tr></table></figure></p><blockquote><p>Though FlacFile class doesn’t inherit AudioFile class,<br>it also has the same interface as three subclass of AudioFile.<br>It is called duck typing.</p></blockquote><p>上面的代码中，<code>MP3File</code>、<code>WavFile</code>、<code>OggFile</code>三个类型继承了<code>AudioFile</code>这一积累，而<code>FlacFile</code>没有扩展<code>AudioFile</code>，但是可以在python中使用完全相同的接口与之交互。  </p><p>因为任何提供正确接口的对象都可以在python中交替使用，它减少了多态的一般<code>超类</code>的需求。继承仍然可以用来共享代码，但是如果所有被共享的都是公共接口，鸭子类型就是所有所需的。这减少了继承的需要，同时也减少了多重继承的需要；通常，当多重继承似乎是一个有效方案的时候，我们只需要使用鸭子类型去模拟多个超类之一（定义和那个超类一样的接口和实现）就可以了。</p><blockquote><p>作者：JasonDing<br>链接：<a href="https://www.jianshu.com/p/650485b78d11" target="_blank" rel="noopener">https://www.jianshu.com/p/650485b78d11</a><br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://baike.baidu.com/item/鸭子类型/10845665?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/鸭子类型/10845665?fr=aladdin</a></li><li><a href="https://www.jianshu.com/p/650485b78d11" target="_blank" rel="noopener">https://www.jianshu.com/p/650485b78d11</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;来源和解释&quot;&gt;&lt;a href=&quot;#来源和解释&quot; class=&quot;headerlink&quot; title=&quot;来源和解释&quot;&gt;&lt;/a&gt;来源和解释&lt;/h2&gt;&lt;p&gt;这是程序设计中的一种类型推断风格，这种风格适用于动态语言(比如PHP、Python、Ruby、Typescript、
      
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
      <category term="Python3 鸭子类型" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/Python3-%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>python3 如何用一个表达式合并两个字典</title>
    <link href="http://yoursite.com/2018/03/03/python3-%E5%A6%82%E4%BD%95%E7%94%A8%E4%B8%80%E4%B8%AA%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E5%AD%97%E5%85%B8/"/>
    <id>http://yoursite.com/2018/03/03/python3-如何用一个表达式合并两个字典/</id>
    <published>2018-03-02T17:00:28.000Z</published>
    <updated>2018-03-02T17:11:37.046Z</updated>
    
    <content type="html"><![CDATA[<p>有两个Python字典,写一个表达式来返回两个字典的合并。<code>update()</code>方法返回的是空值而不是返回合并后的对象.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = &#123;<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = &#123;<span class="string">'b'</span>:<span class="number">10</span>, <span class="string">'c'</span>: <span class="number">11</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z = x.update(y)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> z</span><br><span class="line"><span class="keyword">None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">10</span>, <span class="string">'c'</span>: <span class="number">11</span>&#125;</span><br></pre></td></tr></table></figure></p><p>如何才能让值保存在z而不是x?<br><a id="more"></a></p><p>对于python2可以用下面的方法:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z = dict(x.items() + y.items())</span><br></pre></td></tr></table></figure></p><p>最后就是你想要的最终结果保存在字典z中,而键<code>b</code>的值会被第二个字典的值覆盖.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = &#123;<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = &#123;<span class="string">'b'</span>:<span class="number">10</span>, <span class="string">'c'</span>: <span class="number">11</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z = dict(x.items() + y.items())</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z</span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'c'</span>: <span class="number">11</span>, <span class="string">'b'</span>: <span class="number">10</span>&#125;</span><br></pre></td></tr></table></figure></p><p>对于Python3：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>z = dict(list(x.items()) + list(y.items()))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z</span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'c'</span>: <span class="number">11</span>, <span class="string">'b'</span>: <span class="number">10</span>&#125;</span><br></pre></td></tr></table></figure></p><p>还可以这样:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">z = x.copy()</span><br><span class="line">z.update(y)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有两个Python字典,写一个表达式来返回两个字典的合并。&lt;code&gt;update()&lt;/code&gt;方法返回的是空值而不是返回合并后的对象.&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;x = &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;b&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;y = &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;b&#39;&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;c&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;z = x.update(y)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; z&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;b&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;c&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如何才能让值保存在z而不是x?&lt;br&gt;
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
      <category term="Python3 数据结构" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/Python3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>python3 可迭代对象、迭代器和生成器</title>
    <link href="http://yoursite.com/2018/03/01/python3-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>http://yoursite.com/2018/03/01/python3-可迭代对象、迭代器和生成器/</id>
    <published>2018-03-01T12:17:53.000Z</published>
    <updated>2018-03-02T04:55:21.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>迭代是数据处理的基石。扫描内存中放不下数据集时，我们要找到一种惰性获取数据项的方式，即按需一次获取一个数据项，这就是迭代器模式（iterator pattern）。所有的<code>生成器</code>都是<code>迭代器</code>，因为生成器完全实现了迭代器接口。在python社区中，大多数时候都把<code>迭代器</code>和<code>生成器</code>视作同一概念。</p><p>所有python程序员都知道，序列可迭代，下面说明具体原因。<br><a id="more"></a></p><h2 id="序列可迭代的原因：iter函数"><a href="#序列可迭代的原因：iter函数" class="headerlink" title="序列可迭代的原因：iter函数"></a>序列可迭代的原因：iter函数</h2><p>解释器需要迭代对象x时，会自动调用<code>iter(x)</code>。<br>内置的iter函数有以下作用。</p><ol><li>检查对象是否实现了<code>__iter__</code>方法，如果实现了就调用它，获得一个迭代器。</li><li>如果没有实现<code>__iter__</code>方法，但是实现了<code>__getitem__</code>方法，python会创建一个迭代器，尝试按顺序（从索引0开始）获取元素。</li><li>如果尝试失败，python会抛出<code>TypeError</code>异常，通常会提示”C object is not iterable”,其中C是目标对象所属的类。</li></ol><p>任何Python序列都可迭代的原因是它们实现了<code>__getitem__</code>方法。其实标准的序列也都实现了<code>__iter__</code>方法。之所以对<code>__getitem__</code>方法做特殊处理是为了向后兼容。</p><p>从Python3.4开始，检查x能否迭代，最准确的方法是调用iter(x)函数，如果不可迭代，再处理TypeError异常。这比使用isinstance(x, abc.Iterable)更准确，因为iter(x)函数会考虑到遗留的<code>__getitem__</code>方法，而abc.Iterable类则不考虑。</p><h2 id="可迭代的对象与迭代器的对比"><a href="#可迭代的对象与迭代器的对比" class="headerlink" title="可迭代的对象与迭代器的对比"></a>可迭代的对象与迭代器的对比</h2><h3 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h3><p><strong>使用iter内置函数可以获取迭代器的对象。</strong> 如果实现了能返回迭代器的<code>__iter__</code>方法，那么对象就是可迭代的。序列都可以迭代；实现了<code>__getitem__</code>方法，而且七参数是从零开始的索引，这种对象也是可迭代的。</p><p>我们要明确可迭代对象和迭代器之间的关系：<strong>Python从可迭代的对象中获取迭代器</strong></p><p>标准的迭代器接口有两个方法，即：</p><ol><li><code>__next__</code>:返回下一个可用元素，如果没有元素，抛出<code>StopIteration</code>异常</li><li><code>__iter__</code>:返回self,以便在应该使用可迭代对象的地方使用迭代器，比如for循环中。</li></ol><p>因为<code>迭代器</code>只需<code>__next__</code>和<code>__iter__</code>两个方法，所以除了调用next()方法，以及捕获<code>StopIteration</code>异常之外，没有办法检查是否还有遗留的元素。此外，也没有办法还原迭代器。如果想再次迭代，那就要调用iter(…)，传入之前构建迭代器的可迭代对象。</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器是这样的对象：实现了无参数的<code>__next__</code>方法，返回序列中的下一个元素；如果没有元素了，那么抛出<code>StopIteration</code>异常。Python迭代器还实现了<code>__iter__</code>方法，因此迭代器也可以迭代。</p><p>构建<code>可迭代对象</code>和<code>迭代器</code>时经常会出现错误，原因是混淆了两者。要知道，<code>可迭代的对象</code>有个<code>__iter__</code>方法，每次都实例化一个新的迭代器；而<code>迭代器</code>要实现<code>__next__</code>方法，返回单个元素，此外还要实现<code>__iter__</code>方法，返回迭代器本身。因此，<code>迭代器</code>可以迭代，但是<code>可迭代的对象</code>不是迭代器。</p><p>可迭代的对象一定不是自身的迭代器。也就是说，可迭代的对象必须实现<code>__iter__</code>方法，但不能实现<code>__next__</code>方法。另一方面，迭代器应该一直可以迭代，迭代器的<code>__iter__</code>方法应该返回自身。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="string">'__iter__'</span> <span class="keyword">in</span> dir(a)            <span class="comment"># True</span></span><br><span class="line"><span class="string">'__iter__'</span> <span class="keyword">in</span> dir(iter(a))      <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h2 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h2><p>只要Python函数的定义体中有yield关键字，该函数就是生成器函数。调用生成器函数时，会返回一个生成器对象。也就是说，生成器函数是生成器工厂。</p><p>普通的函数与生成器函数在句法上的唯一区别是，在后者的定义体中有<code>yield</code>关键字。有些人认为定义生成器函数应该使用一个新的关键字，例如gen，而不是def，但是Guido不同意。</p><h3 id="生成器函数工作原理"><a href="#生成器函数工作原理" class="headerlink" title="生成器函数工作原理"></a>生成器函数工作原理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_123</span><span class="params">()</span>:</span>  <span class="comment"># 只要Python代码中包含yield，该函数就是生成器函数</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>    <span class="comment">#生成器函数的定义体中通常都有循环，不过这不是必要条件；此处重复使用了3次yield</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(gen_123)    <span class="comment"># 可以看出gen_123是函数对象</span></span><br><span class="line">    <span class="comment"># &lt;function gen_123 at 0x10be199d8&gt;</span></span><br><span class="line">    print(gen_123())  <span class="comment"># 函数调用时返回的是一个生成器对象</span></span><br><span class="line">    <span class="comment"># &lt;generator object gen_123 at 0x10be31ca8&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> gen_123(): <span class="comment"># 生成器是迭代器，会生成传给yield关键字的表达式的值</span></span><br><span class="line">        print(i)    </span><br><span class="line">        <span class="comment"># 1</span></span><br><span class="line">        <span class="comment"># 2</span></span><br><span class="line">        <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line">    g = gen_123() <span class="comment"># 为了仔细检查，把生成器对象赋值给g</span></span><br><span class="line">    print(next(g))  <span class="comment"># 1</span></span><br><span class="line">    print(next(g))  <span class="comment"># 2</span></span><br><span class="line">    print(next(g))  <span class="comment"># 3</span></span><br><span class="line">    print(next(g))   <span class="comment"># 生成器函数的定义体执行完毕后，生成器对象会抛出异常。</span></span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#   File "test.py", line 17, in &lt;module&gt;</span></span><br><span class="line"><span class="comment">#     print(next(g))</span></span><br><span class="line"><span class="comment"># StopIteration</span></span><br></pre></td></tr></table></figure><p>如上述代码所示：</p><ol><li>只要Python代码中包含yield，该函数就是生成器函数</li><li>生成器函数的定义体中通常都有循环，不过这不是必要条件；此处重复使用了3次yield</li><li>可以看出gen_123是函数对象</li><li>函数调用时返回的是一个生成器对象</li><li>生成器是迭代器，会<code>生成</code>传给yield关键字的表达式的值</li><li>为了仔细检查，把生成器对象赋值给g</li><li>因为g是迭代器，所以调用nest(g)会获取yield<code>生成</code>的下一个元素</li><li>生成器函数的定义体执行完毕后，生成器对象会抛出异常。</li></ol><p>使用准确的词语描述从生成器中获取结果的过程有助于理解生成器。注意，此处说的是<code>产出</code>或<code>生成</code>值。如果说生成器<code>返回</code>值，就会让人难以理解。</p><blockquote><p>函数返回值; 调用生成器函数返回生成器; 生成器<code>产出</code>或<code>生成</code>值。生成器不会以常规方式<code>返回</code>值;</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">66</span>]: <span class="function"><span class="keyword">def</span> <span class="title">gen_AB</span><span class="params">()</span>:</span>            <span class="comment"># 1</span></span><br><span class="line">    ...:     print(<span class="string">'start'</span>)       </span><br><span class="line">    ...:     <span class="keyword">yield</span> <span class="string">'A'</span>            <span class="comment"># 2</span></span><br><span class="line">    ...:     print(<span class="string">'continue'</span>)</span><br><span class="line">    ...:     <span class="keyword">yield</span> <span class="string">'B'</span>            <span class="comment"># 3</span></span><br><span class="line">    ...:     print(<span class="string">'end.'</span>)        <span class="comment"># 4</span></span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">67</span>]: <span class="keyword">for</span> c <span class="keyword">in</span> gen_AB():       <span class="comment"># 5</span></span><br><span class="line">    ...:     print(<span class="string">'--&gt;'</span>, c)      <span class="comment"># 6</span></span><br><span class="line">    ...:</span><br><span class="line">start       <span class="comment"># 7</span></span><br><span class="line">--&gt; A       # 8</span><br><span class="line"><span class="keyword">continue</span>    <span class="comment"># 9</span></span><br><span class="line">--&gt; B       # 10</span><br><span class="line">end.        <span class="comment"># 11</span></span><br></pre></td></tr></table></figure><ol><li>定义生成的器函数的方式与普通函数无异，只不过要使用yield关键字</li><li>在for循环中第一次隐式调用next()函数时（序号5），会打印’start’，然后停在第一个yield语句，生成值 ‘A’</li><li>在for循环第二次隐式调用next()函数时，会打印’continue’，然后停在第二个yield语句，生成值’B’</li><li>第三次调用 next()函数时，会打印’end.’，然后到达函数定义体末尾。导致生成器对象抛出StopIteration异常</li><li>迭代时, for 机制的作用与g = iter(gen_AB())一样，用于获取生成器对象，然后每次迭代时调用next(g)</li><li>循环打印 –&gt; 与 next(g)返回的值。但是，生成器函数中的print函数输出结果之后才会看到这个输出</li><li>‘start’是生成器函数定义体中print(‘start’)输出的记过</li><li>生成器函数定义体中的yield ‘A’ 语句会生成值 A，提供给for循环使用，而A会赋值给变量c，最终输出–&gt; A</li><li>第二次调用next(g)，继续迭代，生成器函数定义体中的代码由yield ‘A’前进到 yield ‘B’。文本continue是由生成器函数定义体中的第二个print函数输出的</li><li>生成器函数定义体中的yield ‘B’ 语句会生成值 B，提供给for循环使用，而B会赋值给变量c，最终输出–&gt; B</li><li>第三次调用next(g)，继续迭代，前进到生成器函数的结尾。文本 end. 是由生成器函数定义体中第三个print函数输出的。</li><li>到达生成器函数定义体结尾时，生成器对象抛出StopIteration异常。for 机制会捕捉异常，因此循环终止没有报错。</li></ol><h2 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h2><p>简单的生成器函数，可以替换成生成器表达式。生成器表达式可以理解为列表推导的惰性版本：不会迫切的构建列表，而是返回一个生成器，按需惰性生成元素。也就是说，如果列表推导是制造工厂的列表，那么生成器表达式就是制造生成器的工厂。如下演示了一个简单的生成器表达式，并且与列表推导做了对比。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">66</span>]: <span class="function"><span class="keyword">def</span> <span class="title">gen_AB</span><span class="params">()</span>:</span>            <span class="comment"># 1</span></span><br><span class="line">    ...:     print(<span class="string">'start'</span>)       </span><br><span class="line">    ...:     <span class="keyword">yield</span> <span class="string">'A'</span>            </span><br><span class="line">    ...:     print(<span class="string">'continue'</span>)</span><br><span class="line">    ...:     <span class="keyword">yield</span> <span class="string">'B'</span>            </span><br><span class="line">    ...:     print(<span class="string">'end.'</span>)        </span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">67</span>]: res1 = [x*<span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> gen_AB()]  <span class="comment"># 2</span></span><br><span class="line">start</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">end.</span><br><span class="line"></span><br><span class="line">In [<span class="number">68</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> res1():       <span class="comment"># 3</span></span><br><span class="line">    ...:     print(<span class="string">'--&gt;'</span>, i)      </span><br><span class="line">    ...:</span><br><span class="line">AAA</span><br><span class="line">BBB</span><br><span class="line"></span><br><span class="line">In [<span class="number">69</span>]: res2 = (x*<span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> gen_AB())  <span class="comment"># 4</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">70</span>]: res2  <span class="comment"># 5</span></span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x106a07620</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">71</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> res2():       <span class="comment"># 6</span></span><br><span class="line">    ...:     print(<span class="string">'--&gt;'</span>, i)</span><br><span class="line">    ...:</span><br><span class="line">start   </span><br><span class="line">--&gt; A   </span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">--&gt; B       </span><br><span class="line">end.</span><br></pre></td></tr></table></figure><ol><li>创建gen_AB函数</li><li>列表推到迫切的迭代gen_AB()函数生成的生成器对象产出的元素：’A’和’B’。注意。下面输出的是start、continue、end.。</li><li>for循环迭代列表推导生成的res1列表</li><li>把生成器表达式返回的值赋值给res2。只需调用gen_AB()函数，虽然调用时会返回一个生成器，但是这里并不使用。</li><li>可以看出res2是一个生成器对象。</li><li>只有for循环迭代res2时，gen_AB函数的定义体才会真正执行。for循环每次迭代时会隐式调用next(res2)，前进到gen_AB函数中的下一个yield语句。注意，gen_AB函数的输出与for循环中print函数的输出夹杂在一起。</li></ol><p>生成器表达式会产出生成器，因此可以使用生成器表达式进一步减少代码量。生成器表达式是一种语法糖，完全可以替换成生成器函数，不过有时候使用生成器表达式更便利。</p><h2 id="何时使用生成器表达式"><a href="#何时使用生成器表达式" class="headerlink" title="何时使用生成器表达式"></a>何时使用生成器表达式</h2><p>生成器表达式是创建生成器的简洁句法，这样无需定义函数再调用。不过，生成器函数灵活的多，可以使用多个语句实现复杂的逻辑，也可以作为<code>协程</code>使用。遇到简单的情况时，可以使用生成器表达式，因为这样扫一眼就知道代码的作用。其实选择那种句法很容易判断：如果生成器表达式需要分行写，倾向于定义成生成器函数，以便提高可读性。此外生成器函数有名称，因此可以重用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;迭代是数据处理的基石。扫描内存中放不下数据集时，我们要找到一种惰性获取数据项的方式，即按需一次获取一个数据项，这就是迭代器模式（iterator pattern）。所有的&lt;code&gt;生成器&lt;/code&gt;都是&lt;code&gt;迭代器&lt;/code&gt;，因为生成器完全实现了迭代器接口。在python社区中，大多数时候都把&lt;code&gt;迭代器&lt;/code&gt;和&lt;code&gt;生成器&lt;/code&gt;视作同一概念。&lt;/p&gt;
&lt;p&gt;所有python程序员都知道，序列可迭代，下面说明具体原因。&lt;br&gt;
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
      <category term="Python3 迭代器和生成器" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/Python3-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>if __name__ == &#39;__main__&#39;: ?</title>
    <link href="http://yoursite.com/2018/03/01/if-name-main/"/>
    <id>http://yoursite.com/2018/03/01/if-name-main/</id>
    <published>2018-03-01T11:50:06.000Z</published>
    <updated>2018-03-01T12:13:18.245Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Every Python module has it’s <code>__name__</code> defined and if this is <code>&#39;__main__&#39;</code>, it implies that the module is being run standalone by the user and we can do corresponding appropriate actions.</p></blockquote><p>当Python解析器读取一个源文件时,它会执行所有的代码.在执行代码前,会定义一些特殊的变量.例如,如果解析器运行的模块(源文件)作为主程序,它将会把<code>__name__</code>变量设置成<code>&quot;__main__&quot;</code>.如果只是引入其他的模块,<code>__name__</code>变量将会设置成模块的名字.<br><a id="more"></a></p><p>这么做的原因是有时你想让你的模块既可以直接的执行,还可以被当做模块导入到其他模块中去.通过检查是不是主函数,可以让你的代码只在它作为主程序运行时执行,而当其他人调用你的模块中的函数的时候不必执行.</p><p>直接上一个栗子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Filename: using_name.py</span></span><br><span class="line"></span><br><span class="line">print(__name__)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">print(<span class="string">'This program is being run by itself'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">print(<span class="string">'I am being imported from another module'</span>)</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ python using_name.py</span><br><span class="line">__main__</span><br><span class="line">This program <span class="keyword">is</span> being run by itself</span><br><span class="line"></span><br><span class="line">$ python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> using_name</span><br><span class="line">using_name</span><br><span class="line">I am being imported <span class="keyword">from</span> another module</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Every Python module has it’s &lt;code&gt;__name__&lt;/code&gt; defined and if this is &lt;code&gt;&amp;#39;__main__&amp;#39;&lt;/code&gt;, it implies that the module is being run standalone by the user and we can do corresponding appropriate actions.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当Python解析器读取一个源文件时,它会执行所有的代码.在执行代码前,会定义一些特殊的变量.例如,如果解析器运行的模块(源文件)作为主程序,它将会把&lt;code&gt;__name__&lt;/code&gt;变量设置成&lt;code&gt;&amp;quot;__main__&amp;quot;&lt;/code&gt;.如果只是引入其他的模块,&lt;code&gt;__name__&lt;/code&gt;变量将会设置成模块的名字.&lt;br&gt;
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Python中的单下划线和双下划线</title>
    <link href="http://yoursite.com/2018/03/01/Python%E4%B8%AD%E7%9A%84%E5%8D%95%E4%B8%8B%E5%88%92%E7%BA%BF%E5%92%8C%E5%8F%8C%E4%B8%8B%E5%88%92%E7%BA%BF/"/>
    <id>http://yoursite.com/2018/03/01/Python中的单下划线和双下划线/</id>
    <published>2018-03-01T10:01:50.000Z</published>
    <updated>2018-03-01T11:55:19.301Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单下划线"><a href="#单下划线" class="headerlink" title="单下划线"></a>单下划线</h3><h4 id="在解释器中"><a href="#在解释器中" class="headerlink" title="在解释器中"></a>在解释器中</h4><p>在交互解释器中，<code>_</code>符号还是指交互解释器中最后一次执行语句的返回结果。这种用法最初出现在CPython解释器中，其他解释器后来也都跟进了。</p><h4 id="作为名称使用"><a href="#作为名称使用" class="headerlink" title="作为名称使用"></a>作为名称使用</h4><p>这个跟上面有点类似。<code>_</code>用作被丢弃的名称。按照惯例，这样做可以让阅读你代码的人知道，这是个不会被使用的特定名称。举个例子，你可能无所谓一个循环计数的值：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">42</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">    do_something()</span><br></pre></td></tr></table></figure></p><a id="more"></a><h4 id="i18n"><a href="#i18n" class="headerlink" title="i18n"></a>i18n</h4><p><code>_</code>还可以被用作函数名。这种情况，单下划线经常被用作国际化和本地化字符串翻译查询的函数名。举个例子，在 <a href="https://docs.djangoproject.com/en/dev/topics/i18n/translation/" target="_blank" rel="noopener">Django documentation for translation</a> 中你可能会看到：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.utils.translation <span class="keyword">import</span> ugettext <span class="keyword">as</span> _</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span><span class="params">(request)</span>:</span></span><br><span class="line">    output = _(<span class="string">"Welcome to my site."</span>)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(output)</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：第二种和第三种用法会引起冲突，所以在任意代码块中，如果使用了_作i18n翻译查询函数，就应该避免再用作被丢弃的变量名。</p><h4 id="单下划线前缀的名称"><a href="#单下划线前缀的名称" class="headerlink" title="单下划线前缀的名称"></a>单下划线前缀的名称</h4><p>首先是单下划线开头，这个被常用于模块中，在一个模块中以单下划线开头的变量和函数被默认当作内部函数,用来指定私有变量。如果使用 <code>from a_module import *</code> 导入时，这部分变量和函数不会被导入。<strong>不过值得注意的是</strong>，如果使用 <code>import a_module</code> 这样导入模块，仍然可以用 <code>a_module._some_var</code> 这样的形式访问到这样的对象。</p><p>另外单下划线开头还有一种一般不会用到的情况在于使用一个 C 编写的扩展库有时会用下划线开头命名，然后使用一个去掉下划线的 Python 模块进行包装。如 struct 这个模块实际上是 C 模块 <code>_struct</code> 的一个 Python 包装。</p><h4 id="单下划线后缀的名称"><a href="#单下划线后缀的名称" class="headerlink" title="单下划线后缀的名称"></a>单下划线后缀的名称</h4><p>在 Python 的官方推荐的代码样式中，还有一种单下划线结尾的样式，这在解析时并没有特别的含义，但通常用于和 Python 关键词区分开来，比如如果我们需要一个变量叫做 class，但 class 是 Python 的关键词，就可以以单下划线结尾写作 class_。</p><h3 id="双下划线"><a href="#双下划线" class="headerlink" title="双下划线"></a>双下划线</h3><p>双下划线开头的命名形式在 Python 的类成员中使用表示名字改编 (Name Mangling)，即如果有一 <code>Test 类</code>里有一成员 <code>__x</code>，那么 dir(Test) 时会看到 <code>_Test__x</code> 而非 <code>__x</code>。这是为了避免该成员的名称与子类中的名称冲突。<strong>但要注意这要求该名称末尾最多有一个下划线</strong> <a href="https://docs.python.org/3.4/tutorial/classes.html#tut-private" target="_blank" rel="noopener">python document</a>.</p><p>双下划线开头双下划线结尾的是一些 Python 的“魔术”对象，如类成员的 <code>__init__</code>、<code>__del__</code>、<code>__add__</code>、<code>__getitem__</code> 等，以及全局的 <code>__file__</code>、<code>__name__</code> 等。 Python <code>官方推荐永远不要</code>将这样的命名方式应用于自己的变量或函数，而是按照文档说明来使用。</p><h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>            self.__superprivate = <span class="string">"Hello"</span></span><br><span class="line"><span class="meta">... </span>            self._semiprivate = <span class="string">", world!"</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mc = MyClass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> mc.__superprivate</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: myClass instance has no attribute <span class="string">'__superprivate'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> mc._semiprivate</span><br><span class="line">, world!</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> mc.__dict__</span><br><span class="line">&#123;<span class="string">'_MyClass__superprivate'</span>: <span class="string">'Hello'</span>, <span class="string">'_semiprivate'</span>: <span class="string">', world!'</span>&#125;</span><br></pre></td></tr></table></figure><p><code>__foo__</code>:一种约定,Python内部的名字,用来区别其他用户自定义的命名,以防冲突，就是例如<code>__init__()</code>,<code>__del__()</code>,<code>__call__()</code>这些特殊方法</p><p><code>_foo</code>:一种约定,用来指定变量私有.程序员用来指定私有变量的一种方式.不能用from module import * 导入，其他方面和公有一样访问；</p><p><code>__foo</code>:这个有真正的意义:解析器用<code>_classname__foo</code>来代替这个名字,以区别和其他类相同的命名,它无法直接像公有成员一样随便访问,但是可以通过对象名 <code>_类名__xxx</code> 这样的方式可以访问.</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>详情见:</p><ol><li><p><a href="http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python" target="_blank" rel="noopener">http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python</a></p></li><li><p><a href="http://www.zhihu.com/question/19754941" target="_blank" rel="noopener">http://www.zhihu.com/question/19754941</a></p></li><li><p><a href="https://segmentfault.com/a/1190000002611411" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002611411</a></p></li><li><p><a href="https://docs.python.org/3.4/tutorial/classes.html#tut-private" target="_blank" rel="noopener">https://docs.python.org/3.4/tutorial/classes.html#tut-private</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;单下划线&quot;&gt;&lt;a href=&quot;#单下划线&quot; class=&quot;headerlink&quot; title=&quot;单下划线&quot;&gt;&lt;/a&gt;单下划线&lt;/h3&gt;&lt;h4 id=&quot;在解释器中&quot;&gt;&lt;a href=&quot;#在解释器中&quot; class=&quot;headerlink&quot; title=&quot;在解释器中&quot;&gt;&lt;/a&gt;在解释器中&lt;/h4&gt;&lt;p&gt;在交互解释器中，&lt;code&gt;_&lt;/code&gt;符号还是指交互解释器中最后一次执行语句的返回结果。这种用法最初出现在CPython解释器中，其他解释器后来也都跟进了。&lt;/p&gt;
&lt;h4 id=&quot;作为名称使用&quot;&gt;&lt;a href=&quot;#作为名称使用&quot; class=&quot;headerlink&quot; title=&quot;作为名称使用&quot;&gt;&lt;/a&gt;作为名称使用&lt;/h4&gt;&lt;p&gt;这个跟上面有点类似。&lt;code&gt;_&lt;/code&gt;用作被丢弃的名称。按照惯例，这样做可以让阅读你代码的人知道，这是个不会被使用的特定名称。举个例子，你可能无所谓一个循环计数的值：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;n = &lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; _ &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(n):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    do_something()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
      <category term="Python3 下划线" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/Python3-%E4%B8%8B%E5%88%92%E7%BA%BF/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Python3 自省</title>
    <link href="http://yoursite.com/2018/03/01/Python3-%E8%87%AA%E7%9C%81/"/>
    <id>http://yoursite.com/2018/03/01/Python3-自省/</id>
    <published>2018-03-01T08:19:37.000Z</published>
    <updated>2018-03-02T17:23:56.828Z</updated>
    
    <content type="html"><![CDATA[<p>自省是python彪悍的特性之一.</p><p>自省（introspection）是一种自我检查行为。在计算机编程中，自省是指这种能力：检查某些事物以确定它是什么、它知道什么以及它能做什么。自省向程序员提供了极大的灵活性和控制力.</p><a id="more"></a><p>自省就是面向对象的语言所写的程序在运行时,所能知道对象的类型.简单一句就是运行时能够获得对象的类型.比如type(),dir(),getattr(),hasattr(),isinstance().</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = &#123;<span class="string">'a'</span>:<span class="number">1</span>,<span class="string">'b'</span>:<span class="number">2</span>,<span class="string">'c'</span>:<span class="number">3</span>&#125;</span><br><span class="line">c = <span class="keyword">True</span></span><br><span class="line"><span class="keyword">print</span> type(a),type(b),type(c) <span class="comment"># &lt;type 'list'&gt; &lt;type 'dict'&gt; &lt;type 'bool'&gt;</span></span><br><span class="line"><span class="keyword">print</span> isinstance(a,list)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure><p>未完待续</p><p>参考：</p><ol><li><a href="http://python.jobbole.com/82110/" target="_blank" rel="noopener">http://python.jobbole.com/82110/</a></li><li><a href="http://blog.csdn.net/IAlexanderI/article/details/78768378" target="_blank" rel="noopener">http://blog.csdn.net/IAlexanderI/article/details/78768378</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自省是python彪悍的特性之一.&lt;/p&gt;
&lt;p&gt;自省（introspection）是一种自我检查行为。在计算机编程中，自省是指这种能力：检查某些事物以确定它是什么、它知道什么以及它能做什么。自省向程序员提供了极大的灵活性和控制力.&lt;/p&gt;
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
      <category term="Python3 自省" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/Python3-%E8%87%AA%E7%9C%81/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Python3 类变量和实例变量</title>
    <link href="http://yoursite.com/2018/03/01/Python3-%E7%B1%BB%E5%8F%98%E9%87%8F%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F/"/>
    <id>http://yoursite.com/2018/03/01/Python3-类变量和实例变量/</id>
    <published>2018-03-01T05:21:38.000Z</published>
    <updated>2018-03-01T08:05:39.909Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>首先来一张图<br><img src="http://upload-images.jianshu.io/upload_images/2952111-07f6d669392b20c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="classvariable.png"></p><h3 id="类变量和实例变量"><a href="#类变量和实例变量" class="headerlink" title="类变量和实例变量"></a>类变量和实例变量</h3><p>在Python Tutorial中对于类变量和实例变量是这样描述的：</p><blockquote><p>Generally speaking, instance variables are for data unique to each instance and class variables are for attributes and methods shared by all instances of the class:</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    kind = <span class="string">'canine'</span>         <span class="comment"># class variable shared by all instances</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name    <span class="comment"># instance variable unique to each instance</span></span><br></pre></td></tr></table></figure><p>类<code>Dog</code>中，类属性<code>kind</code>为所有实例所共享；实例属性<code>name</code>为每个<code>Dog</code>的实例独有。<br><a id="more"></a></p><h4 id="类变量："><a href="#类变量：" class="headerlink" title="类变量："></a>类变量：</h4><blockquote><p>​    是可在类的所有实例之间共享的值（也就是说，它们不是单独分配给每个实例的）。例如下例中，num_of_instance 就是类变量，用于跟踪存在着多少个Test 的实例。</p></blockquote><h4 id="实例变量："><a href="#实例变量：" class="headerlink" title="实例变量："></a>实例变量：</h4><blockquote><p>实例化之后，每个实例单独拥有的变量。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    num_of_instance = <span class="number">0</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span>  </span><br><span class="line">        self.name = name  </span><br><span class="line">        Test.num_of_instance += <span class="number">1</span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  </span><br><span class="line">    <span class="keyword">print</span> Test.num_of_instance   <span class="comment"># 0</span></span><br><span class="line">    t1 = Test(<span class="string">'jack'</span>)  </span><br><span class="line">    <span class="keyword">print</span> Test.num_of_instance   <span class="comment"># 1</span></span><br><span class="line">    t2 = Test(<span class="string">'lucy'</span>)  </span><br><span class="line">    <span class="keyword">print</span> t1.name , t1.num_of_instance  <span class="comment"># jack 2</span></span><br><span class="line">    <span class="keyword">print</span> t2.name , t2.num_of_instance  <span class="comment"># lucy 2</span></span><br></pre></td></tr></table></figure><blockquote><p>补充的例子</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    name=<span class="string">"aaa"</span></span><br><span class="line"></span><br><span class="line">p1=Person()</span><br><span class="line">p2=Person()</span><br><span class="line">p1.name=<span class="string">"bbb"</span></span><br><span class="line"><span class="keyword">print</span> p1.name  <span class="comment"># bbb</span></span><br><span class="line"><span class="keyword">print</span> p2.name  <span class="comment"># aaa</span></span><br><span class="line"><span class="keyword">print</span> Person.name  <span class="comment"># aaa</span></span><br></pre></td></tr></table></figure><p>这里<code>p1.name=&quot;bbb&quot;</code>是实例调用了类变量,属于函数传参的问题,<code>p1.name</code>一开始是指向的类变量<code>name=&quot;aaa&quot;</code>,但是在实例的作用域里把类变量的引用改变了,就变成了一个实例变量,self.name不再引用Person的类变量name了.</p><p>可以看看下面的例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    name=[]</span><br><span class="line"></span><br><span class="line">p1=Person()</span><br><span class="line">p2=Person()</span><br><span class="line">p1.name.append(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">print</span> p1.name  <span class="comment"># [1]</span></span><br><span class="line"><span class="keyword">print</span> p2.name  <span class="comment"># [1]</span></span><br><span class="line"><span class="keyword">print</span> Person.name  <span class="comment"># [1]</span></span><br></pre></td></tr></table></figure><h3 id="类对象和实例对象"><a href="#类对象和实例对象" class="headerlink" title="类对象和实例对象"></a>类对象和实例对象</h3><h4 id="类对象"><a href="#类对象" class="headerlink" title="类对象"></a>类对象</h4><p><code>Python</code>中一切皆对象；类定义完成后，会在当前作用域中定义一个以类名为名字，指向类对象的名字。如<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><p>会在当前作用域定义名字<code>Dog</code>，指向类对象<code>Dog</code>。</p><p><strong>类对象支持的操作</strong>：<br>总的来说，类对象仅支持两个操作：</p><ol><li>实例化；使用<code>instance_name = class_name()</code>的方式实例化，实例化操作创建该类的实例。</li><li>属性引用；使用<code>class_name.attr_name</code>的方式引用类属性。</li></ol><h4 id="实例对象"><a href="#实例对象" class="headerlink" title="实例对象"></a>实例对象</h4><p><strong>实例对象是类对象实例化的产物，实例对象仅支持一个操作</strong>:</p><ol><li>属性引用；与类对象属性引用的方式相同，使用<code>instance_name.attr_name</code>的方式。</li></ol><p>按照严格的面向对象思想，所有属性都应该是实例的，类属性不应该存在。那么在<code>Python</code>中，由于类属性绑定就不应该存在，类定义中就只剩下函数定义了。</p><p>在<a href="https://docs.python.org/3/tutorial/classes.html#class-definition-syntax" target="_blank" rel="noopener">Python tutorial</a>关于类定义也这么说：</p><blockquote><p>In practice, the statements inside a class definition will usually be function definitions, but other statements are allowed, and sometimes useful.</p></blockquote><p>实践中，类定义中的语句通常是函数定义，但是其他语句也是允许的，有时也是有用的。</p><p>这里说的其他语句，就是指类属性的绑定语句。</p><h3 id="属性绑定"><a href="#属性绑定" class="headerlink" title="属性绑定"></a>属性绑定</h3><p>在定义类时，通常我们说的定义属性，其实是分为两个方面的：</p><ol><li>类属性绑定</li><li>实例属性绑定</li></ol><p>用<strong>绑定</strong>这个词更加确切；不管是类对象还是实例对象，属性都是依托对象而存在的。</p><p>我们说的属性绑定，首先需要一个可变对象，才能执行绑定操作，使用</p><pre><code>objname.attr = attr_value</code></pre><p>的方式，为对象<code>objname</code>绑定属性<code>attr</code>。</p><p>这分两种情况：</p><ol><li>若属性<code>attr</code>已经存在，绑定操作会将属性名指向新的对象；</li><li>若不存在，则为该对象添加新的属性，后面就可以引用新增属性。</li></ol><h4 id="类属性绑定"><a href="#类属性绑定" class="headerlink" title="类属性绑定"></a>类属性绑定</h4><p><code>Python</code>作为动态语言，类对象和实例对象都可以在运行时绑定任意属性。因此，类属性的绑定发生在两个地方：</p><ol><li>类定义时；</li><li>运行时任意阶段。</li></ol><p>下面这个例子说明了类属性绑定发生的时期：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    kind = <span class="string">'canine'</span></span><br><span class="line"></span><br><span class="line">Dog.country = <span class="string">'China'</span></span><br><span class="line">print(Dog.kind, <span class="string">' - '</span>, Dog.country) <span class="comment"># output: canine - China</span></span><br><span class="line"><span class="keyword">del</span> Dog.kind</span><br><span class="line">print(Dog.kind, <span class="string">' - '</span>, Dog.country)</span><br><span class="line"><span class="comment"># AttributeError: type object 'Dog' has no attribute 'kind'</span></span><br></pre></td></tr></table></figure></p><p>在类定义中，类属性的绑定并没有使用<code>objname.attr = attr_value</code>的方式，这是一个特例，其实是等同于后面使用类名绑定属性的方式。<br>因为是动态语言，所以可以在运行时增加属性，删除属性。</p><h4 id="实例属性绑定"><a href="#实例属性绑定" class="headerlink" title="实例属性绑定"></a>实例属性绑定</h4><p>与类属性绑定相同，实例属性绑定也发生在两个地方：</p><ol><li>类定义时；</li><li>运行时任意阶段。</li></ol><p>示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">dog = Dog(<span class="string">'Lily'</span>, <span class="number">3</span>)</span><br><span class="line">dog.fur_color = <span class="string">'red'</span></span><br><span class="line">print(<span class="string">'%s is %s years old, it has %s fur'</span> % (dog.name, dog.age, dog.fur_color))</span><br><span class="line"><span class="comment"># Output: Lily is 3 years old, it has red fur</span></span><br></pre></td></tr></table></figure></p><p><code>Python</code>类实例有两个特殊之处：</p><ol><li><code>__init__</code>在实例化时执行</li><li><code>Python</code>实例调用方法时，会将实例对象作为第一个参数传递</li></ol><p>因此，<code>__init__</code>方法中的<code>self</code>就是实例对象本身，这里是<code>dog</code>，语句<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.name = name</span><br><span class="line">self.age = age</span><br></pre></td></tr></table></figure></p><p>以及后面的语句<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dog.fur_color = <span class="string">'red'</span></span><br></pre></td></tr></table></figure></p><p>为实例<code>dog</code>增加三个属性<code>name</code>, <code>age</code>, <code>fur_color</code>。</p><h3 id="属性引用"><a href="#属性引用" class="headerlink" title="属性引用"></a>属性引用</h3><h4 id="类属属性引用"><a href="#类属属性引用" class="headerlink" title="类属属性引用"></a>类属属性引用</h4><p>类属性的引用，肯定是需要类对象的，属性分为两种：</p><ol><li>数据属性</li><li>函数属性</li></ol><p>数据属性引用很简单，示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    kind = <span class="string">'canine'</span></span><br><span class="line"></span><br><span class="line">Dog.country = <span class="string">'China'</span></span><br><span class="line">print(Dog.kind, <span class="string">' - '</span>, Dog.country) <span class="comment"># output: canine - China</span></span><br></pre></td></tr></table></figure></p><p>通常很少有引用类函数属性的需求，示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    kind = <span class="string">'canine'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tell_kind</span><span class="params">()</span>:</span></span><br><span class="line">        print(Dog.kind)</span><br><span class="line"></span><br><span class="line">Dog.tell_kind() <span class="comment"># Output: canine</span></span><br></pre></td></tr></table></figure></p><p>函数<code>tell_kind</code>在引用<code>kind</code>需要使用<code>Dog.kind</code>而不是直接使用<code>kind</code>，涉及到作用域，这一点在我的另一篇文章中有介绍：<a href="http://www.cnblogs.com/crazyrunning/p/6914080.html" target="_blank" rel="noopener">Python进阶 - 命名空间与作用域</a></p><h4 id="实例属性引用"><a href="#实例属性引用" class="headerlink" title="实例属性引用"></a>实例属性引用</h4><p>使用实例对象引用属性稍微复杂一些，因为实例对象可引用类属性以及实例属性。但是实例对象引用属性时遵循以下规则：</p><ol><li>总是先到实例对象中查找属性，再到类属性中查找属性；</li><li>属性绑定语句总是为实例对象创建新属性，属性存在时，更新属性指向的对象。</li></ol><h5 id="数据属性引用"><a href="#数据属性引用" class="headerlink" title="数据属性引用"></a>数据属性引用</h5><p>示例1：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line"></span><br><span class="line">    kind = <span class="string">'canine'</span></span><br><span class="line">    country = <span class="string">'China'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, country)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.country = country</span><br><span class="line"></span><br><span class="line">dog = Dog(<span class="string">'Lily'</span>, <span class="number">3</span>, <span class="string">'Britain'</span>)</span><br><span class="line">print(dog.name, dog.age, dog.kind, dog.country)</span><br><span class="line"><span class="comment"># output: Lily 3 canine Britain</span></span><br></pre></td></tr></table></figure></p><p>类对象<code>Dog</code>与实例对象<code>dog</code>均有属性<code>country</code>，按照规则，<code>dog.country</code>会引用到实例对象的属性；但实例对象<code>dog</code>没有属性<code>kind</code>，按照规则会引用类对象的属性。</p><p>示例2：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line"></span><br><span class="line">    kind = <span class="string">'canine'</span></span><br><span class="line">    country = <span class="string">'China'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, country)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.country = country</span><br><span class="line"></span><br><span class="line">dog = Dog(<span class="string">'Lily'</span>, <span class="number">3</span>, <span class="string">'Britain'</span>)</span><br><span class="line">print(dog.name, dog.age, dog.kind, dog.country) <span class="comment"># Lily 3 canine Britain</span></span><br><span class="line">print(dog.__dict__) <span class="comment"># &#123;'name': 'Lily', 'age': 3, 'country': 'Britain'&#125;</span></span><br><span class="line"></span><br><span class="line">dog.kind = <span class="string">'feline'</span></span><br><span class="line">print(dog.name, dog.age, dog.kind, dog.country) <span class="comment"># Lily 3 feline Britain</span></span><br><span class="line">print(dog.__dict__)  <span class="comment"># &#123;'name': 'Lily', 'age': 3, 'country': 'Britain', 'kind': 'feline'&#125;</span></span><br><span class="line">print(Dog.kind) <span class="comment"># canine 没有改变类属性的指向</span></span><br></pre></td></tr></table></figure></p><p>示例3，可变类属性引用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line"></span><br><span class="line">    tricks = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_trick</span><span class="params">(self, trick)</span>:</span></span><br><span class="line">        <span class="comment"># self.tricks.append(trick)</span></span><br><span class="line">        Dog.tricks.append(trick)</span><br><span class="line"></span><br><span class="line">d = Dog(<span class="string">'Fido'</span>)</span><br><span class="line">e = Dog(<span class="string">'Buddy'</span>)</span><br><span class="line">d.add_trick(<span class="string">'roll over'</span>)</span><br><span class="line">e.add_trick(<span class="string">'play dead'</span>)</span><br><span class="line">print(d.tricks) <span class="comment"># ['roll over', 'play dead']</span></span><br></pre></td></tr></table></figure><p>语句<code>self.tricks.append(trick)</code>并不是属性绑定语句，因此还是在类属性上修改可变对象。</p><h5 id="方法属性引用"><a href="#方法属性引用" class="headerlink" title="方法属性引用"></a>方法属性引用</h5><p>与数据成员不同，类函数属性在实例对象中会变成方法属性。先看一个示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodTest</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_test</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'in class'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer_test</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'out of class'</span>)</span><br><span class="line"></span><br><span class="line">mt = MethodTest()</span><br><span class="line">mt.outer_test = outer_test</span><br><span class="line"></span><br><span class="line">print(type(MethodTest.inner_test))  <span class="comment"># &lt;class 'function'&gt; 类函数</span></span><br><span class="line">print(type(mt.inner_test))          <span class="comment">#&lt;class 'method'&gt; 类方法</span></span><br><span class="line">print(type(mt.outer_test))          <span class="comment">#&lt;class 'function'&gt; 类函数</span></span><br></pre></td></tr></table></figure><p>可以看到，类函数属性在实例对象中变成了方法属性，但是并不是实例对象中所有的函数都是方法。</p><p>Python tutorial中这样介绍方法对象：</p><blockquote><p>When an instance attribute is referenced that isn’t a data attribute, its class is searched. If the name denotes a valid class attribute that is a function object, a method object is created by packing (pointers to) the instance object and the function object just found together in an abstract object: this is the method object. When the method object is called with an argument list, a new argument list is constructed from the instance object and the argument list, and the function object is called with this new argument list.</p></blockquote><p>引用非数据属性的实例属性时，会搜索它对应的类。如果名字是一个有效的函数对象，Python会将实例对象连同函数对象打包到一个抽象的对象中并且依据这个对象创建方法对象：这就是被调用的方法对象。当使用参数列表调用方法对象时，会使用实例对象以及原有参数列表构建新的参数列表，并且使用新的参数列表调用函数对象。</p><p>那么，实例对象只有在引用方法属性时，才会将自身作为第一个参数传递；调用实例对象的普通函数，则不会。<br>所以可以使用如下方式直接调用方法与函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mt.inner_test()</span><br><span class="line">mt.outer_test()</span><br></pre></td></tr></table></figure><p>除了方法与函数的区别，其引用与数据属性都是一样的</p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>虽然<code>Python</code>作为动态语言，支持在运行时绑定属性，但是从面向对象的角度来看，还是在定义类的时候将属性确定下来。</p><p>参考:</p><ol><li><a href="http://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block" target="_blank" rel="noopener">http://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block</a></li><li><a href="https://www.cnblogs.com/crazyrunning/p/6945183.html" target="_blank" rel="noopener">https://www.cnblogs.com/crazyrunning/p/6945183.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;首先来一张图&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2952111-07f6d669392b20c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;classvariable.png&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;类变量和实例变量&quot;&gt;&lt;a href=&quot;#类变量和实例变量&quot; class=&quot;headerlink&quot; title=&quot;类变量和实例变量&quot;&gt;&lt;/a&gt;类变量和实例变量&lt;/h3&gt;&lt;p&gt;在Python Tutorial中对于类变量和实例变量是这样描述的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Generally speaking, instance variables are for data unique to each instance and class variables are for attributes and methods shared by all instances of the class:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Dog&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    kind = &lt;span class=&quot;string&quot;&gt;&#39;canine&#39;&lt;/span&gt;         &lt;span class=&quot;comment&quot;&gt;# class variable shared by all instances&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, name)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.name = name    &lt;span class=&quot;comment&quot;&gt;# instance variable unique to each instance&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;类&lt;code&gt;Dog&lt;/code&gt;中，类属性&lt;code&gt;kind&lt;/code&gt;为所有实例所共享；实例属性&lt;code&gt;name&lt;/code&gt;为每个&lt;code&gt;Dog&lt;/code&gt;的实例独有。&lt;br&gt;
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
      <category term="类变量 和 实例变量" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/%E7%B1%BB%E5%8F%98%E9%87%8F-%E5%92%8C-%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Python3 @staticmethod和@classmethod</title>
    <link href="http://yoursite.com/2018/03/01/Python3-staticmethod%E5%92%8C-classmethod/"/>
    <id>http://yoursite.com/2018/03/01/Python3-staticmethod和-classmethod/</id>
    <published>2018-02-28T18:01:19.000Z</published>
    <updated>2018-03-01T06:36:20.315Z</updated>
    
    <content type="html"><![CDATA[<p>Python其实有3个方法,即静态方法(staticmethod),类方法(classmethod)和实例方法,如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"executing foo(%s)"</span>%(x)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"executing foo(%s,%s)"</span>%(self,x)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">class_foo</span><span class="params">(cls,x)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"executing class_foo(%s,%s)"</span>%(cls,x)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static_foo</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"executing static_foo(%s)"</span>%x</span><br><span class="line"></span><br><span class="line">a=A()</span><br></pre></td></tr></table></figure><a id="more"></a><p>这里先理解下函数参数里面的self和cls。这个self和cls是对类或者实例的绑定,对于一般的函数来说我们可以这么调用<code>foo(x)</code>,这个函数就是最常用的,它的工作跟任何东西(类,实例)无关。<br>对于实例方法,我们知道在类里每次定义方法的时候都需要绑定这个实例,就是<code>foo(self, x)</code>,为什么要这么做呢?因为实例方法的调用离不开实例,我们需要把实例自己传给函数,调用的时候是这样的<code>a.foo(x)</code>(其实是<code>foo(a, x)</code>)。<br>类方法一样,只不过它传递的是<code>类</code>而不是实例,<code>A.class_foo(x)</code>。注意这里的self和cls可以替换别的参数,但是python的约定是这俩,还是不要改的好。</p><p>对于静态方法其实和普通的方法一样,不需要对谁进行绑定,唯一的区别是调用的时候需要使用<code>a.static_foo(x)</code>或者<code>A.static_foo(x)</code>来调用.</p><table><thead><tr><th style="text-align:left">\</th><th style="text-align:left">实例方法</th><th style="text-align:left">类方法</th><th style="text-align:left">静态方法</th></tr></thead><tbody><tr><td style="text-align:left">a = A()</td><td style="text-align:left">a.foo(x)</td><td style="text-align:left">a.class_foo(x)</td><td style="text-align:left">a.static_foo(x)</td></tr><tr><td style="text-align:left">A</td><td style="text-align:left">不可用</td><td style="text-align:left">A.class_foo(x)</td><td style="text-align:left">A.static_foo(x)</td></tr></tbody></table><p>更多关于这个问题:</p><ol><li><a href="http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python" target="_blank" rel="noopener">http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python</a></li><li><a href="https://realpython.com/blog/python/instance-class-and-static-methods-demystified/" target="_blank" rel="noopener">https://realpython.com/blog/python/instance-class-and-static-methods-demystified/</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python其实有3个方法,即静态方法(staticmethod),类方法(classmethod)和实例方法,如下:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(x)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;executing foo(%s)&quot;&lt;/span&gt;%(x)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(object)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self,x)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;executing foo(%s,%s)&quot;&lt;/span&gt;%(self,x)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;    @classmethod&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;class_foo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(cls,x)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;executing class_foo(%s,%s)&quot;&lt;/span&gt;%(cls,x)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;    @staticmethod&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;static_foo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(x)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;executing static_foo(%s)&quot;&lt;/span&gt;%x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a=A()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
      <category term="Staticmethod &amp; Classmethod" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/Staticmethod-Classmethod/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客Next主题添加Fork me on GitHub标签</title>
    <link href="http://yoursite.com/2018/02/28/Hexo%E5%8D%9A%E5%AE%A2Next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0Fork-me-on-GitHub%E6%A0%87%E7%AD%BE/"/>
    <id>http://yoursite.com/2018/02/28/Hexo博客Next主题添加Fork-me-on-GitHub标签/</id>
    <published>2018-02-28T10:09:26.000Z</published>
    <updated>2018-02-28T10:35:15.748Z</updated>
    
    <content type="html"><![CDATA[<p>给自己的个人博客添加Fork me on GitHub标签感觉很专业很逼格，添加的方法也很简单，介绍如下。</p><p>打开文件：<strong>hexo博客根目录/themes/next/layout/_layout.swig</strong> 找到如下代码块<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;div class="&#123;&#123; container_class &#125;&#125; &#123;% block page_class %&#125;&#123;% endblock %&#125; "&gt;</span><br><span class="line">    &lt;div class="headband"&gt;&lt;/div&gt;</span><br><span class="line">    [样式代码]</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>样式代码 <a href="https://link.jianshu.com/?t=https://github.com/blog/273-github-ribbons" target="_blank" rel="noopener"><strong>看这里</strong></a> ，挑选自己喜欢的样式。</p><p>然后将样式代码添加到上述 <strong>_layout.swig</strong> 代码块后面，比如选择黑色经典款，即：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&lt;div class="&#123;&#123; container_class &#125;&#125; &#123;% block page_class %&#125;&#123;% endblock %&#125; "&gt;</span><br><span class="line">    &lt;div class="headband"&gt;&lt;/div&gt;</span><br><span class="line">    <span class="comment"># [样式代码]</span></span><br><span class="line">    &lt;a href="https://github.com/you"&gt;&lt;img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>重新部署一下就可以查看了，如果显示不出来，需要清理浏览器的cookie,多刷新几次就OK了。<br>大家看我的，感觉很搭( ⊙ o ⊙ )！<br><img src="http://upload-images.jianshu.io/upload_images/2952111-13a15afaa9450272.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="fork me on github"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;给自己的个人博客添加Fork me on GitHub标签感觉很专业很逼格，添加的方法也很简单，介绍如下。&lt;/p&gt;
&lt;p&gt;打开文件：&lt;strong&gt;hexo博客根目录/themes/next/layout/_layout.swig&lt;/strong&gt; 找到如下代码块&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;div class=&quot;&amp;#123;&amp;#123; container_class &amp;#125;&amp;#125; &amp;#123;% block page_class %&amp;#125;&amp;#123;% endblock %&amp;#125; &quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;div class=&quot;headband&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [样式代码]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo部署的网站项目(.deploy_git)中添加README.md</title>
    <link href="http://yoursite.com/2018/02/28/Hexo%E9%83%A8%E7%BD%B2%E7%9A%84%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE-deploy-git-%E4%B8%AD%E6%B7%BB%E5%8A%A0README-md/"/>
    <id>http://yoursite.com/2018/02/28/Hexo部署的网站项目-deploy-git-中添加README-md/</id>
    <published>2018-02-28T06:05:20.000Z</published>
    <updated>2018-02-28T06:29:24.312Z</updated>
    
    <content type="html"><![CDATA[<p>终端中执行hexo generate时，会将source文件夹中的.md文件渲染为.html文件到public文件夹中，所以我们可以将README.md文件放到source文件夹中，这样在执行hexo deploy时，生成的.deploy_git文件夹中就会有README文件。但此时并不是我们想要的README.md。<br><a id="more"></a><br>需要注意的是，我们要防止此.md文件被渲染为.html文件，因此，需要在站点配置文件_config.yml中设置skip_render: README.md，这样部署完成后我们就可以在配置的.deploy_git中看到README.md了。</p><p>配置截图如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/2952111-1ce4c1b9e78bee3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终端中执行hexo generate时，会将source文件夹中的.md文件渲染为.html文件到public文件夹中，所以我们可以将README.md文件放到source文件夹中，这样在执行hexo deploy时，生成的.deploy_git文件夹中就会有README文件。但此时并不是我们想要的README.md。&lt;br&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>从零开始学爬虫-05</title>
    <link href="http://yoursite.com/2018/02/28/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E7%88%AC%E8%99%AB-05/"/>
    <id>http://yoursite.com/2018/02/28/从零开始学爬虫-05/</id>
    <published>2018-02-27T17:17:37.000Z</published>
    <updated>2018-02-27T17:22:51.289Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要使用Cookie"><a href="#为什么要使用Cookie" class="headerlink" title="为什么要使用Cookie"></a>为什么要使用Cookie</h2><p>Cookie，指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密)。<br>比如说有些网站需要登录后才能访问某个页面，在登录之前，你想抓取某个页面内容，登陆前与登陆后是不同的，或者不允许的。<br>使用Cookie和使用代理IP一样，也需要创建一个自己的opener。在HTTP包中，提供了cookiejar模块，用于提供对Cookie的支持。</p><p><img src="http://img.blog.csdn.net/20170409144243654?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br><a id="more"></a></p><p>http.cookiejar功能强大，我们可以利用本模块的CookieJar类的对象来捕获cookie并在后续连接请求时重新发送，比如可以实现模拟登录功能。该模块主要的对象有CookieJar、FileCookieJar、MozillaCookieJar、LWPCookieJar。</p><p><strong>它们的关系：</strong> CookieJar–派生–&gt;FileCookieJar–派生–&gt;MozillaCookieJar和LWPCookieJar</p><p><strong>工作原理：</strong> 创建一个带有cookie的opener，在访问登录的URL时，将登录后的cookie保存下来，然后利用这个cookie来访问其他网址。查看登录之后才能看到的信息。</p><p>同样，我们以实例进行讲解，爬取伯乐在线的面向对象的漂亮MM的邮箱联系方式。</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="1-背景介绍"><a href="#1-背景介绍" class="headerlink" title="(1).背景介绍"></a>(1).背景介绍</h3><p>在伯乐在线有这么一个有趣的模块，面向对象，它说白了就是提供了一个程序员(媛)网上相亲的平台。</p><p><strong>URL:</strong> <a href="http://date.jobbole.com/" target="_blank" rel="noopener">http://date.jobbole.com/</a></p><p>它的样子是这样的：</p><p><img src="http://img.blog.csdn.net/20170409144753813?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>可以看到，这里有很多的相亲贴，随便点进去就会有网上相亲MM的详细信息，想获取MM的联系方式，需要积分，积分可以通过签到的方式获取。如果没有登陆账户，获取联系方式的地方是这个样子的：</p><p><img src="http://img.blog.csdn.net/20170409144912938?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>如果登陆了账号，获取联系方式的地方是这个样子的：</p><p><img src="http://img.blog.csdn.net/20170409144955289?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>想要爬取MM的联系邮箱，就需要用到我们本次讲到的知识，Cookie的使用。当然，首先你积分也得够。</p><p>在讲解之前，推荐一款抓包工具–Fiddler，可以在Google Chrome的Google商店下载这个插件，它的样子是这样的：</p><p><img src="http://img.blog.csdn.net/20170409145106869?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>可以看到，通过这个插件，我们可以很容易找到Post的Form Data等信息，很方便，当然也可以用之前讲得浏览器审查元素的方式查看这些信息。</p><h3 id="2-过程分析"><a href="#2-过程分析" class="headerlink" title="(2).过程分析"></a>(2).过程分析</h3><p>在伯乐在线首页点击登陆的按钮，Fiddler的抓包内容如下：</p><p><img src="http://img.blog.csdn.net/20170409145240590?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>从上图可以看出，真正请求的url是</p><p> <a href="http://www.jobbole.com/wp-admin/admin-ajax.php" target="_blank" rel="noopener">http://www.jobbole.com/wp-admin/admin-ajax.php</a></p><p>Form Data的内容记住，这些是我们编程需要用到的。user_login是用户名，user_pass是用户密码。</p><p>在点击取得联系邮箱按钮的时候，Fiddler的抓包内容如下：</p><p><img src="http://img.blog.csdn.net/20170409145403065?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>从上图可以看出，此刻真正请求的url是</p><p> <a href="http://date.jobbole.com/wp-admin/admin-ajax.php" target="_blank" rel="noopener">http://date.jobbole.com/wp-admin/admin-ajax.php</a></p><p>同样Form Data中内容要记下来。postId是每个帖子的id。例如，打开一个相亲贴，它的URL是<a href="http://date.jobbole.com/4128/" target="_blank" rel="noopener">http://date.jobbole.com/4128/</a>，那么它的这个postId就是4128。为了简化程序，这里就不讲解如何自动获取这个postId了，本实例直接指定postId。如果想要自动获取，可以使用beautifulsoup解析<a href="http://date.jobbole.com/" target="_blank" rel="noopener">http://date.jobbole.com/</a>返回的信息。beautifulsoup的使用。有机会的话，会在后面的爬虫笔记中进行讲解。</p><h3 id="3-测试"><a href="#3-测试" class="headerlink" title="(3).测试"></a>(3).测试</h3><p><strong>1)将Cookie保存到变量中</strong></p><p>首先，我们先利用CookieJar对象实现获取cookie的功能，存储到变量中，先来感受一下,执行文件cookie01.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> http <span class="keyword">import</span> cookiejar</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment">#声明一个CookieJar对象实例来保存cookie</span></span><br><span class="line">    cookie = cookiejar.CookieJar()</span><br><span class="line">    <span class="comment">#利用urllib.request库的HTTPCookieProcessor对象来创建cookie处理器,也就CookieHandler</span></span><br><span class="line">    handler=request.HTTPCookieProcessor(cookie)</span><br><span class="line">    <span class="comment">#通过CookieHandler创建opener</span></span><br><span class="line">    opener = request.build_opener(handler)</span><br><span class="line">    <span class="comment">#此处的open方法打开网页</span></span><br><span class="line">    response = opener.open(<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line">    <span class="comment">#打印cookie信息</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> cookie:</span><br><span class="line">        print(<span class="string">'Name = %s'</span> % item.name)</span><br><span class="line">        print(<span class="string">'Value = %s'</span> % item.value)</span><br></pre></td></tr></table></figure><p>我们使用以上方法将cookie保存到变量中，然后打印出了cookie中的值，运行结果如下:</p><p><img src="http://img.blog.csdn.net/20170409145652613?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p><strong>2)保存Cookie到文件</strong></p><p>在上面的方法中，我们将cookie保存到了cookie这个变量中，如果我们想将cookie保存到文件中该怎么做呢？方便以后直接读取文件使用，这时，我们就要用到FileCookieJar这个对象了，在这里我们使用它的子类MozillaCookieJar来实现Cookie的保存，编写代码如下,文件为cookie02.py：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> http <span class="keyword">import</span> cookiejar</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">#设置保存cookie的文件，同级目录下的cookie.txt</span></span><br><span class="line">    filename = <span class="string">'cookie.txt'</span></span><br><span class="line">    <span class="comment">#声明一个MozillaCookieJar对象实例来保存cookie，之后写入文件</span></span><br><span class="line">    cookie = cookiejar.MozillaCookieJar(filename)</span><br><span class="line">    <span class="comment">#利用urllib.request库的HTTPCookieProcessor对象来创建cookie处理器,也就CookieHandler</span></span><br><span class="line">    handler=request.HTTPCookieProcessor(cookie)</span><br><span class="line">    <span class="comment">#通过CookieHandler创建opener</span></span><br><span class="line">    opener = request.build_opener(handler)</span><br><span class="line">    <span class="comment">#此处的open方法打开网页</span></span><br><span class="line">    response = opener.open(<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line">    <span class="comment">#保存cookie到文件</span></span><br><span class="line">    cookie.save(ignore_discard=<span class="keyword">True</span>, ignore_expires=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure></p><p>cookie.save的参数说明：</p><ul><li><p>ignore_discard的意思是即使cookies将被丢弃也将它保存下来；</p></li><li><p>ignore_expires的意思是如果在该文件中cookies已经存在，则覆盖原文件写入。</p></li></ul><p>在这里，我们将这两个全部设置为True。</p><p>运行之后，cookies将被保存到cookie.txt文件中。我们可以查看自己查看下cookie.txt这个文件的内容。</p><p><strong>3)从文件中获取Cookie并访问</strong></p><p>我们已经做到把Cookie保存到文件中了，如果以后想使用，可以利用下面的方法来读取cookie并访问网站，感受一下cookie03.py：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> http <span class="keyword">import</span> cookiejar</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment">#设置保存cookie的文件的文件名,相对路径,也就是同级目录下</span></span><br><span class="line">    filename = <span class="string">'cookie.txt'</span></span><br><span class="line">    <span class="comment">#创建MozillaCookieJar实例对象</span></span><br><span class="line">    cookie = cookiejar.MozillaCookieJar()</span><br><span class="line">    <span class="comment">#从文件中读取cookie内容到变量</span></span><br><span class="line">    cookie.load(filename, ignore_discard=<span class="keyword">True</span>, ignore_expires=<span class="keyword">True</span>)</span><br><span class="line">    <span class="comment">#利用urllib.request库的HTTPCookieProcessor对象来创建cookie处理器,也就CookieHandler</span></span><br><span class="line">    handler=request.HTTPCookieProcessor(cookie)</span><br><span class="line">    <span class="comment">#通过CookieHandler创建opener</span></span><br><span class="line">    opener = request.build_opener(handler)</span><br><span class="line">    <span class="comment">#此用opener的open方法打开网页</span></span><br><span class="line">    response = opener.open(<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line">    <span class="comment">#打印信息</span></span><br><span class="line">    print(response.read().decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure></p><p>了解到以上内容，我们那就可以开始正式编写模拟登陆伯乐在线的程序了。同时，我们也可以获取相亲MM的联系方式。</p><h3 id="4-编写代码"><a href="#4-编写代码" class="headerlink" title="(4).编写代码"></a>(4).编写代码</h3><p>我们利用CookieJar对象实现获取cookie的功能，存储到变量中。然后使用这个cookie变量创建opener，使用这个设置好cookie的opener即可模拟登陆，同笔记四中讲到的IP代理的使用方法类似。</p><p>创建cookie_test.py文件，编写代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> error</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"><span class="keyword">from</span> http <span class="keyword">import</span> cookiejar</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment">#登陆地址</span></span><br><span class="line">    login_url = <span class="string">'http://www.jobbole.com/wp-admin/admin-ajax.php'</span>    </span><br><span class="line">    <span class="comment">#User-Agent信息                   </span></span><br><span class="line">    user_agent = <span class="string">r'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.94 Safari/537.36'</span></span><br><span class="line">    <span class="comment">#Headers信息</span></span><br><span class="line">    head = &#123;<span class="string">'User-Agnet'</span>: user_agent, <span class="string">'Connection'</span>: <span class="string">'keep-alive'</span>&#125;</span><br><span class="line">    <span class="comment">#登陆Form_Data信息</span></span><br><span class="line">    Login_Data = &#123;&#125;</span><br><span class="line">    Login_Data[<span class="string">'action'</span>] = <span class="string">'user_login'</span></span><br><span class="line">    Login_Data[<span class="string">'redirect_url'</span>] = <span class="string">'http://www.jobbole.com/'</span></span><br><span class="line">    Login_Data[<span class="string">'remember_me'</span>] = <span class="string">'0'</span>         <span class="comment">#是否一个月内自动登陆</span></span><br><span class="line">    Login_Data[<span class="string">'user_login'</span>] = <span class="string">'********'</span>       <span class="comment">#改成你自己的用户名</span></span><br><span class="line">    Login_Data[<span class="string">'user_pass'</span>] = <span class="string">'********'</span>        <span class="comment">#改成你自己的密码</span></span><br><span class="line">    <span class="comment">#使用urlencode方法转换标准格式</span></span><br><span class="line">    logingpostdata = parse.urlencode(Login_Data).encode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="comment">#声明一个CookieJar对象实例来保存cookie</span></span><br><span class="line">    cookie = cookiejar.CookieJar()</span><br><span class="line">    <span class="comment">#利用urllib.request库的HTTPCookieProcessor对象来创建cookie处理器,也就CookieHandler</span></span><br><span class="line">    cookie_support = request.HTTPCookieProcessor(cookie)</span><br><span class="line">    <span class="comment">#通过CookieHandler创建opener</span></span><br><span class="line">    opener = request.build_opener(cookie_support)</span><br><span class="line">    <span class="comment">#创建Request对象</span></span><br><span class="line">    req1 = request.Request(url=login_url, data=logingpostdata, headers=head)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#面向对象地址</span></span><br><span class="line">    date_url = <span class="string">'http://date.jobbole.com/wp-admin/admin-ajax.php'</span></span><br><span class="line">    <span class="comment">#面向对象</span></span><br><span class="line">    Date_Data = &#123;&#125;</span><br><span class="line">    Date_Data[<span class="string">'action'</span>] = <span class="string">'get_date_contact'</span></span><br><span class="line">    Date_Data[<span class="string">'postId'</span>] = <span class="string">'4128'</span></span><br><span class="line">    <span class="comment">#使用urlencode方法转换标准格式</span></span><br><span class="line">    datepostdata = parse.urlencode(Date_Data).encode(<span class="string">'utf-8'</span>)</span><br><span class="line">    req2 = request.Request(url=date_url, data=datepostdata, headers=head)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment">#使用自己创建的opener的open方法</span></span><br><span class="line">        response1 = opener.open(req1)</span><br><span class="line">        response2 = opener.open(req2)</span><br><span class="line">        html = response2.read().decode(<span class="string">'utf-8'</span>)</span><br><span class="line">        index = html.find(<span class="string">'jb_contact_email'</span>)</span><br><span class="line">        <span class="comment">#打印查询结果</span></span><br><span class="line">        print(<span class="string">'联系邮箱:%s'</span> % html[index+<span class="number">19</span>:<span class="number">-2</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> error.URLError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">if</span> hasattr(e, <span class="string">'code'</span>):</span><br><span class="line">            print(<span class="string">"HTTPError:%d"</span> % e.code)</span><br><span class="line">        <span class="keyword">elif</span> hasattr(e, <span class="string">'reason'</span>):</span><br><span class="line">            print(<span class="string">"URLError:%s"</span> % e.reason)</span><br></pre></td></tr></table></figure></p><h3 id="5-运行结果如下"><a href="#5-运行结果如下" class="headerlink" title="(5).运行结果如下"></a>(5).运行结果如下</h3><p><img src="http://img.blog.csdn.net/20170409150252854?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么要使用Cookie&quot;&gt;&lt;a href=&quot;#为什么要使用Cookie&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用Cookie&quot;&gt;&lt;/a&gt;为什么要使用Cookie&lt;/h2&gt;&lt;p&gt;Cookie，指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密)。&lt;br&gt;比如说有些网站需要登录后才能访问某个页面，在登录之前，你想抓取某个页面内容，登陆前与登陆后是不同的，或者不允许的。&lt;br&gt;使用Cookie和使用代理IP一样，也需要创建一个自己的opener。在HTTP包中，提供了cookiejar模块，用于提供对Cookie的支持。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170409144243654?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Spider" scheme="http://yoursite.com/categories/Spider/"/>
    
      <category term="Urllib" scheme="http://yoursite.com/categories/Spider/Urllib/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
      <category term="Spider" scheme="http://yoursite.com/tags/Spider/"/>
    
      <category term="Urllib" scheme="http://yoursite.com/tags/Urllib/"/>
    
  </entry>
  
  <entry>
    <title>从零开始学爬虫-04</title>
    <link href="http://yoursite.com/2018/02/28/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E7%88%AC%E8%99%AB-04/"/>
    <id>http://yoursite.com/2018/02/28/从零开始学爬虫-04/</id>
    <published>2018-02-27T17:06:56.000Z</published>
    <updated>2018-02-27T17:18:25.138Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h2><p>urllib_test10.py已经无法爬取了，因为原网站已经添加了防爬虫机制</p><h2 id="一-、为何要设置User-Agent"><a href="#一-、为何要设置User-Agent" class="headerlink" title="(一)、为何要设置User Agent"></a>(一)、为何要设置User Agent</h2><p>有一些网站不喜欢被爬虫程序访问，所以会检测连接对象，如果是爬虫程序，也就是非人点击访问，它就会不让你继续访问，所以为了要让程序可以正常运行，需要隐藏自己的爬虫程序的身份。此时，我们就可以通过设置User Agent的来达到隐藏身份的目的，User Agent的中文名为用户代理，简称UA。</p><p>User Agent存放于Headers中，服务器就是通过查看Headers中的User Agent来判断是谁在访问。在Python中，如果不设置User Agent，程序将使用默认的参数，那么这个User Agent就会有Python的字样，如果服务器检查User Agent，那么没有设置User Agent的Python程序将无法正常访问网站。</p><p>Python允许我们修改这个User Agent来模拟浏览器访问，它的强大毋庸置疑。<br><a id="more"></a></p><h2 id="二-、常见的User-Agent"><a href="#二-、常见的User-Agent" class="headerlink" title="(二)、常见的User Agent"></a>(二)、常见的User Agent</h2><h3 id="1-Android"><a href="#1-Android" class="headerlink" title="(1).Android"></a>(1).Android</h3><ul><li>Mozilla/5.0 (Linux; Android 4.1.1; Nexus 7 Build/JRO03D) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.166 Safari/535.19</li><li>Mozilla/5.0 (Linux; U; Android 4.0.4; en-gb; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30</li><li>Mozilla/5.0 (Linux; U; Android 2.2; en-gb; GT-P1000 Build/FROYO) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1</li></ul><h3 id="2-Firefox"><a href="#2-Firefox" class="headerlink" title="(2).Firefox"></a>(2).Firefox</h3><ul><li>Mozilla/5.0 (Windows NT 6.2; WOW64; rv:21.0) Gecko/20100101 Firefox/21.0</li><li>Mozilla/5.0 (Android; Mobile; rv:14.0) Gecko/14.0 Firefox/14.0</li></ul><h3 id="3-Google-Chrome"><a href="#3-Google-Chrome" class="headerlink" title="(3).Google Chrome"></a>(3).Google Chrome</h3><ul><li>Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.94 Safari/537.36</li><li>Mozilla/5.0 (Linux; Android 4.0.4; Galaxy Nexus Build/IMM76B) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.133 Mobile Safari/535.19</li></ul><h3 id="4-iOS"><a href="#4-iOS" class="headerlink" title="(4).iOS"></a>(4).iOS</h3><ul><li>Mozilla/5.0 (iPad; CPU OS 5_0 like Mac OS X) AppleWebKit/534.46 (KHTML, like Gecko) Version/5.1 Mobile/9A334 Safari/7534.48.3</li><li>Mozilla/5.0 (iPod; U; CPU like Mac OS X; en) AppleWebKit/420.1 (KHTML, like Gecko) Version/3.0 Mobile/3A101a Safari/419.3</li></ul><p>上面列举了Andriod、Firefox、Google Chrome、iOS的一些User Agent，直接copy就能用。</p><h2 id="三-、设置User-Agent的方法"><a href="#三-、设置User-Agent的方法" class="headerlink" title="(三)、设置User Agent的方法"></a>(三)、设置User Agent的方法</h2><p>先看下urllib.request.Request()</p><p> <img src="http://img.blog.csdn.net/20170303123244632?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="1"></p><p>从上图可以看出，在创建Request对象的时候，可以传入headers参数。因此，想要设置User Agent，有两种方法：</p><ul><li><p>1.在创建Request对象的时候，填入headers参数(包含User Agent信息)，这个Headers参数要求为字典；</p></li><li><p>2.在创建Request对象的时候不添加headers参数，在创建完成之后，使用add_header()的方法，添加headers。</p></li></ul><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>创建文件urllib_test08.py，使用上面提到的Android的第一个User Agent，在创建Request对象的时候传入headers参数，编写代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    url = <span class="string">'http://www.csdn.net/'</span></span><br><span class="line">    head = &#123;&#125;</span><br><span class="line">    <span class="comment">#写入User Agent信息</span></span><br><span class="line">    head[<span class="string">'User-Agent'</span>] = <span class="string">'Mozilla/5.0 (Linux; Android 4.1.1; Nexus 7 Build/JRO03D) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.166  Safari/535.19'</span></span><br><span class="line">    <span class="comment">#创建Request对象</span></span><br><span class="line">    req = request.Request(url, headers=head)</span><br><span class="line">    <span class="comment">#传入创建好的Request对象</span></span><br><span class="line">    response = request.urlopen(req)</span><br><span class="line">    <span class="comment">#读取响应信息并解码</span></span><br><span class="line">    html = response.read().decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="comment">#打印信息</span></span><br><span class="line">    print(html)</span><br></pre></td></tr></table></figure></p><p>运行结果如下：</p><p> <img src="http://img.blog.csdn.net/20170303123738649?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="2"></p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>创建文件urllib_test09.py，使用上面提到的Android的第一个User Agent，在创建Request对象时不传入headers参数，创建之后使用add_header()方法，添加headers，编写代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment">#以CSDN为例，CSDN不更改User Agent是无法访问的</span></span><br><span class="line">    url = <span class="string">'http://www.csdn.net/'</span></span><br><span class="line">    <span class="comment">#创建Request对象</span></span><br><span class="line">    req = request.Request(url)</span><br><span class="line">    <span class="comment">#传入headers</span></span><br><span class="line">    req.add_header(<span class="string">'User-Agent'</span>, <span class="string">'Mozilla/5.0 (Linux; Android 4.1.1; Nexus 7 Build/JRO03D) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.166  Safari/535.19'</span>)</span><br><span class="line">    <span class="comment">#传入创建好的Request对象</span></span><br><span class="line">    response = request.urlopen(req)</span><br><span class="line">    <span class="comment">#读取响应信息并解码</span></span><br><span class="line">    html = response.read().decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="comment">#打印信息</span></span><br><span class="line">    print(html)</span><br></pre></td></tr></table></figure></p><p>运行结果和上一个方法是一样的。</p><h2 id="四-、IP代理的使用"><a href="#四-、IP代理的使用" class="headerlink" title="(四)、IP代理的使用"></a>(四)、IP代理的使用</h2><h3 id="1-为何使用IP代理"><a href="#1-为何使用IP代理" class="headerlink" title="(1).为何使用IP代理"></a>(1).为何使用IP代理</h3><p>User Agent已经设置好了，但是还应该考虑一个问题，程序的运行速度是很快的，如果我们利用一个爬虫程序在网站爬取东西，一个固定IP的访问频率就会很高，这不符合人为操作的标准，因为人操作不可能在几ms内，进行如此频繁的访问。所以一些网站会设置一个IP访问频率的阈值，如果一个IP访问频率超过这个阈值，说明这个不是人在访问，而是一个爬虫程序。</p><h3 id="2-一般步骤说明"><a href="#2-一般步骤说明" class="headerlink" title="(2).一般步骤说明"></a>(2).一般步骤说明</h3><p>一个很简单的解决办法就是设置延时，但是这显然不符合爬虫快速爬取信息的目的，所以另一种更好的方法就是使用IP代理。使用代理的步骤：</p><p><strong>(1)</strong> 调用urlib.request.ProxyHandler()，proxies参数为一个字典。</p><p> <img src="http://img.blog.csdn.net/20170303124421012?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="4"></p><p><strong>(2)</strong> 创建Opener(类似于urlopen，这个代开方式是我们自己定制的)</p><p><img src="http://img.blog.csdn.net/20170303124447169?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="5"></p><p><strong>(3)</strong> 安装Opener</p><p><img src="http://img.blog.csdn.net/20170303124507044?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="引用容"></p><p>使用install_opener方法之后，会将程序默认的urlopen方法替换掉。也就是说，如果使用install_opener之后，在该文件中，再次调用urlopen会使用自己创建好的opener。如果不想替换掉，只是想临时使用一下，可以使用opener.open(url)，这样就不会对程序默认的urlopen有影响。</p><h3 id="3-代理IP选取"><a href="#3-代理IP选取" class="headerlink" title="(3).代理IP选取"></a>(3).代理IP选取</h3><p>在写代码之前，先在代理IP网站选好一个IP地址，推荐西刺代理IP。</p><p>URL：<a href="http://www.xicidaili.com/" target="_blank" rel="noopener">http://www.xicidaili.com/</a></p><p>注意：当然也可以写个正则表达式从网站直接爬取IP，但是要记住不要太频繁爬取，加个延时什么的，太频繁给服务器带来压力了，服务器会直接把你block，不让你访问的，我就被封了两天。</p><p>从西刺网站选出信号好的IP，我的选择如下：(106.46.136.112:808)</p><p> <img src="http://img.blog.csdn.net/20170303124651091?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="6"></p><p>编写代码访问<a href="http://www.whatismyip.com.tw/" target="_blank" rel="noopener">http://www.whatismyip.com.tw/</a>，该网站是测试自己IP为多少的网址，服务器会返回访问者的IP。</p><h3 id="4-代码实例"><a href="#4-代码实例" class="headerlink" title="(4).代码实例"></a>(4).代码实例</h3><p>创建文件urllib_test10.py，编写代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment">#访问网址</span></span><br><span class="line">    url = <span class="string">'http://www.whatismyip.com.tw/'</span></span><br><span class="line">    <span class="comment">#这是代理IP</span></span><br><span class="line">    proxy = &#123;<span class="string">'http'</span>:<span class="string">'106.46.136.112:808'</span>&#125;</span><br><span class="line">    <span class="comment">#创建ProxyHandler</span></span><br><span class="line">    proxy_support = request.ProxyHandler(proxy)</span><br><span class="line">    <span class="comment">#创建Opener</span></span><br><span class="line">    opener = request.build_opener(proxy_support)</span><br><span class="line">    <span class="comment">#添加User Angent</span></span><br><span class="line">    opener.addheaders = [(<span class="string">'User-Agent'</span>,<span class="string">'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36'</span>)]</span><br><span class="line">    <span class="comment">#安装OPener</span></span><br><span class="line">    request.install_opener(opener)</span><br><span class="line">    <span class="comment">#使用自己安装好的Opener</span></span><br><span class="line">    response = request.urlopen(url)</span><br><span class="line">    <span class="comment">#读取相应信息并解码</span></span><br><span class="line">    html = response.read().decode(<span class="string">"utf-8"</span>)</span><br><span class="line">    <span class="comment">#打印信息</span></span><br><span class="line">    print(html)</span><br></pre></td></tr></table></figure></p><p>运行结果如下：<br><img src="http://img.blog.csdn.net/20170303124823038?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYzQwNjQ5NTc2Mg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="7"></p><p>从上图可以看出，访问的IP已经伪装成了106.46.136.112。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;说在前面&quot;&gt;&lt;a href=&quot;#说在前面&quot; class=&quot;headerlink&quot; title=&quot;说在前面&quot;&gt;&lt;/a&gt;说在前面&lt;/h2&gt;&lt;p&gt;urllib_test10.py已经无法爬取了，因为原网站已经添加了防爬虫机制&lt;/p&gt;
&lt;h2 id=&quot;一-、为何要设置User-Agent&quot;&gt;&lt;a href=&quot;#一-、为何要设置User-Agent&quot; class=&quot;headerlink&quot; title=&quot;(一)、为何要设置User Agent&quot;&gt;&lt;/a&gt;(一)、为何要设置User Agent&lt;/h2&gt;&lt;p&gt;有一些网站不喜欢被爬虫程序访问，所以会检测连接对象，如果是爬虫程序，也就是非人点击访问，它就会不让你继续访问，所以为了要让程序可以正常运行，需要隐藏自己的爬虫程序的身份。此时，我们就可以通过设置User Agent的来达到隐藏身份的目的，User Agent的中文名为用户代理，简称UA。&lt;/p&gt;
&lt;p&gt;User Agent存放于Headers中，服务器就是通过查看Headers中的User Agent来判断是谁在访问。在Python中，如果不设置User Agent，程序将使用默认的参数，那么这个User Agent就会有Python的字样，如果服务器检查User Agent，那么没有设置User Agent的Python程序将无法正常访问网站。&lt;/p&gt;
&lt;p&gt;Python允许我们修改这个User Agent来模拟浏览器访问，它的强大毋庸置疑。&lt;br&gt;
    
    </summary>
    
      <category term="Spider" scheme="http://yoursite.com/categories/Spider/"/>
    
      <category term="Urllib" scheme="http://yoursite.com/categories/Spider/Urllib/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
      <category term="Spider" scheme="http://yoursite.com/tags/Spider/"/>
    
      <category term="Urllib" scheme="http://yoursite.com/tags/Urllib/"/>
    
  </entry>
  
  <entry>
    <title>从零开始学爬虫-03</title>
    <link href="http://yoursite.com/2018/02/28/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E7%88%AC%E8%99%AB-03/"/>
    <id>http://yoursite.com/2018/02/28/从零开始学爬虫-03/</id>
    <published>2018-02-27T16:57:01.000Z</published>
    <updated>2018-02-27T17:04:43.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="urllib-error"><a href="#urllib-error" class="headerlink" title="urllib.error"></a>urllib.error</h2><p>urllib.error可以接收有urllib.request产生的异常。urllib.error有两个方法，URLError和HTTPError。如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/2952111-165a6b7bb4f6e5af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screen Shot 2018-02-12 at 14.39.09.png"></p><p>URLError是OSError的一个子类，HTTPError是URLError的一个子类，服务器上HTTP的响应会返回一个状态码，根据这个HTTP状态码，我们可以知道我们的访问是否成功。例如第二个笔记中提到的200状态码，表示请求成功，再比如常见的404错误等。<br><a id="more"></a></p><h3 id="1-URLError"><a href="#1-URLError" class="headerlink" title="(1).URLError"></a>(1).URLError</h3><p>让我们先看下URLError的异常，创建文件urllib_test05.py，编写如下代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> error</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment">#一个不存在的连接</span></span><br><span class="line">    url = <span class="string">"http://www.dskfclyfiydl.com/"</span></span><br><span class="line">    req = request.Request(url)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = request.urlopen(req)</span><br><span class="line">        html = response.read().decode(<span class="string">'utf-8'</span>)</span><br><span class="line">        print(html)</span><br><span class="line">    <span class="keyword">except</span> error.URLError <span class="keyword">as</span> e:</span><br><span class="line">        print(e.reason)</span><br></pre></td></tr></table></figure></p><p>可以看到如下运行结果：</p><p><img src="http://upload-images.jianshu.io/upload_images/2952111-5e9dfdc6af1af203.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screen Shot 2018-02-12 at 14.35.56.png"></p><h3 id="2-HTTPError"><a href="#2-HTTPError" class="headerlink" title="(2).HTTPError"></a>(2).HTTPError</h3><p>再看下HTTPError异常，创建文件urllib_test06.py，编写如下代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> error</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment">#一个不存在的连接</span></span><br><span class="line">    url = <span class="string">"http://www.douyu.com/wkx.html"</span></span><br><span class="line">    req = request.Request(url)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        responese = request.urlopen(req)</span><br><span class="line">        <span class="comment"># html = responese.read()</span></span><br><span class="line">    <span class="keyword">except</span> error.HTTPError <span class="keyword">as</span> e:</span><br><span class="line">        print(e.code, <span class="string">'\n'</span> ,e.reason, <span class="string">'\n'</span>, e.headers)</span><br></pre></td></tr></table></figure></p><p>运行之后，我们可以看到404，这说明请求的资源没有在服务器上找到，<a href="http://www.douyu.com" target="_blank" rel="noopener">www.douyu.com</a> 这个服务器是存在的，但是我们要查找的 Jack_Cui.html 资源是没有的，所以抛出404异常。</p><p><img src="http://upload-images.jianshu.io/upload_images/2952111-877b52f32e81d2cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screen Shot 2018-02-12 at 14.36.07.png"></p><h3 id="3-URLError和HTTPError混合使用"><a href="#3-URLError和HTTPError混合使用" class="headerlink" title="(3).URLError和HTTPError混合使用"></a>(3).URLError和HTTPError混合使用</h3><p>最后值得注意的一点是，如果想用HTTPError和URLError一起捕获异常，那么需要将HTTPError放在URLError的前面，因为HTTPError是URLError的一个子类。如果URLError放在前面，出现HTTP异常会先响应URLError，这样HTTPError就捕获不到错误信息了。</p><p><img src="http://upload-images.jianshu.io/upload_images/2952111-81c31b50ef0e4f0d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>如果不用上面的方法，也可以使用hasattr函数判断URLError含有的属性，如果含有reason属性表明是URLError，如果含有code属性表明是HTTPError。创建文件urllib_test07.py，编写代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> error</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment">#一个不存在的连接</span></span><br><span class="line">    url = <span class="string">"http://www.douyu.com/wkx.html"</span></span><br><span class="line">    req = request.Request(url)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        responese = request.urlopen(req)</span><br><span class="line">    <span class="keyword">except</span> error.URLError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">if</span> hasattr(e, <span class="string">'code'</span>):</span><br><span class="line">            print(<span class="string">"HTTPError"</span>)</span><br><span class="line">            print(e.code)</span><br><span class="line">        <span class="keyword">elif</span> hasattr(e, <span class="string">'reason'</span>):</span><br><span class="line">            print(<span class="string">"URLError"</span>)</span><br><span class="line">            print(e.reason)</span><br></pre></td></tr></table></figure></p><p>运行结果如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/2952111-9105667f71cd7051.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screen Shot 2018-02-12 at 14.37.39.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;urllib-error&quot;&gt;&lt;a href=&quot;#urllib-error&quot; class=&quot;headerlink&quot; title=&quot;urllib.error&quot;&gt;&lt;/a&gt;urllib.error&lt;/h2&gt;&lt;p&gt;urllib.error可以接收有urllib.request产生的异常。urllib.error有两个方法，URLError和HTTPError。如下图所示：&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2952111-165a6b7bb4f6e5af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Screen Shot 2018-02-12 at 14.39.09.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;URLError是OSError的一个子类，HTTPError是URLError的一个子类，服务器上HTTP的响应会返回一个状态码，根据这个HTTP状态码，我们可以知道我们的访问是否成功。例如第二个笔记中提到的200状态码，表示请求成功，再比如常见的404错误等。&lt;br&gt;
    
    </summary>
    
      <category term="Spider" scheme="http://yoursite.com/categories/Spider/"/>
    
      <category term="Urllib" scheme="http://yoursite.com/categories/Spider/Urllib/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
      <category term="Spider" scheme="http://yoursite.com/tags/Spider/"/>
    
      <category term="Urllib" scheme="http://yoursite.com/tags/Urllib/"/>
    
  </entry>
  
  <entry>
    <title>从零开始学爬虫-02</title>
    <link href="http://yoursite.com/2018/02/28/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E7%88%AC%E8%99%AB-02/"/>
    <id>http://yoursite.com/2018/02/28/从零开始学爬虫-02/</id>
    <published>2018-02-27T16:48:24.000Z</published>
    <updated>2018-02-27T17:04:42.158Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一个疑问尚未解决疑问，小弟在此跪求大牛解答一下"><a href="#一个疑问尚未解决疑问，小弟在此跪求大牛解答一下" class="headerlink" title="一个疑问尚未解决疑问，小弟在此跪求大牛解答一下"></a>一个疑问尚未解决疑问，小弟在此跪求大牛解答一下</h3><p>为什么把url里的 “_o” 删掉后就可以正常爬取呢？<br><a id="more"></a></p><h3 id="urlopen的url参数-Agent"><a href="#urlopen的url参数-Agent" class="headerlink" title="urlopen的url参数 Agent"></a>urlopen的url参数 Agent</h3><p>url不仅可以是一个字符串，例如:<a href="http://www.baidu.com。" target="_blank" rel="noopener">http://www.baidu.com。</a></p><p>url也可以是一个Request对象，这就需要我们先定义一个Request对象，然后将这个Request对象作为urlopen的参数使用，方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    req = request.Request(<span class="string">"http://fanyi.baidu.com/"</span>)</span><br><span class="line">    response = request.urlopen(req)</span><br><span class="line">    html = response.read()</span><br><span class="line">    html = html.decode(<span class="string">"utf-8"</span>)</span><br><span class="line">    print(html)</span><br></pre></td></tr></table></figure><p>同样，运行这段代码同样可以得到网页信息。可以看一下这段代码和上个笔记中代码的不同，对比一下就明白了。</p><p>urlopen()返回的对象，可以使用read()进行读取，同样也可以使用geturl()方法、info()方法、getcode()方法。</p><ul><li><p>geturl()返回的是一个url的字符串；</p></li><li><p>info()返回的是一些meta标记的元信息，包括一些服务器的信息；</p></li><li><p>getcode()返回的是HTTP的状态码，如果返回200表示请求成功。</p></li></ul><p>关于META标签和HTTP状态码的内容可以自行百度百科，里面有很详细的介绍。</p><p>了解到这些，我们就可以进行新一轮的测试，新建文件名urllib_test04.py，编写如下代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    req = request.Request(<span class="string">"http://fanyi.baidu.com/"</span>)</span><br><span class="line">    response = request.urlopen(req)</span><br><span class="line">    print(<span class="string">"geturl打印信息：%s"</span>%(response.geturl()))</span><br><span class="line">    print(<span class="string">'**********************************************'</span>)</span><br><span class="line">    print(<span class="string">"info打印信息：%s"</span>%(response.info()))</span><br><span class="line">    print(<span class="string">'**********************************************'</span>)</span><br><span class="line">    print(<span class="string">"getcode打印信息：%s"</span>%(response.getcode()))</span><br></pre></td></tr></table></figure></p><h3 id="urlopen的data参数"><a href="#urlopen的data参数" class="headerlink" title="urlopen的data参数"></a>urlopen的data参数</h3><p>我们可以使用data参数，向服务器发送数据。根据HTTP规范，GET用于信息获取，POST是向服务器提交数据的一种请求，再换句话说：</p><p>从客户端向服务器提交数据使用POST；</p><p>从服务器获得数据到客户端使用GET(GET也可以提交，暂不考虑)。</p><p>如果没有设置urlopen()函数的data参数，HTTP请求采用GET方式，也就是我们从服务器获取信息，如果我们设置data参数，HTTP请求采用POST方式，也就是我们向服务器传递数据。</p><p>data参数有自己的格式，它是一个基于application/x-<a href="http://www.form-urlencoded的格式，具体格式我们不用了解，" target="_blank" rel="noopener">www.form-urlencoded的格式，具体格式我们不用了解，</a> 因为我们可以使用urllib.parse.urlencode()函数将字符串自动转换成上面所说的格式。</p><h3 id="发送data实例"><a href="#发送data实例" class="headerlink" title="发送data实例"></a>发送data实例</h3><p>向有道翻译发送data，得到翻译结果。</p><h4 id="1-打开有道翻译界面，如下图所示："><a href="#1-打开有道翻译界面，如下图所示：" class="headerlink" title="(1).打开有道翻译界面，如下图所示："></a>(1).打开有道翻译界面，如下图所示：</h4><p> <img src="http://upload-images.jianshu.io/upload_images/2952111-31f629ec53534a43?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h4 id="2-鼠标右键检查，也就是审查元素，如下图所示："><a href="#2-鼠标右键检查，也就是审查元素，如下图所示：" class="headerlink" title="(2).鼠标右键检查，也就是审查元素，如下图所示："></a>(2).鼠标右键检查，也就是审查元素，如下图所示：</h4><p><img src="http://upload-images.jianshu.io/upload_images/2952111-f199c9cbcd80b40f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h4 id="3-选择右侧出现的Network，如下图所示："><a href="#3-选择右侧出现的Network，如下图所示：" class="headerlink" title="(3).选择右侧出现的Network，如下图所示："></a>(3).选择右侧出现的Network，如下图所示：</h4><p> <img src="http://upload-images.jianshu.io/upload_images/2952111-4354c17b0169d4b9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h4 id="4-在左侧输入翻译内容，输入Jack，如下图所示："><a href="#4-在左侧输入翻译内容，输入Jack，如下图所示：" class="headerlink" title="(4).在左侧输入翻译内容，输入Jack，如下图所示："></a>(4).在左侧输入翻译内容，输入Jack，如下图所示：</h4><p> <img src="http://upload-images.jianshu.io/upload_images/2952111-1a5e4f785e7bbccf?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h4 id="5-点击自动翻译按钮，我们就可以看到右侧出现的内容，如下图所示："><a href="#5-点击自动翻译按钮，我们就可以看到右侧出现的内容，如下图所示：" class="headerlink" title="(5).点击自动翻译按钮，我们就可以看到右侧出现的内容，如下图所示："></a>(5).点击自动翻译按钮，我们就可以看到右侧出现的内容，如下图所示：</h4><p><img src="http://upload-images.jianshu.io/upload_images/2952111-37b47520ec88de2e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h4 id="6-点击上图红框中的内容，查看它的信息，如下图所示："><a href="#6-点击上图红框中的内容，查看它的信息，如下图所示：" class="headerlink" title="(6).点击上图红框中的内容，查看它的信息，如下图所示："></a>(6).点击上图红框中的内容，查看它的信息，如下图所示：</h4><p> <img src="http://upload-images.jianshu.io/upload_images/2952111-9b692ceecf538fd5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p><img src="http://upload-images.jianshu.io/upload_images/2952111-1dc2354ec47dc6ff?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h4 id="7-记住这些信息，这是我们一会儿写程序需要用到的。"><a href="#7-记住这些信息，这是我们一会儿写程序需要用到的。" class="headerlink" title="(7).记住这些信息，这是我们一会儿写程序需要用到的。"></a>(7).记住这些信息，这是我们一会儿写程序需要用到的。</h4><p>  新建文件translate_test.py，编写如下代码：<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment">#对应上图的Request URL</span></span><br><span class="line">    Request_URL = <span class="string">'http://fanyi.youdao.com/translate?smartresult=dict&amp;smartresult=rule&amp;sessionFrom=null'</span></span><br><span class="line">    <span class="comment">#创建Form_Data字典，存储上图的Form Data</span></span><br><span class="line">    Form_Data = &#123;&#125;</span><br><span class="line">    Form_Data[<span class="string">'type'</span>] = <span class="string">'AUTO'</span></span><br><span class="line">    Form_Data[<span class="string">'i'</span>] = <span class="string">'Jack'</span></span><br><span class="line">    Form_Data[<span class="string">'doctype'</span>] = <span class="string">'json'</span></span><br><span class="line">    Form_Data[<span class="string">'xmlVersion'</span>] = <span class="string">'1.8'</span></span><br><span class="line">    Form_Data[<span class="string">'keyfrom'</span>] = <span class="string">'fanyi.web'</span></span><br><span class="line">    Form_Data[<span class="string">'ue'</span>] = <span class="string">'ue:UTF-8'</span></span><br><span class="line">    Form_Data[<span class="string">'action'</span>] = <span class="string">'FY_BY_CLICKBUTTON'</span></span><br><span class="line">    <span class="comment">#使用urlencode方法转换标准格式</span></span><br><span class="line">    data = parse.urlencode(Form_Data).encode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="comment">#传递Request对象和转换完格式的数据</span></span><br><span class="line">    response = request.urlopen(Request_URL,data)</span><br><span class="line">    <span class="comment">#读取信息并解码</span></span><br><span class="line">    html = response.read().decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="comment">#使用JSON</span></span><br><span class="line">    translate_results = json.loads(html)</span><br><span class="line">    <span class="comment">#找到翻译结果</span></span><br><span class="line">    translate_results = translate_results[<span class="string">'translateResult'</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="string">'tgt'</span>]</span><br><span class="line">    <span class="comment">#打印翻译信息</span></span><br><span class="line">    print(<span class="string">"翻译的结果是：%s"</span> % translate_results)</span><br></pre></td></tr></table></figure></p><p>运行查看翻译结果</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一个疑问尚未解决疑问，小弟在此跪求大牛解答一下&quot;&gt;&lt;a href=&quot;#一个疑问尚未解决疑问，小弟在此跪求大牛解答一下&quot; class=&quot;headerlink&quot; title=&quot;一个疑问尚未解决疑问，小弟在此跪求大牛解答一下&quot;&gt;&lt;/a&gt;一个疑问尚未解决疑问，小弟在此跪求大牛解答一下&lt;/h3&gt;&lt;p&gt;为什么把url里的 “_o” 删掉后就可以正常爬取呢？&lt;br&gt;
    
    </summary>
    
      <category term="Spider" scheme="http://yoursite.com/categories/Spider/"/>
    
      <category term="Urllib" scheme="http://yoursite.com/categories/Spider/Urllib/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
      <category term="Spider" scheme="http://yoursite.com/tags/Spider/"/>
    
      <category term="Urllib" scheme="http://yoursite.com/tags/Urllib/"/>
    
  </entry>
  
  <entry>
    <title>从零开始学爬虫-01</title>
    <link href="http://yoursite.com/2018/02/28/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E7%88%AC%E8%99%AB-01/"/>
    <id>http://yoursite.com/2018/02/28/从零开始学爬虫-01/</id>
    <published>2018-02-27T16:37:37.000Z</published>
    <updated>2018-02-27T17:04:40.535Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本节关键字"><a href="#本节关键字" class="headerlink" title="本节关键字"></a>本节关键字</h3><p><em>urllib | chardet</em></p><h3 id="urllib-简介"><a href="#urllib-简介" class="headerlink" title="urllib 简介"></a>urllib 简介</h3><p>在Python3.x中，我们可以使用urlib这个组件抓取网页，urllib是一个URL处理包，这个包中集合了一些处理URL的模块，如下：<br><a id="more"></a></p><blockquote><p>1.urllib.request模块是用来打开和读取URLs的；</p></blockquote><blockquote><p>2.urllib.error模块包含一些有urllib.request产生的错误，可以使用try进行捕捉处理；</p></blockquote><blockquote><p>3.urllib.parse模块包含了一些解析URLs的方法；</p></blockquote><blockquote><p>4.urllib.robotparser模块用来解析robots.txt文本文件.它提供了一个单独的RobotFileParser类，通过该类提供的can_fetch()方法测试爬虫是否可以下载一个页面。</p></blockquote><p>使用urllib.request.urlopen()这个接口函数就可以访问一个网站，读取并打印信息。<br>urlopen有一些可选参数，具体信息可以查阅Python自带的documentation。</p><h3 id="urllib-测试"><a href="#urllib-测试" class="headerlink" title="urllib 测试"></a>urllib 测试</h3><p>了解到这些，我们就可以写一个最简单的程序，文件名为urllib_test01.py，感受一个urllib库的魅力：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    response = request.urlopen(<span class="string">"http://fanyi.baidu.com"</span>)</span><br><span class="line">    html = response.read()</span><br><span class="line">    print(html)</span><br></pre></td></tr></table></figure></p><p>urllib使用使用request.urlopen()访问和读取URLs信息，返回的对象response如同一个文本对象，我们可以调用read()，进行读取。再通过print()屏幕打印。</p><p>浏览器就是作为客户端从服务器端获取信息，然后将信息解析，再展示给我们的。但是显然他们都是二进制的乱码。</p><p>我们可以通过简单的decode()命令将网页的信息进行解码，并显示出来，我们新创建一个文件，命名为urllib_test02.py，编写如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    response = request.urlopen(<span class="string">"http://fanyi.baidu.com/"</span>)</span><br><span class="line">    html = response.read()</span><br><span class="line">    html = html.decode(<span class="string">"utf-8"</span>)</span><br><span class="line">    print(html)</span><br></pre></td></tr></table></figure><p>这样我们就可以得到这样的结果，显然解码后的信息看起来工整和舒服多了：</p><p>当然这个前提是我们已经知道了这个网页是使用utf-8编码的，怎么查看网页的编码方式呢？非常简单的方法是使用使用浏览器审查元素，只需要找到head标签开始位置的chareset，就知道网页是采用何种编码。</p><p>这样我们就知道了这个网站的编码方式，但是这需要我们每次都打开浏览器，并找下编码方式，显然有些费事，使用几行代码解决更加省事并且显得酷一些。</p><p>我们需要安装第三方库chardet，它是用来判断编码的模块。安装好后，我们就可以使用chardet.detect()方法，判断网页的编码方式了。至此，我们就可以编写一个小程序判断网页的编码方式了，新建文件名为chardet_test01.py：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> chardet</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    response = request.urlopen(<span class="string">"http://fanyi.baidu.com"</span>)</span><br><span class="line">    html = response.read()</span><br><span class="line">    charset = chardet.detect(html)</span><br><span class="line">    print(charset)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;本节关键字&quot;&gt;&lt;a href=&quot;#本节关键字&quot; class=&quot;headerlink&quot; title=&quot;本节关键字&quot;&gt;&lt;/a&gt;本节关键字&lt;/h3&gt;&lt;p&gt;&lt;em&gt;urllib | chardet&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;urllib-简介&quot;&gt;&lt;a href=&quot;#urllib-简介&quot; class=&quot;headerlink&quot; title=&quot;urllib 简介&quot;&gt;&lt;/a&gt;urllib 简介&lt;/h3&gt;&lt;p&gt;在Python3.x中，我们可以使用urlib这个组件抓取网页，urllib是一个URL处理包，这个包中集合了一些处理URL的模块，如下：&lt;br&gt;
    
    </summary>
    
      <category term="Spider" scheme="http://yoursite.com/categories/Spider/"/>
    
      <category term="Urllib" scheme="http://yoursite.com/categories/Spider/Urllib/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
      <category term="Spider" scheme="http://yoursite.com/tags/Spider/"/>
    
      <category term="Urllib" scheme="http://yoursite.com/tags/Urllib/"/>
    
  </entry>
  
  <entry>
    <title>一种Git保留两个repo的commit信息进行合并的方法</title>
    <link href="http://yoursite.com/2018/02/27/%E4%B8%80%E7%A7%8DGit%E4%BF%9D%E7%95%99%E4%B8%A4%E4%B8%AArepo%E7%9A%84commit%E4%BF%A1%E6%81%AF%E8%BF%9B%E8%A1%8C%E5%90%88%E5%B9%B6%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/02/27/一种Git保留两个repo的commit信息进行合并的方法/</id>
    <published>2018-02-27T06:46:37.000Z</published>
    <updated>2018-02-27T07:19:42.036Z</updated>
    
    <content type="html"><![CDATA[<p>以往的合并时首先要删除repo的.git文件夹，然后重新add-commit-push。带来的问题是会丢失某一个仓库的提交信息，不利于时光倒退。经过摸索终于实现了保留两个仓库提交信息的合并方法。介绍如下：</p><a id="more"></a><p>比如要将DownloadPicsBySeleniumAndPhantomJS这个项目合并到Web-Spider中，终端中执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add other git@github.com:ByiProX/****.git</span><br><span class="line">$ git fetch other</span><br><span class="line">$ git checkout -b repo1 other/mster</span><br><span class="line">$ git checkout master</span><br><span class="line">$ git merge repo1 --allow-unrelated-histories</span><br></pre></td></tr></table></figure></p><p><img src="http://img.blog.csdn.net/20180213030000117" alt=""></p><p>接下来解决merge冲突即可（可以尝试使用mergetool），如有需要可以删除多余分支和远程连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git mergetool <span class="comment"># 解决merge冲突</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ git remote rm other <span class="comment"># 删除远程连接  </span></span><br><span class="line">$ git branch -d repo1 <span class="comment"># 删除分支操作</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以往的合并时首先要删除repo的.git文件夹，然后重新add-commit-push。带来的问题是会丢失某一个仓库的提交信息，不利于时光倒退。经过摸索终于实现了保留两个仓库提交信息的合并方法。介绍如下：&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Python3下使用Selenium&amp;PhantomJS爬火影忍者漫画</title>
    <link href="http://yoursite.com/2018/02/27/Python3%E4%B8%8B%E4%BD%BF%E7%94%A8Selenium-PhantomJS%E7%88%AC%E7%81%AB%E5%BD%B1%E5%BF%8D%E8%80%85%E6%BC%AB%E7%94%BB/"/>
    <id>http://yoursite.com/2018/02/27/Python3下使用Selenium-PhantomJS爬火影忍者漫画/</id>
    <published>2018-02-27T06:16:38.000Z</published>
    <updated>2018-02-27T17:03:57.896Z</updated>
    
    <content type="html"><![CDATA[<p>近期学习爬虫，发现懂的越多，不懂的知识点越多（所以当个傻子还是很幸福的）。好记性不如烂笔头，之前都是把看到的资料链接直接挂到一些平台，比如知乎、简书、Github等。今天有点时间，就好好码一下字，排排版，方便以后查阅。</p><p>Selenium用来模拟浏览器的行为，比如点击、最大化、滚动窗口等；PhantomJS是一种浏览器，不过这种浏览器没有UI界面，感觉就像是专门为爬虫设计，优点很明显，可以有效减小内存的使用。</p><a id="more"></a><h2 id="爬虫使用到的模块"><a href="#爬虫使用到的模块" class="headerlink" title="爬虫使用到的模块"></a>爬虫使用到的模块</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> myLogging <span class="keyword">import</span> MyLogging</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> re</span><br></pre></td></tr></table></figure><p>myLogging模块是自己配置的日志包，想要的可以点击<strong><em><a href="http://link.zhihu.com/?target=https%3A//github.com/ByiProX/DownloadPicsBySeleniumAndPhantomJS" target="_blank" rel="noopener">这里</a></em></strong>自己看</p><p>爬虫很关键的一点就是能够看懂网页的源代码，记得当初刚刚真正开始接触编程的时候，有很长的一段时间在看HTML、CSS、JS的一些知识，虽然忘得很多，但是印象还是有的，对于后面看网页源代码很有帮助。学习爬虫，除了会基本的python知识以外，还要会网页的一些知识。</p><h2 id="爬取图片思路："><a href="#爬取图片思路：" class="headerlink" title="爬取图片思路："></a>爬取图片思路：</h2><ul><li>已知连接，分析网页的代码结构，看所需的数据是否需要切换frame，并定位所需数据的位于哪个标签之下</li><li>采用不同的模块有不同的保存图片方式，如果采用request模块，保存图片方式是可以采用<strong>requests.get(comicUrl).content</strong>方法，使用该方法需要确定网页的地址。该项目中没有涉及request的使用，所以此后不再表述。对于selenium可以使用 <strong>get_screenshot_as_file()</strong> 方法，使用该方法强烈建议使用phantomjs，如果使用chrome浏览器，图片尺寸太大的话，会出现截图不完整，对比如下：<br><img src="http://upload-images.jianshu.io/upload_images/2952111-2323c462a546dcc3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对比"></li><li>找到下一张图片的连接位置并点击更新网页，一般来讲新网页与之前网页结构相同。</li><li>在新网页的基础上保存图片，设置循环如此反复。</li></ul><p>爬取网页的URL为：<a href="http://link.zhihu.com/?target=http%3A//comic.kukudm.com/comiclist/3/3/1.htm" target="_blank" rel="noopener">爬取火影漫画第一话</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadPics</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, url)</span>:</span></span><br><span class="line">        self.url = url</span><br><span class="line">        self.log = MyLogging()</span><br><span class="line">        self.browser = self.get_browser()</span><br><span class="line">        self.save_pics(self.browser)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_browser</span><span class="params">(self)</span>:</span></span><br><span class="line">        browser = webdriver.PhantomJS()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            browser.get(self.url)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            MyLogging.error(<span class="string">'open the url %s failed'</span> % self.url)</span><br><span class="line">        browser.implicitly_wait(<span class="number">20</span>)</span><br><span class="line">        <span class="keyword">return</span> browser</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save_pics</span><span class="params">(self, browser)</span>:</span></span><br><span class="line">        pics_title = browser.title.split(<span class="string">'_'</span>)[<span class="number">0</span>]</span><br><span class="line">        self.create_dir(pics_title)</span><br><span class="line">        os.chdir(pics_title)</span><br><span class="line">        sum_page = self.find_total_page_num(browser)</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; sum_page:</span><br><span class="line">            image_name = str(i) + <span class="string">'.png'</span></span><br><span class="line">            browser.get_screenshot_as_file(image_name)  </span><br><span class="line">            <span class="comment"># 使用PhantomJS避免了截图的不完整，可以与Chrome比较</span></span><br><span class="line">            self.log.info(<span class="string">'saving image %s'</span> % image_name)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            css_selector = <span class="string">"a[href='/comiclist/3/3/%s.htm']"</span> % i  </span><br><span class="line">            <span class="comment"># 该方法感觉还不错呢，不过这个网站确实挺差劲的</span></span><br><span class="line">            next_page = browser.find_element_by_css_selector(css_selector)</span><br><span class="line">            next_page.click()</span><br><span class="line">            time.sleep(<span class="number">2</span>)</span><br><span class="line">            <span class="comment"># browser.implicitly_wait(20)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_total_page_num</span><span class="params">(self, browser)</span>:</span></span><br><span class="line">        page_element = browser.find_element_by_css_selector(<span class="string">"table[cellspacing='1']"</span>)</span><br><span class="line">        num = re.search(<span class="string">r'共\d+页'</span>, page_element.text).group()[<span class="number">1</span>:<span class="number">-1</span>]  </span><br><span class="line">        <span class="keyword">return</span> int(num)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_dir</span><span class="params">(self, dir_name)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> os.path.exists(dir_name):</span><br><span class="line">            self.log.error(<span class="string">'create directory %s failed cause a same directory exists'</span> % dir_name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                os.makedirs(dir_name)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                self.log.error(<span class="string">'create directory %s failed'</span> % dir_name)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.log.info(<span class="string">'create directory %s success'</span> % dir_name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    start_url = <span class="string">'http://comic.kukudm.com/comiclist/3/3/1.htm'</span></span><br><span class="line">    DL = DownloadPics(start_url)</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="http://upload-images.jianshu.io/upload_images/2952111-e7e2cf39116b5fea.gif?imageMogr2/auto-orient/strip" alt="gif"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期学习爬虫，发现懂的越多，不懂的知识点越多（所以当个傻子还是很幸福的）。好记性不如烂笔头，之前都是把看到的资料链接直接挂到一些平台，比如知乎、简书、Github等。今天有点时间，就好好码一下字，排排版，方便以后查阅。&lt;/p&gt;
&lt;p&gt;Selenium用来模拟浏览器的行为，比如点击、最大化、滚动窗口等；PhantomJS是一种浏览器，不过这种浏览器没有UI界面，感觉就像是专门为爬虫设计，优点很明显，可以有效减小内存的使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Spider" scheme="http://yoursite.com/categories/Spider/"/>
    
      <category term="Selenium" scheme="http://yoursite.com/categories/Spider/Selenium/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
      <category term="Spider" scheme="http://yoursite.com/tags/Spider/"/>
    
      <category term="Selenium" scheme="http://yoursite.com/tags/Selenium/"/>
    
      <category term="PhantomJS" scheme="http://yoursite.com/tags/PhantomJS/"/>
    
  </entry>
  
  <entry>
    <title>Django2.0.1搭建电影网站</title>
    <link href="http://yoursite.com/2018/02/27/Django2-0-1%E6%90%AD%E5%BB%BA%E7%94%B5%E5%BD%B1%E7%BD%91%E7%AB%99/"/>
    <id>http://yoursite.com/2018/02/27/Django2-0-1搭建电影网站/</id>
    <published>2018-02-27T05:48:44.000Z</published>
    <updated>2018-02-27T06:41:59.694Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://school.thoughtworks.cn/bbs/assets/uploads/files/1517985555955-fireshot-capture-8-cinema-http___127.0.0.1_8000_.png" alt="首页"></p><p>本项目已经部署到服务器，可以通过该IP查看<br><a href="http://59.110.221.56/" target="_blank" rel="noopener">http://59.110.221.56/</a><br><a href="https://github.com/ByiProX/ThoughtWorks-Cinema" target="_blank" rel="noopener">GitHub源代码</a><br><a id="more"></a></p><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><blockquote><p>Bootstrap 3 + Django 2.0.1 + MySQL 5.7.17 + Nginx + locust</p></blockquote><h2 id="本地服务运行方法"><a href="#本地服务运行方法" class="headerlink" title="本地服务运行方法"></a>本地服务运行方法</h2><p>终端在venv文件夹路径下开启虚拟环境(根据自己的shell进行选择)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source ../venv/bin/activate.fish</span><br><span class="line">source ../venv/bin/activate</span><br><span class="line">source ../venv/bin/activate.csh</span><br></pre></td></tr></table></figure><p>然后执行：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 TWS_Cinema/manage.py runserver</span><br></pre></td></tr></table></figure></p><p><strong>如果报错</strong>，终端进入requirements.txt所在目录，运行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install -r requirements.txt</span><br></pre></td></tr></table></figure></p><p>然后执行：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 TWS_Cinema/manage.py runserver</span><br></pre></td></tr></table></figure></p><h2 id="单元测试运行方法"><a href="#单元测试运行方法" class="headerlink" title="单元测试运行方法"></a>单元测试运行方法</h2><p>在manage.py路径下终端运行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 manage.py test</span><br></pre></td></tr></table></figure><h2 id="网站功能描述"><a href="#网站功能描述" class="headerlink" title="网站功能描述"></a>网站功能描述</h2><ul><li><p>实现导航栏搜索电影，支持按年份搜索和类型搜索<br>  – 显示分类列表<br>  – 点击分类显示符合分类要求的电影</p></li><li><p>实现搜索功能，支持按电影名称模糊搜索</p></li><li><p>实现电影详细信息查看功能<br>  – 显示电影详细信息<br>  – 显示豆瓣 Top 5 影评<br>  – 在电影详细页面显示相似电影推荐<br>  – 增加电影观看链接</p></li></ul><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><ul><li><p>按电影id搜索 —— api/movie/id/        # 例如：api/movie/id/1291545</p></li><li><p>按电影名搜索 —— api/movie/title/     # 例如：api/movie/title/大鱼</p></li><li><p>按电影原始名搜索 —— api/movie/original_title/     # 例如：api/movie/original_title/Big Fish</p></li><li><p>按电影类型搜索 —— api/movie/genre/   # 例如：api/movie/genre/剧情</p></li><li><p>按电影年份搜索 —— api/movie/year/    # 例如：api/movie/year/2003</p></li></ul><h2 id="网站性能测试结果"><a href="#网站性能测试结果" class="headerlink" title="网站性能测试结果"></a>网站性能测试结果</h2><p>在文件locustfile.py路径下运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locust --host=http://59.110.221.56</span><br></pre></td></tr></table></figure></p><h3 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h3><ul><li>采取的框架：<strong>locust</strong></li><li>服务器性能：<ul><li>CPU：1核</li><li>内存：2 GB (I/O优化)</li><li>带宽：1Mbps</li></ul></li><li>测试结果：<ul><li>500人：100%正确</li><li>1000人：40%出错率</li></ul></li><li>测试截图</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/2952111-4c41c64c40130ebe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screen Shot 2018-02-08 at 16.15.49.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/2952111-c2c542dbf0ce9e58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screen Shot 2018-02-08 at 16.14.10.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/2952111-f5e4ace67f22ddac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screen Shot 2018-02-08 at 16.13.49.png"></p><h2 id="电影网站的其他截图"><a href="#电影网站的其他截图" class="headerlink" title="电影网站的其他截图"></a>电影网站的其他截图</h2><p><img src="https://school.thoughtworks.cn/bbs/assets/uploads/files/1517985569003-fireshot-capture-9-%E9%A6%96%E9%A1%B5-http___127.0.0.1_8000_movie_display_.png" alt="list"><br><img src="https://school.thoughtworks.cn/bbs/assets/uploads/files/1517985586166-fireshot-capture-10-%E7%94%B5%E5%BD%B1%E8%AF%A6%E6%83%85-http___127.0.0.1_8000_movie_id_1291545_.png" alt="detail"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://my.oschina.net/u/1447352/blog/1499428/" target="_blank" rel="noopener">Locust 简介以及使用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://school.thoughtworks.cn/bbs/assets/uploads/files/1517985555955-fireshot-capture-8-cinema-http___127.0.0.1_8000_.png&quot; alt=&quot;首页&quot;&gt;&lt;/p&gt;
&lt;p&gt;本项目已经部署到服务器，可以通过该IP查看&lt;br&gt;&lt;a href=&quot;http://59.110.221.56/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://59.110.221.56/&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/ByiProX/ThoughtWorks-Cinema&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub源代码&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Django" scheme="http://yoursite.com/categories/Django/"/>
    
    
      <category term="Django" scheme="http://yoursite.com/tags/Django/"/>
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>简谈爬虫攻与防</title>
    <link href="http://yoursite.com/2018/02/27/%E7%AE%80%E8%B0%88%E7%88%AC%E8%99%AB%E6%94%BB%E4%B8%8E%E9%98%B2/"/>
    <id>http://yoursite.com/2018/02/27/简谈爬虫攻与防/</id>
    <published>2018-02-27T04:44:38.000Z</published>
    <updated>2018-02-27T17:04:37.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="封锁间隔时间破解"><a href="#封锁间隔时间破解" class="headerlink" title="封锁间隔时间破解"></a>封锁间隔时间破解</h2><p>Scrapy在两次请求之间的时间设置是DOWNLOAD_DELAY。如果不考虑反爬虫的因素，该值当然越小越好。如果DOWNLOAD_DELAY设为0.001，也就是每1毫秒请求一次网页，这简直非人类干的事情。有些网站会检测一个ip的访问时间，异常情况下会封锁该ip。</p><a id="more"></a><h2 id="封锁Cookies"><a href="#封锁Cookies" class="headerlink" title="封锁Cookies"></a>封锁Cookies</h2><p>众所周知，网站是通过Cookie来确定用户身份的，Scrapy在爬取数据时使用同一个Cookies发起请求。该做法和把DOWNLOAD_DELAY设为0.001没有本质区别。在scrapy中，直接社禁用Cookies就可以了。在settings.py中设置<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Disable cookies (enabled by default)</span></span><br><span class="line">COOKIES_ENABLED = <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p><h2 id="封锁user-agent和proxy破解"><a href="#封锁user-agent和proxy破解" class="headerlink" title="封锁user-agent和proxy破解"></a>封锁user-agent和proxy破解</h2><p>user-agent是浏览器的身份标识。网站通过UA来确定浏览器类型。很多浏览器拒绝不符合一定标准的UA请求网页。同一个UA高频率的访问网站会有被网站列入黑名单的危险。破解的方法很简单，可以准备一个<strong>UA池</strong>，每次请求时随机挑选一个进行请求。</p><p>在middlewares.py同级目录下创建UAResource.py,文件内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">UserAgents = [</span><br><span class="line">  <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; AcooBrowser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)"</span>,</span><br><span class="line">  <span class="string">"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)"</span>,</span><br><span class="line">  <span class="string">"Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.35; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)"</span>,</span><br><span class="line">  <span class="string">"Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US)"</span>,</span><br><span class="line">  <span class="string">"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)"</span>,</span><br><span class="line">  <span class="string">"Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)"</span>,</span><br><span class="line">  <span class="string">"Mozilla/4.0 (compatible; MSIE 7.0b; Windows NT 5.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.2; .NET CLR 3.0.04506.30)"</span>,</span><br><span class="line">  <span class="string">"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3) Arora/0.3 (Change: 287 c9dfb30)"</span>,</span><br><span class="line">  <span class="string">"Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6"</span>,</span><br><span class="line">  <span class="string">"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko/20070215 K-Ninja/2.1.1"</span>,</span><br><span class="line">  <span class="string">"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko/20080705 Firefox/3.0 Kapiko/3.0"</span>,</span><br><span class="line">  <span class="string">"Mozilla/5.0 (X11; Linux i686; U;) Gecko/20070322 Kazehakase/0.4.5"</span>,</span><br><span class="line">  <span class="string">"Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora/1.9.0.8-1.fc10 Kazehakase/0.5.6"</span>,</span><br><span class="line">  <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11"</span>,</span><br><span class="line">  <span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.20 (KHTML, like Gecko) Chrome/19.0.1036.7 Safari/535.20"</span>,</span><br><span class="line">  <span class="string">"Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto/2.9.168 Version/11.52"</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Proxies = [</span><br><span class="line"><span class="string">'http://122.114.31.177:808'</span>,</span><br><span class="line"><span class="string">'http://1.2.3.4:80'</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>修改middlewares.py，添加内容为<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .UAResource <span class="keyword">import</span> UserAgents</span><br><span class="line"><span class="keyword">from</span> .UAResource <span class="keyword">import</span> Proxies</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomProxy</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request, spider)</span>:</span></span><br><span class="line">        proxy = random.choice(Proxies)</span><br><span class="line">        request.meta[<span class="string">'proxy'</span>] = proxy</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomUserAgent</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""docstring for RandomUerAgent."""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request, spider)</span>:</span></span><br><span class="line">        ua = random.choice(UserAgents)</span><br><span class="line">        request.headers.setdefault(<span class="string">'User-Agent'</span>, ua)</span><br></pre></td></tr></table></figure></p><p>最后修改setting.py,将RandomUserAgent和RandomProxy添加到DOWNLOADER_MIDDLEWARES中，注意RandomProxy要放到RandomUserAgent之前，即将RandomProxy的值比RandomUserAgent后的值小<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DOWNLOADER_MIDDLEWARES = &#123;</span><br><span class="line">   <span class="comment"># 'meijutt.middlewares.MeijuttDownloaderMiddleware': 543,</span></span><br><span class="line">   <span class="string">'meijutt.middlewares.RandomProxy'</span>: <span class="number">10</span>,</span><br><span class="line">   <span class="string">'meijutt.middlewares.RandomUserAgent'</span>: <span class="number">30</span>,</span><br><span class="line"></span><br><span class="line">   <span class="comment"># 禁止内置的(在 DOWNLOADER_MIDDLEWARES_BASE 中设置并默认启用的)中间件</span></span><br><span class="line">   <span class="string">'scrapy.downloadermiddlewares.useragent.UserAgentMiddleware'</span>: <span class="keyword">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>免费代理不够稳定，如果不想用proxy，设置RandomProxy为None,即禁止使用<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'meijutt.middlewares.RandomProxy'</span>: <span class="keyword">None</span>,</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;封锁间隔时间破解&quot;&gt;&lt;a href=&quot;#封锁间隔时间破解&quot; class=&quot;headerlink&quot; title=&quot;封锁间隔时间破解&quot;&gt;&lt;/a&gt;封锁间隔时间破解&lt;/h2&gt;&lt;p&gt;Scrapy在两次请求之间的时间设置是DOWNLOAD_DELAY。如果不考虑反爬虫的因素，该值当然越小越好。如果DOWNLOAD_DELAY设为0.001，也就是每1毫秒请求一次网页，这简直非人类干的事情。有些网站会检测一个ip的访问时间，异常情况下会封锁该ip。&lt;/p&gt;
    
    </summary>
    
      <category term="Spider" scheme="http://yoursite.com/categories/Spider/"/>
    
      <category term="Scrapy" scheme="http://yoursite.com/categories/Spider/Scrapy/"/>
    
    
      <category term="Spider" scheme="http://yoursite.com/tags/Spider/"/>
    
      <category term="Scrapy" scheme="http://yoursite.com/tags/Scrapy/"/>
    
  </entry>
  
  <entry>
    <title>Github多分支管理Hexo-Blog项目</title>
    <link href="http://yoursite.com/2018/02/27/Github%E5%A4%9A%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86Hexo-Blog%E9%A1%B9%E7%9B%AE/"/>
    <id>http://yoursite.com/2018/02/27/Github多分支管理Hexo-Blog项目/</id>
    <published>2018-02-26T16:23:41.000Z</published>
    <updated>2018-02-27T06:40:56.801Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo在部署之后在github的仓库中我们只能找到生成的静态文件。然而博客的源文件：主题、文章、配置等文件都还在本地，并没有备份。对于多台终端设备的用户不够友好，而且存在一定的风险，万一那天电脑坏了或者是出现一些其他问题，就得从头再来。为了解决上述问题，我们可以利用github的分支思想来备份我们的源文件。</p><a id="more"></a><p>备份之前，需要了解博客根目录下面的文件以及文件夹作用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.deploy_git/        网站静态文件(git)</span><br><span class="line">node_modules/       插件</span><br><span class="line">public/             网站静态文件</span><br><span class="line">scaffolds/          文章模板</span><br><span class="line">source/             博文等</span><br><span class="line">themes/             主题</span><br><span class="line">_config.yml         网站配置文件</span><br><span class="line">package.json        Hexo信息</span><br><span class="line">db.json             数据文件</span><br></pre></td></tr></table></figure></p><h2 id="备份的思路"><a href="#备份的思路" class="headerlink" title="备份的思路"></a>备份的思路</h2><p><code>master分支存放部署生成的静态文件，Hexo-Bog分支存放我们要备份项目源文件。</code>实际备份中，.deploy_git、public文件夹和我们的master分支内容重复，所以略过。因此，我们在根目录下面建一个<strong>.gitignore</strong>文件来建立“黑名单”，禁止备份。</p><h2 id="编辑-gitignore过滤文件"><a href="#编辑-gitignore过滤文件" class="headerlink" title="编辑.gitignore过滤文件"></a>编辑<strong>.gitignore</strong>过滤文件</h2><p>文件内容如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br></pre></td></tr></table></figure></p><h2 id="关于备份"><a href="#关于备份" class="headerlink" title="关于备份"></a>关于备份</h2><p>终端中在项目的根目录下执行，对于作者自己的项目，命令执行的路径为ByiProX/下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">$ git remote add origin git@github.com:username/username.github.io.git</span><br><span class="line"><span class="comment"># username为博客项目的名称，也就是git的用户名</span></span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">"ready for backup of the project"</span></span><br><span class="line">$ git push origin master:Hexo-Blog</span><br></pre></td></tr></table></figure></p><p>执行完毕后会发现github博客仓库已经有了一个新分支Hexo-Blog，于是备份工作完成。<br>以后，开始写博文时，即终端运行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure></p><p>完成文章后,对编辑后的文章进行备份保存，即终端运行,为下面的部署做准备<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">"add one article"</span></span><br><span class="line">$ git push origin master:Hexo-Blog</span><br></pre></td></tr></table></figure></p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>运行一下命令进行仓库master分支静态文件部署<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo generate</span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></p><p>以上完成项目源文件以及静态文件的Git管理</p><h2 id="参考文献及进阶"><a href="#参考文献及进阶" class="headerlink" title="参考文献及进阶"></a>参考文献及进阶</h2><p><a href="https://mrlrf.github.io/2017/05/05/Hexo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">Hexo+github搭建个人博客并实现多终端管理</a><br><a href="https://blog.zaihua.me/post/blog_github_backup.html" target="_blank" rel="noopener">如何在github上面备份Hexo</a><br><a href="https://formulahendry.github.io/2016/12/04/hexo-ci/" target="_blank" rel="noopener">Hexo的版本控制与持续集成</a><br><a href="https://www.zhihu.com/question/21193762" target="_blank" rel="noopener">使用hexo，如果换了电脑怎么更新博客</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hexo在部署之后在github的仓库中我们只能找到生成的静态文件。然而博客的源文件：主题、文章、配置等文件都还在本地，并没有备份。对于多台终端设备的用户不够友好，而且存在一定的风险，万一那天电脑坏了或者是出现一些其他问题，就得从头再来。为了解决上述问题，我们可以利用github的分支思想来备份我们的源文件。&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
</feed>
