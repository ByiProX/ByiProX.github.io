<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Quentin&#39;s Blog</title>
  
  <subtitle>每天进步一点点</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-05T16:51:20.605Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ByiProX</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python3 垃圾回收机制</title>
    <link href="http://yoursite.com/2018/03/05/Python3-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/03/05/Python3-垃圾回收机制/</id>
    <published>2018-03-05T13:38:25.000Z</published>
    <updated>2018-03-05T16:51:20.605Z</updated>
    
    <content type="html"><![CDATA[<p>Python中的垃圾回收GC(Garbage collection)是以引用计数为主，分代收集为辅。引用计数的缺陷是循环引用的问题。<br>分代收集在一定程度上解决了循环引用的问题（可能描述不准确）。</p><a id="more"></a><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>Python语言默认采用的垃圾收集机制是『引用计数法 Reference Counting』，该算法最早George E. Collins在1960的时候首次提出，50年后的今天，该算法依然被很多编程语言使用，『引用计数法』的原理是：每个对象维护一个<code>ob_ref</code>字段，用来记录该对象当前被引用的次数，每当新的引用指向该对象时，它的引用计数ob_ref加1，每当该对象的引用失效时计数ob_ref减1，一旦对象的引用计数为0，该对象立即被回收，对象占用的内存空间将被释放。它的缺点是需要额外的空间维护引用计数，这个问题是其次的，不过最主要的问题是它不能解决对象的“循环引用”，因此，有很多语言比如Java并没有采用该算法做来垃圾的收集机制。</p><p>导致引用计数+1的情况</p><ol><li>对象被创建，例如<code>a=23</code></li><li>对象被引用，例如<code>b=a</code></li><li>对象被作为参数，传入到一个函数中，例如<code>func(a)</code></li><li>对象作为一个元素，存储在容器中，例如<code>list1=[a,a]</code><br>导致引用计数-1的情况</li><li>对象的别名被显式销毁，例如<code>del a</code></li><li>对象的别名被赋予新的对象，例如<code>a=24</code></li><li>一个对象离开它的作用域，例如f函数执行完毕时，func函数中的局部变量（全局变量不会）</li><li>对象所在的容器被销毁，或从容器中删除对象</li></ol><h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><p>『标记清除（Mark—Sweep）』算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。它分为两个阶段：第一阶段是标记阶段，GC会把所有的『活动对象』打上标记，第二阶段是把那些没有标记的对象『非活动对象』进行回收。那么GC又是如何判断哪些是活动对象哪些是非活动对象的呢？</p><p>对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。</p><p><img src="https://foofish.net/images/mark-sweep.svg" alt="mark-sweepg"></p><p>在上图中，我们把小黑圈视为全局变量，也就是把它作为root object，从小黑圈出发，对象1可直达，那么它将被标记，对象2、3可间接到达也会被标记，而4和5不可达，那么1、2、3就是活动对象，4和5是非活动对象会被GC回收。</p><p>标记清除算法作为Python的辅助垃圾收集技术主要处理的是一些容器对象，比如list、dict、tuple，instance等，因为对于字符串、数值对象是不可能造成循环引用问题。Python使用一个双向链表将这些容器对象组织起来。不过，这种简单粗暴的标记清除算法也有明显的缺点：清除非活动的对象前它必须顺序扫描整个堆内存，哪怕只剩下小部分活动对象也要扫描所有对象。</p><h2 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h2><p>分代回收是一种以空间换时间的操作方式，Python将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代），他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发，把那些可以被回收的对象回收掉(包括循环引用的对象)，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。同时，<code>分代回收是建立在标记清除技术基础之上</code>。分代回收同样作为Python的辅助垃圾收集技术处理那些容器对象</p><h2 id="Python中的GC阈值"><a href="#Python中的GC阈值" class="headerlink" title="Python中的GC阈值"></a>Python中的GC阈值</h2><p>随着你的程序运行，Python解释器保持对新创建的对象，以及因为引用计数为零而被释放掉的对象的追踪。从理论上说，这两个值应该保持一致，因为程序新建的每个对象都应该最终被释放掉。</p><p>当然，事实并非如此。因为循环引用的原因，并且因为你的程序使用了一些比其他对象存在时间更长的对象，从而被分配对象的计数值与被释放对象的计数值之间的差异在逐渐增长。一旦这个差异累计超过某个阈值，则Python的收集机制就启动了，并且触发上边所说到的零代算法，释放“浮动的垃圾”，并且将剩下的对象移动到一代列表。</p><p>随着时间的推移，程序所使用的对象逐渐从零代列表移动到一代列表。而Python对于一代列表中对象的处理遵循同样的方法，一旦被分配计数值与被释放计数值累计到达一定阈值，Python会将剩下的活跃对象移动到二代列表。</p><p>通过这种方法，你的代码所长期使用的对象，那些你的代码持续访问的活跃对象，会从零代链表转移到一代再转移到二代。通过不同的阈值设置，Python可以在不同的时间间隔处理这些对象。Python处理零代最为频繁，其次是一代然后才是二代。</p><h2 id="gc模块"><a href="#gc模块" class="headerlink" title="gc模块"></a>gc模块</h2><p><a href="https://docs.python.org/2/library/gc.html" target="_blank" rel="noopener">Garbage Collector interface</a><br>gc模块提供一个接口给开发者设置垃圾回收的选项。上面说到，采用引用计数的方法管理内存的一个缺陷是循环引用，而gc模块的一个主要功能就是解决循环引用的问题。</p><h3 id="常用函数："><a href="#常用函数：" class="headerlink" title="常用函数："></a>常用函数：</h3><ol><li>gc.set_debug(flags)<br>设置gc的debug日志，一般设置为gc.DEBUG_LEAK</li><li>gc.collect([generation])<br>显式进行垃圾回收，可以输入参数，0代表只检查第一代的对象，1代表检查一，二代的对象，2代表检查一，二，三代的对象，如果不传参数，执行一个full collection，也就是等于传2。<br>返回不可达（unreachable objects）对象的数目</li><li>gc.set_threshold(threshold0[, threshold1[, threshold2])<br>设置自动执行垃圾回收的频率。</li><li>gc.get_count()<br>获取当前自动执行垃圾回收的计数器，返回一个长度为3的列表</li></ol><h3 id="gc模块的自动垃圾回收机制"><a href="#gc模块的自动垃圾回收机制" class="headerlink" title="gc模块的自动垃圾回收机制"></a>gc模块的自动垃圾回收机制</h3><p>必须要import gc模块，并且is_enable()=True才会启动自动垃圾回收。<br>这个机制的主要作用就是发现并处理不可达的垃圾对象。</p><p><code>垃圾回收=垃圾检查+垃圾回收</code>  </p><p>在Python中，采用分代收集的方法。把对象分为三代，一开始，对象在创建的时候，放在一代中，如果在一次一代的垃圾检查中，该对象存活下来，就会被放到二代中，同理在一次二代的垃圾检查中，该对象存活下来，就会被放到三代中。</p><p>gc模块里面会有一个长度为3的列表的计数器，可以通过<code>gc.get_count()</code>获取。<br>例如<code>(488,3,0)</code>，其中<code>488</code>是指距离上一次0代垃圾检查，Python分配内存的数目减去释放内存的数目，<strong>注意是内存分配，而不是引用计数的增加</strong>。例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> gc.get_count()  <span class="comment"># (590, 8, 0)</span></span><br><span class="line">a = ClassA()</span><br><span class="line"><span class="keyword">print</span> gc.get_count()  <span class="comment"># (591, 8, 0)</span></span><br><span class="line"><span class="keyword">del</span> a</span><br><span class="line"><span class="keyword">print</span> gc.get_count()  <span class="comment"># (590, 8, 0)</span></span><br></pre></td></tr></table></figure></p><p><code>3</code>是指距离上一次1代垃圾检查，0代垃圾检查的次数，同理，<code>0</code>是指距离上一次2代垃圾检查，1代垃圾检查的次数。</p><p>gc模快有一个自动垃圾回收的阀值，即通过<code>gc.get_threshold</code>函数获取到的长度为3的元组，例如<code>(700,10,10)</code><br>每一次计数器的增加，gc模块就会检查增加后的计数是否达到阀值的数目，如果是，就会执行对应的代数的垃圾检查，然后重置计数器<br>例如，假设阀值是<code>(700,10,10)</code>：</p><ul><li>当计数器从<code>(699,3,0)</code>增加到<code>(700,3,0)</code>，gc模块就会执行<code>gc.collect(0)</code>,即检查0代对象的垃圾，并重置计数器为<code>(0,4,0)</code></li><li>当计数器从<code>(699,9,0)</code>增加到<code>(700,9,0)</code>，gc模块就会执行<code>gc.collect(1)</code>,即检查1、2代对象的垃圾，并重置计数器为<code>(0,0,1)</code></li><li>当计数器从<code>(699,9,9)</code>增加到<code>(700,9,9)</code>，gc模块就会执行<code>gc.collect(2)</code>,即检查0、1、2代对象的垃圾，并重置计数器为<code>(0,0,0)</code></li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol><li>项目中避免循环引用</li><li>引入gc模块，启动gc模块的自动清理循环引用的对象机制</li><li>由于分代收集，所以把需要长期使用的变量集中管理，并尽快移到二代以后，减少GC检查时的消耗</li><li>gc模块唯一处理不了的是循环引用的类都有<code>__del__</code>方法，所以项目中要避免定义_<code>_del__</code>方法，如果一定要使用该方法，同时导致了循环引用，需要代码显式调用<code>gc.garbage</code>里面的对象的<code>__del__</code>来打破僵局</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://python.jobbole.com/87843/" target="_blank" rel="noopener">http://python.jobbole.com/87843/</a></li><li><a href="https://www.cnblogs.com/pinganzi/p/6646742.html" target="_blank" rel="noopener">https://www.cnblogs.com/pinganzi/p/6646742.html</a></li><li><a href="http://python.jobbole.com/87064/?utm_source=blog.jobbole.com&amp;utm_medium=relatedPosts" target="_blank" rel="noopener">http://python.jobbole.com/87064/?utm_source=blog.jobbole.com&amp;utm_medium=relatedPosts</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python中的垃圾回收GC(Garbage collection)是以引用计数为主，分代收集为辅。引用计数的缺陷是循环引用的问题。&lt;br&gt;分代收集在一定程度上解决了循环引用的问题（可能描述不准确）。&lt;/p&gt;
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>IO密集型任务、计算密集型任务，以及多线程、多进程</title>
    <link href="http://yoursite.com/2018/03/05/IO%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1%E3%80%81%E8%AE%A1%E7%AE%97%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%81%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/03/05/IO密集型任务、计算密集型任务，以及多线程、多进程/</id>
    <published>2018-03-05T02:41:27.000Z</published>
    <updated>2018-03-05T15:54:17.211Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IO密集型任务-vs-计算密集型任务"><a href="#IO密集型任务-vs-计算密集型任务" class="headerlink" title="IO密集型任务 vs 计算密集型任务"></a>IO密集型任务 vs 计算密集型任务</h2><ul><li><p>所谓IO密集型任务，是指磁盘IO、网络IO占主要的任务，计算量很小。比如请求网页、读写文件等。当然我们在Python中可以利用sleep达到IO密集型任务的目的。  </p></li><li><p>所谓计算密集型任务，是指CPU计算占主要的任务，CPU一直处于满负荷状态。比如在一个很大的列表中查找元素（当然这不合理），复杂的加减乘除等。</p></li></ul><a id="more"></a><p>计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。</p><p>计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。</p><p>第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。</p><p>IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。</p><h2 id="多线程-VS-多进程"><a href="#多线程-VS-多进程" class="headerlink" title="多线程 VS 多进程"></a>多线程 VS 多进程</h2><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>多线程即在一个进程中启动多个线程执行任务。一般来说使用多线程可以达到并行的目的，但由于Python中使用了全局解释锁GIL的概念，导致Python中的多线程并不是并行执行，而是“交替执行”。类似于下图：（图片转自网络，侵删）</p><p><img src="https://pic2.zhimg.com/80/v2-dfad6468a9ddd7edd2494971296a00d0_hd.jpg" alt=""></p><p>所以Python中的多线程适合IO密集型任务，而不适合计算密集型任务。</p><p>Python提供两组多线程接口，一是thread模块_thread，提供低等级接口。二是threading模块，提供更容易使用的基于对象的接口，可以继承Thread对象来实现线程，此外其还提供了其它线程相关的对象，例如Timer，Lock等。</p><p>多线程模式通常比多进程快一点，但是也快不到哪去，而且，多线程模式致命的缺点就是任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存。在Windows上，如果一个线程执行的代码出了问题，你经常可以看到这样的提示：“该程序执行了非法操作，即将关闭”，其实往往是某个线程出了问题，但是操作系统会强制结束整个进程。</p><p>在Windows下，多线程的效率比多进程要高，所以微软的IIS服务器默认采用多线程模式。由于多线程存在稳定性的问题，IIS的稳定性就不如Apache。为了缓解这个问题，IIS和Apache现在又有多进程+多线程的混合模式，真是把问题越搞越复杂。</p><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>由于Python中GIL的原因，对于计算密集型任务，Python下比较好的并行方式是使用多进程，这样可以非常有效的使用CPU资源。当然同一时间执行的进程数量取决你电脑的CPU核心数。</p><p><img src="https://pic3.zhimg.com/80/v2-f1cdf422f5aef9a23f714a399e8e7016_hd.jpg" alt=""></p><p>Python中的进程模块为mutliprocess模块，提供了很多容易使用的基于对象的接口。另外它提供了封装好的管道和队列，可以方便的在进程间传递消息。Python还提供了进程池Pool对象，可以方便的管理和控制线程。</p><p>多进程模式最大的<code>优点</code>就是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程。（当然主进程挂了所有进程就全挂了，但是Master进程只负责分配任务，挂掉的概率低）著名的Apache最早就是采用多进程模式。</p><p>多进程模式的<code>缺点</code>是创建进程的代价大，在Unix/Linux系统下，用fork调用还行，在Windows下创建进程开销巨大。另外，操作系统能同时运行的进程数也是有限的，在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都会成问题。</p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p><strong>实例讲解Python中的多线程、多进程如何应对IO密集型任务、计算密集型任务</strong></p><p>这里通过一个实例，说明多线程适合IO密集型任务，多进程适合计算密集型任务。首先定义一个队列，并定义初始化队列的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义全局变量Queue</span></span><br><span class="line">g_queue = multiprocessing.Queue()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_queue</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"init g_queue start"</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> g_queue.empty():</span><br><span class="line">        print(g_queue.get())</span><br><span class="line">    <span class="keyword">for</span> _index <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        g_queue.put(_index)</span><br><span class="line">    print(<span class="string">"init g_queue end"</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>定义IO密集型任务和计算密集型任务，分别从队列中获取任务数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个IO密集型任务：利用time.sleep()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task_io</span><span class="params">(task_id)</span>:</span></span><br><span class="line">    print(<span class="string">"IOTask[%s] start"</span> % task_id)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> g_queue.empty():</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = g_queue.get(block=<span class="keyword">True</span>, timeout=<span class="number">1</span>)</span><br><span class="line">            print(<span class="string">"IOTask[%s] get data: %s"</span> % (task_id, data))</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> excep:</span><br><span class="line">            print(<span class="string">"IOTask[%s] error: %s"</span> % (task_id, str(excep)))</span><br><span class="line">    print(<span class="string">"IOTask[%s] end"</span> % task_id)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">g_search_list = list(range(<span class="number">10000</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个计算密集型任务：利用一些复杂加减乘除、列表查找等</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task_cpu</span><span class="params">(task_id)</span>:</span></span><br><span class="line">    print(<span class="string">"CPUTask[%s] start"</span> % task_id)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> g_queue.empty():</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000</span>):</span><br><span class="line">            count += pow(<span class="number">3</span>*<span class="number">2</span>, <span class="number">3</span>*<span class="number">2</span>) <span class="keyword">if</span> i <span class="keyword">in</span> g_search_list <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = g_queue.get(block=<span class="keyword">True</span>, timeout=<span class="number">1</span>)</span><br><span class="line">            print(<span class="string">"CPUTask[%s] get data: %s"</span> % (task_id, data))</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> excep:</span><br><span class="line">            print(<span class="string">"CPUTask[%s] error: %s"</span> % (task_id, str(excep)))</span><br><span class="line">    print(<span class="string">"CPUTask[%s] end"</span> % task_id)</span><br><span class="line">    <span class="keyword">return</span> task_id</span><br></pre></td></tr></table></figure><p>准备完上述代码之后，进行试验：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">"cpu count:"</span>, multiprocessing.cpu_count(), <span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"========== 直接执行IO密集型任务 =========="</span>)</span><br><span class="line">    init_queue()</span><br><span class="line">    time_0 = time.time()</span><br><span class="line">    task_io(<span class="number">0</span>)</span><br><span class="line">    print(<span class="string">"结束："</span>, time.time() - time_0, <span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"========== 多线程执行IO密集型任务 =========="</span>)</span><br><span class="line">    init_queue()</span><br><span class="line">    time_0 = time.time()</span><br><span class="line">    thread_list = [threading.Thread(target=task_io, args=(i,)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> thread_list:</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> thread_list:</span><br><span class="line">        <span class="keyword">if</span> t.is_alive():</span><br><span class="line">            t.join()</span><br><span class="line">    print(<span class="string">"结束："</span>, time.time() - time_0, <span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"========== 多进程执行IO密集型任务 =========="</span>)</span><br><span class="line">    init_queue()</span><br><span class="line">    time_0 = time.time()</span><br><span class="line">    process_list = [multiprocessing.Process(target=task_io, args=(i,)) <span class="keyword">for</span> i <span class="keyword">in</span> range(multiprocessing.cpu_count())]</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> process_list:</span><br><span class="line">        p.start()</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> process_list:</span><br><span class="line">        <span class="keyword">if</span> p.is_alive():</span><br><span class="line">            p.join()</span><br><span class="line">    print(<span class="string">"结束："</span>, time.time() - time_0, <span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"========== 直接执行CPU密集型任务 =========="</span>)</span><br><span class="line">    init_queue()</span><br><span class="line">    time_0 = time.time()</span><br><span class="line">    task_cpu(<span class="number">0</span>)</span><br><span class="line">    print(<span class="string">"结束："</span>, time.time() - time_0, <span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"========== 多线程执行CPU密集型任务 =========="</span>)</span><br><span class="line">    init_queue()</span><br><span class="line">    time_0 = time.time()</span><br><span class="line">    thread_list = [threading.Thread(target=task_cpu, args=(i,)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> thread_list:</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> thread_list:</span><br><span class="line">        <span class="keyword">if</span> t.is_alive():</span><br><span class="line">            t.join()</span><br><span class="line">    print(<span class="string">"结束："</span>, time.time() - time_0, <span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"========== 多进程执行cpu密集型任务 =========="</span>)</span><br><span class="line">    init_queue()</span><br><span class="line">    time_0 = time.time()</span><br><span class="line">    process_list = [multiprocessing.Process(target=task_cpu, args=(i,)) <span class="keyword">for</span> i <span class="keyword">in</span> range(multiprocessing.cpu_count())]</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> process_list:</span><br><span class="line">        p.start()</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> process_list:</span><br><span class="line">        <span class="keyword">if</span> p.is_alive():</span><br><span class="line">            p.join()</span><br><span class="line">    print(<span class="string">"结束："</span>, time.time() - time_0, <span class="string">"\n"</span>)</span><br></pre></td></tr></table></figure></p><p>结果说明：</p><p><strong>对于IO密集型任务：</strong></p><ul><li>直接执行用时：10.0333秒</li><li>多线程执行用时：4.0156秒</li><li>多进程执行用时：5.0182秒</li></ul><p>说明多线程适合IO密集型任务。</p><p><strong>对于计算密集型任务</strong>  </p><ul><li>直接执行用时：10.0273秒</li><li>多线程执行用时：13.247秒</li><li>多进程执行用时：6.8377秒</li></ul><p>说明多进程适合计算密集型任务</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/24283040" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24283040</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;IO密集型任务-vs-计算密集型任务&quot;&gt;&lt;a href=&quot;#IO密集型任务-vs-计算密集型任务&quot; class=&quot;headerlink&quot; title=&quot;IO密集型任务 vs 计算密集型任务&quot;&gt;&lt;/a&gt;IO密集型任务 vs 计算密集型任务&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;所谓IO密集型任务，是指磁盘IO、网络IO占主要的任务，计算量很小。比如请求网页、读写文件等。当然我们在Python中可以利用sleep达到IO密集型任务的目的。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;所谓计算密集型任务，是指CPU计算占主要的任务，CPU一直处于满负荷状态。比如在一个很大的列表中查找元素（当然这不合理），复杂的加减乘除等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="多任务处理" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>进程、线程、协程</title>
    <link href="http://yoursite.com/2018/03/04/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/03/04/进程、线程、协程/</id>
    <published>2018-03-03T17:20:18.000Z</published>
    <updated>2018-03-03T19:00:47.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>电脑里运行的应用程序，都是进程，假设我们用的电脑是单核的，CPU同时只能执行一个进程。当程序处于I/O阻塞的时候，CPU如果和程序一起等待，那就太浪费了，CPU会去执行其他的程序，此时就涉及到切换，切换前要保存上一个程序运行的状态，才能恢复，所以就需要有个东西来记录这个东西，就可以引出进程的概念了。</p><p>进程就是<code>一个程序在一个数据集上的一次动态执行过程</code>。进程是一个动态概念，是竟争计算机系统资源的基本单位。进程由<code>程序</code>，<code>数据集</code>，<code>进程控制块</code>三部分组成。<code>程序</code>用来描述进程哪些功能以及如何完成；<code>数据集</code>是程序执行过程中所使用的资源；<code>进程控制块</code>用来保存程序运行的状态.</p><p><code>进程是系统进行资源分配和调度的一个独立单位</code>。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。</p><a id="more"></a><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>在网络或多用户环境下，一个服务器通常需要接收大量且不确定数量用户的并发请求，为每一个请求都创建一个进程显然是行不通的，——无论是从系统资源开销方面或是响应用户请求的效率方面来看。因此，操作系统中<code>线程</code>的概念便被引进了。线程，是进程的一部分，<code>一个没有线程的进程可以被看作是单线程的</code>。线程有时又被称为<code>轻权进程</code>或<code>轻量级进程</code>，是一个基本的cpu执行单元，也是程序执行过程中的最小单元。一个进程最少也会有一个主线程，在主线程中通过threading模块，再开子线程。</p><p>线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。</p><p><strong>进程拥有一个完整的虚拟地址空间，不依赖于线程而独立存在；反之，线程是进程的一部分，没有自己的地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。</strong></p><p><strong>进程的状态有就绪，运行，等待三个状态；线程的状态有新建-就绪-（阻塞）-运行–死亡四个基本状态</strong></p><p>线程全局锁GIL(Global Interpreter Lock),即Python为了保证线程安全而采取的<code>独立线程运行的限制</code>,说白了就是一个核只能在同一时间运行一个线程.对于io密集型任务，python的多线程起到作用，但对于cpu密集型任务，python的多线程几乎占不到任何优势，还有可能因为争夺资源而变慢。</p><h2 id="进程、线程的关系"><a href="#进程、线程的关系" class="headerlink" title="进程、线程的关系"></a>进程、线程的关系</h2><ol><li>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程</li><li>资源分配给进程，进程是程序的主体，同一进程的所有线程共享该进程的所有资源</li><li>CPU分配给线程，即真正在CPU上运行的是线程</li><li>线程是最小的执行单元，进程是最小的资源管理单元</li></ol><h2 id="协程Coroutine"><a href="#协程Coroutine" class="headerlink" title="协程Coroutine"></a>协程Coroutine</h2><p>协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p><p><code>进程</code>拥有自己独立的堆和栈，既不共享堆，亦不共享栈，<code>进程由操作系统调度</code>。<br><code>线程</code>拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。<br>协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。<br>进程和其他两个的区别还是很明显的。<br><code>协程和线程的区别是</code>：协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，<code>协程也失去了标准线程使用多CPU的能力。</code></p><p>举个例子：<br>假设有一个操作系统，是单核的，系统上没有其他的程序需要运行，有两个线程 A 和 B ，A 和 B 在单独运行时都需要 10 秒来完成自己的任务，而且任务都是运算操作，A B 之间也没有竞争和共享数据的问题。现在 A B 两个线程并行，操作系统会不停的在 A B 两个线程之间切换，达到一种伪并行的效果，假设切换的频率是每秒一次，切换的成本是 0.1 秒(主要是栈切换)，总共需要 20 + 19 <em> 0.1 = 21.9 秒。如果使用协程的方式，可以先运行协程 A ，A 结束的时候让位给协程 B ，只发生一次切换，总时间是 20 + 1 </em> 0.1 = 20.1 秒。如果系统是双核的，而且线程是标准线程，那么 A B 两个线程就可以真并行，总时间只需要 10 秒，而协程的方案仍然需要 20.1 秒。</p><p>人们通常将协程和子程序（函数）比较着理解。<br>子程序调用总是一个入口，一次返回，一旦退出即完成了子程序的执行。<br>协程的起始处是第一个入口点，在协程里，返回点之后是接下来的入口点。在python中，协程可以通过yield来调用其它协程。通过yield方式转移执行权的协程之间不是调用者与被调用者的关系，而是彼此对称、平等的，通过相互协作共同完成任务。其运行的大致流程如下：</p><ol><li>第一步，协程A开始执行。</li><li>第二步，协程A执行到一半，进入暂停，通过yield命令将执行权转移到协程B。</li><li>第三步，（一段时间后）协程B交还执行权。</li><li>第四步，协程A恢复执行。</li></ol><p>协程的特点在于是一个线程执行，与多线程相比，其优势体现在：</p><p>协程的执行效率非常高。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。<br>协程不需要多线程的锁机制。在协程中控制共享资源不加锁，只需要判断状态就好了。<br>Tips:利用多核CPU最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="进程与线程比较"><a href="#进程与线程比较" class="headerlink" title="进程与线程比较"></a>进程与线程比较</h3><p>线程是指进程内的一个执行单元,也是进程内的可调度实体。线程与进程的区别:</p><ol><li>地址空间:线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间，而进程有自己独立的地址空间</li><li>资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源</li><li>线程是处理器调度的基本单位,但进程不是</li><li><p>二者均可并发执行</p></li><li><p>每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制</p></li></ol><h3 id="协程与线程进行比较"><a href="#协程与线程进行比较" class="headerlink" title="协程与线程进行比较"></a>协程与线程进行比较</h3><ol><li>一个线程可以多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核CPU。</li><li>线程进程都是同步机制，而协程则是异步</li><li>协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h2&gt;&lt;p&gt;电脑里运行的应用程序，都是进程，假设我们用的电脑是单核的，CPU同时只能执行一个进程。当程序处于I/O阻塞的时候，CPU如果和程序一起等待，那就太浪费了，CPU会去执行其他的程序，此时就涉及到切换，切换前要保存上一个程序运行的状态，才能恢复，所以就需要有个东西来记录这个东西，就可以引出进程的概念了。&lt;/p&gt;
&lt;p&gt;进程就是&lt;code&gt;一个程序在一个数据集上的一次动态执行过程&lt;/code&gt;。进程是一个动态概念，是竟争计算机系统资源的基本单位。进程由&lt;code&gt;程序&lt;/code&gt;，&lt;code&gt;数据集&lt;/code&gt;，&lt;code&gt;进程控制块&lt;/code&gt;三部分组成。&lt;code&gt;程序&lt;/code&gt;用来描述进程哪些功能以及如何完成；&lt;code&gt;数据集&lt;/code&gt;是程序执行过程中所使用的资源；&lt;code&gt;进程控制块&lt;/code&gt;用来保存程序运行的状态.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;进程是系统进行资源分配和调度的一个独立单位&lt;/code&gt;。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="多任务处理" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Mac OS 命令之文件(夹)删除</title>
    <link href="http://yoursite.com/2018/03/03/Mac-OS-%E5%91%BD%E4%BB%A4%E4%B9%8B%E6%96%87%E4%BB%B6-%E5%A4%B9-%E5%88%A0%E9%99%A4/"/>
    <id>http://yoursite.com/2018/03/03/Mac-OS-命令之文件-夹-删除/</id>
    <published>2018-03-03T05:40:34.000Z</published>
    <updated>2018-03-03T05:49:16.813Z</updated>
    
    <content type="html"><![CDATA[<p><code>rmdir</code>删除空目录，不过一旦目录非空会提示<br>Directiry not empty</p><p>使用<code>rm</code>既可以删除文件又可以删除文件夹<br>删除文件夹（无论文件夹是否为空），使用 <code>-rf</code> 命令即可。<br>即：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm -rf 目录名字</span><br></pre></td></tr></table></figure></p><p><code>-r</code> 就是向下递归，不管有多少级目录，一并删除<br><code>-f</code> 就是直接强行删除，不作任何提示的意思<br><a id="more"></a><br>删除<code>文件夹</code>实例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm -rf  /User/Dhyana/desktop</span><br></pre></td></tr></table></figure></p><p>将会删除 /User/Dhyana/desktop目录以及其下所有文件、文件夹</p><p>删除<code>文件</code>使用实例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm -f  /User/Dhyana/desktop/test.py</span><br></pre></td></tr></table></figure></p><p>将会<strong>强制删除</strong>/User/Dhyana/desktop/test.py这个文件</p><p>值得注意的是：<br>使用这个rm -rf的时候一定要格外小心，linux没有回收站的，删除之后再想找回就很难了。有一个非常好笑的笑话就是命令行中输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rm -rf /.*</span><br><span class="line"><span class="comment"># 千万不要输入此命令，否则清空整个操作系统，后果自负</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;rmdir&lt;/code&gt;删除空目录，不过一旦目录非空会提示&lt;br&gt;Directiry not empty&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;rm&lt;/code&gt;既可以删除文件又可以删除文件夹&lt;br&gt;删除文件夹（无论文件夹是否为空），使用 &lt;code&gt;-rf&lt;/code&gt; 命令即可。&lt;br&gt;即：&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ rm -rf 目录名字&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-r&lt;/code&gt; 就是向下递归，不管有多少级目录，一并删除&lt;br&gt;&lt;code&gt;-f&lt;/code&gt; 就是直接强行删除，不作任何提示的意思&lt;br&gt;
    
    </summary>
    
      <category term="Mac OS 命令行" scheme="http://yoursite.com/categories/Mac-OS-%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
    
      <category term="Mac OS 命令行" scheme="http://yoursite.com/tags/Mac-OS-%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>Python3 使用virtualenv搭建虚拟环境</title>
    <link href="http://yoursite.com/2018/03/03/Python3-%E4%BD%BF%E7%94%A8virtualenv%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2018/03/03/Python3-使用virtualenv搭建虚拟环境/</id>
    <published>2018-03-03T05:28:31.000Z</published>
    <updated>2018-03-03T05:32:43.613Z</updated>
    
    <content type="html"><![CDATA[<p>在使用Python进行多个项目开发时，每个项目可能会需要安装不同的组件。把这些组件安装在同一台计算机下可能会导致组件之间的相互冲突，比如项目A使用Django 1.10，而项目B使用Django 1.8，那么同时安装两个版本可能在具体使用时产生冲突。使用虚拟环境可以有效避免这样的问题。</p><p>Python虚拟环境是一套由Ian Bicking编写的管理独立Python运行环境的系统。这样，开发者可以让每个项目运行在独立的虚拟环境中，从而避免了不同项目之间组件配置的冲突。<br><a id="more"></a></p><h4 id="1-虚拟环境安装"><a href="#1-虚拟环境安装" class="headerlink" title="1.虚拟环境安装"></a>1.虚拟环境安装</h4><p>在终端中执行命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install virtualenv</span><br></pre></td></tr></table></figure></p><h4 id="2-虚拟环境使用"><a href="#2-虚拟环境使用" class="headerlink" title="2.虚拟环境使用"></a>2.虚拟环境使用</h4><p>假定我们要开发一个新的项目，需要一套独立的Python运行环境，或者为已有的项目建立虚拟环境，终端执行如下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span>   [项目所在目录]</span><br><span class="line">$ virtualenv venv</span><br></pre></td></tr></table></figure></p><p>该命令执行后，将在当前目录下建立一个venv目录，<strong>该目录拷贝一份完整的当前系统的Python环境</strong>；</p><p>我么也可以执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ virtualenv --no-site-packages venv</span><br></pre></td></tr></table></figure></p><p>这样，已经安装到系统Python环境中的所有第三方包都不会复制过来，这样，我们就得到了一个不带任何第三方包的“干净”的Python运行环境。新建的Python环境被放到当前目录下的venv目录。</p><p>有了venv这个Python环境，可以用source进入该环境（注意是在cd之后的目录）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">source</span> venv/bin/activate[.fish|.zsh]</span><br></pre></td></tr></table></figure></p><p>注意到命令提示符变了，有个(venv)前缀，表示当前环境是一个名为venv的Python环境。在venv环境下，用pip安装的包都被安装到venv/lib目录，而不会影响系统的Python环境。</p><p>退出当前的venv环境，使用deactivate命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ deactivate</span><br></pre></td></tr></table></figure></p><p>此时回到了正常的环境，现在pip或python均是在系统Python环境下执行。</p><h4 id="3-注意"><a href="#3-注意" class="headerlink" title="3.注意"></a>3.注意</h4><p>为保证项目之间的独立性，建议所有使用pip安装的组件都在项目虚拟环境中进行，避免不同版本的冲突。</p><p>最后附上<a href="https://virtualenv.pypa.io/en/stable/" target="_blank" rel="noopener">Virtualenv的官方文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用Python进行多个项目开发时，每个项目可能会需要安装不同的组件。把这些组件安装在同一台计算机下可能会导致组件之间的相互冲突，比如项目A使用Django 1.10，而项目B使用Django 1.8，那么同时安装两个版本可能在具体使用时产生冲突。使用虚拟环境可以有效避免这样的问题。&lt;/p&gt;
&lt;p&gt;Python虚拟环境是一套由Ian Bicking编写的管理独立Python运行环境的系统。这样，开发者可以让每个项目运行在独立的虚拟环境中，从而避免了不同项目之间组件配置的冲突。&lt;br&gt;
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
      <category term="Python3 virtualenv" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/Python3-virtualenv/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Python3 真假值对照表</title>
    <link href="http://yoursite.com/2018/03/03/Python3-%E7%9C%9F%E5%81%87%E5%80%BC%E5%AF%B9%E7%85%A7%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/03/03/Python3-真假值对照表/</id>
    <published>2018-03-03T05:14:45.000Z</published>
    <updated>2018-03-03T05:21:56.663Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">False</th><th style="text-align:center">True</th></tr></thead><tbody><tr><td style="text-align:center">布尔</td><td style="text-align:center">False(与0等价)</td><td style="text-align:center">True(与1等价)</td></tr><tr><td style="text-align:center">数值</td><td style="text-align:center">0, &nbsp;&nbsp;0.0</td><td style="text-align:center">非零的数值</td></tr><tr><td style="text-align:center">字符串</td><td style="text-align:center">‘’,&nbsp;&nbsp;””(空字符串)</td><td style="text-align:center">非空字符串</td></tr><tr><td style="text-align:center">容器</td><td style="text-align:center">[],&nbsp;&nbsp;(),&nbsp;&nbsp;{},&nbsp;&nbsp;set()</td><td style="text-align:center">至少有一个元素的容器对象</td></tr><tr><td style="text-align:center">None</td><td style="text-align:center">None</td><td style="text-align:center">非None对象</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;类型&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;False&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;True&lt;/th&gt;

      
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
      <category term="Python3 True or False" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/Python3-True-or-False/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Markdown小技巧之空格输入</title>
    <link href="http://yoursite.com/2018/03/03/Markdown%E5%B0%8F%E6%8A%80%E5%B7%A7%E4%B9%8B%E7%A9%BA%E6%A0%BC%E8%BE%93%E5%85%A5/"/>
    <id>http://yoursite.com/2018/03/03/Markdown小技巧之空格输入/</id>
    <published>2018-03-03T05:06:47.000Z</published>
    <updated>2018-03-03T05:07:54.804Z</updated>
    
    <content type="html"><![CDATA[<p>在使用Markdown的时候，有时候会与到这样的需求——为Markdown添加空格。跟word等其他编辑器不同，Markdown只能识别一个空格（在半角输入状态下）。通过搜寻资料找到了两个解决方案。</p><ol><li><p>手动输入空格 （<strong>&amp;nbsp；</strong>）。<strong>注意！此时的分号为英文分号</strong>，但是不推荐使用此方法，太麻烦！</p></li><li><p>使用<strong>全角空格</strong>。即：在<strong>全角</strong>输入状态下直接使用空格键就ok了</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在使用Markdown的时候，有时候会与到这样的需求——为Markdown添加空格。跟word等其他编辑器不同，Markdown只能识别一个空格（在半角输入状态下）。通过搜寻资料找到了两个解决方案。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;手动输入空格 （&lt;strong&gt;&amp;amp;
      
    
    </summary>
    
      <category term="Markdown" scheme="http://yoursite.com/categories/Markdown/"/>
    
    
      <category term="Markdown" scheme="http://yoursite.com/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Python3 is和==的区别</title>
    <link href="http://yoursite.com/2018/03/03/Python3-is%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/03/03/Python3-is和-的区别/</id>
    <published>2018-03-03T04:16:34.000Z</published>
    <updated>2018-03-03T05:12:14.031Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python-对象三要素"><a href="#Python-对象三要素" class="headerlink" title="Python 对象三要素"></a>Python 对象三要素</h2><p>要理解Python中is和==的区别，首先要理解Python对象的三个要素:</p><table><thead><tr><th style="text-align:center">要素</th><th style="text-align:center">说明</th><th style="text-align:center">获取方式</th></tr></thead><tbody><tr><td style="text-align:center">id</td><td style="text-align:center">身份标识，基本就是内存地址，用来唯一标识一个对象</td><td style="text-align:center">id(obj)</td></tr><tr><td style="text-align:center">type</td><td style="text-align:center">数据类型</td><td style="text-align:center">type(obj)</td></tr><tr><td style="text-align:center">value</td><td style="text-align:center">值</td><td style="text-align:center">:—–:</td></tr></tbody></table><a id="more"></a><h2 id="is和-区别"><a href="#is和-区别" class="headerlink" title="is和==区别"></a>is和==区别</h2><table><thead><tr><th style="text-align:center">标识</th><th style="text-align:center">名称</th><th style="text-align:center">判断方法</th></tr></thead><tbody><tr><td style="text-align:center">is</td><td style="text-align:center">同一性运算符</td><td style="text-align:center">id</td></tr><tr><td style="text-align:center">==</td><td style="text-align:center">比较运算符</td><td style="text-align:center">value</td></tr></tbody></table><hr><h2 id="程序举例"><a href="#程序举例" class="headerlink" title="程序举例"></a>程序举例</h2><h3 id="例1："><a href="#例1：" class="headerlink" title="例1："></a>例1：</h3><p><img src="http://upload-images.jianshu.io/upload_images/2952111-ec5fa82d12a42a34.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕截图2.jpg"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">"a"</span>:<span class="number">1</span>, <span class="string">"b"</span>:<span class="number">2</span>&#125;</span><br><span class="line">b = a.copy()</span><br><span class="line"></span><br><span class="line">a == b  <span class="comment"># True value一样</span></span><br><span class="line">a <span class="keyword">is</span> b  <span class="comment"># False id不一样</span></span><br></pre></td></tr></table></figure><hr><h3 id="例2："><a href="#例2：" class="headerlink" title="例2："></a>例2：</h3><p><img src="http://upload-images.jianshu.io/upload_images/2952111-21696bc9de2d0e56.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕截图.jpg"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = y = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x == y</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x == z</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x <span class="keyword">is</span> y</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x <span class="keyword">is</span> z</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> id(x)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> id(y)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> id(z)</span><br></pre></td></tr></table></figure><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span> <span class="comment">#a和b为数值类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'cheesezh'</span> <span class="comment">#a和b为字符串类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">'cheesezh'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="comment">#a和b为元组类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="comment">#a和b为list类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;<span class="string">'cheese'</span>:<span class="number">1</span>,<span class="string">'zh'</span>:<span class="number">2</span>&#125; <span class="comment">#a和b为dict类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = &#123;<span class="string">'cheese'</span>:<span class="number">1</span>,<span class="string">'zh'</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = set([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])<span class="comment">#a和b为set类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = set([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Python-对象三要素&quot;&gt;&lt;a href=&quot;#Python-对象三要素&quot; class=&quot;headerlink&quot; title=&quot;Python 对象三要素&quot;&gt;&lt;/a&gt;Python 对象三要素&lt;/h2&gt;&lt;p&gt;要理解Python中is和==的区别，首先要理解Python对象的三个要素:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;要素&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;说明&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;获取方式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;id&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;身份标识，基本就是内存地址，用来唯一标识一个对象&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;id(obj)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;type&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;数据类型&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;type(obj)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;value&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;值&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;:—–:&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Python3 拷贝对象(深拷贝deepcopy和浅拷贝copy)</title>
    <link href="http://yoursite.com/2018/03/03/Python3-%E6%8B%B7%E8%B4%9D%E5%AF%B9%E8%B1%A1-%E6%B7%B1%E6%8B%B7%E8%B4%9Ddeepcopy%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9Dcopy/"/>
    <id>http://yoursite.com/2018/03/03/Python3-拷贝对象-深拷贝deepcopy和浅拷贝copy/</id>
    <published>2018-03-03T04:10:54.000Z</published>
    <updated>2018-03-03T04:14:09.659Z</updated>
    
    <content type="html"><![CDATA[<ol><li>copy.copy 浅拷贝 <code>只拷贝父对象</code>，不会拷贝对象的内部的子对象。</li><li>copy.deepcopy 深拷贝 <code>拷贝对象及其子对象</code></li></ol><hr><p><img src="http://upload-images.jianshu.io/upload_images/2952111-17e1f4233f95285d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕截图3.jpg"></p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*-coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]] <span class="comment">#原始对象</span></span><br><span class="line"></span><br><span class="line">b = a <span class="comment">#赋值，传对象的引用</span></span><br><span class="line">c = copy.copy(a) <span class="comment">#对象拷贝，浅拷贝</span></span><br><span class="line">d = copy.deepcopy(a) <span class="comment">#对象拷贝，深拷贝</span></span><br><span class="line"></span><br><span class="line">a.append(<span class="number">5</span>) <span class="comment">#修改对象a</span></span><br><span class="line">a[<span class="number">4</span>].append(<span class="string">'c'</span>) <span class="comment">#修改对象a中的['a', 'b']数组对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'a = '</span>, a</span><br><span class="line"><span class="keyword">print</span> <span class="string">'b = '</span>, b</span><br><span class="line"><span class="keyword">print</span> <span class="string">'c = '</span>, c</span><br><span class="line"><span class="keyword">print</span> <span class="string">'d = '</span>, d</span><br><span class="line">输出结果：</span><br><span class="line">a =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], <span class="number">5</span>]</span><br><span class="line">b =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], <span class="number">5</span>]</span><br><span class="line">c =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]]</span><br><span class="line">d =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;copy.copy 浅拷贝 &lt;code&gt;只拷贝父对象&lt;/code&gt;，不会拷贝对象的内部的子对象。&lt;/li&gt;
&lt;li&gt;copy.deepcopy 深拷贝 &lt;code&gt;拷贝对象及其子对象&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2952111-17e1f4233f95285d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;屏幕截图3.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
      <category term="Python3 拷贝对象" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/Python3-%E6%8B%B7%E8%B4%9D%E5%AF%B9%E8%B1%A1/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Python3 作用域</title>
    <link href="http://yoursite.com/2018/03/03/Python3-%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2018/03/03/Python3-作用域/</id>
    <published>2018-03-03T03:48:30.000Z</published>
    <updated>2018-03-03T03:56:30.508Z</updated>
    
    <content type="html"><![CDATA[<p>Python 中，一个变量的作用域总是由在代码中被赋值的地方所决定的。</p><p>Python 获取变量中的值的搜索顺序为：</p><p>本地作用域（Local）→ 当前作用域被嵌入的本地作用域（Enclosing locals）→ 全局/模块作用域（Global）→内置作用域（Built-in）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Python 中，一个变量的作用域总是由在代码中被赋值的地方所决定的。&lt;/p&gt;
&lt;p&gt;Python 获取变量中的值的搜索顺序为：&lt;/p&gt;
&lt;p&gt;本地作用域（Local）→ 当前作用域被嵌入的本地作用域（Enclosing locals）→ 全局/模块作用域（Global）→
      
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
      <category term="Python3 作用域" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/Python3-%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Python3 函数重载</title>
    <link href="http://yoursite.com/2018/03/03/Python3-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/"/>
    <id>http://yoursite.com/2018/03/03/Python3-函数重载/</id>
    <published>2018-03-03T02:54:44.000Z</published>
    <updated>2018-03-03T03:46:12.845Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数重载的目的"><a href="#函数重载的目的" class="headerlink" title="函数重载的目的"></a>函数重载的目的</h2><p>动态语言中，有鸭子类型，如果走起路来像鸭子，叫起来也像鸭子，那么它就是鸭子。一个对象的特征不是由它的类型决定，而是通过对象中的方法决定，所以函数重载在动态语言中就显得没有意义了，因为函数可以通过鸭子类型来处理不同类型的对象，鸭子类型也是多态性的一种表现。</p><p>在Python中实现函数重载：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Writer</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(output, content)</span>:</span></span><br><span class="line">        <span class="comment"># output对象只要实现了write方法就行</span></span><br><span class="line">        output.write(content)</span><br><span class="line"></span><br><span class="line"><span class="comment"># stringIO类型</span></span><br><span class="line">output = StringIO()</span><br><span class="line">Writer.write(output, <span class="string">'hello world'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># file 类型</span></span><br><span class="line">output = open(<span class="string">'out.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line">Writer.write(output, <span class="string">'hello world'</span>)</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>在静态语言中，方法重载是希望类可以以统一的方式处理不同类型的数据提供了可能。多个同名函数同时存在，具有不同的参数个数/类型，重载是一个类中多态性的一种表现。</p><p>在Java中实现函数重载：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Writer&#123;</span><br><span class="line">    public static void write(StringIO output, String content)&#123;</span><br><span class="line">        output.write(content);</span><br><span class="line">        <span class="keyword">return</span> null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void write(File output, String content)&#123;</span><br><span class="line">        output.write(content);</span><br><span class="line">        <span class="keyword">return</span> null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>参考自知乎用户刘志军：<a href="https://www.zhihu.com/question/20053359" target="_blank" rel="noopener">https://www.zhihu.com/question/20053359</a></p><hr><h2 id="函数重载主要是为了解决两个问题"><a href="#函数重载主要是为了解决两个问题" class="headerlink" title="函数重载主要是为了解决两个问题"></a>函数重载主要是为了解决两个问题</h2><ol><li>可变参数类型。</li><li>可变参数个数。</li></ol><blockquote><p>另外，一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载，如果两个函数的功能其实不同，那么不应当使用重载，而应当使用一个名字不同的函数。</p></blockquote><p>那么对于情况 1 ，函数功能相同，但是参数类型不同，python 如何处理？答案是根本不需要处理，因为 python 可以接受任何类型的参数，如果函数的功能相同，那么不同的参数类型在 python 中很可能是相同的代码，没有必要做成两个不同函数。</p><p>那么对于情况 2 ，函数功能相同，但参数个数不同，python 如何处理？大家知道，答案就是<code>缺省参数</code>。对那些缺少的参数设定为缺省参数即可解决问题。因为你假设函数功能相同，那么那些缺少的参数终归是需要用的。好了，鉴于情况 1 跟 情况 2 都有了解决方案，python 自然就不需要函数重载了。</p><p>参考自知乎用户<code>pansz</code>：<a href="https://www.zhihu.com/question/20053359" target="_blank" rel="noopener">https://www.zhihu.com/question/20053359</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;函数重载的目的&quot;&gt;&lt;a href=&quot;#函数重载的目的&quot; class=&quot;headerlink&quot; title=&quot;函数重载的目的&quot;&gt;&lt;/a&gt;函数重载的目的&lt;/h2&gt;&lt;p&gt;动态语言中，有鸭子类型，如果走起路来像鸭子，叫起来也像鸭子，那么它就是鸭子。一个对象的特征不是由它的类型决定，而是通过对象中的方法决定，所以函数重载在动态语言中就显得没有意义了，因为函数可以通过鸭子类型来处理不同类型的对象，鸭子类型也是多态性的一种表现。&lt;/p&gt;
&lt;p&gt;在Python中实现函数重载：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; io &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; StringIO&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Writer&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;    @staticmethod&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(output, content)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;# output对象只要实现了write方法就行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        output.write(content)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# stringIO类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;output = StringIO()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Writer.write(output, &lt;span class=&quot;string&quot;&gt;&#39;hello world&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# file 类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;output = open(&lt;span class=&quot;string&quot;&gt;&#39;out.txt&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;w&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Writer.write(output, &lt;span class=&quot;string&quot;&gt;&#39;hello world&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
      <category term="Python3 重载" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/Python3-%E9%87%8D%E8%BD%BD/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Python3 子类的查看与类的对象判断</title>
    <link href="http://yoursite.com/2018/03/03/Python3-%E5%AD%90%E7%B1%BB%E7%9A%84%E6%9F%A5%E7%9C%8B%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%88%A4%E6%96%AD/"/>
    <id>http://yoursite.com/2018/03/03/Python3-子类的查看与类的对象判断/</id>
    <published>2018-03-02T18:24:21.000Z</published>
    <updated>2018-03-03T02:39:26.058Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>如果想要查看一个类是不是另一个类的子类，可以使用內建的 <code>issubclass</code> 函数或者使用它的特殊特性<code>__base__</code>；</p></li><li><p>如果想要检查一个对象是不是一个类的实例，可以使用內建的 <code>isinstance</code> 函数或者使用它的特殊特性<code>__class__</code>;</p><a id="more"></a></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-  </span></span><br><span class="line">__metaclass__ = type <span class="comment">#确定使新式类  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">father</span><span class="params">()</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        print(<span class="string">"father()已经创建"</span>)  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">son</span><span class="params">(father)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        print(<span class="string">"son()已经创建"</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment">#下面测试issubclass()函数  </span></span><br><span class="line">print(issubclass(father,son))  <span class="comment"># output: False</span></span><br><span class="line">print(issubclass(son,father))  <span class="comment"># output: True</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#下面使用__bases__  </span></span><br><span class="line">print(<span class="string">"father.__bases__:"</span>,father.__bases__)  <span class="comment"># output: father.__bases__: (&lt;class 'object'&gt;,)  </span></span><br><span class="line">print(<span class="string">"son.__bases__:"</span>,son.__bases__)        <span class="comment"># output: son.__bases__: (&lt;class '__main__.father'&gt;,)  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#下面测试isinstance()函数  </span></span><br><span class="line">s = son()  </span><br><span class="line">print(isinstance(s,son))    <span class="comment"># output: True</span></span><br><span class="line">print(isinstance(s,father)) <span class="comment"># output: True</span></span><br><span class="line">print(isinstance(s,str))    <span class="comment"># output: False</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#下面使用__class__  </span></span><br><span class="line">print(<span class="string">"s.__class__:"</span>,s.__class__) <span class="comment"># output: s.__class__: &lt;class '__main__.son'&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果想要查看一个类是不是另一个类的子类，可以使用內建的 &lt;code&gt;issubclass&lt;/code&gt; 函数或者使用它的特殊特性&lt;code&gt;__base__&lt;/code&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果想要检查一个对象是不是一个类的实例，可以使用內建的 &lt;code&gt;isinstance&lt;/code&gt; 函数或者使用它的特殊特性&lt;code&gt;__class__&lt;/code&gt;;&lt;/p&gt;
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Python3 鸭子类型</title>
    <link href="http://yoursite.com/2018/03/03/Python3-%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/03/03/Python3-鸭子类型/</id>
    <published>2018-03-02T17:52:21.000Z</published>
    <updated>2018-03-03T05:40:54.624Z</updated>
    
    <content type="html"><![CDATA[<h2 id="来源和解释"><a href="#来源和解释" class="headerlink" title="来源和解释"></a>来源和解释</h2><p>Duck typing 这个概念来源于美国印第安纳州的诗人詹姆斯·惠特科姆·莱利（James Whitcomb Riley,1849-1916）的诗句：</p><blockquote><p>“ When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.”</p></blockquote><p>中文：</p><blockquote><p>“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”</p></blockquote><p>“鸭子类型”的语言是这么推断的：一只鸟走起来像鸭子、游起泳来像鸭子、叫起来也像鸭子，那它就可以被当做鸭子。也就是说，它不关注对象的类型，而是关注对象具有的行为(方法)。<br><a id="more"></a></p><p>鸭子类型是程序设计中的一种类型推断风格，这种风格适用于动态语言(比如PHP、Python、Ruby、Typescript、Perl、Objective-C、Lua、Julia、JavaScript、Java、Groovy、C#等)和某些静态语言(比如Golang,一般来说，静态类型语言在编译时便已确定了变量的类型，但是Golang的实现是：在编译时推断变量的类型)，支持”鸭子类型”的语言的解释器/编译器将会在解析(Parse)或编译时，推断对象的类型。</p><p><code>在鸭子类型中，关注的不是对象的类型本身，而是它是如何使用的。</code> 例如，在不使用鸭子类型的语言中，我们可以编写一个函数，它接受一个类型为鸭的对象，并调用它的走和叫方法。在使用鸭子类型的语言中，这样的一个函数可以接受一个任意类型的对象，并调用它的走和叫方法。如果这些需要被调用的方法不存在，那么将引发一个运行时错误。任何拥有这样的正确的走和叫方法的对象都可被函数接受的这种行为引出了以上表述，这种决定类型的方式因此得名。</p><p><code>鸭子类型通常得益于不测试方法和函数中参数的类型，而是依赖文档、清晰的代码和测试来确保正确使用。</code>从静态类型语言转向动态类型语言的用户通常试图添加一些静态的（在运行之前的）类型检查，从而影响了鸭子类型的益处和可伸缩性，并约束了语言的动态特性。</p><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><p>“鸭子类型”没有任何静态检查，如类型检查、属性检查、方法签名检查等。</p><p>“鸭子类型”语言的程序可能会在运行时因为不具备某种特定的方法而抛出异常：如果一只小狗(对象)想加入合唱团(以对象会不会嘎嘎嘎叫的方法为检验标准)，也学鸭子那么嘎嘎嘎叫，好吧，它加入了，可是加入之后，却不会像鸭子那样走路，那么，迟早要出问题的。</p><p>再举个例子：一只小老鼠被猫盯上了，情急之下，它学了狗叫，猫撤了之后，小老鼠的妈妈不无感叹的对它说：看吧，我让你学的这门儿外语多么重要啊。这虽然是个段子，但是，由于猫在思考时，使用了 “鸭子测试”，它以为会叫的就是狗，会对自己产生威胁，所以撤退了，也正是因为这个错误的判断，它误失了一次进食机会。</p><h2 id="静态类型语言和动态类型语言的区别"><a href="#静态类型语言和动态类型语言的区别" class="headerlink" title="静态类型语言和动态类型语言的区别"></a>静态类型语言和动态类型语言的区别</h2><p>静态类型语言在编译时便已确定变量的类型，而动态类型语言的变量类型要到程序运行的时候，待变量被赋予某个值之后，才会具有某种类型。  </p><p><code>静态类型语言的优点</code>首先是在编译时就能发现类型不匹配的错误，编辑器可以帮助我们提前避免程序在运行期间有可能发生的一些错误。其次，如果在程序中明确地规定了数据类型，编译器还可以针对这些信息对程序进行一些优化工作，提高程序执行速度。  </p><p><code>静态类型语言的缺点</code>首先是迫使程序员依照强契约来编写程序，为每个变量规定数据类型，归根结底只是辅助我们编写可靠性高程序的一种手段，而不是编写程序的目的，毕竟大部分人编写程序的目的是为了完成需求交付生产。其次，类型的声明也会增加更多的代码，在程序编写过程中，这些细节会让程序员的精力从思考业务逻辑上分散开来。  </p><p><code>动态类型语言的优点</code>是编写的代码数量更少，看起来也更加简洁，程序员可以把精力更多地放在业务逻辑上面。虽然不区分类型在某些情况下会让程序变得难以理解，但整体而言，代码量越少，越专注于逻辑表达，对阅读程序是越有帮助的。<br><code>动态类型语言的缺点</code>是无法保证变量的类型，从而在程序的运行期有可能发生跟类型相关的错误。</p><p><strong>动态类型语言对变量类型的宽容给实际编码带来了很大的灵活性。由于无需进行类型检测，我们可以尝试调用任何对象的任意方法，而无需去考虑它原本是否被设计为拥有该方法。</strong></p><h2 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a>面向接口编程</h2><p>动态类型语言的面向对象设计中，鸭子类型的概念至关重要。利用鸭子类型的思想，我们不必借助<code>超类型</code>的帮助，就能轻松地在动态类型语言中实现一个原则：“面向接口编程，而不是面向实现编程”。<br>例如,</p><ol><li>一个对象若有push和pop方法，并且这些方法提供了正确的实现，它就可以被当作栈来使用。</li><li>一个对象如果有length属性，也可以依照下标来存取属性（最好还要拥有slice和splice等方法），这个对象就可以被当作数组来使用。</li><li>比如在python中，有很多file-like的东西，比如StringIO,GzipFile,socket。它们有很多相同的方法，我们把它们当作文件使用。</li><li>又比如list.extend()方法中,我们并不关心它的参数是不是list,只要它是可迭代的,所以它的参数可以是list/tuple/dict/字符串/生成器等.</li></ol><p>鸭子类型在动态语言中经常使用，非常灵活，使得python不想java那样专门去弄一大堆的设计模式。</p><p>在静态类型语言中，要实现“面向接口编程”并不是一件容易的事情，往往要通过抽象类或者接口等将对象进行<code>向上转型</code>。当对象的真正类型被隐藏在它的超类型身后，这些对象才能在<code>类型检查系统</code>的“监视”之下互相被替换使用。只有当对象能够被互相替换使用，才能体现出对象多态性的价值。</p><h2 id="Python中的多态"><a href="#Python中的多态" class="headerlink" title="Python中的多态"></a>Python中的多态</h2><p><strong>Python中的鸭子类型允许我们使用任何提供所需方法的对象，而不需要迫使它成为一个子类。</strong><br>由于python属于动态语言，当你定义了一个基类和基类中的方法，并编写几个继承该基类的子类时，由于python在定义变量时不指定变量的类型，而是由解释器根据变量内容推断变量类型的（也就是说变量的类型取决于所关联的对象），这就使得python的多态不像是c++或java中那样—定义一个基类类型变量而隐藏了具体子类的细节。</p><p>请看下面的例子和说明：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AudioFile</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filename)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> filename.endswith(self.ext):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Invalid file format"</span>)</span><br><span class="line">        self.filename = filename</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MP3File</span><span class="params">(AudioFile)</span>:</span></span><br><span class="line">    ext = <span class="string">"mp3"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">play</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Playing &#123;&#125; as mp3"</span>.format(self.filename))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WavFile</span><span class="params">(AudioFile)</span>:</span></span><br><span class="line">    ext = <span class="string">"wav"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">play</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Playing &#123;&#125; as wav"</span>.format(self.filename))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OggFile</span><span class="params">(AudioFile)</span>:</span></span><br><span class="line">    ext = <span class="string">"ogg"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">play</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Playing &#123;&#125; as ogg"</span>.format(self.filename))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlacFile</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Though FlacFile class doesn't inherit AudioFile class,</span></span><br><span class="line"><span class="string">    it also has the same interface as three subclass of AudioFile.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    It is called duck typing.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filename)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> filename.endswith(<span class="string">".flac"</span>):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Invalid file format"</span>)</span><br><span class="line">        self.filename = filename</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">play</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Playing &#123;&#125; as flac"</span>.format(self.filename))</span><br></pre></td></tr></table></figure></p><blockquote><p>Though FlacFile class doesn’t inherit AudioFile class,<br>it also has the same interface as three subclass of AudioFile.<br>It is called duck typing.</p></blockquote><p>上面的代码中，<code>MP3File</code>、<code>WavFile</code>、<code>OggFile</code>三个类型继承了<code>AudioFile</code>这一积累，而<code>FlacFile</code>没有扩展<code>AudioFile</code>，但是可以在python中使用完全相同的接口与之交互。  </p><p>因为任何提供正确接口的对象都可以在python中交替使用，它减少了多态的一般<code>超类</code>的需求。继承仍然可以用来共享代码，但是如果所有被共享的都是公共接口，鸭子类型就是所有所需的。这减少了继承的需要，同时也减少了多重继承的需要；通常，当多重继承似乎是一个有效方案的时候，我们只需要使用鸭子类型去模拟多个超类之一（定义和那个超类一样的接口和实现）就可以了。</p><blockquote><p>作者：JasonDing<br>链接：<a href="https://www.jianshu.com/p/650485b78d11" target="_blank" rel="noopener">https://www.jianshu.com/p/650485b78d11</a><br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://baike.baidu.com/item/鸭子类型/10845665?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/鸭子类型/10845665?fr=aladdin</a></li><li><a href="https://www.jianshu.com/p/650485b78d11" target="_blank" rel="noopener">https://www.jianshu.com/p/650485b78d11</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;来源和解释&quot;&gt;&lt;a href=&quot;#来源和解释&quot; class=&quot;headerlink&quot; title=&quot;来源和解释&quot;&gt;&lt;/a&gt;来源和解释&lt;/h2&gt;&lt;p&gt;Duck typing 这个概念来源于美国印第安纳州的诗人詹姆斯·惠特科姆·莱利（James Whitcomb Riley,1849-1916）的诗句：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“ When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;中文：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“鸭子类型”的语言是这么推断的：一只鸟走起来像鸭子、游起泳来像鸭子、叫起来也像鸭子，那它就可以被当做鸭子。也就是说，它不关注对象的类型，而是关注对象具有的行为(方法)。&lt;br&gt;
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
      <category term="Python3 鸭子类型" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/Python3-%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>python3 如何用一个表达式合并两个字典</title>
    <link href="http://yoursite.com/2018/03/03/python3-%E5%A6%82%E4%BD%95%E7%94%A8%E4%B8%80%E4%B8%AA%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E5%AD%97%E5%85%B8/"/>
    <id>http://yoursite.com/2018/03/03/python3-如何用一个表达式合并两个字典/</id>
    <published>2018-03-02T17:00:28.000Z</published>
    <updated>2018-03-02T17:11:37.046Z</updated>
    
    <content type="html"><![CDATA[<p>有两个Python字典,写一个表达式来返回两个字典的合并。<code>update()</code>方法返回的是空值而不是返回合并后的对象.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = &#123;<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = &#123;<span class="string">'b'</span>:<span class="number">10</span>, <span class="string">'c'</span>: <span class="number">11</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z = x.update(y)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> z</span><br><span class="line"><span class="keyword">None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">10</span>, <span class="string">'c'</span>: <span class="number">11</span>&#125;</span><br></pre></td></tr></table></figure></p><p>如何才能让值保存在z而不是x?<br><a id="more"></a></p><p>对于python2可以用下面的方法:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z = dict(x.items() + y.items())</span><br></pre></td></tr></table></figure></p><p>最后就是你想要的最终结果保存在字典z中,而键<code>b</code>的值会被第二个字典的值覆盖.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = &#123;<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = &#123;<span class="string">'b'</span>:<span class="number">10</span>, <span class="string">'c'</span>: <span class="number">11</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z = dict(x.items() + y.items())</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z</span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'c'</span>: <span class="number">11</span>, <span class="string">'b'</span>: <span class="number">10</span>&#125;</span><br></pre></td></tr></table></figure></p><p>对于Python3：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>z = dict(list(x.items()) + list(y.items()))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z</span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'c'</span>: <span class="number">11</span>, <span class="string">'b'</span>: <span class="number">10</span>&#125;</span><br></pre></td></tr></table></figure></p><p>还可以这样:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">z = x.copy()</span><br><span class="line">z.update(y)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有两个Python字典,写一个表达式来返回两个字典的合并。&lt;code&gt;update()&lt;/code&gt;方法返回的是空值而不是返回合并后的对象.&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;x = &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;b&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;y = &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;b&#39;&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;c&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;z = x.update(y)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; z&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;b&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;c&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如何才能让值保存在z而不是x?&lt;br&gt;
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
      <category term="Python3 数据结构" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/Python3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>python3 可迭代对象、迭代器和生成器</title>
    <link href="http://yoursite.com/2018/03/01/python3-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>http://yoursite.com/2018/03/01/python3-可迭代对象、迭代器和生成器/</id>
    <published>2018-03-01T12:17:53.000Z</published>
    <updated>2018-03-02T04:55:21.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>迭代是数据处理的基石。扫描内存中放不下数据集时，我们要找到一种惰性获取数据项的方式，即按需一次获取一个数据项，这就是迭代器模式（iterator pattern）。所有的<code>生成器</code>都是<code>迭代器</code>，因为生成器完全实现了迭代器接口。在python社区中，大多数时候都把<code>迭代器</code>和<code>生成器</code>视作同一概念。</p><p>所有python程序员都知道，序列可迭代，下面说明具体原因。<br><a id="more"></a></p><h2 id="序列可迭代的原因：iter函数"><a href="#序列可迭代的原因：iter函数" class="headerlink" title="序列可迭代的原因：iter函数"></a>序列可迭代的原因：iter函数</h2><p>解释器需要迭代对象x时，会自动调用<code>iter(x)</code>。<br>内置的iter函数有以下作用。</p><ol><li>检查对象是否实现了<code>__iter__</code>方法，如果实现了就调用它，获得一个迭代器。</li><li>如果没有实现<code>__iter__</code>方法，但是实现了<code>__getitem__</code>方法，python会创建一个迭代器，尝试按顺序（从索引0开始）获取元素。</li><li>如果尝试失败，python会抛出<code>TypeError</code>异常，通常会提示”C object is not iterable”,其中C是目标对象所属的类。</li></ol><p>任何Python序列都可迭代的原因是它们实现了<code>__getitem__</code>方法。其实标准的序列也都实现了<code>__iter__</code>方法。之所以对<code>__getitem__</code>方法做特殊处理是为了向后兼容。</p><p>从Python3.4开始，检查x能否迭代，最准确的方法是调用iter(x)函数，如果不可迭代，再处理TypeError异常。这比使用isinstance(x, abc.Iterable)更准确，因为iter(x)函数会考虑到遗留的<code>__getitem__</code>方法，而abc.Iterable类则不考虑。</p><h2 id="可迭代的对象与迭代器的对比"><a href="#可迭代的对象与迭代器的对比" class="headerlink" title="可迭代的对象与迭代器的对比"></a>可迭代的对象与迭代器的对比</h2><h3 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h3><p><strong>使用iter内置函数可以获取迭代器的对象。</strong> 如果实现了能返回迭代器的<code>__iter__</code>方法，那么对象就是可迭代的。序列都可以迭代；实现了<code>__getitem__</code>方法，而且七参数是从零开始的索引，这种对象也是可迭代的。</p><p>我们要明确可迭代对象和迭代器之间的关系：<strong>Python从可迭代的对象中获取迭代器</strong></p><p>标准的迭代器接口有两个方法，即：</p><ol><li><code>__next__</code>:返回下一个可用元素，如果没有元素，抛出<code>StopIteration</code>异常</li><li><code>__iter__</code>:返回self,以便在应该使用可迭代对象的地方使用迭代器，比如for循环中。</li></ol><p>因为<code>迭代器</code>只需<code>__next__</code>和<code>__iter__</code>两个方法，所以除了调用next()方法，以及捕获<code>StopIteration</code>异常之外，没有办法检查是否还有遗留的元素。此外，也没有办法还原迭代器。如果想再次迭代，那就要调用iter(…)，传入之前构建迭代器的可迭代对象。</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器是这样的对象：实现了无参数的<code>__next__</code>方法，返回序列中的下一个元素；如果没有元素了，那么抛出<code>StopIteration</code>异常。Python迭代器还实现了<code>__iter__</code>方法，因此迭代器也可以迭代。</p><p>构建<code>可迭代对象</code>和<code>迭代器</code>时经常会出现错误，原因是混淆了两者。要知道，<code>可迭代的对象</code>有个<code>__iter__</code>方法，每次都实例化一个新的迭代器；而<code>迭代器</code>要实现<code>__next__</code>方法，返回单个元素，此外还要实现<code>__iter__</code>方法，返回迭代器本身。因此，<code>迭代器</code>可以迭代，但是<code>可迭代的对象</code>不是迭代器。</p><p>可迭代的对象一定不是自身的迭代器。也就是说，可迭代的对象必须实现<code>__iter__</code>方法，但不能实现<code>__next__</code>方法。另一方面，迭代器应该一直可以迭代，迭代器的<code>__iter__</code>方法应该返回自身。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="string">'__iter__'</span> <span class="keyword">in</span> dir(a)            <span class="comment"># True</span></span><br><span class="line"><span class="string">'__iter__'</span> <span class="keyword">in</span> dir(iter(a))      <span class="comment"># True</span></span><br></pre></td></tr></table></figure><h2 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h2><p>只要Python函数的定义体中有yield关键字，该函数就是生成器函数。调用生成器函数时，会返回一个生成器对象。也就是说，生成器函数是生成器工厂。</p><p>普通的函数与生成器函数在句法上的唯一区别是，在后者的定义体中有<code>yield</code>关键字。有些人认为定义生成器函数应该使用一个新的关键字，例如gen，而不是def，但是Guido不同意。</p><h3 id="生成器函数工作原理"><a href="#生成器函数工作原理" class="headerlink" title="生成器函数工作原理"></a>生成器函数工作原理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_123</span><span class="params">()</span>:</span>  <span class="comment"># 只要Python代码中包含yield，该函数就是生成器函数</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>    <span class="comment">#生成器函数的定义体中通常都有循环，不过这不是必要条件；此处重复使用了3次yield</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(gen_123)    <span class="comment"># 可以看出gen_123是函数对象</span></span><br><span class="line">    <span class="comment"># &lt;function gen_123 at 0x10be199d8&gt;</span></span><br><span class="line">    print(gen_123())  <span class="comment"># 函数调用时返回的是一个生成器对象</span></span><br><span class="line">    <span class="comment"># &lt;generator object gen_123 at 0x10be31ca8&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> gen_123(): <span class="comment"># 生成器是迭代器，会生成传给yield关键字的表达式的值</span></span><br><span class="line">        print(i)    </span><br><span class="line">        <span class="comment"># 1</span></span><br><span class="line">        <span class="comment"># 2</span></span><br><span class="line">        <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line">    g = gen_123() <span class="comment"># 为了仔细检查，把生成器对象赋值给g</span></span><br><span class="line">    print(next(g))  <span class="comment"># 1</span></span><br><span class="line">    print(next(g))  <span class="comment"># 2</span></span><br><span class="line">    print(next(g))  <span class="comment"># 3</span></span><br><span class="line">    print(next(g))   <span class="comment"># 生成器函数的定义体执行完毕后，生成器对象会抛出异常。</span></span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#   File "test.py", line 17, in &lt;module&gt;</span></span><br><span class="line"><span class="comment">#     print(next(g))</span></span><br><span class="line"><span class="comment"># StopIteration</span></span><br></pre></td></tr></table></figure><p>如上述代码所示：</p><ol><li>只要Python代码中包含yield，该函数就是生成器函数</li><li>生成器函数的定义体中通常都有循环，不过这不是必要条件；此处重复使用了3次yield</li><li>可以看出gen_123是函数对象</li><li>函数调用时返回的是一个生成器对象</li><li>生成器是迭代器，会<code>生成</code>传给yield关键字的表达式的值</li><li>为了仔细检查，把生成器对象赋值给g</li><li>因为g是迭代器，所以调用nest(g)会获取yield<code>生成</code>的下一个元素</li><li>生成器函数的定义体执行完毕后，生成器对象会抛出异常。</li></ol><p>使用准确的词语描述从生成器中获取结果的过程有助于理解生成器。注意，此处说的是<code>产出</code>或<code>生成</code>值。如果说生成器<code>返回</code>值，就会让人难以理解。</p><blockquote><p>函数返回值; 调用生成器函数返回生成器; 生成器<code>产出</code>或<code>生成</code>值。生成器不会以常规方式<code>返回</code>值;</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">66</span>]: <span class="function"><span class="keyword">def</span> <span class="title">gen_AB</span><span class="params">()</span>:</span>            <span class="comment"># 1</span></span><br><span class="line">    ...:     print(<span class="string">'start'</span>)       </span><br><span class="line">    ...:     <span class="keyword">yield</span> <span class="string">'A'</span>            <span class="comment"># 2</span></span><br><span class="line">    ...:     print(<span class="string">'continue'</span>)</span><br><span class="line">    ...:     <span class="keyword">yield</span> <span class="string">'B'</span>            <span class="comment"># 3</span></span><br><span class="line">    ...:     print(<span class="string">'end.'</span>)        <span class="comment"># 4</span></span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">67</span>]: <span class="keyword">for</span> c <span class="keyword">in</span> gen_AB():       <span class="comment"># 5</span></span><br><span class="line">    ...:     print(<span class="string">'--&gt;'</span>, c)      <span class="comment"># 6</span></span><br><span class="line">    ...:</span><br><span class="line">start       <span class="comment"># 7</span></span><br><span class="line">--&gt; A       # 8</span><br><span class="line"><span class="keyword">continue</span>    <span class="comment"># 9</span></span><br><span class="line">--&gt; B       # 10</span><br><span class="line">end.        <span class="comment"># 11</span></span><br></pre></td></tr></table></figure><ol><li>定义生成的器函数的方式与普通函数无异，只不过要使用yield关键字</li><li>在for循环中第一次隐式调用next()函数时（序号5），会打印’start’，然后停在第一个yield语句，生成值 ‘A’</li><li>在for循环第二次隐式调用next()函数时，会打印’continue’，然后停在第二个yield语句，生成值’B’</li><li>第三次调用 next()函数时，会打印’end.’，然后到达函数定义体末尾。导致生成器对象抛出StopIteration异常</li><li>迭代时, for 机制的作用与g = iter(gen_AB())一样，用于获取生成器对象，然后每次迭代时调用next(g)</li><li>循环打印 –&gt; 与 next(g)返回的值。但是，生成器函数中的print函数输出结果之后才会看到这个输出</li><li>‘start’是生成器函数定义体中print(‘start’)输出的记过</li><li>生成器函数定义体中的yield ‘A’ 语句会生成值 A，提供给for循环使用，而A会赋值给变量c，最终输出–&gt; A</li><li>第二次调用next(g)，继续迭代，生成器函数定义体中的代码由yield ‘A’前进到 yield ‘B’。文本continue是由生成器函数定义体中的第二个print函数输出的</li><li>生成器函数定义体中的yield ‘B’ 语句会生成值 B，提供给for循环使用，而B会赋值给变量c，最终输出–&gt; B</li><li>第三次调用next(g)，继续迭代，前进到生成器函数的结尾。文本 end. 是由生成器函数定义体中第三个print函数输出的。</li><li>到达生成器函数定义体结尾时，生成器对象抛出StopIteration异常。for 机制会捕捉异常，因此循环终止没有报错。</li></ol><h2 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h2><p>简单的生成器函数，可以替换成生成器表达式。生成器表达式可以理解为列表推导的惰性版本：不会迫切的构建列表，而是返回一个生成器，按需惰性生成元素。也就是说，如果列表推导是制造工厂的列表，那么生成器表达式就是制造生成器的工厂。如下演示了一个简单的生成器表达式，并且与列表推导做了对比。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">66</span>]: <span class="function"><span class="keyword">def</span> <span class="title">gen_AB</span><span class="params">()</span>:</span>            <span class="comment"># 1</span></span><br><span class="line">    ...:     print(<span class="string">'start'</span>)       </span><br><span class="line">    ...:     <span class="keyword">yield</span> <span class="string">'A'</span>            </span><br><span class="line">    ...:     print(<span class="string">'continue'</span>)</span><br><span class="line">    ...:     <span class="keyword">yield</span> <span class="string">'B'</span>            </span><br><span class="line">    ...:     print(<span class="string">'end.'</span>)        </span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">67</span>]: res1 = [x*<span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> gen_AB()]  <span class="comment"># 2</span></span><br><span class="line">start</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">end.</span><br><span class="line"></span><br><span class="line">In [<span class="number">68</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> res1():       <span class="comment"># 3</span></span><br><span class="line">    ...:     print(<span class="string">'--&gt;'</span>, i)      </span><br><span class="line">    ...:</span><br><span class="line">AAA</span><br><span class="line">BBB</span><br><span class="line"></span><br><span class="line">In [<span class="number">69</span>]: res2 = (x*<span class="number">3</span> <span class="keyword">for</span> x <span class="keyword">in</span> gen_AB())  <span class="comment"># 4</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">70</span>]: res2  <span class="comment"># 5</span></span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x106a07620</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">71</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> res2():       <span class="comment"># 6</span></span><br><span class="line">    ...:     print(<span class="string">'--&gt;'</span>, i)</span><br><span class="line">    ...:</span><br><span class="line">start   </span><br><span class="line">--&gt; A   </span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">--&gt; B       </span><br><span class="line">end.</span><br></pre></td></tr></table></figure><ol><li>创建gen_AB函数</li><li>列表推到迫切的迭代gen_AB()函数生成的生成器对象产出的元素：’A’和’B’。注意。下面输出的是start、continue、end.。</li><li>for循环迭代列表推导生成的res1列表</li><li>把生成器表达式返回的值赋值给res2。只需调用gen_AB()函数，虽然调用时会返回一个生成器，但是这里并不使用。</li><li>可以看出res2是一个生成器对象。</li><li>只有for循环迭代res2时，gen_AB函数的定义体才会真正执行。for循环每次迭代时会隐式调用next(res2)，前进到gen_AB函数中的下一个yield语句。注意，gen_AB函数的输出与for循环中print函数的输出夹杂在一起。</li></ol><p>生成器表达式会产出生成器，因此可以使用生成器表达式进一步减少代码量。生成器表达式是一种语法糖，完全可以替换成生成器函数，不过有时候使用生成器表达式更便利。</p><h2 id="何时使用生成器表达式"><a href="#何时使用生成器表达式" class="headerlink" title="何时使用生成器表达式"></a>何时使用生成器表达式</h2><p>生成器表达式是创建生成器的简洁句法，这样无需定义函数再调用。不过，生成器函数灵活的多，可以使用多个语句实现复杂的逻辑，也可以作为<code>协程</code>使用。遇到简单的情况时，可以使用生成器表达式，因为这样扫一眼就知道代码的作用。其实选择那种句法很容易判断：如果生成器表达式需要分行写，倾向于定义成生成器函数，以便提高可读性。此外生成器函数有名称，因此可以重用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;迭代是数据处理的基石。扫描内存中放不下数据集时，我们要找到一种惰性获取数据项的方式，即按需一次获取一个数据项，这就是迭代器模式（iterator pattern）。所有的&lt;code&gt;生成器&lt;/code&gt;都是&lt;code&gt;迭代器&lt;/code&gt;，因为生成器完全实现了迭代器接口。在python社区中，大多数时候都把&lt;code&gt;迭代器&lt;/code&gt;和&lt;code&gt;生成器&lt;/code&gt;视作同一概念。&lt;/p&gt;
&lt;p&gt;所有python程序员都知道，序列可迭代，下面说明具体原因。&lt;br&gt;
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
      <category term="Python3 迭代器和生成器" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/Python3-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>if __name__ == &#39;__main__&#39;: ?</title>
    <link href="http://yoursite.com/2018/03/01/if-name-main/"/>
    <id>http://yoursite.com/2018/03/01/if-name-main/</id>
    <published>2018-03-01T11:50:06.000Z</published>
    <updated>2018-03-01T12:13:18.245Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Every Python module has it’s <code>__name__</code> defined and if this is <code>&#39;__main__&#39;</code>, it implies that the module is being run standalone by the user and we can do corresponding appropriate actions.</p></blockquote><p>当Python解析器读取一个源文件时,它会执行所有的代码.在执行代码前,会定义一些特殊的变量.例如,如果解析器运行的模块(源文件)作为主程序,它将会把<code>__name__</code>变量设置成<code>&quot;__main__&quot;</code>.如果只是引入其他的模块,<code>__name__</code>变量将会设置成模块的名字.<br><a id="more"></a></p><p>这么做的原因是有时你想让你的模块既可以直接的执行,还可以被当做模块导入到其他模块中去.通过检查是不是主函数,可以让你的代码只在它作为主程序运行时执行,而当其他人调用你的模块中的函数的时候不必执行.</p><p>直接上一个栗子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Filename: using_name.py</span></span><br><span class="line"></span><br><span class="line">print(__name__)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">print(<span class="string">'This program is being run by itself'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">print(<span class="string">'I am being imported from another module'</span>)</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ python using_name.py</span><br><span class="line">__main__</span><br><span class="line">This program <span class="keyword">is</span> being run by itself</span><br><span class="line"></span><br><span class="line">$ python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> using_name</span><br><span class="line">using_name</span><br><span class="line">I am being imported <span class="keyword">from</span> another module</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Every Python module has it’s &lt;code&gt;__name__&lt;/code&gt; defined and if this is &lt;code&gt;&amp;#39;__main__&amp;#39;&lt;/code&gt;, it implies that the module is being run standalone by the user and we can do corresponding appropriate actions.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当Python解析器读取一个源文件时,它会执行所有的代码.在执行代码前,会定义一些特殊的变量.例如,如果解析器运行的模块(源文件)作为主程序,它将会把&lt;code&gt;__name__&lt;/code&gt;变量设置成&lt;code&gt;&amp;quot;__main__&amp;quot;&lt;/code&gt;.如果只是引入其他的模块,&lt;code&gt;__name__&lt;/code&gt;变量将会设置成模块的名字.&lt;br&gt;
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Python3 中的单下划线和双下划线</title>
    <link href="http://yoursite.com/2018/03/01/Python3-%E5%8D%95%E4%B8%8B%E5%88%92%E7%BA%BF%E5%92%8C%E5%8F%8C%E4%B8%8B%E5%88%92%E7%BA%BF/"/>
    <id>http://yoursite.com/2018/03/01/Python3-单下划线和双下划线/</id>
    <published>2018-03-01T10:01:50.000Z</published>
    <updated>2018-03-02T18:25:01.034Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单下划线"><a href="#单下划线" class="headerlink" title="单下划线"></a>单下划线</h3><h4 id="在解释器中"><a href="#在解释器中" class="headerlink" title="在解释器中"></a>在解释器中</h4><p>在交互解释器中，<code>_</code>符号还是指交互解释器中最后一次执行语句的返回结果。这种用法最初出现在CPython解释器中，其他解释器后来也都跟进了。</p><h4 id="作为名称使用"><a href="#作为名称使用" class="headerlink" title="作为名称使用"></a>作为名称使用</h4><p>这个跟上面有点类似。<code>_</code>用作被丢弃的名称。按照惯例，这样做可以让阅读你代码的人知道，这是个不会被使用的特定名称。举个例子，你可能无所谓一个循环计数的值：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">42</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">    do_something()</span><br></pre></td></tr></table></figure></p><a id="more"></a><h4 id="i18n"><a href="#i18n" class="headerlink" title="i18n"></a>i18n</h4><p><code>_</code>还可以被用作函数名。这种情况，单下划线经常被用作国际化和本地化字符串翻译查询的函数名。举个例子，在 <a href="https://docs.djangoproject.com/en/dev/topics/i18n/translation/" target="_blank" rel="noopener">Django documentation for translation</a> 中你可能会看到：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.utils.translation <span class="keyword">import</span> ugettext <span class="keyword">as</span> _</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span><span class="params">(request)</span>:</span></span><br><span class="line">    output = _(<span class="string">"Welcome to my site."</span>)</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(output)</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：第二种和第三种用法会引起冲突，所以在任意代码块中，如果使用了_作i18n翻译查询函数，就应该避免再用作被丢弃的变量名。</p><h4 id="单下划线前缀的名称"><a href="#单下划线前缀的名称" class="headerlink" title="单下划线前缀的名称"></a>单下划线前缀的名称</h4><p>首先是单下划线开头，这个被常用于模块中，在一个模块中以单下划线开头的变量和函数被默认当作内部函数,用来指定私有变量。如果使用 <code>from a_module import *</code> 导入时，这部分变量和函数不会被导入。<strong>不过值得注意的是</strong>，如果使用 <code>import a_module</code> 这样导入模块，仍然可以用 <code>a_module._some_var</code> 这样的形式访问到这样的对象。</p><p>另外单下划线开头还有一种一般不会用到的情况在于使用一个 C 编写的扩展库有时会用下划线开头命名，然后使用一个去掉下划线的 Python 模块进行包装。如 struct 这个模块实际上是 C 模块 <code>_struct</code> 的一个 Python 包装。</p><h4 id="单下划线后缀的名称"><a href="#单下划线后缀的名称" class="headerlink" title="单下划线后缀的名称"></a>单下划线后缀的名称</h4><p>在 Python 的官方推荐的代码样式中，还有一种单下划线结尾的样式，这在解析时并没有特别的含义，但通常用于和 Python 关键词区分开来，比如如果我们需要一个变量叫做 class，但 class 是 Python 的关键词，就可以以单下划线结尾写作 class_。</p><h3 id="双下划线"><a href="#双下划线" class="headerlink" title="双下划线"></a>双下划线</h3><p>双下划线开头的命名形式在 Python 的类成员中使用表示名字改编 (Name Mangling)，即如果有一 <code>Test 类</code>里有一成员 <code>__x</code>，那么 dir(Test) 时会看到 <code>_Test__x</code> 而非 <code>__x</code>。这是为了避免该成员的名称与子类中的名称冲突。<strong>但要注意这要求该名称末尾最多有一个下划线</strong> <a href="https://docs.python.org/3.4/tutorial/classes.html#tut-private" target="_blank" rel="noopener">python document</a>.</p><p>双下划线开头双下划线结尾的是一些 Python 的“魔术”对象，如类成员的 <code>__init__</code>、<code>__del__</code>、<code>__add__</code>、<code>__getitem__</code> 等，以及全局的 <code>__file__</code>、<code>__name__</code> 等。 Python <code>官方推荐永远不要</code>将这样的命名方式应用于自己的变量或函数，而是按照文档说明来使用。</p><h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>            self.__superprivate = <span class="string">"Hello"</span></span><br><span class="line"><span class="meta">... </span>            self._semiprivate = <span class="string">", world!"</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mc = MyClass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> mc.__superprivate</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: myClass instance has no attribute <span class="string">'__superprivate'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> mc._semiprivate</span><br><span class="line">, world!</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> mc.__dict__</span><br><span class="line">&#123;<span class="string">'_MyClass__superprivate'</span>: <span class="string">'Hello'</span>, <span class="string">'_semiprivate'</span>: <span class="string">', world!'</span>&#125;</span><br></pre></td></tr></table></figure><p><code>__foo__</code>:一种约定,Python内部的名字,用来区别其他用户自定义的命名,以防冲突，就是例如<code>__init__()</code>,<code>__del__()</code>,<code>__call__()</code>这些特殊方法</p><p><code>_foo</code>:一种约定,用来指定变量私有.程序员用来指定私有变量的一种方式.不能用from module import * 导入，其他方面和公有一样访问；</p><p><code>__foo</code>:这个有真正的意义:解析器用<code>_classname__foo</code>来代替这个名字,以区别和其他类相同的命名,它无法直接像公有成员一样随便访问,但是可以通过对象名 <code>_类名__xxx</code> 这样的方式可以访问.</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>详情见:</p><ol><li><p><a href="http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python" target="_blank" rel="noopener">http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python</a></p></li><li><p><a href="http://www.zhihu.com/question/19754941" target="_blank" rel="noopener">http://www.zhihu.com/question/19754941</a></p></li><li><p><a href="https://segmentfault.com/a/1190000002611411" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002611411</a></p></li><li><p><a href="https://docs.python.org/3.4/tutorial/classes.html#tut-private" target="_blank" rel="noopener">https://docs.python.org/3.4/tutorial/classes.html#tut-private</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;单下划线&quot;&gt;&lt;a href=&quot;#单下划线&quot; class=&quot;headerlink&quot; title=&quot;单下划线&quot;&gt;&lt;/a&gt;单下划线&lt;/h3&gt;&lt;h4 id=&quot;在解释器中&quot;&gt;&lt;a href=&quot;#在解释器中&quot; class=&quot;headerlink&quot; title=&quot;在解释器中&quot;&gt;&lt;/a&gt;在解释器中&lt;/h4&gt;&lt;p&gt;在交互解释器中，&lt;code&gt;_&lt;/code&gt;符号还是指交互解释器中最后一次执行语句的返回结果。这种用法最初出现在CPython解释器中，其他解释器后来也都跟进了。&lt;/p&gt;
&lt;h4 id=&quot;作为名称使用&quot;&gt;&lt;a href=&quot;#作为名称使用&quot; class=&quot;headerlink&quot; title=&quot;作为名称使用&quot;&gt;&lt;/a&gt;作为名称使用&lt;/h4&gt;&lt;p&gt;这个跟上面有点类似。&lt;code&gt;_&lt;/code&gt;用作被丢弃的名称。按照惯例，这样做可以让阅读你代码的人知道，这是个不会被使用的特定名称。举个例子，你可能无所谓一个循环计数的值：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;n = &lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; _ &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(n):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    do_something()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
      <category term="Python3 下划线" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/Python3-%E4%B8%8B%E5%88%92%E7%BA%BF/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Python3 自省</title>
    <link href="http://yoursite.com/2018/03/01/Python3-%E8%87%AA%E7%9C%81/"/>
    <id>http://yoursite.com/2018/03/01/Python3-自省/</id>
    <published>2018-03-01T08:19:37.000Z</published>
    <updated>2018-03-02T17:23:56.828Z</updated>
    
    <content type="html"><![CDATA[<p>自省是python彪悍的特性之一.</p><p>自省（introspection）是一种自我检查行为。在计算机编程中，自省是指这种能力：检查某些事物以确定它是什么、它知道什么以及它能做什么。自省向程序员提供了极大的灵活性和控制力.</p><a id="more"></a><p>自省就是面向对象的语言所写的程序在运行时,所能知道对象的类型.简单一句就是运行时能够获得对象的类型.比如type(),dir(),getattr(),hasattr(),isinstance().</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = &#123;<span class="string">'a'</span>:<span class="number">1</span>,<span class="string">'b'</span>:<span class="number">2</span>,<span class="string">'c'</span>:<span class="number">3</span>&#125;</span><br><span class="line">c = <span class="keyword">True</span></span><br><span class="line"><span class="keyword">print</span> type(a),type(b),type(c) <span class="comment"># &lt;type 'list'&gt; &lt;type 'dict'&gt; &lt;type 'bool'&gt;</span></span><br><span class="line"><span class="keyword">print</span> isinstance(a,list)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure><p>未完待续</p><p>参考：</p><ol><li><a href="http://python.jobbole.com/82110/" target="_blank" rel="noopener">http://python.jobbole.com/82110/</a></li><li><a href="http://blog.csdn.net/IAlexanderI/article/details/78768378" target="_blank" rel="noopener">http://blog.csdn.net/IAlexanderI/article/details/78768378</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自省是python彪悍的特性之一.&lt;/p&gt;
&lt;p&gt;自省（introspection）是一种自我检查行为。在计算机编程中，自省是指这种能力：检查某些事物以确定它是什么、它知道什么以及它能做什么。自省向程序员提供了极大的灵活性和控制力.&lt;/p&gt;
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
      <category term="Python3 自省" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/Python3-%E8%87%AA%E7%9C%81/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Python3 类变量和实例变量</title>
    <link href="http://yoursite.com/2018/03/01/Python3-%E7%B1%BB%E5%8F%98%E9%87%8F%E5%92%8C%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F/"/>
    <id>http://yoursite.com/2018/03/01/Python3-类变量和实例变量/</id>
    <published>2018-03-01T05:21:38.000Z</published>
    <updated>2018-03-01T08:05:39.909Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>首先来一张图<br><img src="http://upload-images.jianshu.io/upload_images/2952111-07f6d669392b20c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="classvariable.png"></p><h3 id="类变量和实例变量"><a href="#类变量和实例变量" class="headerlink" title="类变量和实例变量"></a>类变量和实例变量</h3><p>在Python Tutorial中对于类变量和实例变量是这样描述的：</p><blockquote><p>Generally speaking, instance variables are for data unique to each instance and class variables are for attributes and methods shared by all instances of the class:</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    kind = <span class="string">'canine'</span>         <span class="comment"># class variable shared by all instances</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name    <span class="comment"># instance variable unique to each instance</span></span><br></pre></td></tr></table></figure><p>类<code>Dog</code>中，类属性<code>kind</code>为所有实例所共享；实例属性<code>name</code>为每个<code>Dog</code>的实例独有。<br><a id="more"></a></p><h4 id="类变量："><a href="#类变量：" class="headerlink" title="类变量："></a>类变量：</h4><blockquote><p>​    是可在类的所有实例之间共享的值（也就是说，它们不是单独分配给每个实例的）。例如下例中，num_of_instance 就是类变量，用于跟踪存在着多少个Test 的实例。</p></blockquote><h4 id="实例变量："><a href="#实例变量：" class="headerlink" title="实例变量："></a>实例变量：</h4><blockquote><p>实例化之后，每个实例单独拥有的变量。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span><span class="params">(object)</span>:</span>  </span><br><span class="line">    num_of_instance = <span class="number">0</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span>  </span><br><span class="line">        self.name = name  </span><br><span class="line">        Test.num_of_instance += <span class="number">1</span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  </span><br><span class="line">    <span class="keyword">print</span> Test.num_of_instance   <span class="comment"># 0</span></span><br><span class="line">    t1 = Test(<span class="string">'jack'</span>)  </span><br><span class="line">    <span class="keyword">print</span> Test.num_of_instance   <span class="comment"># 1</span></span><br><span class="line">    t2 = Test(<span class="string">'lucy'</span>)  </span><br><span class="line">    <span class="keyword">print</span> t1.name , t1.num_of_instance  <span class="comment"># jack 2</span></span><br><span class="line">    <span class="keyword">print</span> t2.name , t2.num_of_instance  <span class="comment"># lucy 2</span></span><br></pre></td></tr></table></figure><blockquote><p>补充的例子</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    name=<span class="string">"aaa"</span></span><br><span class="line"></span><br><span class="line">p1=Person()</span><br><span class="line">p2=Person()</span><br><span class="line">p1.name=<span class="string">"bbb"</span></span><br><span class="line"><span class="keyword">print</span> p1.name  <span class="comment"># bbb</span></span><br><span class="line"><span class="keyword">print</span> p2.name  <span class="comment"># aaa</span></span><br><span class="line"><span class="keyword">print</span> Person.name  <span class="comment"># aaa</span></span><br></pre></td></tr></table></figure><p>这里<code>p1.name=&quot;bbb&quot;</code>是实例调用了类变量,属于函数传参的问题,<code>p1.name</code>一开始是指向的类变量<code>name=&quot;aaa&quot;</code>,但是在实例的作用域里把类变量的引用改变了,就变成了一个实例变量,self.name不再引用Person的类变量name了.</p><p>可以看看下面的例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    name=[]</span><br><span class="line"></span><br><span class="line">p1=Person()</span><br><span class="line">p2=Person()</span><br><span class="line">p1.name.append(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">print</span> p1.name  <span class="comment"># [1]</span></span><br><span class="line"><span class="keyword">print</span> p2.name  <span class="comment"># [1]</span></span><br><span class="line"><span class="keyword">print</span> Person.name  <span class="comment"># [1]</span></span><br></pre></td></tr></table></figure><h3 id="类对象和实例对象"><a href="#类对象和实例对象" class="headerlink" title="类对象和实例对象"></a>类对象和实例对象</h3><h4 id="类对象"><a href="#类对象" class="headerlink" title="类对象"></a>类对象</h4><p><code>Python</code>中一切皆对象；类定义完成后，会在当前作用域中定义一个以类名为名字，指向类对象的名字。如<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><p>会在当前作用域定义名字<code>Dog</code>，指向类对象<code>Dog</code>。</p><p><strong>类对象支持的操作</strong>：<br>总的来说，类对象仅支持两个操作：</p><ol><li>实例化；使用<code>instance_name = class_name()</code>的方式实例化，实例化操作创建该类的实例。</li><li>属性引用；使用<code>class_name.attr_name</code>的方式引用类属性。</li></ol><h4 id="实例对象"><a href="#实例对象" class="headerlink" title="实例对象"></a>实例对象</h4><p><strong>实例对象是类对象实例化的产物，实例对象仅支持一个操作</strong>:</p><ol><li>属性引用；与类对象属性引用的方式相同，使用<code>instance_name.attr_name</code>的方式。</li></ol><p>按照严格的面向对象思想，所有属性都应该是实例的，类属性不应该存在。那么在<code>Python</code>中，由于类属性绑定就不应该存在，类定义中就只剩下函数定义了。</p><p>在<a href="https://docs.python.org/3/tutorial/classes.html#class-definition-syntax" target="_blank" rel="noopener">Python tutorial</a>关于类定义也这么说：</p><blockquote><p>In practice, the statements inside a class definition will usually be function definitions, but other statements are allowed, and sometimes useful.</p></blockquote><p>实践中，类定义中的语句通常是函数定义，但是其他语句也是允许的，有时也是有用的。</p><p>这里说的其他语句，就是指类属性的绑定语句。</p><h3 id="属性绑定"><a href="#属性绑定" class="headerlink" title="属性绑定"></a>属性绑定</h3><p>在定义类时，通常我们说的定义属性，其实是分为两个方面的：</p><ol><li>类属性绑定</li><li>实例属性绑定</li></ol><p>用<strong>绑定</strong>这个词更加确切；不管是类对象还是实例对象，属性都是依托对象而存在的。</p><p>我们说的属性绑定，首先需要一个可变对象，才能执行绑定操作，使用</p><pre><code>objname.attr = attr_value</code></pre><p>的方式，为对象<code>objname</code>绑定属性<code>attr</code>。</p><p>这分两种情况：</p><ol><li>若属性<code>attr</code>已经存在，绑定操作会将属性名指向新的对象；</li><li>若不存在，则为该对象添加新的属性，后面就可以引用新增属性。</li></ol><h4 id="类属性绑定"><a href="#类属性绑定" class="headerlink" title="类属性绑定"></a>类属性绑定</h4><p><code>Python</code>作为动态语言，类对象和实例对象都可以在运行时绑定任意属性。因此，类属性的绑定发生在两个地方：</p><ol><li>类定义时；</li><li>运行时任意阶段。</li></ol><p>下面这个例子说明了类属性绑定发生的时期：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    kind = <span class="string">'canine'</span></span><br><span class="line"></span><br><span class="line">Dog.country = <span class="string">'China'</span></span><br><span class="line">print(Dog.kind, <span class="string">' - '</span>, Dog.country) <span class="comment"># output: canine - China</span></span><br><span class="line"><span class="keyword">del</span> Dog.kind</span><br><span class="line">print(Dog.kind, <span class="string">' - '</span>, Dog.country)</span><br><span class="line"><span class="comment"># AttributeError: type object 'Dog' has no attribute 'kind'</span></span><br></pre></td></tr></table></figure></p><p>在类定义中，类属性的绑定并没有使用<code>objname.attr = attr_value</code>的方式，这是一个特例，其实是等同于后面使用类名绑定属性的方式。<br>因为是动态语言，所以可以在运行时增加属性，删除属性。</p><h4 id="实例属性绑定"><a href="#实例属性绑定" class="headerlink" title="实例属性绑定"></a>实例属性绑定</h4><p>与类属性绑定相同，实例属性绑定也发生在两个地方：</p><ol><li>类定义时；</li><li>运行时任意阶段。</li></ol><p>示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">dog = Dog(<span class="string">'Lily'</span>, <span class="number">3</span>)</span><br><span class="line">dog.fur_color = <span class="string">'red'</span></span><br><span class="line">print(<span class="string">'%s is %s years old, it has %s fur'</span> % (dog.name, dog.age, dog.fur_color))</span><br><span class="line"><span class="comment"># Output: Lily is 3 years old, it has red fur</span></span><br></pre></td></tr></table></figure></p><p><code>Python</code>类实例有两个特殊之处：</p><ol><li><code>__init__</code>在实例化时执行</li><li><code>Python</code>实例调用方法时，会将实例对象作为第一个参数传递</li></ol><p>因此，<code>__init__</code>方法中的<code>self</code>就是实例对象本身，这里是<code>dog</code>，语句<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.name = name</span><br><span class="line">self.age = age</span><br></pre></td></tr></table></figure></p><p>以及后面的语句<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dog.fur_color = <span class="string">'red'</span></span><br></pre></td></tr></table></figure></p><p>为实例<code>dog</code>增加三个属性<code>name</code>, <code>age</code>, <code>fur_color</code>。</p><h3 id="属性引用"><a href="#属性引用" class="headerlink" title="属性引用"></a>属性引用</h3><h4 id="类属属性引用"><a href="#类属属性引用" class="headerlink" title="类属属性引用"></a>类属属性引用</h4><p>类属性的引用，肯定是需要类对象的，属性分为两种：</p><ol><li>数据属性</li><li>函数属性</li></ol><p>数据属性引用很简单，示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    kind = <span class="string">'canine'</span></span><br><span class="line"></span><br><span class="line">Dog.country = <span class="string">'China'</span></span><br><span class="line">print(Dog.kind, <span class="string">' - '</span>, Dog.country) <span class="comment"># output: canine - China</span></span><br></pre></td></tr></table></figure></p><p>通常很少有引用类函数属性的需求，示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    kind = <span class="string">'canine'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tell_kind</span><span class="params">()</span>:</span></span><br><span class="line">        print(Dog.kind)</span><br><span class="line"></span><br><span class="line">Dog.tell_kind() <span class="comment"># Output: canine</span></span><br></pre></td></tr></table></figure></p><p>函数<code>tell_kind</code>在引用<code>kind</code>需要使用<code>Dog.kind</code>而不是直接使用<code>kind</code>，涉及到作用域，这一点在我的另一篇文章中有介绍：<a href="http://www.cnblogs.com/crazyrunning/p/6914080.html" target="_blank" rel="noopener">Python进阶 - 命名空间与作用域</a></p><h4 id="实例属性引用"><a href="#实例属性引用" class="headerlink" title="实例属性引用"></a>实例属性引用</h4><p>使用实例对象引用属性稍微复杂一些，因为实例对象可引用类属性以及实例属性。但是实例对象引用属性时遵循以下规则：</p><ol><li>总是先到实例对象中查找属性，再到类属性中查找属性；</li><li>属性绑定语句总是为实例对象创建新属性，属性存在时，更新属性指向的对象。</li></ol><h5 id="数据属性引用"><a href="#数据属性引用" class="headerlink" title="数据属性引用"></a>数据属性引用</h5><p>示例1：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line"></span><br><span class="line">    kind = <span class="string">'canine'</span></span><br><span class="line">    country = <span class="string">'China'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, country)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.country = country</span><br><span class="line"></span><br><span class="line">dog = Dog(<span class="string">'Lily'</span>, <span class="number">3</span>, <span class="string">'Britain'</span>)</span><br><span class="line">print(dog.name, dog.age, dog.kind, dog.country)</span><br><span class="line"><span class="comment"># output: Lily 3 canine Britain</span></span><br></pre></td></tr></table></figure></p><p>类对象<code>Dog</code>与实例对象<code>dog</code>均有属性<code>country</code>，按照规则，<code>dog.country</code>会引用到实例对象的属性；但实例对象<code>dog</code>没有属性<code>kind</code>，按照规则会引用类对象的属性。</p><p>示例2：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line"></span><br><span class="line">    kind = <span class="string">'canine'</span></span><br><span class="line">    country = <span class="string">'China'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, country)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.country = country</span><br><span class="line"></span><br><span class="line">dog = Dog(<span class="string">'Lily'</span>, <span class="number">3</span>, <span class="string">'Britain'</span>)</span><br><span class="line">print(dog.name, dog.age, dog.kind, dog.country) <span class="comment"># Lily 3 canine Britain</span></span><br><span class="line">print(dog.__dict__) <span class="comment"># &#123;'name': 'Lily', 'age': 3, 'country': 'Britain'&#125;</span></span><br><span class="line"></span><br><span class="line">dog.kind = <span class="string">'feline'</span></span><br><span class="line">print(dog.name, dog.age, dog.kind, dog.country) <span class="comment"># Lily 3 feline Britain</span></span><br><span class="line">print(dog.__dict__)  <span class="comment"># &#123;'name': 'Lily', 'age': 3, 'country': 'Britain', 'kind': 'feline'&#125;</span></span><br><span class="line">print(Dog.kind) <span class="comment"># canine 没有改变类属性的指向</span></span><br></pre></td></tr></table></figure></p><p>示例3，可变类属性引用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line"></span><br><span class="line">    tricks = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_trick</span><span class="params">(self, trick)</span>:</span></span><br><span class="line">        <span class="comment"># self.tricks.append(trick)</span></span><br><span class="line">        Dog.tricks.append(trick)</span><br><span class="line"></span><br><span class="line">d = Dog(<span class="string">'Fido'</span>)</span><br><span class="line">e = Dog(<span class="string">'Buddy'</span>)</span><br><span class="line">d.add_trick(<span class="string">'roll over'</span>)</span><br><span class="line">e.add_trick(<span class="string">'play dead'</span>)</span><br><span class="line">print(d.tricks) <span class="comment"># ['roll over', 'play dead']</span></span><br></pre></td></tr></table></figure><p>语句<code>self.tricks.append(trick)</code>并不是属性绑定语句，因此还是在类属性上修改可变对象。</p><h5 id="方法属性引用"><a href="#方法属性引用" class="headerlink" title="方法属性引用"></a>方法属性引用</h5><p>与数据成员不同，类函数属性在实例对象中会变成方法属性。先看一个示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodTest</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_test</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'in class'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer_test</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'out of class'</span>)</span><br><span class="line"></span><br><span class="line">mt = MethodTest()</span><br><span class="line">mt.outer_test = outer_test</span><br><span class="line"></span><br><span class="line">print(type(MethodTest.inner_test))  <span class="comment"># &lt;class 'function'&gt; 类函数</span></span><br><span class="line">print(type(mt.inner_test))          <span class="comment">#&lt;class 'method'&gt; 类方法</span></span><br><span class="line">print(type(mt.outer_test))          <span class="comment">#&lt;class 'function'&gt; 类函数</span></span><br></pre></td></tr></table></figure><p>可以看到，类函数属性在实例对象中变成了方法属性，但是并不是实例对象中所有的函数都是方法。</p><p>Python tutorial中这样介绍方法对象：</p><blockquote><p>When an instance attribute is referenced that isn’t a data attribute, its class is searched. If the name denotes a valid class attribute that is a function object, a method object is created by packing (pointers to) the instance object and the function object just found together in an abstract object: this is the method object. When the method object is called with an argument list, a new argument list is constructed from the instance object and the argument list, and the function object is called with this new argument list.</p></blockquote><p>引用非数据属性的实例属性时，会搜索它对应的类。如果名字是一个有效的函数对象，Python会将实例对象连同函数对象打包到一个抽象的对象中并且依据这个对象创建方法对象：这就是被调用的方法对象。当使用参数列表调用方法对象时，会使用实例对象以及原有参数列表构建新的参数列表，并且使用新的参数列表调用函数对象。</p><p>那么，实例对象只有在引用方法属性时，才会将自身作为第一个参数传递；调用实例对象的普通函数，则不会。<br>所以可以使用如下方式直接调用方法与函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mt.inner_test()</span><br><span class="line">mt.outer_test()</span><br></pre></td></tr></table></figure><p>除了方法与函数的区别，其引用与数据属性都是一样的</p><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>虽然<code>Python</code>作为动态语言，支持在运行时绑定属性，但是从面向对象的角度来看，还是在定义类的时候将属性确定下来。</p><p>参考:</p><ol><li><a href="http://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block" target="_blank" rel="noopener">http://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block</a></li><li><a href="https://www.cnblogs.com/crazyrunning/p/6945183.html" target="_blank" rel="noopener">https://www.cnblogs.com/crazyrunning/p/6945183.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;首先来一张图&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2952111-07f6d669392b20c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;classvariable.png&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;类变量和实例变量&quot;&gt;&lt;a href=&quot;#类变量和实例变量&quot; class=&quot;headerlink&quot; title=&quot;类变量和实例变量&quot;&gt;&lt;/a&gt;类变量和实例变量&lt;/h3&gt;&lt;p&gt;在Python Tutorial中对于类变量和实例变量是这样描述的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Generally speaking, instance variables are for data unique to each instance and class variables are for attributes and methods shared by all instances of the class:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Dog&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    kind = &lt;span class=&quot;string&quot;&gt;&#39;canine&#39;&lt;/span&gt;         &lt;span class=&quot;comment&quot;&gt;# class variable shared by all instances&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, name)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.name = name    &lt;span class=&quot;comment&quot;&gt;# instance variable unique to each instance&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;类&lt;code&gt;Dog&lt;/code&gt;中，类属性&lt;code&gt;kind&lt;/code&gt;为所有实例所共享；实例属性&lt;code&gt;name&lt;/code&gt;为每个&lt;code&gt;Dog&lt;/code&gt;的实例独有。&lt;br&gt;
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
      <category term="类变量 和 实例变量" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/%E7%B1%BB%E5%8F%98%E9%87%8F-%E5%92%8C-%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Python3 @staticmethod和@classmethod</title>
    <link href="http://yoursite.com/2018/03/01/Python3-staticmethod%E5%92%8C-classmethod/"/>
    <id>http://yoursite.com/2018/03/01/Python3-staticmethod和-classmethod/</id>
    <published>2018-02-28T18:01:19.000Z</published>
    <updated>2018-03-01T06:36:20.315Z</updated>
    
    <content type="html"><![CDATA[<p>Python其实有3个方法,即静态方法(staticmethod),类方法(classmethod)和实例方法,如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"executing foo(%s)"</span>%(x)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"executing foo(%s,%s)"</span>%(self,x)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">class_foo</span><span class="params">(cls,x)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"executing class_foo(%s,%s)"</span>%(cls,x)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static_foo</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"executing static_foo(%s)"</span>%x</span><br><span class="line"></span><br><span class="line">a=A()</span><br></pre></td></tr></table></figure><a id="more"></a><p>这里先理解下函数参数里面的self和cls。这个self和cls是对类或者实例的绑定,对于一般的函数来说我们可以这么调用<code>foo(x)</code>,这个函数就是最常用的,它的工作跟任何东西(类,实例)无关。<br>对于实例方法,我们知道在类里每次定义方法的时候都需要绑定这个实例,就是<code>foo(self, x)</code>,为什么要这么做呢?因为实例方法的调用离不开实例,我们需要把实例自己传给函数,调用的时候是这样的<code>a.foo(x)</code>(其实是<code>foo(a, x)</code>)。<br>类方法一样,只不过它传递的是<code>类</code>而不是实例,<code>A.class_foo(x)</code>。注意这里的self和cls可以替换别的参数,但是python的约定是这俩,还是不要改的好。</p><p>对于静态方法其实和普通的方法一样,不需要对谁进行绑定,唯一的区别是调用的时候需要使用<code>a.static_foo(x)</code>或者<code>A.static_foo(x)</code>来调用.</p><table><thead><tr><th style="text-align:left">\</th><th style="text-align:left">实例方法</th><th style="text-align:left">类方法</th><th style="text-align:left">静态方法</th></tr></thead><tbody><tr><td style="text-align:left">a = A()</td><td style="text-align:left">a.foo(x)</td><td style="text-align:left">a.class_foo(x)</td><td style="text-align:left">a.static_foo(x)</td></tr><tr><td style="text-align:left">A</td><td style="text-align:left">不可用</td><td style="text-align:left">A.class_foo(x)</td><td style="text-align:left">A.static_foo(x)</td></tr></tbody></table><p>更多关于这个问题:</p><ol><li><a href="http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python" target="_blank" rel="noopener">http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python</a></li><li><a href="https://realpython.com/blog/python/instance-class-and-static-methods-demystified/" target="_blank" rel="noopener">https://realpython.com/blog/python/instance-class-and-static-methods-demystified/</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python其实有3个方法,即静态方法(staticmethod),类方法(classmethod)和实例方法,如下:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(x)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;executing foo(%s)&quot;&lt;/span&gt;%(x)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(object)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self,x)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;executing foo(%s,%s)&quot;&lt;/span&gt;%(self,x)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;    @classmethod&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;class_foo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(cls,x)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;executing class_foo(%s,%s)&quot;&lt;/span&gt;%(cls,x)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;    @staticmethod&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;static_foo&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(x)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;executing static_foo(%s)&quot;&lt;/span&gt;%x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a=A()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
      <category term="Staticmethod &amp; Classmethod" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/Staticmethod-Classmethod/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
</feed>
