<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Quentin&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kunxiang.wang/"/>
  <updated>2019-02-15T02:19:32.592Z</updated>
  <id>http://kunxiang.wang/</id>
  
  <author>
    <name>ByiProX</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>布尔环</title>
    <link href="http://kunxiang.wang/2019/02/15/%E5%B8%83%E5%B0%94%E7%8E%AF/"/>
    <id>http://kunxiang.wang/2019/02/15/布尔环/</id>
    <published>2019-02-15T02:07:21.000Z</published>
    <updated>2019-02-15T02:19:32.592Z</updated>
    
    <content type="html"><![CDATA[<p>布尔环与整数运算有很多相同属性。例如整数运算的一个属性是每个值x都有一个加法逆元(additive-inverse)<code>-x</code>, 使得<code>x+(-x)=0</code>。布尔环也有类似的属性，这里的加法运算时<code>^</code>,不过这时每个元素的加法逆元是它自己本身。也就是说，对于任何值a来说，<code>a^a=0</code>, 这里用0表示全0的位向量。</p><p>相同道理还有一个有意思的属性，即<code>(a^b)^a=b</code>，该属性可以用来交换两个元素的值，而不需要第三方变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a ^ b</span><br><span class="line">b = a ^ b</span><br><span class="line">a = a ^ b</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;布尔环与整数运算有很多相同属性。例如整数运算的一个属性是每个值x都有一个加法逆元(additive-inverse)&lt;code&gt;-x&lt;/code&gt;, 使得&lt;code&gt;x+(-x)=0&lt;/code&gt;。布尔环也有类似的属性，这里的加法运算时&lt;code&gt;^&lt;/code&gt;,不过这时
      
    
    </summary>
    
    
      <category term="计算机基础" scheme="http://kunxiang.wang/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>搭建Git服务器的一种方法</title>
    <link href="http://kunxiang.wang/2019/02/11/%E6%90%AD%E5%BB%BAGit%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://kunxiang.wang/2019/02/11/搭建Git服务器的一种方法/</id>
    <published>2019-02-11T05:43:13.000Z</published>
    <updated>2019-02-11T06:11:23.884Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-确保自己的服务器上安装有Git和ssh"><a href="#1-确保自己的服务器上安装有Git和ssh" class="headerlink" title="1. 确保自己的服务器上安装有Git和ssh"></a>1. 确保自己的服务器上安装有Git和ssh</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install ssh</span><br><span class="line">yum install git</span><br></pre></td></tr></table></figure><h3 id="2-配置git用户"><a href="#2-配置git用户" class="headerlink" title="2. 配置git用户"></a>2. 配置git用户</h3><h4 id="新建git用户"><a href="#新建git用户" class="headerlink" title="新建git用户"></a>新建git用户</h4><p>主要是为了让大家在上传代码时登录使用，一般使用：git<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adduser git</span><br></pre></td></tr></table></figure></p><a id="more"></a><h4 id="配置git用户的ssh登录"><a href="#配置git用户的ssh登录" class="headerlink" title="配置git用户的ssh登录"></a>配置git用户的ssh登录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/git    //进入git用户文件夹</span><br><span class="line">sudo mkdir .ssh    //创建 .ssh 文件夹</span><br><span class="line">sudo touch .ssh/authorized_keys    //创建authorized_keys文件，用以保存公钥</span><br></pre></td></tr></table></figure><p><code>authorized_keys</code> 是公钥保存文件，<code>客户端的私钥</code>与<code>服务器的公钥</code>配对成功，则可以登录。<code>之后将需要使用这个git服务器的成员的公钥复制粘贴到这个文件中（每个占一行）</code>。</p><p>客户端电脑进入 /users/用户名/.ssh 文件夹，如果已经有自己的秘钥，直接打开 <code>pub</code> 文件，复制里面的公钥信息，进入服务器，粘贴到 authorized_keys 文件中，如果没有，使用<code>ssh-keygen</code>命令生成后复制粘贴即可。</p><h3 id="3-初始化裸仓库来保存项目"><a href="#3-初始化裸仓库来保存项目" class="headerlink" title="3. 初始化裸仓库来保存项目"></a>3. 初始化裸仓库来保存项目</h3><p>在<code>/home/git</code>下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir repos    //创建repos文件夹，用于保存git仓库，名字随各人喜好，这里使用repos</span><br><span class="line"><span class="built_in">cd</span> repos    //进入repos文件夹</span><br><span class="line">sudo git init --bare sample.git    //创建一个裸仓库，名字按自己需要选择，这里使用sample</span><br></pre></td></tr></table></figure></p><p>repos文件夹中会创建 sample.git 文件夹。那么，剩下的事情，就是将本地代码上传到服务器的仓库中。</p><ol><li><p>如果本地没有初始代码，可以直接从服务器克隆仓库到本地：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@server:repos/sample.git</span><br></pre></td></tr></table></figure><p>git@server是登录服务器使用的用户名（git）和IP地址（server），登录之后有默认进入用户文件夹（/home/git），后面的路径就是用户文件夹下的仓库路径，也就是 repos/sample.git 。</p></li><li><p>如果本地有一些初始代码，需要直接同步到服务器的仓库，可以进入本地代码文件夹，创建并将代码保存到git仓库后同步至服务器仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git init    //创建git仓库</span><br><span class="line">git add .    //添加所有文件</span><br><span class="line">git commit -m <span class="string">"your remark"</span>    //将代码提交到本地仓库</span><br><span class="line">git remote add origin git@server:repos/sample.git    //添加远程仓库地址</span><br><span class="line">git push --<span class="built_in">set</span>-upstream origin master    //将代码上传到远程仓库并把本地上传的代码设为master分支</span><br></pre></td></tr></table></figure></li></ol><p>有时会出现git远程仓库配置写错的情况，或者需要修改远程仓库，可以使用以下命令删除原有的远程仓库配置后重新配置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-确保自己的服务器上安装有Git和ssh&quot;&gt;&lt;a href=&quot;#1-确保自己的服务器上安装有Git和ssh&quot; class=&quot;headerlink&quot; title=&quot;1. 确保自己的服务器上安装有Git和ssh&quot;&gt;&lt;/a&gt;1. 确保自己的服务器上安装有Git和ssh&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;yum install ssh&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yum install git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;2-配置git用户&quot;&gt;&lt;a href=&quot;#2-配置git用户&quot; class=&quot;headerlink&quot; title=&quot;2. 配置git用户&quot;&gt;&lt;/a&gt;2. 配置git用户&lt;/h3&gt;&lt;h4 id=&quot;新建git用户&quot;&gt;&lt;a href=&quot;#新建git用户&quot; class=&quot;headerlink&quot; title=&quot;新建git用户&quot;&gt;&lt;/a&gt;新建git用户&lt;/h4&gt;&lt;p&gt;主要是为了让大家在上传代码时登录使用，一般使用：git&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;adduser git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://kunxiang.wang/categories/Git/"/>
    
    
      <category term="Git" scheme="http://kunxiang.wang/tags/Git/"/>
    
      <category term="Github" scheme="http://kunxiang.wang/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>Python中如何生成一定格式的日期字符串</title>
    <link href="http://kunxiang.wang/2018/12/03/Python%E4%B8%AD%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E4%B8%80%E5%AE%9A%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%97%A5%E6%9C%9F%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://kunxiang.wang/2018/12/03/Python中如何生成一定格式的日期字符串/</id>
    <published>2018-12-03T08:20:56.000Z</published>
    <updated>2018-12-03T08:28:40.358Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">timeStamp = time.time()</span><br><span class="line">timeArray = time.localtime(time.time())</span><br><span class="line">print(timeArray)</span><br><span class="line"><span class="comment"># time.struct_time(tm_year=2018, tm_mon=12, tm_mday=3, tm_hour=16, tm_min=23, tm_sec=55, tm_wday=0, tm_yday=337, tm_isdst=0)</span></span><br><span class="line"></span><br><span class="line">formatTime = time.strftime(<span class="string">"%Y%m%d-%H:%M:%S"</span>, timeArray)</span><br><span class="line">print(formatTime)</span><br><span class="line"><span class="comment"># 20181203-16:23:55</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas
      
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://kunxiang.wang/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Python3" scheme="http://kunxiang.wang/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Python中append和extend效率</title>
    <link href="http://kunxiang.wang/2018/11/27/Python%E4%B8%ADappend%E5%92%8Cextend%E6%95%88%E7%8E%87/"/>
    <id>http://kunxiang.wang/2018/11/27/Python中append和extend效率/</id>
    <published>2018-11-27T07:29:14.000Z</published>
    <updated>2018-11-27T07:58:02.098Z</updated>
    
    <content type="html"><![CDATA[<p>python提供了一个名为extend的方法，该方法将一个列表中的所有元素添加到另一个列表的结尾。在作用上，调用<code>data.extend(other)</code>的输出结果与以下代码的输出结果相同。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> elem <span class="keyword">in</span> other:</span><br><span class="line">    data.append(elem)</span><br></pre></td></tr></table></figure></p><p>在任何情况下，运行时间都正比于另一张列表的长度，并且之所以<code>摊销</code>，是因为第一张列表的底层数组需要调整打下以容纳增添的元素。</p><p>在实践中，相对于重复调用append方法，我们更倾向于选择extend方法。原因是渐进分析中隐含的常数明显更小。extend方法效率更高体现在三个方面：</p><ol><li>首先，使用合适的python方法总会有一些优势，因为这些方法通常使用本地编译语言执行</li><li>与调用很多独立的方法相比，调用一个函数完成所有工作的开销更小。</li><li><code>extend提升的效率来源更新列表的最终大小能提前计算出。</code>例如第二个数据集是非常大的，当重复调用append时，底层动态数组会有很多次调整大小的风险，如果调用一次extend方法，最多执行一次调整工作。</li></ol><a id="more"></a><p>我们所熟悉的构造新列表的语法，在几乎所有情况下，该行为的渐进效率在创建列表的长度方面是线性的。但是不同的方法在<br>实际效率上会有不同。</p><p>在python中经常使用一个诸如<code>squares = [k*k for k in range(1, n+1)]</code>的例子作为<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">squares = []</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>)</span><br><span class="line">    squares.append(k*k)</span><br></pre></td></tr></table></figure></p><p>的一种速记，并由此引入了列表推导式。实验可以证明用列表推导式语法比不断增添数据来创建列表速度更快。</p><p>类似的，使用乘法操作初始化一个固定的列表，也是一种很常见的python风格，例如<code>[0]*100</code>生成一张长度为100的列表，这样做不但语法简单，而且比逐步构造这样的表效率更高</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python提供了一个名为extend的方法，该方法将一个列表中的所有元素添加到另一个列表的结尾。在作用上，调用&lt;code&gt;data.extend(other)&lt;/code&gt;的输出结果与以下代码的输出结果相同。&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; elem &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; other:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    data.append(elem)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在任何情况下，运行时间都正比于另一张列表的长度，并且之所以&lt;code&gt;摊销&lt;/code&gt;，是因为第一张列表的底层数组需要调整打下以容纳增添的元素。&lt;/p&gt;
&lt;p&gt;在实践中，相对于重复调用append方法，我们更倾向于选择extend方法。原因是渐进分析中隐含的常数明显更小。extend方法效率更高体现在三个方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先，使用合适的python方法总会有一些优势，因为这些方法通常使用本地编译语言执行&lt;/li&gt;
&lt;li&gt;与调用很多独立的方法相比，调用一个函数完成所有工作的开销更小。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extend提升的效率来源更新列表的最终大小能提前计算出。&lt;/code&gt;例如第二个数据集是非常大的，当重复调用append时，底层动态数组会有很多次调整大小的风险，如果调用一次extend方法，最多执行一次调整工作。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://kunxiang.wang/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Python3" scheme="http://kunxiang.wang/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>IP地址的分类</title>
    <link href="http://kunxiang.wang/2018/11/07/IP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E7%B1%BB/"/>
    <id>http://kunxiang.wang/2018/11/07/IP地址的分类/</id>
    <published>2018-11-07T11:43:34.000Z</published>
    <updated>2018-11-07T12:10:20.810Z</updated>
    
    <content type="html"><![CDATA[<p>IP地址分类（A类 B类 C类 D类 E类）</p><p>IP地址由两部分组成，即<code>网络地址</code>和<code>主机地址</code>。网络地址表示其属于互联网的哪一个网络，主机地址表示其属于该网络中的哪一台主机。二者是主从关系。</p><p>IP地址的四大类型标识的是网络中的某台主机。IPv4的地址长度为32位，共4个字节，但实际中我们用点分十进制记法。</p><p>IP地址根据网络号和主机号来分，分为A、B、C三类及特殊地址D、E。    <code>全0和全1的都保留不用</code>。</p><ul><li><p>A类：（1.0.0.0-126.0.0.0）（默认子网掩码：255.0.0.0或 0xFF000000）</p><p>   第一个字节为网络号，后三个字节为主机号。<code>该类IP地址的最前面为“0”</code>，所以地址的网络号取值于1~126之间。</p><p>   一般用于大型网络。</p></li><li><p>B类：（128.1.0.0-191.255.0.0）（默认子网掩码：255.255.0.0或0xFFFF0000）</p><p>   前两个字节为网络号，后两个字节为主机号。<code>该类IP地址的最前面为“10”</code>，所以地址的网络号取值于128~191之间。</p><p>   一般用于中等规模网络。</p></li><li><p>C类：（192.0.1.0-223.255.255.0）（子网掩码：255.255.255.0或 0xFFFFFF00）</p><p>   前三个字节为网络号，最后一个字节为主机号。<code>该类IP地址的最前面为“110”</code>，所以地址的网络号取值于192~223之间。</p><p>   一般用于小型网络。</p></li><li><p>D类：是<code>多播地址</code>。<code>该类IP地址的最前面为“1110”</code>，所以地址的网络号取值于224~239之间。一般用于多路广播用户。</p></li><li><p>E类：是<code>保留地址</code>。<code>该类IP地址的最前面为“1111”</code>，所以地址的网络号取值于240~255之间。</p></li></ul><p>回送地址：127.0.0.1。 也是本机地址，等效于localhost或本机IP。 </p><p>一般用于测试使用。例如：ping 127.0.0.1来测试本机TCP/IP是否正常。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;IP地址分类（A类 B类 C类 D类 E类）&lt;/p&gt;
&lt;p&gt;IP地址由两部分组成，即&lt;code&gt;网络地址&lt;/code&gt;和&lt;code&gt;主机地址&lt;/code&gt;。网络地址表示其属于互联网的哪一个网络，主机地址表示其属于该网络中的哪一台主机。二者是主从关系。&lt;/p&gt;
&lt;p&gt;IP地址
      
    
    </summary>
    
      <category term="网络" scheme="http://kunxiang.wang/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://kunxiang.wang/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Java内部类</title>
    <link href="http://kunxiang.wang/2018/11/05/Java%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>http://kunxiang.wang/2018/11/05/Java内部类/</id>
    <published>2018-11-05T04:59:24.000Z</published>
    <updated>2018-11-05T05:23:13.566Z</updated>
    
    <content type="html"><![CDATA[<p>类中的定义成员有三种，分别是</p><ol><li>字段</li><li>方法</li><li>内部类</li></ol><p>内部类：定义在类结构中的另一个类</p><p><code>为什么要使用内部类？</code></p><ol><li>增强封装，把内部类隐藏在外部类之内，不允许其他类访问该类</li><li>内部类能提高代码的可读性和可维护性，把小型类嵌入到外部类中结构上代码会更清晰。</li><li>内部类可以直接访问外部类的成员</li></ol><a id="more"></a><p>内部类根据使用不同的修饰符或者存在的位置不同，可以分为四种:</p><ol><li>实例内部类</li><li>静态内部类</li><li>局部内部类</li><li>匿名内部类（仅适合于一次使用的类）</li></ol><table><thead><tr><th></th><th>实例内部类</th><th>静态内部类</th><th>局部内部类</th></tr></thead><tbody><tr><td>主要特征</td><td>内部类的实例引用特定的外部类的实例</td><td>内部类的实例不与外部类的任何实例关联</td><td>可见范围是所在的方法</td></tr><tr><td>可用修饰符</td><td>访问控制修饰符，abstract，final</td><td>访问控制修饰符，static，abstract，final</td><td>abstract，final</td></tr><tr><td>可以访问外部类的哪些成员</td><td>可以直接访问外部类的所有成员</td><td>只能直接访问外部类的静态成员</td><td>可以直接访问外部类的所有成员，并且能访问所在方法的final类型的变量和参数</td></tr><tr><td>拥有成员类型</td><td>只能拥有实例成员</td><td>可以拥有静态成员和实例成员</td><td>只能拥有实例成员</td></tr><tr><td>外部类如何访问内部类的成员</td><td>必须通过内部类的实例来访问</td><td>对于静态成员，可以通过内部类的完整类名来访问</td><td>必须通过内部类的实例来访问</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;类中的定义成员有三种，分别是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;字段&lt;/li&gt;
&lt;li&gt;方法&lt;/li&gt;
&lt;li&gt;内部类&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;内部类：定义在类结构中的另一个类&lt;/p&gt;
&lt;p&gt;&lt;code&gt;为什么要使用内部类？&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;增强封装，把内部类隐藏在外部类之内，不允许其他类访问该类&lt;/li&gt;
&lt;li&gt;内部类能提高代码的可读性和可维护性，把小型类嵌入到外部类中结构上代码会更清晰。&lt;/li&gt;
&lt;li&gt;内部类可以直接访问外部类的成员&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java" scheme="http://kunxiang.wang/categories/Java/"/>
    
    
      <category term="Java" scheme="http://kunxiang.wang/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的接口和抽象类</title>
    <link href="http://kunxiang.wang/2018/11/04/Java%E4%B8%AD%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    <id>http://kunxiang.wang/2018/11/04/Java中的接口和抽象类/</id>
    <published>2018-11-04T14:20:35.000Z</published>
    <updated>2018-11-05T04:38:52.272Z</updated>
    
    <content type="html"><![CDATA[<p>相同点：</p><ul><li>都位于继承的顶端，用于被其他实现或继承</li><li>都不能实例化</li><li>都可以定义抽象方法，其子类/实现类都必须复写这些抽象方法。</li></ul><p>不同点：</p><ul><li>接口没有构造方法，抽象类有构造方法。这是因为子类继承抽象类后，在实例化一个子类时，需要检查父类的是否有构造方法。</li><li>抽象类可包含骗人通方法和抽象方法，<code>接口只能包含抽象方法（java8之前）</code></li><li>一个类只能继承一个直接父类（可能是抽象类），接口是多继承并且支持一个类实现多个接口（弥补了Java的单继承）</li><li>成员变量：接口里默认是public static final，抽象类默认包权限</li><li>方法：接口里默认public abstract,抽象类默认包访问权限</li><li>内部类：接口里默认public static，抽象类默认包访问权限</li></ul><p>如果接口和实现类可以完成与其他方法实现的其他功能，尽量使用接口，面向接口编程。</p><p>设计模式：接口和抽象类集合使用的（适配器模式）</p><p><code>面向接口编程：多态的好处：把实现类对象付给接口类型变量，屏蔽了不同实现类之间的差异，从而可以做到通用编程</code></p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wkx.jedis;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IUSB</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swapData</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mouse</span> <span class="keyword">implements</span> <span class="title">IUSB</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swapData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"i am moving..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span> <span class="keyword">implements</span> <span class="title">IUSB</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swapData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"i am printing, dididi..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MotherBoard</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IUSB[] usbs = <span class="keyword">new</span> IUSB[<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pluginIn</span><span class="params">(IUSB usb)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (usbs.length == num) <span class="keyword">return</span>;</span><br><span class="line">        usbs[num] = usb;</span><br><span class="line">        num ++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (IUSB usb : usbs)&#123;</span><br><span class="line">            <span class="keyword">if</span>(usb != <span class="keyword">null</span>) usb.swapData();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IUSBDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MotherBoard.pluginIn(<span class="keyword">new</span> Mouse());</span><br><span class="line">        MotherBoard.pluginIn(<span class="keyword">new</span> Mouse());</span><br><span class="line">        MotherBoard.pluginIn(<span class="keyword">new</span> Mouse());</span><br><span class="line">        MotherBoard.pluginIn(<span class="keyword">new</span> Printer());</span><br><span class="line">        MotherBoard.pluginIn(<span class="keyword">new</span> Printer());</span><br><span class="line">        MotherBoard.pluginIn(<span class="keyword">new</span> Printer());</span><br><span class="line">        MotherBoard.pluginIn(<span class="keyword">new</span> Printer());</span><br><span class="line">        MotherBoard.doWork();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相同点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;都位于继承的顶端，用于被其他实现或继承&lt;/li&gt;
&lt;li&gt;都不能实例化&lt;/li&gt;
&lt;li&gt;都可以定义抽象方法，其子类/实现类都必须复写这些抽象方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不同点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接口没有构造方法，抽象类有构造方法。这是因为子类继承抽象类后，在实例化一个子类时，需要检查父类的是否有构造方法。&lt;/li&gt;
&lt;li&gt;抽象类可包含骗人通方法和抽象方法，&lt;code&gt;接口只能包含抽象方法（java8之前）&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;一个类只能继承一个直接父类（可能是抽象类），接口是多继承并且支持一个类实现多个接口（弥补了Java的单继承）&lt;/li&gt;
&lt;li&gt;成员变量：接口里默认是public static final，抽象类默认包权限&lt;/li&gt;
&lt;li&gt;方法：接口里默认public abstract,抽象类默认包访问权限&lt;/li&gt;
&lt;li&gt;内部类：接口里默认public static，抽象类默认包访问权限&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果接口和实现类可以完成与其他方法实现的其他功能，尽量使用接口，面向接口编程。&lt;/p&gt;
&lt;p&gt;设计模式：接口和抽象类集合使用的（适配器模式）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;面向接口编程：多态的好处：把实现类对象付给接口类型变量，屏蔽了不同实现类之间的差异，从而可以做到通用编程&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://kunxiang.wang/categories/Java/"/>
    
    
      <category term="面试" scheme="http://kunxiang.wang/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="Java" scheme="http://kunxiang.wang/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Redis之数据类型的内部编码</title>
    <link href="http://kunxiang.wang/2018/11/01/Redis%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%86%85%E9%83%A8%E7%BC%96%E7%A0%81/"/>
    <id>http://kunxiang.wang/2018/11/01/Redis之数据类型的内部编码/</id>
    <published>2018-11-01T03:25:48.000Z</published>
    <updated>2018-11-01T09:00:53.873Z</updated>
    
    <content type="html"><![CDATA[<h4 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h4><p>哈希类型内部编码有两种形式：</p><ol><li><p><code>ziplist</code>(压缩列表，感觉与python中的zip方法类似，有待验证。。。)：当哈希类型元素个数小于<code>hash-max-ziplist-entries</code>配置(默认512)、同时所有值都小于<code>hash-max-ziplist-value</code>配置(默认64字节)，Redis会使用ziplist作为哈希的内部实现。ziplist使用更加紧凑结构实现多个元素的连续存储，所以在节省内存方面比hashtable更有优势。</p></li><li><p><code>hashtable</code>(哈希表)：当哈希类型无法满足ziplist条件时，Redis会使用hashtable作为哈希的内部实现，因此此时ziplist读写效率会下降，hashtable读写的时间复杂度为O(1).</p></li></ol><a id="more"></a><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>从Redis3.2之后开始提供了<code>quicklist内部编码，它是一种将ziplist和linkedlist结合的一种编码方式</code>。</p><ol><li><code>ziplist</code>(压缩列表):当列表的元素个数小于<code>list-max-ziplist-entries</code>配置(默认512个),同时列表中每个元素值都小于<code>list-max-ziplist-value</code>配置(默认64字节),Redis会选用ziplist来作为列表内部的实现来减小内存使用。</li><li><code>linkedlist</code>(链表):当列表类型无法满足ziplist的条件时，Redis会使用linkedlist作为列表的内部实现。</li></ol><p>Redis3.2之后提供了quicklist内部编码，简单的说它是一个ziplist为节点的linkedlist，它结合了两者的优势，为列表类型提供了一种更为优秀的内部编码实现。</p><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>集合类型的内部编码也有两种：</p><ol><li><code>intset</code>(整数集合)：当集合中的元素都是<code>整数</code>且<code>元素个数小于set-max-intset-entries配置(默认512个)</code>，Redis会选用intset来作为集合的内部实现，从而减小内存的使用。</li><li><code>hashtable</code>(哈希表)：当集合类型无法满足intset的条件时，Redis会使用hashtable作为集合的内部实现。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;哈希&quot;&gt;&lt;a href=&quot;#哈希&quot; class=&quot;headerlink&quot; title=&quot;哈希&quot;&gt;&lt;/a&gt;哈希&lt;/h4&gt;&lt;p&gt;哈希类型内部编码有两种形式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;ziplist&lt;/code&gt;(压缩列表，感觉与python中的zip方法类似，有待验证。。。)：当哈希类型元素个数小于&lt;code&gt;hash-max-ziplist-entries&lt;/code&gt;配置(默认512)、同时所有值都小于&lt;code&gt;hash-max-ziplist-value&lt;/code&gt;配置(默认64字节)，Redis会使用ziplist作为哈希的内部实现。ziplist使用更加紧凑结构实现多个元素的连续存储，所以在节省内存方面比hashtable更有优势。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;hashtable&lt;/code&gt;(哈希表)：当哈希类型无法满足ziplist条件时，Redis会使用hashtable作为哈希的内部实现，因此此时ziplist读写效率会下降，hashtable读写的时间复杂度为O(1).&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://kunxiang.wang/categories/Redis/"/>
    
      <category term="数据类型" scheme="http://kunxiang.wang/categories/Redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
    
      <category term="Redis" scheme="http://kunxiang.wang/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Java包装类中的缓存设计</title>
    <link href="http://kunxiang.wang/2018/10/30/Java%E5%8C%85%E8%A3%85%E7%B1%BB%E4%B8%AD%E7%9A%84%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/"/>
    <id>http://kunxiang.wang/2018/10/30/Java包装类中的缓存设计/</id>
    <published>2018-10-30T07:13:26.000Z</published>
    <updated>2018-10-30T07:50:02.617Z</updated>
    
    <content type="html"><![CDATA[<p>包装类中的<code>缓存设计</code>(<a href="https://baike.baidu.com/item/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/10541959?fr=aladdin" target="_blank" rel="noopener">享元模式-FlyWeight</a>)，本质就是缓存设计。</p><p><code>Byte/Short/Integer/Long</code>:缓存[-128, 127]区间的数据；<br><code>Character</code>:缓存[0,127]区间的数据.<br><a id="more"></a><br>首先来看一个有意思的面试题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//case 1</span></span><br><span class="line">        Integer i1 = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">        Integer i2 = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">        System.out.println(i1 == i2); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//case 2</span></span><br><span class="line">        Integer i3 = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">        Integer i4 = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">        System.out.println(i3 == i4); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//case 3</span></span><br><span class="line">        Integer i5 = <span class="number">123</span>; <span class="comment">//自动装箱操作，底层编译后代码为Integer.valueOf(123);    和case2相同</span></span><br><span class="line">        Integer i6 = <span class="number">123</span>;</span><br><span class="line">        System.out.println(i5 == i6); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//case 4</span></span><br><span class="line">        Integer ii1 = <span class="keyword">new</span> Integer(<span class="number">250</span>);</span><br><span class="line">        Integer ii2 = <span class="keyword">new</span> Integer(<span class="number">250</span>);</span><br><span class="line">        System.out.println(ii1 == ii2); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//case 5</span></span><br><span class="line">        Integer ii3 = Integer.valueOf(<span class="number">250</span>); <span class="comment">// 250不在缓存区间内，就得new新对象</span></span><br><span class="line">        Integer ii4 = Integer.valueOf(<span class="number">250</span>);</span><br><span class="line">        System.out.println(ii3 == ii4); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// case 6</span></span><br><span class="line">        Integer ii5 = <span class="number">250</span>;</span><br><span class="line">        Integer ii6 = <span class="number">250</span>;</span><br><span class="line">        System.out.println(ii5 == ii6); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看一下integer源码,如下所示。可以看到Integer的缓存空间在[-128, 127]之间。<br>当传入的数值在此区间内时，之间调用缓存内的数据。反之，重新<code>return new Integer(i);</code>在堆空间返回一个新整形对象。</p><p>那么我们应该如何比较两个对象的值得大小呢？<br>正确的方法是使用<code>equals</code>来比较，equals方法来自于Object根对象，按照官方的建议，在构造子类对象时需要复写父类中的equals方法，来比较我们关心的数据，而不是内存地址（<code>==</code>比较的是内存地址）。现将Integer中的equals拿出来检查一下复写情况</p><p><code>((Integer)obj).intValue()</code>拆箱操作，<code>value == ((Integer)obj).intValue();</code>使用基本的数据类型进行比较。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">        <span class="keyword">return</span> value == ((Integer)obj).intValue(); <span class="comment">// 拆箱操作，比较基本数据类型</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123; <span class="comment">// 初始化操作</span></span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">            String integerCacheHighPropValue =</span><br><span class="line">                sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">            <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                    i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                    <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                    <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            high = h;</span><br><span class="line"></span><br><span class="line">            cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> j = low;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">                cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;包装类中的&lt;code&gt;缓存设计&lt;/code&gt;(&lt;a href=&quot;https://baike.baidu.com/item/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/10541959?fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;享元模式-FlyWeight&lt;/a&gt;)，本质就是缓存设计。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Byte/Short/Integer/Long&lt;/code&gt;:缓存[-128, 127]区间的数据；&lt;br&gt;&lt;code&gt;Character&lt;/code&gt;:缓存[0,127]区间的数据.&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://kunxiang.wang/categories/Java/"/>
    
    
      <category term="Java" scheme="http://kunxiang.wang/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的单例模式</title>
    <link href="http://kunxiang.wang/2018/10/30/Java%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://kunxiang.wang/2018/10/30/Java中的单例模式/</id>
    <published>2018-10-30T04:00:22.000Z</published>
    <updated>2018-10-30T04:04:25.179Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-饿汉模式"><a href="#1-饿汉模式" class="headerlink" title="1. 饿汉模式"></a>1. 饿汉模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayUtil.getInstance().sort(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 在该类中，实例化一个实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ArrayUtil instance = <span class="keyword">new</span> ArrayUtil();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 私有化自身的构造器，防止外界通过构造器new对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ArrayUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 对外开放一个静态公共方法，用于获取对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayUtil <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//此处编写排序代码</span></span><br><span class="line">        System.out.println(<span class="string">"I'm sorting "</span> + array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-饿汉模式&quot;&gt;&lt;a href=&quot;#1-饿汉模式&quot; class=&quot;headerlink&quot; title=&quot;1. 饿汉模式&quot;&gt;&lt;/a&gt;1. 饿汉模式&lt;/h4&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu
      
    
    </summary>
    
      <category term="Java" scheme="http://kunxiang.wang/categories/Java/"/>
    
    
      <category term="Java" scheme="http://kunxiang.wang/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的代码块</title>
    <link href="http://kunxiang.wang/2018/10/30/Java%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
    <id>http://kunxiang.wang/2018/10/30/Java中的代码块/</id>
    <published>2018-10-30T01:24:49.000Z</published>
    <updated>2018-10-30T02:43:22.581Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>什么是代码块：在类或者方法中，直接使用<code>{}</code>括起来的一段代码，表示一块带啊区域。</p></blockquote><p>代码在块中属于局部变量，只在自己所在的花括号区域内有效。<br>根据代码块所定义的位置不同，代码块分为三种形式</p><ol><li><p><code>局部代码块</code>：直接定义在<code>方法内部</code>的代码块。<br>一般的，不会直接使用局部代码块，只不过会结合if、while等关键字，表示一块代码区域。</p></li><li><p><code>初始化代码块(构造代码块)</code>：直接定义在<code>类</code>中。<br>每次创建对象的时候都会执行初始化代码块：每次创建对象的时候都会调用构造器，在调用构造器之前，会先执行本类中的初始化代码块。<code>PS</code>:<code>通过反编译，可以看到，初始化代码也作为构造器最初的语句。</code>一般不使用这种用法，因为不够优雅美观。即使要初始化操作，一般在构造器中进行初始化即可。或者专门定义一个方法做初始化操作，方法哦构造器中进行调用。</p></li><li><p><code>静态代码块：使用static修饰的初始化代码块。</code><br>静态代码块在主方法执行之前进行调用，而且只会执行一次。main方法是程序的入口，静态代码块由于main方法执行。静态成员随着字节码的加载也加载进JVM,此时main还没执行，因为方法需要JVM调用，先把字节码加载进JVM，然后JVM再调用main方法。<code>一般的，我们使用静态代码块来做初始化操作，加载资源，加载配置文件等。</code></p></li></ol><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CodeBlockDemo</span></span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    System.out.println(<span class="string">"初始化代码块"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  CodeBlockDemo()&#123;</span><br><span class="line">    System.out.println(<span class="string">"构造器。。。"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"静态代码块"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"进入main方法"</span>);</span><br><span class="line">    <span class="comment">//创建三个匿名对象</span></span><br><span class="line">    <span class="keyword">new</span> CodeBlockDemo();</span><br><span class="line">    <span class="keyword">new</span> CodeBlockDemo();</span><br><span class="line">    <span class="keyword">new</span> CodeBlockDemo();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*执行结果如下</span></span><br><span class="line"><span class="comment">静态代码块</span></span><br><span class="line"><span class="comment">进入main方法</span></span><br><span class="line"><span class="comment">初始化代码块</span></span><br><span class="line"><span class="comment">构造器。。。</span></span><br><span class="line"><span class="comment">初始化代码块</span></span><br><span class="line"><span class="comment">构造器。。。</span></span><br><span class="line"><span class="comment">初始化代码块</span></span><br><span class="line"><span class="comment">构造器。。。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>一道Java面试题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> App d = <span class="keyword">new</span> App();</span><br><span class="line">    <span class="keyword">private</span> SuperClass t = <span class="keyword">new</span> SubClass(); <span class="comment">//先确定依赖，由此开始作为入口</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    App()&#123;</span><br><span class="line">        System.out.println(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    SuperClass()&#123;</span><br><span class="line">        System.out.println(<span class="string">"构造SuperClass"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubClass()&#123;</span><br><span class="line">        <span class="comment">//super();</span></span><br><span class="line">        System.out.println(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">构造SuperClass</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">Hello</span><br></pre></td></tr></table></figure></p><p><code>分析：</code></p><ol><li>首先在执行子类subclass构造器的时候先执行隐藏的<code>super();</code>来执行父类的构造器，也就是构造<code>SuperClass</code>在<code>2</code>之前打印.</li><li><p>为什么不先打印4而是先打印子类的1？原因是class App依赖于依赖于subclass，会优先编译subclass，也就是说会优先编译被依赖的优先存在的类。所以首先把subclass加载到虚拟机，因此首先打印1.<code>编译的时候首先确定依赖!!!</code></p></li><li><p>非static字段的初始化都在构造器中执行，也就是说App类反编译后如下。可以看出，打印<code>1</code>后,在APP构造器中实例化subclass，此时，先打印父类构造器中的<code>构造SuperClass</code>,然后打印子类的<code>2</code>。紧接着继续执行APP构造器的代码块，打印app构造器中的<code>3</code>。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> App d = <span class="keyword">new</span> App();</span><br><span class="line">    <span class="keyword">private</span> SuperClass t = <span class="keyword">null</span>; <span class="comment">//先确定依赖，由此开始作为入口</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    App()&#123;</span><br><span class="line">        t = <span class="keyword">new</span> SubClass(); <span class="comment">//非static字段的初始化都在构造器中执行</span></span><br><span class="line">        System.out.println(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>以上依赖关系确认完毕，然后开始将App加载进虚拟机，执行由于静态代码块优先于main，静态代码块执行，打印4，最后执行main方法，打印hello.</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;什么是代码块：在类或者方法中，直接使用&lt;code&gt;{}&lt;/code&gt;括起来的一段代码，表示一块带啊区域。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;代码在块中属于局部变量，只在自己所在的花括号区域内有效。&lt;br&gt;根据代码块所定义的位置不同，代码块分为三种形式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;局部代码块&lt;/code&gt;：直接定义在&lt;code&gt;方法内部&lt;/code&gt;的代码块。&lt;br&gt;一般的，不会直接使用局部代码块，只不过会结合if、while等关键字，表示一块代码区域。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;初始化代码块(构造代码块)&lt;/code&gt;：直接定义在&lt;code&gt;类&lt;/code&gt;中。&lt;br&gt;每次创建对象的时候都会执行初始化代码块：每次创建对象的时候都会调用构造器，在调用构造器之前，会先执行本类中的初始化代码块。&lt;code&gt;PS&lt;/code&gt;:&lt;code&gt;通过反编译，可以看到，初始化代码也作为构造器最初的语句。&lt;/code&gt;一般不使用这种用法，因为不够优雅美观。即使要初始化操作，一般在构造器中进行初始化即可。或者专门定义一个方法做初始化操作，方法哦构造器中进行调用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;静态代码块：使用static修饰的初始化代码块。&lt;/code&gt;&lt;br&gt;静态代码块在主方法执行之前进行调用，而且只会执行一次。main方法是程序的入口，静态代码块由于main方法执行。静态成员随着字节码的加载也加载进JVM,此时main还没执行，因为方法需要JVM调用，先把字节码加载进JVM，然后JVM再调用main方法。&lt;code&gt;一般的，我们使用静态代码块来做初始化操作，加载资源，加载配置文件等。&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java" scheme="http://kunxiang.wang/categories/Java/"/>
    
    
      <category term="Java" scheme="http://kunxiang.wang/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java编译类型和运行类型</title>
    <link href="http://kunxiang.wang/2018/10/29/Java%E7%BC%96%E8%AF%91%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E8%A1%8C%E7%B1%BB%E5%9E%8B/"/>
    <id>http://kunxiang.wang/2018/10/29/Java编译类型和运行类型/</id>
    <published>2018-10-29T14:00:41.000Z</published>
    <updated>2018-10-29T14:18:16.575Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line">Animal a = <span class="keyword">new</span> Dog();</span><br><span class="line">a.eat()<span class="comment">//编译报错</span></span><br><span class="line">((Dog) a).run()<span class="comment">//编译通过</span></span><br></pre></td></tr></table></figure><p>如上的简易代码，编译时会报错。<br>编译类型：Animal a<br>运行类型：new Dog()</p><p>编译时，编译类型会根据a.eat()查找eat方法，找不到就会报错。<br>使用强制类型转换可以解决该问题，即<br>((Dog) a).run()</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
      <category term="Java" scheme="http://kunxiang.wang/categories/Java/"/>
    
    
      <category term="Java" scheme="http://kunxiang.wang/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java之Object根类</title>
    <link href="http://kunxiang.wang/2018/10/29/Java%E4%B9%8BObject%E6%A0%B9%E7%B1%BB/"/>
    <id>http://kunxiang.wang/2018/10/29/Java之Object根类/</id>
    <published>2018-10-29T03:48:41.000Z</published>
    <updated>2018-10-29T05:11:33.301Z</updated>
    
    <content type="html"><![CDATA[<p>Object本身就是指对象的意思。开发时发现对象具有一些共通的行为，因此抽象出一个类：Object，来表示对象类，其他都会继承于Object类，也就是Object中的方法。</p><p><code>引用数据类型：类/接口/数组</code>，<code>引用类型又称为对象类</code>，<code>所谓的数组变量名称应该指代数组对象</code>。<br>Object类常用方法：</p><ol><li><p><code>protected void finalize()</code>:当垃圾回收器确定不存在对该对象的更多引用时，由对象回收期调用此方法。垃圾回收器在回收某一个对象之前会调用该方法，做扫尾操作。</p></li><li><p><code>Class getClass</code>:返回当前对象的真实类型。</p></li><li><p><code>int hashCode()</code>:返回该对象的哈希值，hashCode决定了对象在哈希表中的存储位置，不同对象的hashCode是不一样的。</p></li><li><p><code>boolean equals(Object obj)</code>: 拿当前对象(this)和参数obj比较。在Object类中的equals方法，本身和’==’符号相同，都是比较的内存地址。官方建议：每个类都应该赋写equals方法，不要比较内存地址，而是比较我们关心的数据。</p></li><li><p><code>String toString()</code>:表示把一个对象转换为字符串表示。在调用打印时，其实打印的就是对象的toString方法。<code>System.out.println(obj);</code>等价于<code>System.out.println(obj.toString);</code>(决堤可以查看Java源代码)。默认情况下打印对象，打印的是对象的十六进制hashCode,但我们更关心对象中的真实存储数据。官方建议：每个类最好赋写toString方法，返回我们关心的数据。</p></li></ol><p><img src="https://upload-images.jianshu.io/upload_images/2952111-d5a996ebf97c420b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screen Shot 2018-10-29 at 12.08.42.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Object本身就是指对象的意思。开发时发现对象具有一些共通的行为，因此抽象出一个类：Object，来表示对象类，其他都会继承于Object类，也就是Object中的方法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;引用数据类型：类/接口/数组&lt;/code&gt;，&lt;code&gt;引用类型又称为对象
      
    
    </summary>
    
      <category term="Java" scheme="http://kunxiang.wang/categories/Java/"/>
    
    
      <category term="Java" scheme="http://kunxiang.wang/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java之super和this</title>
    <link href="http://kunxiang.wang/2018/10/29/Java%E4%B9%8Bsuper%E5%92%8Cthis/"/>
    <id>http://kunxiang.wang/2018/10/29/Java之super和this/</id>
    <published>2018-10-29T01:31:49.000Z</published>
    <updated>2018-10-29T03:06:58.118Z</updated>
    
    <content type="html"><![CDATA[<p>this: 当前的对象，哪一个对象调用this，this就代指哪一个对象。使用在某一个对象中。<br>super: 当前对象的父类方法或构造器。使用在继承关系中。</p><h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><ol><li><p><code>当new一个子类对象的时候，会先创建一个父类对象</code>。可以认为，在调用子类构造器之前，在子类构造器中会先调用父类的构造器，默认调用的是父类无参数的构造器。调用父类构造器后悔创建一个父类的对象。</p></li><li><p>如果父类不存在可以被子类访问的构造器，则不能存在子类，即子类不会被创建成功。</p></li><li><p>如果父类没有提供无参数的构造器，则此时子类必须显式的通过<code>super</code>语句去掉用父类带参数的构造器。</p></li><li><p>子类构建的所有的行为建立在第一条规则基础之上。</p></li></ol><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>    age;</span><br><span class="line">    Animal(String name, <span class="keyword">int</span> age)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        System.out.println(<span class="string">"animal constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Animal(String color)&#123;</span><br><span class="line">        System.out.println(<span class="string">"this is a "</span> + color +<span class="string">" color"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Animals Say sth..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fish</span> <span class="keyword">extends</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    Fish()&#123;</span><br><span class="line">       <span class="comment">//构造器中的第一句必须为super，如果不写，则默认调用super()</span></span><br><span class="line">       <span class="keyword">super</span>(<span class="string">"RED"</span>); <span class="comment">//子类没有提供无参数的构造器，必须显示super滴啊用，否则会编译失败</span></span><br><span class="line">       System.out.println(<span class="string">"Fish Constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个简单的示意图如下：<br><img src="https://upload-images.jianshu.io/upload_images/2952111-2db47a7c0f8a1ec1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screen Shot 2018-10-28 at 22.12.48.png"></p><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><h5 id="存在于位置"><a href="#存在于位置" class="headerlink" title="存在于位置"></a>存在于位置</h5><ol><li>在构造器中，表示当前创建的对象</li><li>在方法中，哪一个对象调用this所在的方法，那么此时this就表示哪一个对象。</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/2952111-bf1b724c2da63d77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screen Shot 2018-10-28 at 16.28.10.png"></p><h5 id="this的使用"><a href="#this的使用" class="headerlink" title="this的使用"></a>this的使用</h5><ol><li>解决成员变量的参数（局部变量）之间的二义性，必须使用this区分</li><li>同类中实例方法互相调用时可以省略this关键字，但是不建议省略</li><li>将this作为参数传递给另外一个方法</li><li>将this作为方法的返回值（链式方法编程）</li><li>构造器函数的互相调用，this([参数])必须写在构造器内的第一行，与super类似。</li><li>this、super不能static一起使用。原因是当字节码被加载进jvm时，static成员已经存在了，但是此时对象还没有被创建，没有对象，也就没有this。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">User(String name)&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">User(String name, <span class="keyword">int</span> age)&#123;</span><br><span class="line">  <span class="keyword">this</span>(name); <span class="comment">//表示在调用参数为string类型的构造器</span></span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上述调用方式为多参数构造器调用少参数构造器，一般工程经验为少参数构造器调用多参数构造器</span></span><br><span class="line"><span class="comment">//对于多余的参数，使用默认值赋值即可，如下</span></span><br><span class="line">User(String name, <span class="keyword">int</span> age)&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">User(String name)&#123;</span><br><span class="line">  <span class="keyword">this</span>(name, <span class="number">0</span>);<span class="comment">//此处对int age赋值为0即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/2952111-955c8e05df6fd8ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screen Shot 2018-10-28 at 16.41.16.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/2952111-1d10520f4fc5a369.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Screen Shot 2018-10-28 at 16.58.54.png"></p><p>是</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;this: 当前的对象，哪一个对象调用this，this就代指哪一个对象。使用在某一个对象中。&lt;br&gt;super: 当前对象的父类方法或构造器。使用在继承关系中。&lt;/p&gt;
&lt;h4 id=&quot;super&quot;&gt;&lt;a href=&quot;#super&quot; class=&quot;headerlink&quot; title=&quot;super&quot;&gt;&lt;/a&gt;super&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;当new一个子类对象的时候，会先创建一个父类对象&lt;/code&gt;。可以认为，在调用子类构造器之前，在子类构造器中会先调用父类的构造器，默认调用的是父类无参数的构造器。调用父类构造器后悔创建一个父类的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果父类不存在可以被子类访问的构造器，则不能存在子类，即子类不会被创建成功。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果父类没有提供无参数的构造器，则此时子类必须显式的通过&lt;code&gt;super&lt;/code&gt;语句去掉用父类带参数的构造器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;子类构建的所有的行为建立在第一条规则基础之上。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java" scheme="http://kunxiang.wang/categories/Java/"/>
    
    
      <category term="Java" scheme="http://kunxiang.wang/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java方法的值传递机制</title>
    <link href="http://kunxiang.wang/2018/10/26/Java%E6%96%B9%E6%B3%95%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/"/>
    <id>http://kunxiang.wang/2018/10/26/Java方法的值传递机制/</id>
    <published>2018-10-26T02:48:38.000Z</published>
    <updated>2018-10-26T07:08:13.589Z</updated>
    
    <content type="html"><![CDATA[<ul><li>对于基本数据类型(八种基本数据类型)来说，方法形参传递的是<code>值的副本</code>;</li><li>对于引用数据类型，方法的形参传递的是<code>引用的地址值的副本</code>;</li></ul><p>对于引用数据类型，JVM中的存储图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/2952111-24d050aa031dd985.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IMG_0013.PNG"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;对于基本数据类型(八种基本数据类型)来说，方法形参传递的是&lt;code&gt;值的副本&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;对于引用数据类型，方法的形参传递的是&lt;code&gt;引用的地址值的副本&lt;/code&gt;;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于引用数据类型，JVM中的存储图如
      
    
    </summary>
    
      <category term="Java" scheme="http://kunxiang.wang/categories/Java/"/>
    
    
      <category term="Java" scheme="http://kunxiang.wang/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>四种方法实现交换两个变量的值</title>
    <link href="http://kunxiang.wang/2018/10/25/%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC/"/>
    <id>http://kunxiang.wang/2018/10/25/四种方法实现交换两个变量的值/</id>
    <published>2018-10-25T01:38:37.000Z</published>
    <updated>2018-10-26T03:07:50.307Z</updated>
    
    <content type="html"><![CDATA[<h4 id="方法1-位运算"><a href="#方法1-位运算" class="headerlink" title="方法1 位运算"></a>方法1 位运算</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = a ^ b</span><br><span class="line">b = a ^ b</span><br><span class="line">a = a ^ b</span><br><span class="line"></span><br><span class="line">原理：a^b^b == a</span><br></pre></td></tr></table></figure><h4 id="方法2-栈实现"><a href="#方法2-栈实现" class="headerlink" title="方法2 栈实现"></a>方法2 栈实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span> S</span><br><span class="line"></span><br><span class="line">S.push(x)</span><br><span class="line">S.push(y)</span><br><span class="line">x = S.pop()</span><br><span class="line">y = S.pop()</span><br></pre></td></tr></table></figure><h4 id="方法3-借助第三变量"><a href="#方法3-借助第三变量" class="headerlink" title="方法3 借助第三变量"></a>方法3 借助第三变量</h4><h4 id="方法4-算术运算"><a href="#方法4-算术运算" class="headerlink" title="方法4 算术运算"></a>方法4 算术运算</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;方法1-位运算&quot;&gt;&lt;a href=&quot;#方法1-位运算&quot; class=&quot;headerlink&quot; title=&quot;方法1 位运算&quot;&gt;&lt;/a&gt;方法1 位运算&lt;/h4&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut
      
    
    </summary>
    
    
      <category term="Funny" scheme="http://kunxiang.wang/tags/Funny/"/>
    
  </entry>
  
  <entry>
    <title>Java中的+=赋值运算</title>
    <link href="http://kunxiang.wang/2018/10/24/Java%E4%B8%AD%E7%9A%84-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97/"/>
    <id>http://kunxiang.wang/2018/10/24/Java中的-赋值运算/</id>
    <published>2018-10-24T07:22:03.000Z</published>
    <updated>2018-10-24T07:38:47.392Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">a += <span class="number">5</span>;</span><br><span class="line">System.out.println(a); <span class="comment">//15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span> s = <span class="number">30</span>;</span><br><span class="line">s = s + <span class="number">5</span>;<span class="comment">//编译报错</span></span><br><span class="line"><span class="comment">//Error:(23, 15) java: incompatible types: possible lossy conversion from int to short</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span> s = <span class="number">30</span>;</span><br><span class="line">s += <span class="number">5</span>;<span class="comment">//等价于 s = short(s+5),该表达式自带隐式类型转换</span></span><br></pre></td></tr></table></figure><p>上述代码中，变量s为short类型，<code>s+5</code>的结果为int类型，int类型赋值给short类型，编译报错。<br>错误信息为如下：<br><code>Error:(23, 15) java: incompatible types: possible lossy conversion from int to short</code></p><p>关于<code>自动类型转换</code>，也称为<code>隐式类型转换</code><br>当把<code>小数据范围类型的数值或变量</code>赋值给另一个<code>大数据范围类型变量</code>时，系统可以自动完成类型转换。<br>boolean类型是不可以转换为其他数据类型。</p><p><code>强制类型转换</code>，也称为<code>显示类型转换</code><br>当把<code>大范围类型的数值或变量</code>赋值给另一个<code>小范围类型变量</code>时，此时系统不能自动完成转换，需要加上强制转换符，但这样的操作可能在成数据精度的降低或溢出，使用时需要格外注意。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
      <category term="Java" scheme="http://kunxiang.wang/categories/Java/"/>
    
    
      <category term="Java" scheme="http://kunxiang.wang/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>C语言中的&#39;if(n==1)&#39;和&#39;if(1==n)&#39;的区别</title>
    <link href="http://kunxiang.wang/2018/09/29/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84-if-n-1-%E5%92%8C-if-1-n-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://kunxiang.wang/2018/09/29/C语言中的-if-n-1-和-if-1-n-的区别/</id>
    <published>2018-09-28T16:04:53.000Z</published>
    <updated>2018-09-29T05:19:57.158Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>C语言中两种if语句判断方式。请问哪种写法更好？为什么？<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) <span class="comment">// 第一种判断方式</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> == n) <span class="comment">// 第二种判断方式</span></span><br></pre></td></tr></table></figure></p></blockquote><a id="more"></a><h4 id="第一种写法"><a href="#第一种写法" class="headerlink" title="第一种写法"></a>第一种写法</h4><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>在写判断语句的时候很容易漏写一个“=” ,比如把<br><code>if (n == 1) { } 写成 if (n = 1) { }</code>。<br>而在C中 “n = 1” 是有返回值的， 这个返回值是1， 于是原语句相当于<br>if ( 1 ) { } ,即条件永远为真，{ } 内的代码始终能够得到执行，当这样的<br>错误深深埋藏在代码当中，非常难以debug。</li></ul><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>主要目的是防止写成if(n = 1)而导致错误,但现在的编译器一般会给出警告信息所以现在不常用了.第1种更符合习惯,只要把相应的编译选项打开,一般不会出问题。</li></ul><h4 id="第二种写法"><a href="#第二种写法" class="headerlink" title="第二种写法"></a>第二种写法</h4><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul><li>反人类<h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5></li><li><p>if ( 1 == n ) { } 及时少写一个”=”, 编译器就会报错，省得在运行期调试<br>得死去活来。</p></li><li><p>会省掉很多  debug  的时间的。</p></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;C语言中两种if语句判断方式。请问哪种写法更好？为什么？&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (n == &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// 第一种判断方式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; == n) &lt;span class=&quot;comment&quot;&gt;// 第二种判断方式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="面试" scheme="http://kunxiang.wang/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://kunxiang.wang/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>如何理解http是无连接，无状态的？</title>
    <link href="http://kunxiang.wang/2018/09/28/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3http%E6%98%AF%E6%97%A0%E8%BF%9E%E6%8E%A5%EF%BC%8C%E6%97%A0%E7%8A%B6%E6%80%81%E7%9A%84%EF%BC%9F/"/>
    <id>http://kunxiang.wang/2018/09/28/如何理解http是无连接，无状态的？/</id>
    <published>2018-09-28T08:46:24.000Z</published>
    <updated>2018-09-28T13:45:26.772Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP 是一个属于应用层的面向对象的协议，HTTP 协议一共有五大特点：</p><ol><li>支持客户/服务器模式；</li><li>简单快速；</li><li>灵活；</li><li><code>无连接</code>；</li><li><code>无状态</code>。</li></ol><h4 id="无连接"><a href="#无连接" class="headerlink" title="无连接"></a>无连接</h4><p><code>无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</code></p><blockquote><p>ps:早期这么做的原因是 HTTP 协议产生于互联网，因此服务器需要处理同时面向全世界数十万、上百万客户端的网页访问，但每个客户端（即浏览器）与服务器之间交换数据的间歇性较大（即传输具有突发性、瞬时性），并且网页浏览的联想性、发散性导致两次传送的数据关联性很低，大部分通道实际上会很空闲、无端占用资源。因此 <code>HTTP 的设计者有意利用这种特点将协议设计为请求时建连接、请求完释放连接，以尽快将资源释放出来服务其他客户端</code></p></blockquote><p>随着时间的推移，网页变得越来越复杂，里面可能嵌入了很多图片，这时候每次访问图片都需要建立一次 TCP 连接就显得很低效。后来，<code>Keep-Alive</code> 被提出用来解决这效率低的问题。</p><p>Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接。市场上的大部分 Web 服务器，包括 iPlanet、IIS 和 Apache，都支持 HTTP Keep-Alive。对于提供静态内容的网站来说，这个功能通常很有用。但是，对于负担较重的网站来说，这里存在另外一个问题：虽然为客户保留打开的连接有一定的好处，但它同样影响了性能，<code>因为在处理暂停期间，本来可以释放的资源仍旧被占用。当Web服务器和应用服务器在同一台机器上运行时，Keep-Alive 功能对资源利用的影响尤其突出。</code></p><p>这样一来，客户端和服务器之间的 HTTP 连接就会被保持，不会断开（超过 Keep-Alive 规定的时间，意外断电等情况除外），当客户端发送另外一个请求时，就使用这条已经建立的连接。</p><a id="more"></a><h4 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h4><p>协议的状态是指<code>下一次传输</code>可以“记住”<code>这次传输</code>信息的能力，http是不会为了下一次连接而维护这次连接所传输的信息的.<br>HTTP无状态是指，当浏览器发送请求给服务器的时候，服务器响应，但是同一个浏览器再发送请求给服务器的时候，它会响应，但是他不知道你就是刚才那个浏览器，简单地说，就是服务器不会去记得你，所以是无状态协议。</p><p>无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送 HTTP 请求之后，服务器根据请求，会给我们发送数据过来，但是，发送完，不会记录任何信息。<br><code>HTTP 是一个无状态协议，这意味着每个请求都是独立的，Keep-Alive 没能改变这个结果。</code><br>HTTP 协议这种特性有优点也有缺点，优点在于解放了服务器，每一次请求“点到为止”不会造成不必要连接占用，缺点在于每次请求可能会传输大量重复的内容信息。</p><blockquote><p>ps:客户端与服务器进行动态交互的 Web 应用程序出现之后，HTTP 无状态的特性严重阻碍了这些应用程序的实现，毕竟交互是需要承前启后的，简单的购物车程序也要知道用户到底在之前选择了什么商品。于是，两种用于保持 HTTP 连接状态的技术就应运而生了，一个是 <code>Cookie</code>，而另一个则是 <code>Session</code>。</p></blockquote><hr><p>本文来自 Mike__Jiang 的CSDN 博客 ，全文地址请点击：<a href="https://blog.csdn.net/tennysonsky/article/details/44562435?utm_source=copy" target="_blank" rel="noopener">https://blog.csdn.net/tennysonsky/article/details/44562435?utm_source=copy</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP 是一个属于应用层的面向对象的协议，HTTP 协议一共有五大特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;支持客户/服务器模式；&lt;/li&gt;
&lt;li&gt;简单快速；&lt;/li&gt;
&lt;li&gt;灵活；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;无连接&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;无状态&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;无连接&quot;&gt;&lt;a href=&quot;#无连接&quot; class=&quot;headerlink&quot; title=&quot;无连接&quot;&gt;&lt;/a&gt;无连接&lt;/h4&gt;&lt;p&gt;&lt;code&gt;无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ps:早期这么做的原因是 HTTP 协议产生于互联网，因此服务器需要处理同时面向全世界数十万、上百万客户端的网页访问，但每个客户端（即浏览器）与服务器之间交换数据的间歇性较大（即传输具有突发性、瞬时性），并且网页浏览的联想性、发散性导致两次传送的数据关联性很低，大部分通道实际上会很空闲、无端占用资源。因此 &lt;code&gt;HTTP 的设计者有意利用这种特点将协议设计为请求时建连接、请求完释放连接，以尽快将资源释放出来服务其他客户端&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;随着时间的推移，网页变得越来越复杂，里面可能嵌入了很多图片，这时候每次访问图片都需要建立一次 TCP 连接就显得很低效。后来，&lt;code&gt;Keep-Alive&lt;/code&gt; 被提出用来解决这效率低的问题。&lt;/p&gt;
&lt;p&gt;Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接。市场上的大部分 Web 服务器，包括 iPlanet、IIS 和 Apache，都支持 HTTP Keep-Alive。对于提供静态内容的网站来说，这个功能通常很有用。但是，对于负担较重的网站来说，这里存在另外一个问题：虽然为客户保留打开的连接有一定的好处，但它同样影响了性能，&lt;code&gt;因为在处理暂停期间，本来可以释放的资源仍旧被占用。当Web服务器和应用服务器在同一台机器上运行时，Keep-Alive 功能对资源利用的影响尤其突出。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这样一来，客户端和服务器之间的 HTTP 连接就会被保持，不会断开（超过 Keep-Alive 规定的时间，意外断电等情况除外），当客户端发送另外一个请求时，就使用这条已经建立的连接。&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="http://kunxiang.wang/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://kunxiang.wang/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>JSP相关概念</title>
    <link href="http://kunxiang.wang/2018/09/28/JSP%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
    <id>http://kunxiang.wang/2018/09/28/JSP相关概念/</id>
    <published>2018-09-28T02:49:49.000Z</published>
    <updated>2018-09-28T04:38:37.566Z</updated>
    
    <content type="html"><![CDATA[<h4 id="JSP内置对象："><a href="#JSP内置对象：" class="headerlink" title="JSP内置对象："></a>JSP内置对象：</h4><ol><li><p><code>request</code>：负责得到客户端请求的信息，对应类型：javax.servlet.http.HttpServletRequest</p></li><li><p><code>response</code>:负责向客户端发出响应，对应类型：javax.servlet.http.HttpServletResponse</p></li><li><p><code>session</code>:负责保存同一客户端一次会话过程中的一些信息，对应类型：javax.servlet.http.httpsession</p></li><li><p><code>out</code>: 负责管理对客户端的输出，对应类型：javax.serlvet.jsp.jspwriter</p></li><li><p><code>application</code>:表示整个应用环境的信息，对应类型：javax.servlet.servletcontext</p></li><li><p><code>config</code>:表示ServletConfig，对应类型：javax.servlet.servletconfig</p></li><li><p><code>exception</code>:表示页面中发生的异常，可以通过它获得页面异常信息，对应类型：java.lang.exception</p></li><li><p><code>pagecontext</code>:表示这个JSP页面上下文，对应类型：javax.servlet.jsp.pagecontext</p></li><li><p><code>page</code>:表示当前JSP页面本身。</p></li></ol><a id="more"></a><h4 id="JSP的四种作用域"><a href="#JSP的四种作用域" class="headerlink" title="JSP的四种作用域"></a>JSP的四种作用域</h4><ol><li><p><code>page</code>是代表一个页面相关的对象和属性。一个页面由一个编译好的java servlet类（可以带有include指令，但不可以带有include动作）表示。这既包括servlet又包括编译成servlet的jsp页面。</p></li><li><p><code>request</code>是代表与web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个web组件（由于<code>forward</code>指令和<code>include</code>动作的关系）</p></li><li><p><code>session</code>是代表与用于某个web客户机的一个用户体验相关的对象和属性。一个web回话也可以经常跨域多个客户机请求。</p></li><li><p><code>application</code>是代表与整个web应用程序相关的对象和属性。这实质上是跨域整个web应用程序，包括多个页面、请求和回话的一个全局作用域</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;JSP内置对象：&quot;&gt;&lt;a href=&quot;#JSP内置对象：&quot; class=&quot;headerlink&quot; title=&quot;JSP内置对象：&quot;&gt;&lt;/a&gt;JSP内置对象：&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;request&lt;/code&gt;：负责得到客户端请求的信息，对应类型：javax.servlet.http.HttpServletRequest&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;response&lt;/code&gt;:负责向客户端发出响应，对应类型：javax.servlet.http.HttpServletResponse&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;session&lt;/code&gt;:负责保存同一客户端一次会话过程中的一些信息，对应类型：javax.servlet.http.httpsession&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;out&lt;/code&gt;: 负责管理对客户端的输出，对应类型：javax.serlvet.jsp.jspwriter&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;application&lt;/code&gt;:表示整个应用环境的信息，对应类型：javax.servlet.servletcontext&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;config&lt;/code&gt;:表示ServletConfig，对应类型：javax.servlet.servletconfig&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;exception&lt;/code&gt;:表示页面中发生的异常，可以通过它获得页面异常信息，对应类型：java.lang.exception&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;pagecontext&lt;/code&gt;:表示这个JSP页面上下文，对应类型：javax.servlet.jsp.pagecontext&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;page&lt;/code&gt;:表示当前JSP页面本身。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
