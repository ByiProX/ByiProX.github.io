<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Quentin&#39;s Blog</title>
  
  <subtitle>每天进步一点点</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-19T18:00:53.753Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ByiProX</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一次完整的HTTP请求流程</title>
    <link href="http://yoursite.com/2018/03/20/%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/03/20/一次完整的HTTP请求流程/</id>
    <published>2018-03-19T17:34:08.000Z</published>
    <updated>2018-03-19T18:00:53.753Z</updated>
    
    <content type="html"><![CDATA[<p>HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤：</p><h2 id="1-建立TCP连接："><a href="#1-建立TCP连接：" class="headerlink" title="1. 建立TCP连接："></a>1. 建立TCP连接：</h2><p>在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，</p><p>即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能进行更高层协议的连接，</p><p>因此，首先要建立TCP连接，一般TCP连接的端口号是80。</p><h2 id="2-Web浏览器向Web服务器发送请求命令："><a href="#2-Web浏览器向Web服务器发送请求命令：" class="headerlink" title="2. Web浏览器向Web服务器发送请求命令："></a>2. Web浏览器向Web服务器发送请求命令：</h2><p>一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET/sample/hello.jsp HTTP/1.1。</p><h2 id="3-Web浏览器发送请求头信息-："><a href="#3-Web浏览器发送请求头信息-：" class="headerlink" title="3. Web浏览器发送请求头信息 ："></a>3. Web浏览器发送请求头信息 ：</h2><p>浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。</p><h2 id="4-Web服务器应答-："><a href="#4-Web服务器应答-：" class="headerlink" title="4. Web服务器应答 ："></a>4. Web服务器应答 ：</h2><p>客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。</p><h2 id="5-Web服务器发送应答头信息："><a href="#5-Web服务器发送应答头信息：" class="headerlink" title="5. Web服务器发送应答头信息："></a>5. Web服务器发送应答头信息：</h2><p>正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。</p><h2 id="6-Web服务器向浏览器发送数据："><a href="#6-Web服务器向浏览器发送数据：" class="headerlink" title="6. Web服务器向浏览器发送数据："></a>6. Web服务器向浏览器发送数据：</h2><p>Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。</p><h2 id="7-Web服务器关闭TCP连接-："><a href="#7-Web服务器关闭TCP连接-：" class="headerlink" title="7. Web服务器关闭TCP连接 ："></a>7. Web服务器关闭TCP连接 ：</h2><p>一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：Connection:keep-alive；</p><p>TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p><a id="more"></a><p><img src="https://upload-images.jianshu.io/upload_images/2952111-d8db37f9da639c61.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="http请求.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤：&lt;/p&gt;
&lt;h2 id=&quot;1-建立TCP连接：&quot;&gt;&lt;a href=&quot;#1-建立TCP连接：&quot; class=&quot;headerlink&quot; title=&quot;1. 建立TCP连接：&quot;&gt;&lt;/a&gt;1. 建立TCP连接：&lt;/h2&gt;&lt;p&gt;在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，&lt;/p&gt;
&lt;p&gt;即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能进行更高层协议的连接，&lt;/p&gt;
&lt;p&gt;因此，首先要建立TCP连接，一般TCP连接的端口号是80。&lt;/p&gt;
&lt;h2 id=&quot;2-Web浏览器向Web服务器发送请求命令：&quot;&gt;&lt;a href=&quot;#2-Web浏览器向Web服务器发送请求命令：&quot; class=&quot;headerlink&quot; title=&quot;2. Web浏览器向Web服务器发送请求命令：&quot;&gt;&lt;/a&gt;2. Web浏览器向Web服务器发送请求命令：&lt;/h2&gt;&lt;p&gt;一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET/sample/hello.jsp HTTP/1.1。&lt;/p&gt;
&lt;h2 id=&quot;3-Web浏览器发送请求头信息-：&quot;&gt;&lt;a href=&quot;#3-Web浏览器发送请求头信息-：&quot; class=&quot;headerlink&quot; title=&quot;3. Web浏览器发送请求头信息 ：&quot;&gt;&lt;/a&gt;3. Web浏览器发送请求头信息 ：&lt;/h2&gt;&lt;p&gt;浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。&lt;/p&gt;
&lt;h2 id=&quot;4-Web服务器应答-：&quot;&gt;&lt;a href=&quot;#4-Web服务器应答-：&quot; class=&quot;headerlink&quot; title=&quot;4. Web服务器应答 ：&quot;&gt;&lt;/a&gt;4. Web服务器应答 ：&lt;/h2&gt;&lt;p&gt;客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。&lt;/p&gt;
&lt;h2 id=&quot;5-Web服务器发送应答头信息：&quot;&gt;&lt;a href=&quot;#5-Web服务器发送应答头信息：&quot; class=&quot;headerlink&quot; title=&quot;5. Web服务器发送应答头信息：&quot;&gt;&lt;/a&gt;5. Web服务器发送应答头信息：&lt;/h2&gt;&lt;p&gt;正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。&lt;/p&gt;
&lt;h2 id=&quot;6-Web服务器向浏览器发送数据：&quot;&gt;&lt;a href=&quot;#6-Web服务器向浏览器发送数据：&quot; class=&quot;headerlink&quot; title=&quot;6. Web服务器向浏览器发送数据：&quot;&gt;&lt;/a&gt;6. Web服务器向浏览器发送数据：&lt;/h2&gt;&lt;p&gt;Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。&lt;/p&gt;
&lt;h2 id=&quot;7-Web服务器关闭TCP连接-：&quot;&gt;&lt;a href=&quot;#7-Web服务器关闭TCP连接-：&quot; class=&quot;headerlink&quot; title=&quot;7. Web服务器关闭TCP连接 ：&quot;&gt;&lt;/a&gt;7. Web服务器关闭TCP连接 ：&lt;/h2&gt;&lt;p&gt;一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：Connection:keep-alive；&lt;/p&gt;
&lt;p&gt;TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>三次握手 | 四次挥手</title>
    <link href="http://yoursite.com/2018/03/19/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%20%7C%20%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>http://yoursite.com/2018/03/19/三次握手 | 四次挥手/</id>
    <published>2018-03-19T15:30:52.000Z</published>
    <updated>2018-03-19T16:01:53.251Z</updated>
    
    <content type="html"><![CDATA[<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p><strong>第一次握手</strong></p><p>建立连接时，客户端发送<code>syn包（syn=j）</code>到服务器，并进入SYN_SENT状态，等待服务器确认；<br>SYN即<code>同步序列编号</code>(synchronize sequence numbers)。</p><p><strong>第二次握手</strong></p><p>服务器收到<code>syn包</code>，必须确认客户的SYN（ack = j+1）,同时自己也发送一个SYN包（syn=k），即发<code>送SYN和ACK包</code>，此时服务器进入<code>SYN_RECV</code>状态。</p><p><strong>第三次握手</strong></p><p>客户端收到服务器的<code>SYN+ACK包</code>，向服务器发送确认<code>包ACK（ack=k+1）</code>，此包发送完毕，客户端和服务器进入<code>ESTABLISHED</code>状态，TCP连接成功，完成三次握手。</p><p>完成上述三次握手后，客户端和服务器开始传送数据。</p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>对于一个已经建立的连接，TCP使用改进的三次握手来释放连接（使用一个带有FIN附加标记的字段）。TCP关闭连接的步骤如下</p><ol><li>当主机A的应用程序通知TCP数据已经发送完毕时，TCP向主机B发送一个带有FIN附加标记的报文段（FIN=finish）</li><li>当主机B收到这个FIN报文段之后，并不立即用FIN报文回复主机A，而是想主机A发送一个确认序号ACK，同时通知自己的应用程序：对方要求关闭连接。【先发送ACK的目的是为了防止在这段时间内，对方重传FIN报文】</li><li>主机B的应用程序告诉TCP：我要彻底关闭连接，TCP向主机A发送一个FIN报文段。</li><li>主机A收到这个FIN报文段后，向主机B发送一个ACK表示连接彻底释放。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;三次握手&quot;&gt;&lt;a href=&quot;#三次握手&quot; class=&quot;headerlink&quot; title=&quot;三次握手&quot;&gt;&lt;/a&gt;三次握手&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;第一次握手&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;建立连接时，客户端发送&lt;code&gt;syn包（syn=j）&lt;/co
      
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Python3 回文字符串的判断</title>
    <link href="http://yoursite.com/2018/03/19/Python3-%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A4%E6%96%AD/"/>
    <id>http://yoursite.com/2018/03/19/Python3-回文字符串的判断/</id>
    <published>2018-03-19T10:25:12.000Z</published>
    <updated>2018-03-19T10:33:22.228Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(str_)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(str_) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">if</span> str_[<span class="number">0</span>] != str_[<span class="number">-1</span>]:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isPalindrome(str_[<span class="number">1</span>:<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Python3 单例模式</title>
    <link href="http://yoursite.com/2018/03/19/Python3-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/03/19/Python3-单例模式/</id>
    <published>2018-03-19T05:44:05.000Z</published>
    <updated>2018-03-19T09:13:44.103Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式（Singleton Pattern）是最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。<br>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><p><strong>注意：</strong></p><ul><li>1、单例类只能有一个实例。</li><li>2、单例类必须自己创建自己的唯一实例。</li><li>3、单例类必须给所有其他对象提供这一实例。<a id="more"></a><h2 id="单例模式介绍"><a href="#单例模式介绍" class="headerlink" title="单例模式介绍"></a>单例模式介绍</h2><strong>意图：</strong> 保证一个类仅有一个实例，并提供一个访问它的全局访问点。</li></ul><p><strong>主要解决：</strong> 一个全局使用的类频繁地创建与销毁。</p><p><strong>何时使用：</strong> 当您想控制实例数目，节省系统资源的时候。</p><p><strong>如何解决：</strong> 判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p><p><strong>关键代码：</strong> 构造函数是私有的。</p><p><strong>应用实例：</strong> 1、一个党只能有一个主席。 2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。 3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</p><p><strong>优点：</strong> 1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。 2、避免对资源的多重占用（比如写文件操作）。</p><p><strong>缺点：</strong> 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p><p><strong>使用场景：</strong> 1、要求生产唯一序列号。 2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</p><p><strong>注意事项：</strong> getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。</p><h2 id="单例模式的实现"><a href="#单例模式的实现" class="headerlink" title="单例模式的实现"></a>单例模式的实现</h2><p>在 Python 中，我们可以用多种方法来实现单例模式：</p><ul><li>使用基类 <code>__new__</code></li><li>使用模块</li><li>使用装饰器（decorator）</li><li>使用元类（metaclass）</li></ul><h3 id="使用基类-new"><a href="#使用基类-new" class="headerlink" title="使用基类 __new__"></a>使用基类 <code>__new__</code></h3><p><code>__new__</code> 是真正创建实例对象的方法，所以重写基类的<code>__new__</code>方法，以此来保证创建对象的时候只生成一个实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">'_instance'</span>):</span><br><span class="line">            cls._instance = super(Singleton, cls).__new__(cls, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls._instance  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(Singleton)</span>:</span>  </span><br><span class="line">    a = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，我们将类的实例和一个类变量 <code>_instance</code> 关联起来，如果 <code>cls._instance</code> 为 None 则创建实例，否则直接返回 <code>cls._instance</code>。执行结果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>one = MyClass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>two = MyClass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one == two</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one <span class="keyword">is</span> two</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(one), id(two)</span><br><span class="line">(<span class="number">4303862608</span>, <span class="number">4303862608</span>)</span><br></pre></td></tr></table></figure></p><h3 id="使用元类"><a href="#使用元类" class="headerlink" title="使用元类"></a>使用元类</h3><p>元类（参考：<a href="http://blog.jobbole.com/21351/" target="_blank" rel="noopener">深刻理解Python中的元类</a>）是用于创建类对象的类，类对象创建实例对象时一定会调用<code>__call__</code>方法，因此在调用<code>__call__</code>时候保证始终只创建一个实例即可，<code>type</code>是python中的一个元类。</p><p>元类（metaclass）可以控制类的创建过程，它主要做三件事：</p><ul><li>拦截类的创建</li><li>修改类的定义</li><li>返回修改后的类</li></ul><p>使用元类实现单例模式的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">'_instance'</span>):</span><br><span class="line">            cls._instance = super(Singleton, cls).__call__(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(metaclass=Singleton)</span>:</span>  </span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 执行结果如下</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one = MyClass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>two = MyClass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one == two</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one <span class="keyword">is</span> two</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(one), id(two)</span><br><span class="line">(<span class="number">4303862608</span>, <span class="number">4303862608</span>)</span><br></pre></td></tr></table></figure><h3 id="使用装饰器"><a href="#使用装饰器" class="headerlink" title="使用装饰器"></a>使用装饰器</h3><p>装饰器（decorator）可以动态地修改一个类或函数的功能。这里，我们也可以使用装饰器来装饰某个类，使其只能生成一个实例，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span><span class="params">(cls)</span>:</span></span><br><span class="line">    instances = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">            instances[cls] = cls(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> instances[cls]</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>在上面，我们定义了一个装饰器 singleton，它返回了一个内部函数 <code>warpper</code>，该函数会判断某个类是否在字典 instances 中，如果不存在，则会将 cls 作为 key，<code>cls(*args, **kw)</code> 作为 value 存到 instances 中，否则，直接返回 instances[cls]</p><h3 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h3><p>Python 的模块就是天然的单例模式，因为模块在第一次导入时，会生成 .pyc 文件，当第二次导入时，就会直接加载 .pyc 文件，而不会再次执行模块代码。因此，我们只需把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了。如果我们真的想要一个单例类，可以考虑这样做：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysingleton.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">My_Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">my_singleton = My_Singleton()</span><br></pre></td></tr></table></figure></p><p>将上面的代码保存在文件 mysingleton.py 中，然后这样使用:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> mysingleton <span class="keyword">import</span> my_singleton</span><br><span class="line"></span><br><span class="line">my_singleton.foo()</span><br></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://python.jobbole.com/87294/" target="_blank" rel="noopener">http://python.jobbole.com/87294/</a></li><li><a href="http://python.jobbole.com/87791/?utm_source=blog.jobbole.com&amp;utm_medium=relatedPosts" target="_blank" rel="noopener">http://python.jobbole.com/87791/?utm_source=blog.jobbole.com&amp;utm_medium=relatedPosts</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例模式（Singleton Pattern）是最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。&lt;br&gt;这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、单例类只能有一个实例。&lt;/li&gt;
&lt;li&gt;2、单例类必须自己创建自己的唯一实例。&lt;/li&gt;
&lt;li&gt;3、单例类必须给所有其他对象提供这一实例。
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python3 基于链表技术实现栈</title>
    <link href="http://yoursite.com/2018/03/17/Python3-%E5%9F%BA%E4%BA%8E%E9%93%BE%E8%A1%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
    <id>http://yoursite.com/2018/03/17/Python3-基于链表技术实现栈/</id>
    <published>2018-03-17T07:40:12.000Z</published>
    <updated>2018-03-18T20:13:11.735Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义异常类"><a href="#定义异常类" class="headerlink" title="定义异常类"></a>定义异常类</h2><p>实现栈结构之前，先考虑为操作失败的处理定义一个异常类。在这里通过继承已有的异常类定义自己的异常类。由于栈操作(如空栈弹出)时不满足需要可以看做参数值错误，采用下面的定义<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackUnderflow</span><span class="params">(ValueError)</span>:</span>  <span class="comment"># 栈下溢，空栈访问</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><h2 id="定义一个表结点类"><a href="#定义一个表结点类" class="headerlink" title="定义一个表结点类"></a>定义一个表结点类</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, elem, next_=None)</span>:</span></span><br><span class="line">        self.elem = elem</span><br><span class="line">        self.next = next_</span><br></pre></td></tr></table></figure><p>方法的第二个参数用名字<code>next_</code>，是为了避免与Python<code>标准函数next</code>重名</p><a id="more"></a><h2 id="栈的链接表实现"><a href="#栈的链接表实现" class="headerlink" title="栈的链接表实现"></a>栈的链接表实现</h2><p>由于所有栈的操作都在线性表的一端进行，采用链接表技术，自然应该用表头一端作为栈顶，表尾作为栈底，是操作实现方便，效率也高。按照这种安排，容易定义出一个链接栈类。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LStack</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._top = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._top <span class="keyword">is</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self._top <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> StackUnderflow(<span class="string">'in LStack.top()'</span>)</span><br><span class="line">        <span class="keyword">return</span> self._top.elem</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, elem)</span>:</span></span><br><span class="line">        self._top = LNode(elem, self._top)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self._top <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> StackUnderflow(<span class="string">'in LStack.pop()'</span>)</span><br><span class="line">        p = self._top</span><br><span class="line">        self._top = p.next</span><br><span class="line">        <span class="keyword">return</span> p.elem</span><br></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>《数据结构与算法Python语言描述》 — 裘宗燕</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义异常类&quot;&gt;&lt;a href=&quot;#定义异常类&quot; class=&quot;headerlink&quot; title=&quot;定义异常类&quot;&gt;&lt;/a&gt;定义异常类&lt;/h2&gt;&lt;p&gt;实现栈结构之前，先考虑为操作失败的处理定义一个异常类。在这里通过继承已有的异常类定义自己的异常类。由于栈操作(如空栈弹出)时不满足需要可以看做参数值错误，采用下面的定义&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;StackUnderflow&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ValueError)&lt;/span&gt;:&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;# 栈下溢，空栈访问&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;pass&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;定义一个表结点类&quot;&gt;&lt;a href=&quot;#定义一个表结点类&quot; class=&quot;headerlink&quot; title=&quot;定义一个表结点类&quot;&gt;&lt;/a&gt;定义一个表结点类&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;LNode&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, elem, next_=None)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.elem = elem&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.next = next_&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;方法的第二个参数用名字&lt;code&gt;next_&lt;/code&gt;，是为了避免与Python&lt;code&gt;标准函数next&lt;/code&gt;重名&lt;/p&gt;
    
    </summary>
    
      <category term="Data Structures" scheme="http://yoursite.com/categories/Data-Structures/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="Data Structures" scheme="http://yoursite.com/tags/Data-Structures/"/>
    
  </entry>
  
  <entry>
    <title>Python3 基于顺序表技术实现栈类</title>
    <link href="http://yoursite.com/2018/03/17/Python3-%E5%9F%BA%E4%BA%8E%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E6%A0%88%E7%B1%BB/"/>
    <id>http://yoursite.com/2018/03/17/Python3-基于顺序表技术实现栈类/</id>
    <published>2018-03-17T06:40:55.000Z</published>
    <updated>2018-03-17T07:12:09.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义异常类"><a href="#定义异常类" class="headerlink" title="定义异常类"></a>定义异常类</h2><p>实现栈结构之前，先考虑为操作失败的处理定义一个异常类。在这里通过继承已有的异常类定义自己的异常类。由于栈操作(如空栈弹出)时不满足需要可以看做参数值错误，采用下面的定义<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackUnderflow</span><span class="params">(ValueError)</span>:</span>  <span class="comment"># 栈下溢，空栈访问</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><p>上面把异常<code>StackUnderflow</code>定义为<code>ValueError</code>子类，只简单定义了一个类名，类体部分只有一个<code>pass</code>语句，未定义任何新属性，因为不准备提供<code>ValueError</code>之外的新功能，只是想与其他<code>ValueError</code>异常有所区分，程序出错时能产生不同的错误信息。必要时可以定义专门的异常处理操作。自定义异常与python内置异常类似，同样通过<code>except</code>进行捕捉和处理，但只能通过<code>raise</code>语句引发。</p><a id="more"></a><h2 id="栈类定义"><a href="#栈类定义" class="headerlink" title="栈类定义"></a>栈类定义</h2><p>把list当做栈使用时，完全可以满足应用需要。但是，这样建立的对象实际上还是list，提供了list类型的所有操作。特别是提供了一大批栈结构原本不应该支持的操作，威胁栈的使用安全性(例如，栈要求未经弹出的元素应该存在，但表运行任意删除)。另外，这样的“栈”不是一个独立的类型，因此没有独立类型的所有重要性质。</p><p>为了概念更清晰，实现更安全，操作名也更容易理解，，可以考虑使用顺序表定义一个栈类，使之成为一个独立的类型，把Python的list隐藏在类内部，作为其实现基础。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">基于顺序表实现栈类</span></span><br><span class="line"><span class="string">用list对象 _elems存储栈中的元素</span></span><br><span class="line"><span class="string">所有的栈操作都映射到list操作</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SStack</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._elems = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._elems == []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self._elems == []:</span><br><span class="line">            <span class="keyword">raise</span> StackUnderflow(<span class="string">'in SStack.top()'</span>)</span><br><span class="line">        <span class="keyword">return</span> self._elems[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, elem)</span>:</span></span><br><span class="line">        self._elems.append(elem)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self._elems == []:</span><br><span class="line">            <span class="keyword">raise</span> StackUnderflow(<span class="string">'in SStack.pop()'</span>)</span><br><span class="line">        <span class="keyword">return</span> self._elems.pop()</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>《数据结构与算法Python语言描述》 — 裘宗燕</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义异常类&quot;&gt;&lt;a href=&quot;#定义异常类&quot; class=&quot;headerlink&quot; title=&quot;定义异常类&quot;&gt;&lt;/a&gt;定义异常类&lt;/h2&gt;&lt;p&gt;实现栈结构之前，先考虑为操作失败的处理定义一个异常类。在这里通过继承已有的异常类定义自己的异常类。由于栈操作(如空栈弹出)时不满足需要可以看做参数值错误，采用下面的定义&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;StackUnderflow&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ValueError)&lt;/span&gt;:&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;# 栈下溢，空栈访问&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;pass&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面把异常&lt;code&gt;StackUnderflow&lt;/code&gt;定义为&lt;code&gt;ValueError&lt;/code&gt;子类，只简单定义了一个类名，类体部分只有一个&lt;code&gt;pass&lt;/code&gt;语句，未定义任何新属性，因为不准备提供&lt;code&gt;ValueError&lt;/code&gt;之外的新功能，只是想与其他&lt;code&gt;ValueError&lt;/code&gt;异常有所区分，程序出错时能产生不同的错误信息。必要时可以定义专门的异常处理操作。自定义异常与python内置异常类似，同样通过&lt;code&gt;except&lt;/code&gt;进行捕捉和处理，但只能通过&lt;code&gt;raise&lt;/code&gt;语句引发。&lt;/p&gt;
    
    </summary>
    
      <category term="Data Structures" scheme="http://yoursite.com/categories/Data-Structures/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="Data Structures" scheme="http://yoursite.com/tags/Data-Structures/"/>
    
  </entry>
  
  <entry>
    <title>Python3 实现二叉树前、中、后序遍历及按层遍历</title>
    <link href="http://yoursite.com/2018/03/15/Python3-%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E3%80%81%E4%B8%AD%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%8F%8A%E6%8C%89%E5%B1%82%E9%81%8D%E5%8E%86/"/>
    <id>http://yoursite.com/2018/03/15/Python3-实现二叉树前、中、后序遍历及按层遍历/</id>
    <published>2018-03-15T15:57:26.000Z</published>
    <updated>2018-03-18T20:12:31.302Z</updated>
    
    <content type="html"><![CDATA[<p>假设有这么一个二叉树如下：<br><img src="https://upload-images.jianshu.io/upload_images/2952111-707a1e95da262138.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="二叉树.png"></p><p>前序遍历结果：1, 2, 4, 5, 8, 9, 11, 3, 6, 7, 10<br>中序遍历结果：4, 2, 8, 5, 11, 9, 1, 6, 3, 10, 7<br>后序遍历结果：4, 8, 11, 9, 5, 2, 6, 10, 7, 3, 1</p><h2 id="二叉树的类实现"><a href="#二叉树的类实现" class="headerlink" title="二叉树的类实现"></a>二叉树的类实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value=None, left=None, right=None)</span>:</span></span><br><span class="line">        self.value = value</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    tree = Node(<span class="number">1</span>, Node(<span class="number">2</span>, Node(<span class="number">4</span>),</span><br><span class="line">                           Node(<span class="number">5</span>, Node(<span class="number">8</span>),</span><br><span class="line">                                   Node(<span class="number">9</span>, left=Node(<span class="number">11</span>)))),</span><br><span class="line">                   Node(<span class="number">3</span>, Node(<span class="number">6</span>),</span><br><span class="line">                           Node(<span class="number">7</span>, left=Node(<span class="number">10</span>))))</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h2><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前序遍历（递归）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pre_deep_func</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    print(root.value, end = <span class="string">' '</span>)  <span class="comment"># print 放到下一行 就是中序遍历，放到最后 就是后序遍历</span></span><br><span class="line">    pre_deep_func(root.left)</span><br><span class="line">    pre_deep_func(root.right)</span><br></pre></td></tr></table></figure><h3 id="非递归法"><a href="#非递归法" class="headerlink" title="非递归法"></a>非递归法</h3><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>根据已有的认识，此函数需要一个栈，保存树尚未访问过的部分信息。对于前序遍历也会有不同的实现方法，下面考虑一种方法，即：</p><ol><li>由于采取先序遍历，遇到结点就应该访问，下一步就应该沿着树的坐分支下行</li><li>但结点的右分支（右子树）还没有访问，因此需要记录，将右子结点入栈。</li><li>遇到空树时回溯，取出栈中保存的一个右分支，像一颗二叉树一样遍历它。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 方法一 常规打印</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorder_nonrec</span><span class="params">(root)</span>:</span></span><br><span class="line">    s = []</span><br><span class="line">    <span class="keyword">while</span> s <span class="keyword">or</span> root:</span><br><span class="line">        <span class="keyword">while</span> root:  <span class="comment"># 沿左分支下行</span></span><br><span class="line">            print(root.value, end = <span class="string">' '</span>)  <span class="comment"># 先处理根数据</span></span><br><span class="line">            s.append(root.right)          <span class="comment"># 右分支入栈</span></span><br><span class="line">            root = root.left</span><br><span class="line">        root = s.pop()                    <span class="comment">#  遇到空树，回溯</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 方法二 通过生成器函数遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorder_elements</span><span class="params">(root)</span>:</span></span><br><span class="line">    s = []</span><br><span class="line">    <span class="keyword">while</span> s <span class="keyword">or</span> root:</span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            s.append(root.right)</span><br><span class="line">            <span class="keyword">yield</span> root.value</span><br><span class="line">            root = root.left</span><br><span class="line">        root = s.pop()</span><br><span class="line"></span><br><span class="line"><span class="comment">## 方法三</span></span><br><span class="line"><span class="comment"># 前序遍历（根左右）:模拟压栈过程</span></span><br><span class="line"><span class="comment"># 入栈之前读（根、左），这样出栈时再读右（也是右结点子节点们的根）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pre_deep_func2</span><span class="params">(root)</span>:</span></span><br><span class="line">    a = []</span><br><span class="line">    <span class="keyword">while</span> a <span class="keyword">or</span> root:</span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            print(root.value, end = <span class="string">' '</span>)</span><br><span class="line">            a.append(root)  <span class="comment">## 根入栈</span></span><br><span class="line">            root = root.left</span><br><span class="line">        h = a.pop()</span><br><span class="line">        root = h.right</span><br></pre></td></tr></table></figure><p>非递归算法的一个价值是把算法过程完整的暴露出来，便于进行细致的分析。<br>时间复杂度：在非递归的算法中，因为在执行的过程中访问每个结点一次，一部分子树(所有右子树，方法一、二)被压入和弹出各一次(栈操作是O(1)时间)，所以整个遍历过程需要的时间复杂度为O(n)。<br>空间复杂度：这里的关键因素是遍历中栈可能达到的最大深度（栈中元素的最大深度个数），而栈的最大深度由被遍历的二叉树的高度决定。由于二叉树的高度可能达到O(n)，所以在最坏情况下，算法的空间复杂度为O(n)，n个结点的二叉树的平均高度为O(log n)，所以非递归前序遍历的平均空间复杂度为O(log n)。<br>在一些情况下，修改实现方法也可能降低空间的开销。对于上面函数，修改其定义，只把非空的右子树进栈，在很多情况下能减小一些空间开销。</p><p>其他非递归的遍历算法，包括中序遍历和后续遍历算法以及层次遍历算法，都可以直接了当的修改成迭代器。但是递归算法不可以。</p><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 中序遍历（左根右）:模拟压栈过程</span></span><br><span class="line"><span class="comment"># 出栈之后读（左、根），这样出栈后指针变更再读右</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mid_deep_func2</span><span class="params">(root)</span>:</span></span><br><span class="line">    a = []</span><br><span class="line">    <span class="keyword">while</span> a <span class="keyword">or</span> root:</span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            a.append(root)</span><br><span class="line">            root = root.left</span><br><span class="line">        h = a.pop()</span><br><span class="line">        <span class="keyword">print</span> h.value</span><br><span class="line">        root = h.right</span><br></pre></td></tr></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 后序遍历（左右根）:模拟逆序(根右左)存入数组b，然后再数组b逆序输出</span></span><br><span class="line"><span class="comment"># (根右左)与(根左右)类似，入栈a前读（根、右），出栈后指针变更再读左</span></span><br><span class="line"><span class="comment">## 方法 1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">after_deep_func2</span><span class="params">(root)</span>:</span></span><br><span class="line">    a = []</span><br><span class="line">    b = []</span><br><span class="line">    <span class="keyword">while</span> a <span class="keyword">or</span> root:</span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            b.append(root.value)</span><br><span class="line">            a.append(root.left)</span><br><span class="line">            root = root.right</span><br><span class="line">        root = a.pop()</span><br><span class="line">    print(b[::<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">## 方法2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">after_deep_func2</span><span class="params">(root)</span>:</span></span><br><span class="line">    a = []</span><br><span class="line">    b = []</span><br><span class="line">    <span class="keyword">while</span> a <span class="keyword">or</span> root:</span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            b.append(root.value)</span><br><span class="line">            a.append(root)</span><br><span class="line">            root = root.right</span><br><span class="line">        h = a.pop()</span><br><span class="line">        root = h.left</span><br><span class="line">    <span class="keyword">print</span> b[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">level_func</span><span class="params">(root)</span>:</span></span><br><span class="line">    a = []</span><br><span class="line">    a.append(root)</span><br><span class="line">    <span class="keyword">while</span> a:</span><br><span class="line">        head = a.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">print</span> head.value</span><br><span class="line">        <span class="keyword">if</span> head.left:</span><br><span class="line">            a.append(head.left)</span><br><span class="line">        <span class="keyword">if</span> head.right:</span><br><span class="line">            a.append(head.right)</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://blog.csdn.net/su92chen/article/details/70242822" target="_blank" rel="noopener">http://blog.csdn.net/su92chen/article/details/70242822</a></li><li>《数据结构与算法Python语言描述》 — 裘宗燕</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假设有这么一个二叉树如下：&lt;br&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2952111-707a1e95da262138.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;二叉树.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;前序遍历结果：1, 2, 4, 5, 8, 9, 11, 3, 6, 7, 10&lt;br&gt;中序遍历结果：4, 2, 8, 5, 11, 9, 1, 6, 3, 10, 7&lt;br&gt;后序遍历结果：4, 8, 11, 9, 5, 2, 6, 10, 7, 3, 1&lt;/p&gt;
&lt;h2 id=&quot;二叉树的类实现&quot;&gt;&lt;a href=&quot;#二叉树的类实现&quot; class=&quot;headerlink&quot; title=&quot;二叉树的类实现&quot;&gt;&lt;/a&gt;二叉树的类实现&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(object)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, value=None, left=None, right=None)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.value = value&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.left = left&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.right = right&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; __name__ == &lt;span class=&quot;string&quot;&gt;&quot;__main__&quot;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    tree = Node(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, Node(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, Node(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                           Node(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;, Node(&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                   Node(&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;, left=Node(&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;)))),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                   Node(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, Node(&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                           Node(&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;, left=Node(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;))))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Data Structures" scheme="http://yoursite.com/categories/Data-Structures/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="Data Structures" scheme="http://yoursite.com/tags/Data-Structures/"/>
    
  </entry>
  
  <entry>
    <title>什么是Socket(转)</title>
    <link href="http://yoursite.com/2018/03/13/%E4%BB%80%E4%B9%88%E6%98%AFSocket-%E8%BD%AC/"/>
    <id>http://yoursite.com/2018/03/13/什么是Socket-转/</id>
    <published>2018-03-12T16:49:26.000Z</published>
    <updated>2018-03-12T17:03:47.890Z</updated>
    
    <content type="html"><![CDATA[<p>对TCP/IP、UDP、Socket编程这些词你不会很陌生吧？随着网络技术的发展，这些词充斥着我们的耳朵。那么我想问：</p><ol><li>什么是TCP/IP、UDP？</li><li>Socket在哪里呢？</li><li>Socket是什么呢？</li><li>你会使用它们吗？</li></ol><h2 id="什么是TCP-IP、UDP"><a href="#什么是TCP-IP、UDP" class="headerlink" title="什么是TCP/IP、UDP"></a>什么是TCP/IP、UDP</h2><p>TCP/IP（Transmission Control Protocol/Internet Protocol）即传输控制协议/网间协议，是一个工业标准的协议集，它是为广域网（WANs）设计的。<br>UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是属于TCP/IP协议族中的一种。</p><p><img src="https://upload-images.jianshu.io/upload_images/2952111-571c60b933d42028.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.jpg"></p><a id="more"></a><p>TCP/IP协议族包括运输层、网络层、链路层。由上图可以知道TCP/IP与UDP的关系。</p><h2 id="Socket在哪里"><a href="#Socket在哪里" class="headerlink" title="Socket在哪里"></a>Socket在哪里</h2><p><img src="https://upload-images.jianshu.io/upload_images/2952111-1dd2ce6b61d08816.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.jpg"></p><h2 id="Socket是什么"><a href="#Socket是什么" class="headerlink" title="Socket是什么"></a>Socket是什么</h2><p>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>前人已经给我们做了好多的事了，网络间的通信也就简单了许多，但毕竟还是有挺多工作要做的。以前听到Socket编程，觉得它是比较高深的编程知识，但是只要弄清Socket编程的工作原理，神秘的面纱也就揭开了。<br>一个生活中的场景。你要打电话给一个朋友，先拨号，朋友听到电话铃声后提起电话，这时你和你的朋友就建立起了连接，就可以讲话了。等交流结束，挂断电话结束此次交谈。<br>生活中的场景就解释了这工作原理，也许TCP/IP协议族就是诞生于生活中，这也不一定。</p><p><img src="https://upload-images.jianshu.io/upload_images/2952111-99ebc49204f5b380.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.jpg"></p><p>先从服务器端说起。服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。</p><p>在这里我就举个简单的例子，我们走的是TCP协议这条路（见图2）。例子用MFC编写，运行的界面如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/2952111-36073682cf397e4f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.jpg"></p><p><img src="https://upload-images.jianshu.io/upload_images/2952111-61b92a5dbbb8bf69.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.jpg"></p><p>在客户端输入服务器端的IP地址和发送的数据，然后按发送按钮，服务器端接收到数据，然后回应客户端。客户端读取回应的数据，显示在界面上。</p><p>客户端就一个函数完成了一次通信。在这里IP地址为何用127.0.0.1呢？使用这个IP地址，服务器端和客户端就能运行在同一台机器上，这样调试方便多了。当然你可以在你朋友的机器上运行Server程序(本人在局域网中测试过)，在自己的机器上运行Client程序，当然输入的IP地址就该是你朋友机器的IP地址了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对TCP/IP、UDP、Socket编程这些词你不会很陌生吧？随着网络技术的发展，这些词充斥着我们的耳朵。那么我想问：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;什么是TCP/IP、UDP？&lt;/li&gt;
&lt;li&gt;Socket在哪里呢？&lt;/li&gt;
&lt;li&gt;Socket是什么呢？&lt;/li&gt;
&lt;li&gt;你会使用它们吗？&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;什么是TCP-IP、UDP&quot;&gt;&lt;a href=&quot;#什么是TCP-IP、UDP&quot; class=&quot;headerlink&quot; title=&quot;什么是TCP/IP、UDP&quot;&gt;&lt;/a&gt;什么是TCP/IP、UDP&lt;/h2&gt;&lt;p&gt;TCP/IP（Transmission Control Protocol/Internet Protocol）即传输控制协议/网间协议，是一个工业标准的协议集，它是为广域网（WANs）设计的。&lt;br&gt;UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是属于TCP/IP协议族中的一种。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2952111-571c60b933d42028.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;1.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Python3 实现遍历目录与子目录，并抓取.py文件</title>
    <link href="http://yoursite.com/2018/03/12/Python3-%E5%AE%9E%E7%8E%B0%E9%81%8D%E5%8E%86%E7%9B%AE%E5%BD%95%E4%B8%8E%E5%AD%90%E7%9B%AE%E5%BD%95%EF%BC%8C%E5%B9%B6%E6%8A%93%E5%8F%96-py%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/03/12/Python3-实现遍历目录与子目录，并抓取-py文件/</id>
    <published>2018-03-12T08:54:54.000Z</published>
    <updated>2018-03-12T09:04:15.759Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tree <span class="built_in">test</span></span><br><span class="line">.</span><br><span class="line">├── subtest1</span><br><span class="line">│   ├── subsubdir</span><br><span class="line">│   │   └── sub.py</span><br><span class="line">│   └── test1.py</span><br><span class="line">├── subtest2</span><br><span class="line">│   └── test2.py</span><br><span class="line">└── subtest3</span><br><span class="line">    └── test3.py</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. for-in dir/subdir to get the filesname  </span></span><br><span class="line"><span class="comment"># 2. splitext filename to filter  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getFiles</span><span class="params">(dir, suffix)</span>:</span>  </span><br><span class="line"></span><br><span class="line">    res = []  </span><br><span class="line">    <span class="keyword">for</span> root, directory, files <span class="keyword">in</span> os.walk(dir):  </span><br><span class="line">        <span class="keyword">for</span> filename <span class="keyword">in</span> files:  </span><br><span class="line">            name, suf = os.path.splitext(filename)  </span><br><span class="line">            <span class="keyword">if</span> suf == suffix:  </span><br><span class="line">                res.append(os.path.join(root, filename))  </span><br><span class="line">    <span class="keyword">return</span> res  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> getFiles(<span class="string">"./"</span>, <span class="string">'.py'</span>):  </span><br><span class="line">    print(file)</span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># ./walkdir.py</span></span><br><span class="line"><span class="comment"># ./subtest2/test2.py</span></span><br><span class="line"><span class="comment"># ./subtest3/test3.py</span></span><br><span class="line"><span class="comment"># ./subtest1/test1.py</span></span><br><span class="line"><span class="comment"># ./subtest1/subsubdir/sub.py</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Python3 os和sys模块的作用，以及常用的模块方法</title>
    <link href="http://yoursite.com/2018/03/12/Python3-os%E5%92%8Csys%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E6%A8%A1%E5%9D%97%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/03/12/Python3-os和sys模块的作用，以及常用的模块方法/</id>
    <published>2018-03-12T08:43:03.000Z</published>
    <updated>2018-03-12T08:49:03.868Z</updated>
    
    <content type="html"><![CDATA[<p>官方解释：</p><blockquote><p>os： This module provides a portable way of using operating system dependent functionality.</p></blockquote><p>翻译：提供一种方便的使用<code>操作系统函数</code>的方法。</p><blockquote><p>sys：This module provides access to some variables used or maintained by the interpreter and to functions that interact strongly with the interpreter.</p></blockquote><p>翻译：提供访问由<code>解释器</code>使用或维护的变量和在与<code>解释器交互</code>使用到的函数。</p><a id="more"></a><h2 id="os-常用方法"><a href="#os-常用方法" class="headerlink" title="os 常用方法"></a>os 常用方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">os.remove()  <span class="comment"># 删除文件  </span></span><br><span class="line">os.rename()  <span class="comment"># 重命名文件  </span></span><br><span class="line">os.walk()  <span class="comment"># 生成目录树下的所有文件名  </span></span><br><span class="line">os.chdir()  <span class="comment"># 改变目录  </span></span><br><span class="line">os.mkdir/makedirs  <span class="comment"># 创建目录/多层目录  </span></span><br><span class="line">os.rmdir/removedirs  <span class="comment"># 删除目录/多层目录  </span></span><br><span class="line">os.listdir()  <span class="comment"># 列出指定目录的文件  </span></span><br><span class="line">os.getcwd()  <span class="comment"># 取得当前工作目录  </span></span><br><span class="line">os.chmod()  <span class="comment"># 改变目录权限  </span></span><br><span class="line">os.path.basename()  <span class="comment"># 去掉目录路径，返回文件名  </span></span><br><span class="line">os.path.dirname()  <span class="comment"># 去掉文件名，返回目录路径  </span></span><br><span class="line">os.path.join()  <span class="comment"># 将分离的各部分组合成一个路径名  </span></span><br><span class="line">os.path.split()  <span class="comment"># 返回（dirname(),basename())元组  </span></span><br><span class="line">os.path.splitext()  <span class="comment"># 返回(filename,extension)元组  </span></span><br><span class="line">os.path.getatime|ctime|mtime   <span class="comment"># 分别返回最近访问、创建、修改时间  </span></span><br><span class="line">os.path.getsize()  <span class="comment"># 返回文件大小  </span></span><br><span class="line">os.path.exists()  <span class="comment"># 是否存在  </span></span><br><span class="line">os.path.isabs()  <span class="comment"># 是否为绝对路径  </span></span><br><span class="line">os.path.isdir()  <span class="comment"># 是否为目录  </span></span><br><span class="line">os.path.isfile()  <span class="comment"># 是否为文件</span></span><br></pre></td></tr></table></figure><h2 id="sys-常用方法"><a href="#sys-常用方法" class="headerlink" title="sys 常用方法"></a>sys 常用方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sys.argv           <span class="comment"># 命令行参数List，第一个元素是程序本身路径    </span></span><br><span class="line">sys.modules.keys() <span class="comment"># 返回所有已经导入的模块列表    </span></span><br><span class="line">sys.exc_info()     <span class="comment"># 获取当前正在处理的异常类,exc_type、exc_value、exc_traceback当前处理的异常详细信息    </span></span><br><span class="line">sys.exit(n)        <span class="comment"># 退出程序，正常退出时exit(0)    </span></span><br><span class="line">sys.hexversion     <span class="comment"># 获取Python解释程序的版本值，16进制格式如：0x020403F0    </span></span><br><span class="line">sys.version        <span class="comment"># 获取Python解释程序的版本信息    </span></span><br><span class="line">sys.maxint         <span class="comment"># 最大的Int值    </span></span><br><span class="line">sys.maxunicode     <span class="comment"># 最大的Unicode值    </span></span><br><span class="line">sys.modules        <span class="comment"># 返回系统导入的模块字段，key是模块名，value是模块    </span></span><br><span class="line">sys.path           <span class="comment"># 返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值    </span></span><br><span class="line">sys.platform       <span class="comment"># 返回操作系统平台名称    </span></span><br><span class="line">sys.stdout         <span class="comment"># 标准输出   </span></span><br><span class="line">sys.stdin          <span class="comment"># 标准输入   </span></span><br><span class="line">sys.stderr         <span class="comment"># 错误输出   </span></span><br><span class="line">sys.exc_clear()    <span class="comment"># 用来清除当前线程所出现的当前的或最近的错误信息   </span></span><br><span class="line">sys.exec_prefix    <span class="comment"># 返回平台独立的python文件安装的位置   </span></span><br><span class="line">sys.byteorder      <span class="comment"># 本地字节规则的指示器，big-endian平台的值是'big',little-endian平台的值是'little'   </span></span><br><span class="line">sys.copyright      <span class="comment"># 记录python版权相关的东西   </span></span><br><span class="line">sys.api_version    <span class="comment"># 解释器的C的API版本   </span></span><br><span class="line">sys.version_info</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;官方解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;os： This module provides a portable way of using operating system dependent functionality.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;翻译：提供一种方便的使用&lt;code&gt;操作系统函数&lt;/code&gt;的方法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sys：This module provides access to some variables used or maintained by the interpreter and to functions that interact strongly with the interpreter.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;翻译：提供访问由&lt;code&gt;解释器&lt;/code&gt;使用或维护的变量和在与&lt;code&gt;解释器交互&lt;/code&gt;使用到的函数。&lt;/p&gt;
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Tesseract的使用</title>
    <link href="http://yoursite.com/2018/03/12/Tesseract%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/03/12/Tesseract的使用/</id>
    <published>2018-03-12T04:35:36.000Z</published>
    <updated>2018-03-12T06:34:34.885Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Running-Tesseract-with-command-line"><a href="#Running-Tesseract-with-command-line" class="headerlink" title="Running Tesseract with command-line"></a>Running Tesseract with command-line</h2><p>Tesseract is a command-line program, so first open a terminal or command prompt. The command is used like this:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tesseract imagename outputbase [-l lang] [-psm pagesegmode] [configfile...]</span><br></pre></td></tr></table></figure></p><p>So basic usage to do OCR on an image called ‘myscan.png’ and save the result to ‘out.txt’ would be:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tesseract myscan.png out</span><br></pre></td></tr></table></figure></p><p>Or to do the same with German:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tesseract myscan.png out -l deu</span><br></pre></td></tr></table></figure></p><p>It can even be used with multiple languages traineddata at a time eg. English and German:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tesseract myscan.png out -l eng+deu</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>Tesseract also includes a hOCR mode, which produces a special HTML file with the coordinates of each word. This can be used to create a searchable pdf, using a tool such as <a href="https://exactcode.com/opensource/exactimage/" target="_blank" rel="noopener">Hocr2PDF</a>. To use it, use the ‘hocr’ config option, like this:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tesseract myscan.png out hocr</span><br></pre></td></tr></table></figure></p><p>You can also create a searchable pdf directly from tesseract ( versions &gt;=3.03):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tesseract myscan.png out pdf</span><br></pre></td></tr></table></figure></p><p>More information about the various options is available in the <a href="https://github.com/tesseract-ocr/tesseract/blob/master/doc/tesseract.1.asc" target="_blank" rel="noopener">Tesseract manpage</a>.</p><h3 id="Other-Languages"><a href="#Other-Languages" class="headerlink" title="Other Languages"></a>Other Languages</h3><p>Tesseract has been trained for <a href="https://github.com/tesseract-ocr/tesseract/blob/master/doc/tesseract.1.asc#languages" target="_blank" rel="noopener">many languages</a>, check for your language in the <a href="https://github.com/tesseract-ocr/tessdata" target="_blank" rel="noopener">Tessdata repository</a>.</p><p>For example, if we want Tesseract support Chinese language, just put <code>chi_sim.traineddata</code> into the path <code>/usr/local/Cellar/tesseract/3.05.01/share/tessdata/</code>。</p><p>It can also be trained to support other languages and scripts; for more details see <a href="https://github.com/tesseract-ocr/tesseract/wiki/TrainingTesseract" target="_blank" rel="noopener">TrainingTesseract</a>.</p><h2 id="Running-Tesseract-with-Python"><a href="#Running-Tesseract-with-Python" class="headerlink" title="Running Tesseract with Python"></a>Running Tesseract with Python</h2><p>Python-tesseract is an optical character recognition (OCR) tool for python. That is, it will recognize and “read” the text embedded in images.</p><h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><p><strong> Quick start </strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> pytesseract</span><br><span class="line"></span><br><span class="line">pytesseract.pytesseract.tesseract_cmd = <span class="string">'&lt;full_path_to_your_tesseract_executable&gt;'</span></span><br><span class="line"><span class="comment"># Include the above line, if you don't have tesseract executable in your PATH</span></span><br><span class="line"><span class="comment"># Example tesseract_cmd: 'C:\\Program Files (x86)\\Tesseract-OCR\\tesseract'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Simple image to string</span></span><br><span class="line">print(pytesseract.image_to_string(Image.open(<span class="string">'test.png'</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># French text image to string</span></span><br><span class="line">print(pytesseract.image_to_string(Image.open(<span class="string">'test-european.jpg'</span>), lang=<span class="string">'fra'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get bounding box estimates</span></span><br><span class="line">print(pytesseract.image_to_boxes(Image.open(<span class="string">'test.png'</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get verbose data including boxes, confidences, line and page numbers</span></span><br><span class="line">print(pytesseract.image_to_data(Image.open(<span class="string">'test.png'</span>)))</span><br></pre></td></tr></table></figure></p><p>Support for OpenCV image/NumPy array objects<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'/**path_to_image**/digits.png'</span>)</span><br><span class="line">print(pytesseract.image_to_string(img))</span><br><span class="line"><span class="comment"># OR explicit beforehand converting</span></span><br><span class="line">print(pytesseract.image_to_string(Image.fromarray(img))</span><br></pre></td></tr></table></figure></p><p>Add the following config, if you have tessdata error like: “Error opening data file…”<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tessdata_dir_config = <span class="string">'--tessdata-dir "&lt;replace_with_your_tessdata_dir_path&gt;"'</span></span><br><span class="line"><span class="comment"># Example config: '--tessdata-dir "C:\\Program Files (x86)\\Tesseract-OCR\\tessdata"'</span></span><br><span class="line"><span class="comment"># It's important to add double quotes around the dir path.</span></span><br><span class="line"></span><br><span class="line">pytesseract.image_to_string(image, lang=<span class="string">'chi_sim'</span>, config=tessdata_dir_config)</span><br></pre></td></tr></table></figure></p><p><strong>Functions</strong></p><ul><li><strong>image_to_string</strong> Returns the result of a Tesseract OCR run on the image to string</li><li><strong>image_to_boxes</strong> Returns result containing recognized characters and their box boundaries</li><li><strong>image_to_data</strong> Returns result containing box boundaries, confidences, and other information. Requires Tesseract 3.05+. For more information, please check the <a href="https://github.com/tesseract-ocr/tesseract/wiki/Command-Line-Usage#tsv-output-currently-available-in-305-dev-in-master-branch-on-github" target="_blank" rel="noopener">Tesseract TSV documentation</a></li></ul><p><strong>Parameters</strong></p><p><code>image_to_data(image, lang=None, config=&#39;&#39;, nice=0, output_type=Output.STRING)</code></p><ul><li><strong>image</strong> Object, PIL Image/NumPy array of the image to be processed by Tesseract</li><li><strong>lang</strong> String, Tesseract language code string</li><li><strong>config</strong> String, Any additional configurations as a string, ex: <code>config=&#39;--psm 6&#39;</code></li><li><strong>nice</strong> Integer, modifies the processor priority for the Tesseract run. Not supported on Windows. Nice adjusts the niceness of unix-like processes.</li><li><strong>output_type</strong> Class attribute, specifies the type of the output, defaults to <code>string</code>. For the full list of all supported types, please check the definition of <a href="https://github.com/madmaze/pytesseract/blob/master/src/pytesseract.py" target="_blank" rel="noopener">pytesseract.Output</a> class.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Running-Tesseract-with-command-line&quot;&gt;&lt;a href=&quot;#Running-Tesseract-with-command-line&quot; class=&quot;headerlink&quot; title=&quot;Running Tesseract with command-line&quot;&gt;&lt;/a&gt;Running Tesseract with command-line&lt;/h2&gt;&lt;p&gt;Tesseract is a command-line program, so first open a terminal or command prompt. The command is used like this:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;tesseract imagename outputbase [-l lang] [-psm pagesegmode] [configfile...]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;So basic usage to do OCR on an image called ‘myscan.png’ and save the result to ‘out.txt’ would be:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;tesseract myscan.png out&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Or to do the same with German:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;tesseract myscan.png out -l deu&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;It can even be used with multiple languages traineddata at a time eg. English and German:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;tesseract myscan.png out -l eng+deu&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Tesseract" scheme="http://yoursite.com/categories/Tesseract/"/>
    
    
      <category term="Tesseract" scheme="http://yoursite.com/tags/Tesseract/"/>
    
  </entry>
  
  <entry>
    <title>Python3 将两个排好序的列表合并成一个有序列表</title>
    <link href="http://yoursite.com/2018/03/12/Python3-%E5%B0%86%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%A5%BD%E5%BA%8F%E7%9A%84%E5%88%97%E8%A1%A8%E5%90%88%E5%B9%B6%E6%88%90%E4%B8%80%E4%B8%AA%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/03/12/Python3-将两个排好序的列表合并成一个有序列表/</id>
    <published>2018-03-11T16:11:27.000Z</published>
    <updated>2018-03-11T17:59:27.116Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_list</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> a:</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> b:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    a_index = b_index = <span class="number">0</span></span><br><span class="line">    ret = []</span><br><span class="line">    <span class="keyword">while</span> a_index &lt; len(a) <span class="keyword">and</span> b_index &lt; len(b):</span><br><span class="line">        <span class="keyword">if</span> a[a_index] &lt;= b[b_index]:</span><br><span class="line">            ret.append(a[a_index])</span><br><span class="line">            a_index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ret.append(b[b_index])</span><br><span class="line">            b_index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> a_index &lt; len(a):</span><br><span class="line">        ret.extend(a[a_index:])</span><br><span class="line">    <span class="keyword">if</span> b_index &lt; len(b):</span><br><span class="line">        ret.extend(b[b_index:])</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line">    b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line">    print(merge_list(a, b))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Python3 实现常见的各种排序方法</title>
    <link href="http://yoursite.com/2018/03/09/Python3-%E5%AE%9E%E7%8E%B0%E5%B8%B8%E8%A7%81%E7%9A%84%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/03/09/Python3-实现常见的各种排序方法/</id>
    <published>2018-03-09T07:56:09.000Z</published>
    <updated>2018-03-19T14:16:30.068Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序的思路：</p><ol><li>先从数列中取出一个数作为基准数。</li><li>分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边(假定从小到大排序)。</li><li>再对左右区间重复第二步，直到各区间只有一个数</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="string">"""快速排序"""</span></span><br><span class="line">    <span class="keyword">if</span> len(array) &lt; <span class="number">2</span>:  <span class="comment"># 基线条件：为空或者只有一个元素的数组是有序的</span></span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pivot = array[<span class="number">0</span>]  <span class="comment"># 递归条件,基准值</span></span><br><span class="line">        less = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i &lt;= pivot]  <span class="comment"># 所有小于基准值的元素组成的子数组</span></span><br><span class="line">        greater = [i <span class="keyword">for</span> i <span class="keyword">in</span> array[<span class="number">1</span>:] <span class="keyword">if</span> i &gt; pivot]  <span class="comment"># 所有大于基准值的元素组成的子数组</span></span><br><span class="line">        <span class="keyword">return</span> quicksort(less) + [pivot] + quicksort(greater)</span><br><span class="line"></span><br><span class="line">print(quicksort([<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">3</span>]))</span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="http://upload-images.jianshu.io/upload_images/2952111-d52e0c914f7272a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="快速排序"></p><p><img src="http://upload-images.jianshu.io/upload_images/2952111-03cf1024e51c6dee.gif?imageMogr2/auto-orient/strip" alt="20170801013540271.gif"></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序原理即：从数组下标为0的位置开始，比较下标位置为0和1的数据，如果0号位置的大，则交换位置，如果1号位置大，则什么也不做，然后右移一个位置，比较1号和2号的数据，和刚才的一样，如果1号的大，则交换位置，以此类推直至最后一个位置结束，到此数组中最大的元素就被排到了最后，之后再根据之前的步骤开始排前面的数据，直至全部数据都排序完成。</p><p>就是传说中的大的沉到底原则，适用于小量数据</p><p>冒泡排序思路: 每一趟只能将一个数归位, 如果有n个数进行排序,只需将n-1个数归位, 也就是说要进行n-1趟操作(已经归位的数不用再比较)</p><p>缺点: 冒泡排序解决了桶排序浪费空间的问题, 但是冒泡排序的效率特别低<br><img src="http://upload-images.jianshu.io/upload_images/2952111-020fcd7b86279da7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="冒泡排序"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span><span class="params">(relist)</span>:</span></span><br><span class="line">    <span class="string">"""冒泡排序"""</span></span><br><span class="line">    len_ = len(relist)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len_ - <span class="number">1</span>):  <span class="comment"># 这个循环负责设置冒泡排序进行的次数</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,len_-i<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> relist[j] &gt; relist[j+<span class="number">1</span>]:</span><br><span class="line">                relist[j+<span class="number">1</span>], relist[j] = relist[j], relist[j+<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> relist</span><br><span class="line"></span><br><span class="line">print(bubbleSort([<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">3</span>]))</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/2952111-e421e0f31170cb93.gif?imageMogr2/auto-orient/strip" alt="冒泡排序"></p><p>由上图看出最大的数一直沉到底部</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序基本原理：</p><ol><li>第1趟，在待排序记录r1 ~ r[n]中选出最小的记录，将它与r1交换；</li><li>第2趟，在待排序记录r2 ~ r[n]中选出最小的记录，将它与r2交换；</li><li>以此类推，第i趟在待排序记录r[i] ~ r[n]中选出最小的记录，将它与r[i]交换，使有序序列不断增长直到全部排序完毕。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectSort</span><span class="params">(relist)</span>:</span></span><br><span class="line">    len_ = len(relist)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len_):</span><br><span class="line">        min_index = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len_):  <span class="comment"># 这个循环会找到值比第i个索引所代表值小的索引</span></span><br><span class="line">            <span class="keyword">if</span> relist[j] &lt; relist[min_index]:</span><br><span class="line">                min_index = j</span><br><span class="line">        relist[i] ,relist[min_index] = relist[min_index], relist[i]  <span class="comment"># 互换两个索引位置</span></span><br><span class="line">    <span class="keyword">return</span> relist</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> selectSort([<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findSmallest</span><span class="params">(arr)</span>:</span></span><br><span class="line">    smallest = arr[<span class="number">0</span>]</span><br><span class="line">    smallest_index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(arr)):</span><br><span class="line">        <span class="keyword">if</span> arr[i] &lt; smallest:</span><br><span class="line">            smallest = arr[i]</span><br><span class="line">            smallest_index = i</span><br><span class="line">    <span class="keyword">return</span> smallest_index</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectionSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    newArr = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">        smallest = findSmallest(arr)</span><br><span class="line">        newArr.append(arr.pop(smallest))</span><br><span class="line">    <span class="keyword">return</span> newArr</span><br><span class="line"></span><br><span class="line">print(selectionSort([<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">8</span>]))</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/2952111-3b59aac6b772ddf0.gif?imageMogr2/auto-orient/strip" alt="选择排序"></p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p><code>所谓归并是指将若干个已排好序的部分合并成一个有序的部分。</code></p><p>假设我们有一个没有排好序的序列(14,12,15,13,11,16)，那么首先我们使用分割的办法将这个序列分割成一个个已经排好序的子序列。然后再利用归并的方法将一个个的子序列合并成排序好的序列。分割和归并的过程可以看下面的图例。这样通过先递归的分解数列，再合并数列就完成了归并排序。</p><p><img src="https://upload-images.jianshu.io/upload_images/2952111-b7ca2aad908df253.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MergeSort.jpg"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left, right)</span>:</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">        result.append(left.pop(<span class="number">0</span>) <span class="keyword">if</span> left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>] <span class="keyword">else</span> right.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">while</span> left:</span><br><span class="line">        result.append(left.pop(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">while</span> right:</span><br><span class="line">        result.append(right.pop(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">(relist)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(relist) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> relist</span><br><span class="line">    mid_index = math.floor(len(relist)/<span class="number">2</span>)</span><br><span class="line">    left = mergeSort(relist[:mid_index])  <span class="comment"># 递归拆解的过程</span></span><br><span class="line">    right = mergeSort(relist[mid_index:])</span><br><span class="line">    <span class="keyword">return</span> merge(left, right)  <span class="comment"># 合并的过程</span></span><br><span class="line"></span><br><span class="line">print(mergeSort([<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">3</span>]))</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/2952111-8ee3d2a2a81eab80.gif?imageMogr2/auto-orient/strip" alt="归并排序"></p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><ol><li>创建最大堆:将堆所有数据重新排序，使其成为最大堆</li><li>最大堆调整:作用是保持最大堆的性质，是创建最大堆的核心子程序</li><li>堆排序:移除位在第一个数据的根节点，并做最大堆调整的递归运算</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/2952111-5903c9ca1e9a0473.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="堆排序.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># code from -http://blog.csdn.net/minxihou/article/details/51850001</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MAX_Heapify</span><span class="params">(heap,HeapSize,root)</span>:</span><span class="comment">#在堆中做结构调整使得父节点的值大于子节点</span></span><br><span class="line"></span><br><span class="line">    left = <span class="number">2</span>*root + <span class="number">1</span></span><br><span class="line">    right = left + <span class="number">1</span></span><br><span class="line">    larger = root</span><br><span class="line">    <span class="keyword">if</span> left &lt; HeapSize <span class="keyword">and</span> heap[larger] &lt; heap[left]:</span><br><span class="line">        larger = left</span><br><span class="line">    <span class="keyword">if</span> right &lt; HeapSize <span class="keyword">and</span> heap[larger] &lt; heap[right]:</span><br><span class="line">        larger = right</span><br><span class="line">    <span class="keyword">if</span> larger != root:<span class="comment">#如果做了堆调整则larger的值等于左节点或者右节点的，这个时候做对调值操作</span></span><br><span class="line">        heap[larger],heap[root] = heap[root],heap[larger]</span><br><span class="line">        MAX_Heapify(heap, HeapSize, larger)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Build_MAX_Heap</span><span class="params">(heap)</span>:</span><span class="comment">#构造一个堆，将堆中所有数据重新排序</span></span><br><span class="line">    HeapSize = len(heap)<span class="comment">#将堆的长度当独拿出来方便</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range((HeapSize <span class="number">-2</span>)//<span class="number">2</span>,<span class="number">-1</span>,<span class="number">-1</span>):<span class="comment">#从后往前出数</span></span><br><span class="line">        MAX_Heapify(heap,HeapSize,i)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">HeapSort</span><span class="params">(heap)</span>:</span><span class="comment">#将根节点取出与最后一位做对调，对前面len-1个节点继续进行对调整过程。</span></span><br><span class="line">    Build_MAX_Heap(heap)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(heap)<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        heap[<span class="number">0</span>],heap[i] = heap[i],heap[<span class="number">0</span>]</span><br><span class="line">        MAX_Heapify(heap, i, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> heap</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">30</span>,<span class="number">50</span>,<span class="number">57</span>,<span class="number">77</span>,<span class="number">62</span>,<span class="number">78</span>,<span class="number">94</span>,<span class="number">80</span>,<span class="number">84</span>]</span><br><span class="line">    print(a)</span><br><span class="line">    HeapSort(a)</span><br><span class="line">    print(a)</span><br><span class="line">    b = [random.randint(<span class="number">1</span>,<span class="number">1000</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>)]</span><br><span class="line">    <span class="comment">#print b</span></span><br><span class="line">    HeapSort(b)</span><br><span class="line">    print(b)</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/2952111-d80509464c38434d.gif?imageMogr2/auto-orient/strip" alt="堆排序.gif"></p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><table><thead><tr><th style="text-align:left">排序法</th><th style="text-align:left">最差时间</th><th style="text-align:left">平均时间复杂度</th><th style="text-align:left">稳定度</th><th style="text-align:left">空间复杂度</th></tr></thead><tbody><tr><td style="text-align:left">冒泡排序</td><td style="text-align:left">O(n^2)</td><td style="text-align:left">O(n^2)</td><td style="text-align:left">稳定</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">快速排序</td><td style="text-align:left">O(n^2)</td><td style="text-align:left">O(n*log n)</td><td style="text-align:left">不稳定</td><td style="text-align:left">O(log2n)~O(n)</td></tr><tr><td style="text-align:left">选择排序</td><td style="text-align:left">O(n^2)</td><td style="text-align:left">O(n^2)</td><td style="text-align:left">不稳定</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">二叉树排序</td><td style="text-align:left">O(n^2)</td><td style="text-align:left">O(n*log n)</td><td style="text-align:left">不一定</td><td style="text-align:left">O(n)</td></tr><tr><td style="text-align:left">插入排序</td><td style="text-align:left">O(n^2)</td><td style="text-align:left">O(n^2)</td><td style="text-align:left">稳定</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">堆排序</td><td style="text-align:left">O(n*log n)</td><td style="text-align:left">O(n*log n)</td><td style="text-align:left">不稳定</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">希尔排序</td><td style="text-align:left">O</td><td style="text-align:left">O</td><td style="text-align:left">不稳定</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">归并排序</td><td style="text-align:left">O(n*log n)</td><td style="text-align:left">O(n*log n)</td><td style="text-align:left">稳定</td><td style="text-align:left">?</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://blog.csdn.net/mrlevo520/article/details/77829204" target="_blank" rel="noopener">http://blog.csdn.net/mrlevo520/article/details/77829204</a></li><li><a href="http://blog.csdn.net/minxihou/article/details/51850001" target="_blank" rel="noopener">http://blog.csdn.net/minxihou/article/details/51850001</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h2&gt;&lt;p&gt;快速排序的思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先从数列中取出一个数作为基准数。&lt;/li&gt;
&lt;li&gt;分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边(假定从小到大排序)。&lt;/li&gt;
&lt;li&gt;再对左右区间重复第二步，直到各区间只有一个数&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;quicksort&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(array)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;&quot;&quot;快速排序&quot;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; len(array) &amp;lt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;:  &lt;span class=&quot;comment&quot;&gt;# 基线条件：为空或者只有一个元素的数组是有序的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; array&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        pivot = array[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]  &lt;span class=&quot;comment&quot;&gt;# 递归条件,基准值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        less = [i &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; array[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:] &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; i &amp;lt;= pivot]  &lt;span class=&quot;comment&quot;&gt;# 所有小于基准值的元素组成的子数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        greater = [i &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; array[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:] &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; i &amp;gt; pivot]  &lt;span class=&quot;comment&quot;&gt;# 所有大于基准值的元素组成的子数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; quicksort(less) + [pivot] + quicksort(greater)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(quicksort([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
      <category term="Data Structures" scheme="http://yoursite.com/tags/Data-Structures/"/>
    
  </entry>
  
  <entry>
    <title>Python3 实现二分查找</title>
    <link href="http://yoursite.com/2018/03/09/Python3-%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>http://yoursite.com/2018/03/09/Python3-实现二分查找/</id>
    <published>2018-03-09T06:32:16.000Z</published>
    <updated>2018-03-09T07:26:37.282Z</updated>
    
    <content type="html"><![CDATA[<p>二分查找,给出一个已经排好序的列表,<code>注意是已经排好序的</code>,查找指定元素在列表中的位置<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(my_list, item)</span>:</span></span><br><span class="line">    <span class="string">"""从list中查找item"""</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = len(my_list) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        mid = math.floor((low + high)/<span class="number">2</span>)</span><br><span class="line">        guess = my_list[mid]</span><br><span class="line">        <span class="keyword">if</span> guess &gt; item:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> guess &lt; item:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">my_list = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line">item = <span class="number">1</span></span><br><span class="line">print(binary_search(my_list, item))</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;二分查找,给出一个已经排好序的列表,&lt;code&gt;注意是已经排好序的&lt;/code&gt;,查找指定元素在列表中的位置&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Python3 向上取整ceil|向下取整floor|四舍五入round</title>
    <link href="http://yoursite.com/2018/03/09/Python3-%E5%90%91%E4%B8%8A%E5%8F%96%E6%95%B4ceil-%E5%90%91%E4%B8%8B%E5%8F%96%E6%95%B4floor-%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5round/"/>
    <id>http://yoursite.com/2018/03/09/Python3-向上取整ceil-向下取整floor-四舍五入round/</id>
    <published>2018-03-09T06:21:35.000Z</published>
    <updated>2018-03-09T06:27:14.992Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="comment">#向上取整</span></span><br><span class="line">print(<span class="string">"math.ceil---向上取整"</span>)  </span><br><span class="line">print(<span class="string">"math.ceil(2.3) =&gt; "</span>, math.ceil(<span class="number">2.3</span>))  <span class="comment"># 3</span></span><br><span class="line">print(<span class="string">"math.ceil(2.6) =&gt; "</span>, math.ceil(<span class="number">2.6</span>))  <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#向下取整</span></span><br><span class="line">print(<span class="string">"\nmath.floor---向下取整"</span>)</span><br><span class="line">print(<span class="string">"math.floor(2.3) =&gt; "</span>, math.floor(<span class="number">2.3</span>)) <span class="comment"># 2</span></span><br><span class="line">print(<span class="string">"math.floor(2.6) =&gt; "</span>, math.floor(<span class="number">2.6</span>)) <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#四舍五入</span></span><br><span class="line">print(<span class="string">"\nround---四舍五入"</span>)</span><br><span class="line">print(<span class="string">"round(2.3) =&gt; "</span>, round(<span class="number">2.3</span>)) <span class="comment"># 2</span></span><br><span class="line">print(<span class="string">"round(2.6) =&gt; "</span>, round(<span class="number">2.6</span>)) <span class="comment"># 3</span></span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">math.ceil---向上取整</span><br><span class="line">math.ceil(2.3) =&gt;  3</span><br><span class="line">math.ceil(2.6) =&gt;  3</span><br><span class="line"></span><br><span class="line">math.floor---向下取整</span><br><span class="line">math.floor(2.3) =&gt;  2</span><br><span class="line">math.floor(2.6) =&gt;  2</span><br><span class="line"></span><br><span class="line">round---四舍五入</span><br><span class="line">round(2.3) =&gt;  2</span><br><span class="line">round(2.6) =&gt;  3</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; math&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#向上取整&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&lt;span class=&quot;string&quot;&gt;&quot;math.ceil---向上取整&quot;&lt;/span&gt;)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&lt;span class=&quot;string&quot;&gt;&quot;math.ceil(2.3) =&amp;gt; &quot;&lt;/span&gt;, math.ceil(&lt;span class=&quot;number&quot;&gt;2.3&lt;/span&gt;))  &lt;span class=&quot;comment&quot;&gt;# 3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&lt;span class=&quot;string&quot;&gt;&quot;math.ceil(2.6) =&amp;gt; &quot;&lt;/span&gt;, math.ceil(&lt;span class=&quot;number&quot;&gt;2.6&lt;/span&gt;))  &lt;span class=&quot;comment&quot;&gt;# 3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#向下取整&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&lt;span class=&quot;string&quot;&gt;&quot;\nmath.floor---向下取整&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&lt;span class=&quot;string&quot;&gt;&quot;math.floor(2.3) =&amp;gt; &quot;&lt;/span&gt;, math.floor(&lt;span class=&quot;number&quot;&gt;2.3&lt;/span&gt;)) &lt;span class=&quot;comment&quot;&gt;# 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&lt;span class=&quot;string&quot;&gt;&quot;math.floor(2.6) =&amp;gt; &quot;&lt;/span&gt;, math.floor(&lt;span class=&quot;number&quot;&gt;2.6&lt;/span&gt;)) &lt;span class=&quot;comment&quot;&gt;# 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#四舍五入&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&lt;span class=&quot;string&quot;&gt;&quot;\nround---四舍五入&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&lt;span class=&quot;string&quot;&gt;&quot;round(2.3) =&amp;gt; &quot;&lt;/span&gt;, round(&lt;span class=&quot;number&quot;&gt;2.3&lt;/span&gt;)) &lt;span class=&quot;comment&quot;&gt;# 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&lt;span class=&quot;string&quot;&gt;&quot;round(2.6) =&amp;gt; &quot;&lt;/span&gt;, round(&lt;span class=&quot;number&quot;&gt;2.6&lt;/span&gt;)) &lt;span class=&quot;comment&quot;&gt;# 3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Apache和Nginx的对比</title>
    <link href="http://yoursite.com/2018/03/08/Apache%E5%92%8CNginx%E7%9A%84%E5%AF%B9%E6%AF%94/"/>
    <id>http://yoursite.com/2018/03/08/Apache和Nginx的对比/</id>
    <published>2018-03-07T18:11:57.000Z</published>
    <updated>2018-03-07T18:31:50.268Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h2><ol><li>apache 的 rewrite 比 nginx 强大，在 rewrite 频繁的情况下，用 apache</li><li>apache 发展到现在，模块超多，基本想到的都可以找到</li><li>apache 更为成熟，少 bug ，nginx 的 bug 相对较多</li><li>apache 超稳定</li><li>apache 对 PHP 支持比较简单，nginx 需要配合其他后端用</li><li>apache 在处理动态请求有优势，nginx 在这方面是鸡肋，一般动态请求要 apache 去做，nginx 适合静态和反向。</li><li>apache 仍然是目前的主流，拥有丰富的特性，成熟的技术和开发社区</li></ol><a id="more"></a><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><ol><li>轻量级，采用 C 进行编写，同样的 web 服务，会占用更少的内存及资源</li><li>抗并发，nginx 以 epoll and kqueue 作为开发模型，处理请求是异步非阻塞的，负载能力比 apache 高很多，而 apache 则是阻塞型的。在高并发下 nginx 能保持低资源低消耗高性能 ，而 apache 在 PHP 处理慢或者前端压力很大的情况下，很容易出现进程数飙升，从而拒绝服务的现象。</li><li>nginx 处理静态文件好，静态处理性能比 apache 高三倍以上</li><li>nginx 的设计高度模块化，编写模块相对简单</li><li>nginx 配置简洁，正则配置让很多事情变得简单，而且改完配置能使用 -t 测试配置有没有问题，apache 配置复杂 ，重启的时候发现配置出错了，会很崩溃</li><li>nginx 作为负载均衡服务器，支持 7 层负载均衡</li><li>nginx 本身就是一个反向代理服务器，而且可以作为非常优秀的邮件代理服务器</li><li>启动特别容易, 并且几乎可以做到 7*24 不间断运行，即使运行数个月也不需要重新启动，还能够不间断服务的情况下进行软件版本的升级</li><li>社区活跃，各种高性能模块出品迅速</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>nginx 相对 apache 的优点：</p><ul><li>轻量级，同样起web 服务，比apache 占用更少的内存及资源</li><li>抗并发，<code>nginx 处理请求是异步非阻塞的</code>，支持更多的并发连接，而<code>apache 则是阻塞型的</code>，在高并发下nginx 能保持低资源低消耗高性能</li><li>配置简洁</li><li>高度模块化的设计，编写模块相对简单</li><li>社区活跃</li></ul><p>apache 相对nginx 的优点：</p><ul><li>rewrite ，比nginx 的rewrite 强大</li><li>模块超多，基本想到的都可以找到</li><li>少bug ，nginx 的bug 相对较多</li><li>超稳定</li></ul><p>两者最核心的区别在于 <code>apache 是同步多进程模型，一个连接对应一个进程</code>，而 <code>nginx 是异步的，多个连接（万级别）可以对应一个进程</code></p><p>一般来说，需要性能的 web 服务，用 nginx 。如果不需要性能只求稳定，更考虑 apache ，后者的各种功能模块实现得比前者，例如 ssl 的模块就比前者好，可配置项多。epoll(freebsd 上是 kqueue ) 网络 IO 模型是 nginx 处理性能高的根本理由，但并不是所有的情况下都是 epoll 大获全胜的，如果本身提供静态服务的就只有寥寥几个文件，apache 的 select 模型或许比 epoll 更高性能。当然，这只是根据网络 IO 模型的原理作的一个假设，真正的应用还是需要实测了再说的。</p><p>更为通用的方案是，前端 nginx 抗并发，后端 apache 集群，配合起来会更好。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Apache&quot;&gt;&lt;a href=&quot;#Apache&quot; class=&quot;headerlink&quot; title=&quot;Apache&quot;&gt;&lt;/a&gt;Apache&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;apache 的 rewrite 比 nginx 强大，在 rewrite 频繁的情况下，用 apache&lt;/li&gt;
&lt;li&gt;apache 发展到现在，模块超多，基本想到的都可以找到&lt;/li&gt;
&lt;li&gt;apache 更为成熟，少 bug ，nginx 的 bug 相对较多&lt;/li&gt;
&lt;li&gt;apache 超稳定&lt;/li&gt;
&lt;li&gt;apache 对 PHP 支持比较简单，nginx 需要配合其他后端用&lt;/li&gt;
&lt;li&gt;apache 在处理动态请求有优势，nginx 在这方面是鸡肋，一般动态请求要 apache 去做，nginx 适合静态和反向。&lt;/li&gt;
&lt;li&gt;apache 仍然是目前的主流，拥有丰富的特性，成熟的技术和开发社区&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Web服务器" scheme="http://yoursite.com/tags/Web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>用户密码保存的方式有哪些</title>
    <link href="http://yoursite.com/2018/03/08/%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E4%BF%9D%E5%AD%98%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B/"/>
    <id>http://yoursite.com/2018/03/08/用户密码保存的方式有哪些/</id>
    <published>2018-03-07T18:03:43.000Z</published>
    <updated>2018-03-07T18:05:08.274Z</updated>
    
    <content type="html"><![CDATA[<ol><li>明文保存</li><li>明文hash后保存,如md5</li><li>MD5+Salt方式,这个salt可以随机</li><li>知乎使用了Bcrypy(好像)加密</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;明文保存&lt;/li&gt;
&lt;li&gt;明文hash后保存,如md5&lt;/li&gt;
&lt;li&gt;MD5+Salt方式,这个salt可以随机&lt;/li&gt;
&lt;li&gt;知乎使用了Bcrypy(好像)加密&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
    
      <category term="加密" scheme="http://yoursite.com/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>进程间的通信方式(IPC)</title>
    <link href="http://yoursite.com/2018/03/07/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F-IPC/"/>
    <id>http://yoursite.com/2018/03/07/进程间的通信方式-IPC/</id>
    <published>2018-03-07T15:47:10.000Z</published>
    <updated>2018-03-07T15:49:17.891Z</updated>
    
    <content type="html"><![CDATA[<ol><li><code>管道</code>（Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。</li><li><code>命名管道</code>（named pipe）：命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。</li><li><code>信号</code>（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。</li><li><code>消息（Message）队列</code>：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺</li><li><code>共享内存</code>：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。</li><li><code>内存映射</code>（mapped memory）：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。</li><li><code>信号量</code>（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。</li><li><code>套接口</code>（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;code&gt;管道&lt;/code&gt;（Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;命名管道&lt;/code&gt;（named pipe）：命名管道克服了管道没有名字的限制，因此，除具有管
      
    
    </summary>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Django运行方式以及处理流程简介(转载)</title>
    <link href="http://yoursite.com/2018/03/07/Django%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E7%AE%80%E4%BB%8B-%E8%BD%AC%E8%BD%BD/"/>
    <id>http://yoursite.com/2018/03/07/Django运行方式以及处理流程简介-转载/</id>
    <published>2018-03-07T11:07:58.000Z</published>
    <updated>2018-03-07T12:09:44.924Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Django的运行方式"><a href="#Django的运行方式" class="headerlink" title="Django的运行方式"></a>Django的运行方式</h2><p>运行Django项目的方法很多，这里主要介绍一下常用的方法。一种是在开发和调试中经常用到<code>runserver</code>方法，使用Django自己的web server(WSGI Server)；另外一种就是使用<code>fastcgi，uWSGIt</code>等协议运行Django项目。</p><a id="more"></a><h3 id="runserver方法"><a href="#runserver方法" class="headerlink" title="runserver方法"></a>runserver方法</h3><p>runserver方法是调试Django时经常用到的运行方式，它使用Django自带的WSGI Server运行，主要在测试和开发中使用，使用方法如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Usage: manage.py runserver [options] [optional port number, <span class="keyword">or</span> ipaddr:port]</span><br><span class="line"><span class="comment"># python manager.py runserver    # default port is 8000</span></span><br><span class="line"><span class="comment"># python manager.py runserver 8080</span></span><br><span class="line"><span class="comment"># python manager.py runserver 127.0.0.1:9090</span></span><br></pre></td></tr></table></figure></p><p>看一下manager.py的源码，你会发现上面的命令其实是通过Django的execute_from_command_line方法执行了内部实现的runserver命令，那么现在看一下runserver具体做了什么。。</p><p>看了源码之后，可以发现runserver命令主要做了两件事情：</p><pre><code>1). 解析参数，并通过django.core.servers.basehttp.get_internal_wsgi_application方法获取wsgi handler;2). 根据ip_address和port生成一个WSGIServer对象，接受用户请求</code></pre><p>get_internal_wsgi_application的源码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_internal_wsgi_application</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Loads and returns the WSGI application as configured by the user in</span></span><br><span class="line"><span class="string">    ``settings.WSGI_APPLICATION``. With the default ``startproject`` layout,</span></span><br><span class="line"><span class="string">    this will be the ``application`` object in ``projectname/wsgi.py``.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This function, and the ``WSGI_APPLICATION`` setting itself, are only useful</span></span><br><span class="line"><span class="string">    for Django's internal servers (runserver, runfcgi); external WSGI servers</span></span><br><span class="line"><span class="string">    should just be configured to point to the correct application object</span></span><br><span class="line"><span class="string">    directly.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If settings.WSGI_APPLICATION is not set (is ``None``), we just return</span></span><br><span class="line"><span class="string">    whatever ``django.core.wsgi.get_wsgi_application`` returns.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line">    app_path = getattr(settings, <span class="string">'WSGI_APPLICATION'</span>)</span><br><span class="line">    <span class="keyword">if</span> app_path <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> get_wsgi_application()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> import_by_path(</span><br><span class="line">        app_path,</span><br><span class="line">        error_prefix=<span class="string">"WSGI application '%s' could not be loaded; "</span> % app_path</span><br><span class="line">    )</span><br></pre></td></tr></table></figure></p><p>通过上面的代码我们可以知道，Django会先根据settings中的WSGI_APPLICATION来获取handler；在创建project的时候，Django会默认创建一个wsgi.py文件，而settings中的WSGI_APPLICATION配置也会默认指向这个文件。看一下这个wsgi.py文件，其实它也和上面的逻辑一样，最终调用get_wsgi_application实现。</p><h2 id="uWSGI方法"><a href="#uWSGI方法" class="headerlink" title="uWSGI方法"></a>uWSGI方法</h2><p>uWSGI + Nginx的方法是现在最常见的在生产环境中运行Django的方法，要了解这种方法，首先要了解一下WSGI和uWSGI协议。</p><p>WSGI，全称<code>Web Server Gateway Interface</code>，或者<code>Python Web Server Gateway Interface</code>，是为Python语言定义的Web服务器和Web应用程序或框架之间的一种简单而通用的接口，基于现存的<code>CGI标准</code>而设计的。WSGI其实就是一个网关(Gateway)，其作用就是在协议之间进行转换。(PS: 这里只对WSGI做简单介绍，想要了解更多的内容可自行搜索)</p><p><code>uWSGI是一个Web服务器</code>，它实现了WSGI协议、uwsgi、http等协议。<code>注意!</code>uwsgi是一种通信协议，而uWSGI是实现uwsgi协议和WSGI协议的Web服务器。uWSGI具有超快的性能、低内存占用和多app管理等优点。以我的博客为例，uWSGI的xml配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uwsgi</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 端口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">socket</span>&gt;</span>:7600<span class="tag">&lt;/<span class="name">socket</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">stats</span>&gt;</span>:40000<span class="tag">&lt;/<span class="name">stats</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 系统环境变量 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">env</span>&gt;</span>DJANGO_SETTINGS_MODULE=geek_blog.settings<span class="tag">&lt;/<span class="name">env</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定的python WSGI模块 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>django.core.handlers.wsgi:WSGIHandler()<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">processes</span>&gt;</span>6<span class="tag">&lt;/<span class="name">processes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">master</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">master-as-root</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 超时设置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">harakiri</span>&gt;</span>60<span class="tag">&lt;/<span class="name">harakiri</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">harakiri-verbose</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">daemonize</span>&gt;</span>/var/app/log/blog/uwsgi.log<span class="tag">&lt;/<span class="name">daemonize</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- socket的监听队列大小 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listen</span>&gt;</span>32768<span class="tag">&lt;/<span class="name">listen</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 内部超时时间 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">socket-timeout</span>&gt;</span>60<span class="tag">&lt;/<span class="name">socket-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">uwsgi</span>&gt;</span></span><br></pre></td></tr></table></figure><p>uWSGI和Nginx一起使用的配置方法就不在这里说明了，网上教程很多，需要的可以自行搜索。</p><h2 id="HTTP请求处理流程"><a href="#HTTP请求处理流程" class="headerlink" title="HTTP请求处理流程"></a>HTTP请求处理流程</h2><p>Django和其他Web框架一样，HTTP的处理流程基本类似：接受request，返回response内容。Django的具体处理流程大致如下图所示：</p><p><strong>1. 加载project settings</strong></p><p>在通过django-admin.py创建project的时候，Django会自动生成默认的settings文件和manager.py等文件，在创建WSGIServer之前会执行下面的引用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br></pre></td></tr></table></figure></p><p>上面引用在执行时，会读取os.environ中的DJANGO_SETTINGS_MODULE配置，加载项目配置文件，生成settings对象。所以，在manager.py文件中你可以看到，在获取WSGIServer之前，会先将project的settings路径加到os路径中。</p><p><strong>2. 创建WSGIServer</strong></p><p>不管是使用runserver还是uWSGI运行Django项目，在启动时都会调用django.core.servers.basehttp中的run()方法，创建一个django.core.servers.basehttp.WSGIServer类的实例，之后调用其serve_forever()方法启动HTTP服务。run方法的源码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(addr, port, wsgi_handler, ipv6=False, threading=False)</span>:</span></span><br><span class="line">    server_address = (addr, port)</span><br><span class="line">    <span class="keyword">if</span> threading:</span><br><span class="line">        httpd_cls = type(str(<span class="string">'WSGIServer'</span>), (socketserver.ThreadingMixIn, WSGIServer), &#123;&#125;)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        httpd_cls = WSGIServer</span><br><span class="line">    httpd = httpd_cls(server_address, WSGIRequestHandler, ipv6=ipv6)</span><br><span class="line">    <span class="comment"># Sets the callable application as the WSGI application that will receive requests</span></span><br><span class="line">    httpd.set_app(wsgi_handler)</span><br><span class="line">    httpd.serve_forever()</span><br></pre></td></tr></table></figure></p><p>如上，我们可以看到：在创建WSGIServer实例的时候会指定HTTP请求的Handler，上述代码使用WSGIRequestHandler。当用户的HTTP请求到达服务器时，WSGIServer会创建WSGIRequestHandler实例，使用其handler方法来处理HTTP请求(其实最终是调用wsgiref.handlers.BaseHandler中的run方法处理)。WSGIServer通过set_app方法设置一个可调用(callable)的对象作为application，上面提到的handler方法最终会调用设置的application处理request，并返回response。</p><p>其中，WSGIServer继承自wsgiref.simple_server.WSGIServer，而WSGIRequestHandler继承自wsgiref.simple_server.WSGIRequestHandler，wsgiref是Python标准库给出的WSGI的参考实现。其源码可自行到<a href="https://pypi.python.org/pypi/wsgiref" target="_blank" rel="noopener">wsgiref</a>参看，这里不再细说.</p><p><strong>3. 处理Request</strong></p><p>第二步中说到的application，在Django中一般是django.core.handlers.wsgi.WSGIHandler对象，WSGIHandler继承自django.core.handlers.base.BaseHandler，这个是Django处理request的核心逻辑，它会创建一个WSGIRequest实例，而WSGIRequest是从http.HttpRequest继承而来</p><p><strong>4. 返回Response</strong></p><p>上面提到的BaseHandler中有个get_response方法，该方法会先加载Django项目的ROOT_URLCONF，然后根据url规则找到对应的view方法(类)，view逻辑会根据request实例生成并返回具体的response。</p><p>在Django返回结果之后，第二步中提到wsgiref.handlers.BaseHandler.run方法会调用finish_response结束请求，并将内容返回给用户。</p><h2 id="Django处理Request的详细流程"><a href="#Django处理Request的详细流程" class="headerlink" title="Django处理Request的详细流程"></a>Django处理Request的详细流程</h2><p>上述的第三步和第四步逻辑只是大致说了一下处理过程，Django在处理request的时候其实做了很多事情，下面我们详细的过一下。首先给大家分享两个网上看到的Django流程图：<br><img src="http://upload-images.jianshu.io/upload_images/2952111-5e684abfea788d78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="django.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/2952111-f72ffe64a49bd4d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="django_flow.png"></p><p>上面的两张流程图可以大致描述Django处理request的流程，按照流程图2的标注，可以分为以下几个步骤：</p><pre><code>1. 用户通过浏览器请求一个页面2. 请求到达Request Middlewares，中间件对request做一些预处理或者直接response请求3. URLConf通过urls.py文件和请求的URL找到相应的View4. View Middlewares被访问，它同样可以对request做一些处理或者直接返回response5. 调用View中的函数6. View中的方法可以选择性的通过Models访问底层的数据7. 所有的Model-to-DB的交互都是通过manager完成的8. 如果需要，Views可以使用一个特殊的Context9. Context被传给Template用来生成页面a. Template使用Filters和Tags去渲染输出b. 输出被返回到Viewc. HTTPResponse被发送到Response Middlewaresd. 任何Response Middlewares都可以丰富response或者返回一个完全不同的responsee. Response返回到浏览器，呈现给用户</code></pre><p>上述流程中最主要的几个部分分别是：Middleware(中间件，包括request, view, exception, response)，URLConf(url映射关系)，Template(模板系统)，下面一一介绍一下。</p><p><strong>1. Middleware(中间件)</strong></p><p>Middleware并不是Django所独有的东西，在其他的Web框架中也有这种概念。在Django中，Middleware可以渗入处理流程的四个阶段：request，view，response和exception，相应的，在每个Middleware类中都有rocess_request，process_view， process_response 和 process_exception这四个方法。你可以定义其中任意一个或多个方法，这取决于你希望该Middleware作用于哪个处理阶段。每个方法都可以直接返回response对象。</p><p>Middleware是在Django BaseHandler的load_middleware方法执行时加载的，加载之后会建立四个列表作为处理器的实例变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_request_middleware：process_request方法的列表</span><br><span class="line"></span><br><span class="line">_view_middleware：process_view方法的列表</span><br><span class="line"></span><br><span class="line">_response_middleware：process_response方法的列表</span><br><span class="line"></span><br><span class="line">_exception_middleware：process_exception方法的列表</span><br></pre></td></tr></table></figure></p><p>Django的中间件是在其配置文件(settings.py)的MIDDLEWARE_CLASSES元组中定义的。在MIDDLEWARE_CLASSES中，中间件组件用字符串表示：指向中间件类名的完整Python路径。例如GeekBlog项目的配置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MIDDLEWARE_CLASSES = (</span><br><span class="line">    <span class="string">'django.middleware.cache.UpdateCacheMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.common.CommonMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.cache.FetchFromCacheMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.sessions.middleware.SessionMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.csrf.CsrfViewMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.auth.middleware.AuthenticationMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.messages.middleware.MessageMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.locale.LocaleMiddleware'</span>,</span><br><span class="line">    <span class="string">'geek_blog.middlewares.MobileDetectionMiddleware'</span>,    <span class="comment"># 自定义的Middleware</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>Django项目的安装并不强制要求任何中间件，如果你愿意，MIDDLEWARE_CLASSES可以为空。中间件出现的顺序非常重要：在request和view的处理阶段，Django按照MIDDLEWARE_CLASSES中出现的顺序来应用中间件，而在response和exception异常处理阶段，Django则按逆序来调用它们。也就是说，Django将MIDDLEWARE_CLASSES视为view函数外层的顺序包装子：在request阶段按顺序从上到下穿过，而在response则反过来。</p><p>以下两张图可以更好地帮助你理解：</p><p><img src="http://xianglong.qiniudn.com/django_middleware_flow.png" alt="Django Middleware流程1"></p><p><img src="http://xianglong.qiniudn.com/django_middleware_flow2.png" alt="Django Middleware流程图2"></p><p><strong>2. URLConf(URL映射)</strong></p><p>如果处理request的中间件都没有直接返回response，那么Django会去解析用户请求的URL。URLconf就是Django所支撑网站的目录。它的本质是URL模式以及要为该URL模式调用的视图函数之间的映射表。通过这种方式可以告诉Django，对于这个URL调用这段代码，对于那个URL调用那段代码。具体的，在Django项目的配置文件中有ROOT_URLCONF常量，这个常量加上根目录”/“，作为参数来创建django.core.urlresolvers.RegexURLResolver的实例，然后通过它的resolve方法解析用户请求的URL，找到第一个匹配的view。</p><p>其他有关URLConf的内容，这里不再具体介绍，大家可以看<a href="http://djangobook.py3k.cn/2.0/chapter03/" target="_blank" rel="noopener">DjangoBook</a>了解。</p><p><strong>3. Template(模板)</strong></p><p>大部分web框架都有自己的Template(模板)系统，Django也是。但是，Django模板不同于Mako模板和jinja2模板，在Django模板不能直接写Python代码，只能通过额外的定义filter和template tag实现。由于本文主要介绍Django流程，模板内容就不过多介绍。</p><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><ol><li><a href="http://www.nowamagic.net/academy/detail/1330328" target="_blank" rel="noopener">uWSGI Web服务器介绍</a>  </li><li><a href="http://blog.csdn.net/on_1y/article/details/18818081" target="_blank" rel="noopener">wsgiref源码分析</a>  </li><li><a href="http://www.tuicool.com/articles/aYBRBz" target="_blank" rel="noopener">用Python写一个简单的Web框架</a>  </li><li><a href="http://my.oschina.net/tenking/blog/29439" target="_blank" rel="noopener">Django 结构及处理流程分析</a></li><li><a href="http://blog.csdn.net/yongche_shi/article/details/49513431" target="_blank" rel="noopener">Django运行方式及处理流程总结</a> </li></ol><p>PS: 以上代码和内容都是基于Django 1.6.5版本，其他版本可能与其不同，请参考阅读。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Django的运行方式&quot;&gt;&lt;a href=&quot;#Django的运行方式&quot; class=&quot;headerlink&quot; title=&quot;Django的运行方式&quot;&gt;&lt;/a&gt;Django的运行方式&lt;/h2&gt;&lt;p&gt;运行Django项目的方法很多，这里主要介绍一下常用的方法。一种是在开发和调试中经常用到&lt;code&gt;runserver&lt;/code&gt;方法，使用Django自己的web server(WSGI Server)；另外一种就是使用&lt;code&gt;fastcgi，uWSGIt&lt;/code&gt;等协议运行Django项目。&lt;/p&gt;
    
    </summary>
    
      <category term="Django" scheme="http://yoursite.com/categories/Django/"/>
    
    
      <category term="Django" scheme="http://yoursite.com/tags/Django/"/>
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>三种多路复用IO实现方式：select，poll，epoll</title>
    <link href="http://yoursite.com/2018/03/07/%E4%B8%89%E7%A7%8D%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8IO%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9Aselect%EF%BC%8Cpoll%EF%BC%8Cepoll/"/>
    <id>http://yoursite.com/2018/03/07/三种多路复用IO实现方式：select，poll，epoll/</id>
    <published>2018-03-07T07:43:44.000Z</published>
    <updated>2018-03-07T10:40:20.981Z</updated>
    
    <content type="html"><![CDATA[<p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p><p>在linux 没有实现epoll事件驱动机制之前，我们一般选择用select或者poll等IO多路复用的方法来实现并发服务程序。在大数据、高并发、集群等一些名词唱得火热之年代，select和poll的用武之地越来越有限，风头已经被epoll占尽。</p><p>简单来讲<br>select有3个缺点:</p><ol><li>连接数受限</li><li>查找配对速度慢</li><li>数据由内核拷贝到用户态</li></ol><p>poll改善了第一个缺点<br>epoll改了三个缺点.</p><a id="more"></a><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合：</p><ol><li><p>当客户处理多个描述符时（一般是交互式输入和网络套接口），必须使用I/O复用。</p></li><li><p>当一个客户同时处理多个套接口时，这种情况是可能的，但很少出现。</p></li><li><p>如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。</p></li><li><p>如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。</p></li><li><p>如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。</p></li></ol><h2 id="select、poll、epoll简介"><a href="#select、poll、epoll简介" class="headerlink" title="select、poll、epoll简介"></a>select、poll、epoll简介</h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p><strong>基本原理：</strong>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</p><p><strong>基本流程，如图所示：</strong></p><p><strong><img src="https://images2015.cnblogs.com/blog/667911/201604/667911-20160426172125064-1263315531.png" alt=""></strong></p><p>　　select目前几乎在所有的平台上支持，<code>其良好跨平台支持也是它的一个优点</code>。<code>select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制</code>，在Linux上一般为1024，<code>可以通过修改宏定义甚至重新编译内核的方式提升这一限制</code>，但是这样也会造成效率的降低。</p><p><code>select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理</code>。这样所带来的缺点是：</p><p>1、select最大的缺陷就是单个进程所打开的FD是有一定限制的，它由FD_SETSIZE设置，默认值是1024。</p><p>　　一般来说这个数目和系统内存关系很大，<code>具体数目可以cat /proc/sys/fs/file-max察看</code>。32位机默认是1024个。64位机默认是2048.</p><p>2、对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低。</p><p>　　当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。这会浪费很多CPU时间。<code>如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询</code>，这正是epoll与kqueue做的。</p><p><code>3、需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。</code></p><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p><strong>基本原理：</strong><code>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间</code>，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。</p><p><strong>它没有最大连接数的限制，<code>原因是它是基于链表来存储的</code>，但是同样有一个缺点：</strong></p><p><code>1）大量的fd的数组被整体复制于用户态和内核地址空间之间</code>，而不管这样的复制是不是有意义。</p><p><code>2）poll还有一个特点是“水平触发”</code>，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。</p><p><strong>注意：</strong>从上面看，select和poll都需要在返回后，<code>通过遍历文件描述符来获取已经就绪的socket</code>。事实上，<code>同时连接的大量客户端在一时刻可能只有很少的处于就绪状态</code>，因此随着监视的描述符数量的增长，其效率也会线性下降。</p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>　　epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。<code>epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次</code>。</p><p><strong>基本原理：</strong><code>epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次</code>。还有一个特点是，<code>epoll使用“事件”的就绪通知方式</code>，通过epoll_ctl注册fd，<code>一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd</code>，epoll_wait便可以收到通知。</p><p><strong>epoll的优点：</strong></p><p><code>1、没有最大并发连接的限制</code>，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。</p><p><code>2、效率提升，不是轮询的方式，不会随着FD数目的增加效率下降</code>。</p><p>　　只有活跃可用的FD才会调用callback函数；<code>即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关</code>，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</p><p><code>3、内存拷贝</code>，利用mmap()文件映射内存加速与内核空间的消息传递；<code>即epoll使用mmap减少复制开销</code>。</p><p>epoll对文件描述符的操作有两种模式：<code>LT（level trigger）和ET（edge trigger）</code>。LT模式是默认模式，LT模式与ET模式的区别如下：</p><p>LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序可以不立即处理该事件</code>。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</p><p>ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序必须立即处理该事件</code>。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p><h2 id="select、poll、epoll对比"><a href="#select、poll、epoll对比" class="headerlink" title="select、poll、epoll对比"></a>select、poll、epoll对比</h2><h3 id="1、支持一个进程所能打开的最大连接数"><a href="#1、支持一个进程所能打开的最大连接数" class="headerlink" title="1、支持一个进程所能打开的最大连接数"></a><strong>1、支持一个进程所能打开的最大连接数</strong></h3><p><img src="https://images2015.cnblogs.com/blog/667911/201604/667911-20160426172727142-152295964.png" alt=""></p><h3 id="2、FD剧增后带来的IO效率问题"><a href="#2、FD剧增后带来的IO效率问题" class="headerlink" title="2、FD剧增后带来的IO效率问题"></a><strong>2、FD剧增后带来的IO效率问题</strong></h3><p><img src="https://images2015.cnblogs.com/blog/667911/201604/667911-20160426173035611-62395960.png" alt=""></p><h3 id="3、消息传递方式"><a href="#3、消息传递方式" class="headerlink" title="3、消息传递方式"></a><strong>3、消息传递方式</strong></h3><p><img src="https://images2015.cnblogs.com/blog/667911/201604/667911-20160426172915283-1257843409.png" alt=""></p><p>综上，在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点：</p><p>1、表面上看epoll的性能最好，<code>但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好</code>，毕竟epoll的通知机制需要很多函数回调。</p><p><code>2、select低效是因为每次它都需要轮询</code>。但低效也是相对的，视情况而定，也可通过良好的设计改善。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.cnblogs.com/jeakeven/p/5435916.html" target="_blank" rel="noopener">https://www.cnblogs.com/jeakeven/p/5435916.html</a></li><li><a href="http://blog.csdn.net/davidsguo008/article/details/73556811" target="_blank" rel="noopener">http://blog.csdn.net/davidsguo008/article/details/73556811</a></li><li><a href="https://www.cnblogs.com/wangyufu/p/6593515.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangyufu/p/6593515.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。&lt;/p&gt;
&lt;p&gt;在linux 没有实现epoll事件驱动机制之前，我们一般选择用select或者poll等IO多路复用的方法来实现并发服务程序。在大数据、高并发、集群等一些名词唱得火热之年代，select和poll的用武之地越来越有限，风头已经被epoll占尽。&lt;/p&gt;
&lt;p&gt;简单来讲&lt;br&gt;select有3个缺点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;连接数受限&lt;/li&gt;
&lt;li&gt;查找配对速度慢&lt;/li&gt;
&lt;li&gt;数据由内核拷贝到用户态&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;poll改善了第一个缺点&lt;br&gt;epoll改了三个缺点.&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="多任务处理" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
