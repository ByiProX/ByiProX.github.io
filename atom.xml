<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Quentin&#39;s Blog</title>
  
  <subtitle>每天进步一点点</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-06T19:08:03.944Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ByiProX</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅谈TCP和UDP的区别以及应用</title>
    <link href="http://yoursite.com/2018/03/07/%E6%B5%85%E8%B0%88TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2018/03/07/浅谈TCP和UDP的区别以及应用/</id>
    <published>2018-03-06T18:28:32.000Z</published>
    <updated>2018-03-06T19:08:03.944Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="TCP和UDP区别"></a>TCP和UDP区别</h2><p>TCP(<code>Transmission Control Protocol</code>)—<code>传输控制协议</code>,<code>提供的是面向连接、可靠的字节流服务</code>。当客户和服务器彼此交换数据前，必须先在双方之间建立一个TCP连接，之后才能传输数据。TCP提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。<br>UDP(<code>User Datagram Protocol</code>)—<code>用户数据报协议</code>，<code>是一个简单的面向数据报的运输层协议</code>。在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。由于UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol><li><p>HTTP协议在运输层采用的就是<code>TCP协议</code>，在浏览器中输入IP地址后，与服务器建立连接，采用的就是TCP协议，是一种面向连接、可靠的字节流服务。</p></li><li><p>当强调传输性能而不是传输的完整性时，如：音频、多媒体应用和视频会议时，<code>UDP</code>是最好的选择。另外，腾讯QQ采用也是UDP协议。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;TCP和UDP区别&quot;&gt;&lt;a href=&quot;#TCP和UDP区别&quot; class=&quot;headerlink&quot; title=&quot;TCP和UDP区别&quot;&gt;&lt;/a&gt;TCP和UDP区别&lt;/h2&gt;&lt;p&gt;TCP(&lt;code&gt;Transmission Control Protocol&lt;/c
      
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Session和Cookie的区别与联系</title>
    <link href="http://yoursite.com/2018/03/07/%E6%B5%85%E8%B0%88Session%E5%92%8CCookie%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB/"/>
    <id>http://yoursite.com/2018/03/07/浅谈Session和Cookie的区别与联系/</id>
    <published>2018-03-06T18:27:40.000Z</published>
    <updated>2018-03-06T19:01:04.896Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th style="text-align:left"></th><th style="text-align:left">Cookie</th><th style="text-align:left">Session</th></tr></thead><tbody><tr><td style="text-align:left">储存位置</td><td style="text-align:left">客户端</td><td style="text-align:left">服务器端</td></tr><tr><td style="text-align:left">目的</td><td style="text-align:left">跟踪会话，也可以保存用户偏好设置或者保存用户名密码等</td><td style="text-align:left">跟踪会话</td></tr><tr><td style="text-align:left">安全性</td><td style="text-align:left">不安全</td><td style="text-align:left">安全</td></tr></tbody></table><p>session技术是要使用到cookie的，之所以出现session技术，主要是为了安全。</p><a id="more"></a><h2 id="Session的概念"><a href="#Session的概念" class="headerlink" title="Session的概念"></a>Session的概念</h2><p>Session 是存放在服务器端的，类似于Session结构来存放用户数据，当浏览器 第一次发送请求时，服务器自动生成了一个Session和一个Session ID用来唯一标识这个Session，并将其通过响应发送到浏览器。当浏览器第二次发送请求，会将前一次服务器响应中的Session ID放在请求中一并发送到服务器上，服务器从请求中提取出Session ID，并和保存的所有Session ID进行对比，找到这个用户对应的Session。</p><p>一般情况下，服务器会在一定时间内（默认30分钟）保存这个 Session，过了时间限制，就会销毁这个Session。在销毁之前，程序员可以将用户的一些数据以Key和Value的形式暂时存放在这个 Session中。当然，也有使用数据库将这个Session序列化后保存起来的，这样的好处是没了时间的限制，坏处是随着时间的增加，这个数据 库会急速膨胀，特别是访问量增加的时候。一般还是采取前一种方式，以减轻服务器压力。</p><h2 id="cookie的概念"><a href="#cookie的概念" class="headerlink" title="cookie的概念"></a>cookie的概念</h2><p>Cookie意为“甜饼”，是由W3C组织提出，最早由Netscape社区发展的一种机制。目前Cookie已经成为标准，所有的主流浏览器如IE、Netscape、Firefox、Opera等都支持Cookie。</p><p>由于HTTP是一种无状态的协议，服务器单从网络连接上无从知道客户身份。怎么办呢？就给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理。</p><p>Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。</p><h2 id="Session的客户端实现形式（即Session-ID的保存方法）"><a href="#Session的客户端实现形式（即Session-ID的保存方法）" class="headerlink" title="Session的客户端实现形式（即Session ID的保存方法）"></a>Session的客户端实现形式（即Session ID的保存方法）</h2><p>一般浏览器提供了两种方式来保存，还有一种是程序员使用html隐藏域的方式自定义实现：</p><ol><li><p>使用Cookie来保存，这是最常见的方法，本文“记住我的登录状态”功能的实现正式基于这种方式的。服务器通过设置Cookie的方式将Session ID发送到浏览器。如果我们不设置这个过期时间，那么这个Cookie将不存放在硬盘上，当浏览器关闭的时候，Cookie就消失了，这个Session ID就丢失了。如果我们设置这个时间为若干天之后，那么这个Cookie会保存在客户端硬盘中，即使浏览器关闭，这个值仍然存在，下次访问相应网站时，同 样会发送到服务器上。</p></li><li><p>使用URL附加信息的方式，也就是像我们经常看到JSP网站会有<code>aaa.jsp?JSESSIONID=*</code>一样的。这种方式和第一种方式里面不设置Cookie过期时间是一样的。</p></li><li><p>第三种方式是在页面表单里面增加隐藏域，这种方式实际上和第二种方式一样，只不过前者通过GET方式发送数据，后者使用POST方式发送数据。但是明显后者比较麻烦。</p></li></ol><h2 id="cookie与session的区别"><a href="#cookie与session的区别" class="headerlink" title="cookie与session的区别"></a>cookie与session的区别</h2><p>cookie数据保存在客户端，session数据保存在服务器端。</p><p>简 单的说，当你登录一个网站的时候，如果web服务器端使用的是session,那么所有的数据都保存在服务器上面，客户端每次请求服务器的时候会发送 当前会话的sessionid，服务器根据当前sessionid判断相应的用户数据标志，以确定用户是否登录，或具有某种权限。由于数据是存储在服务器 上面，所以你不能伪造，但是如果你能够获取某个登录用户的sessionid，用特殊的浏览器伪造该用户的请求也是能够成功的。sessionid是服务 器和客户端链接时候随机分配的，一般来说是不会有重复，但如果有大量的并发请求，也不是没有重复的可能性，我曾经就遇到过一次。登录某个网站，开始显示的 是自己的信息，等一段时间超时了，一刷新，居然显示了别人的信息。</p><p>如果浏览器使用的是 cookie，那么所有的数据都保存在浏览器端，比如你登录以后，服务器设置了 cookie用户名(username),那么，当你再次请求服务器的时候，浏览器会将username一块发送给服务器，这些变量有一定的特殊标记。服 务器会解释为 cookie变量。所以只要不关闭浏览器，那么 cookie变量便一直是有效的，所以能够保证长时间不掉线。如果你能够截获某个用户的 cookie变量，然后伪造一个数据包发送过去，那么服务器还是认为你是合法的。所以，使用 cookie被攻击的可能性比较大。如果设置了的有效时间，那么它会将 cookie保存在客户端的硬盘上，下次再访问该网站的时候，浏览器先检查有没有 cookie，如果有的话，就读取该 cookie，然后发送给服务器。如果你在机器上面保存了某个论坛 cookie，有效期是一年，如果有人入侵你的机器，将你的 cookie拷走，然后放在他的浏览器的目录下面，那么他登录该网站的时候就是用你的的身份登录的。所以 cookie是可以伪造的。当然，伪造的时候需要主意，直接copy cookie文件到 cookie目录，浏览器是不认的，他有一个index.dat文件，存储了 cookie文件的建立时间，以及是否有修改，所以你必须先要有该网站的 cookie文件，并且要从保证时间上骗过浏览器，曾经在学校的vbb论坛上面做过试验，copy别人的 cookie登录，冒用了别人的名义发帖子，完全没有问题。</p><p>Session是由应用服务器维持的一个服务器端的存储空间，用户在连接服务器时，会由服务器生成一个唯一的SessionID,用该SessionID 为标识符来存取服务器端的Session存储空间。而SessionID这一数据则是保存到客户端，用Cookie保存的，用户提交页面时，会将这一 SessionID提交到服务器端，来存取Session数据。这一过程，是不用开发人员干预的。所以一旦客户端禁用Cookie，那么Session也会失效。</p><p>服务器也可以通过URL重写的方式来传递SessionID的值，因此不是完全依赖Cookie。如果客户端Cookie禁用，则服务器可以自动通过重写URL的方式来保存Session的值，并且这个过程对程序员透明。</p><p>可以试一下，即使不写Cookie，在使用request.getCookies();取出的Cookie数组的长度也是1，而这个Cookie的名字就是JSESSIONID，还有一个很长的二进制的字符串，是SessionID的值。</p><h2 id="Session与Cookie的应用场景"><a href="#Session与Cookie的应用场景" class="headerlink" title="Session与Cookie的应用场景"></a>Session与Cookie的应用场景</h2><p>Cookies是属于Session对象的一种。但有不同，Cookies不会占服务器资源，是存在客服端内存或者一个cookie的文本文件中；而“Session”则会占用服务器资源。所以，尽量不要使用Session，而使用Cookies。但是我们一般认为cookie是不可靠的，session是可靠地，但是目前很多著名的站点也都以来cookie。有时候为了解决禁用cookie后的页面处理，通常采用url重写技术，调用session中大量有用的方法从session中获取数据后置入页面。</p><p>Cookies与Session的应用场景：<br>Cookies的安全性能一直是倍受争议的。虽然Cookies是保存在本机上的，但是其信息的完全可见性且易于本地编辑性，往往可以引起很多的安全问题。所以Cookies到底该不该用，到底该怎样用，就有了一个需要给定的底线。</p><p>先来看看，网站的敏感数据有哪些。</p><p>登陆验证信息。一般采用Session(“Logon”)＝true or false的形式。<br>用户的各种私人信息，比如姓名等，某种情况下，需要保存在Session里<br>需要在页面间传递的内容信息，比如调查工作需要分好几步。每一步的信息都保存在Session里，最后在统一更新到数据库。</p><p>当然还会有很多，这里列举一些比较典型的<br>假如，一个人孤僻到不想碰Session，因为他认为，如果用户万一不小心关闭了浏览器，那么之前保存的数据就全部丢失了。所以，他出于好意，决定把这些用Session的地方，都改成用Cookies来存储，这完全是可行的，且基本操作和用Session一模一样。那么，下面就针对以上的3个典型例子，做一个分析<br>很显然，只要某个有意非法入侵者，知道该网站验证登陆信息的Session变量是什么，那么他就可以事先编辑好该Cookies，放入到Cookies目录中，这样就可以顺利通过验证了。这是不是很可怕？<br>Cookies完全是可见的，即使程序员设定了Cookies的生存周期（比如只在用户会话有效期内有效），它也是不安全的。假设，用户忘了关浏览器 或者一个恶意者硬性把用户给打晕，那用户的损失将是巨大的。<br>这点如上点一样，很容易被它人窃取重要的私人信息。但，其还有一个问题所在是，可能这些数据信息量太大，而使得Cookies的文件大小剧增。这可不是用户希望所看到的。</p><p>显然，Cookies并不是那么一块好啃的小甜饼。但，Cookies的存在，当然有其原因。它给予程序员更多发挥编程才能的空间。所以，使用Cookies该有个底线。这个底线一般来说，遵循以下原则。<br>不要保存私人信息。<br>任何重要数据，最好通过加密形式来保存数据（最简单的可以用URLEncode，当然也可以用完善的可逆加密方式，遗憾的是，最好不要用md5来加密）。<br>是否保存登陆信息，需有用户自行选择。<br>长于10K的数据，不要用到Cookies。<br>也不要用Cookies来玩点让客户惊喜的小游戏。</p><h2 id="cookie最典型的应用是："><a href="#cookie最典型的应用是：" class="headerlink" title="cookie最典型的应用是："></a>cookie最典型的应用是：</h2><ol><li><p>判断用户是否登陆过网站，以便下次登录时能够直接登录。如果我们删除cookie，则每次登录必须从新填写登录的相关信息。</p></li><li><p>另一个重要的应用是“购物车”中类的处理和设计。用户可能在一段时间内在同一家网站的不同页面选择不同的商品，可以将这些信息都写入cookie，在最后付款时从cookie中提取这些信息，当然这里面有了安全和性能问题需要我们考虑了。</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.cnblogs.com/andy-zhou/p/5360107.html#_caption_1" target="_blank" rel="noopener">https://www.cnblogs.com/andy-zhou/p/5360107.html#_caption_1</a></li><li><a href="http://blog.csdn.net/duan1078774504/article/details/51912868" target="_blank" rel="noopener">http://blog.csdn.net/duan1078774504/article/details/51912868</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;Cookie&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;Session&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;储存位置&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;客户端&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;服务器端&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;目的&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;跟踪会话，也可以保存用户偏好设置或者保存用户名密码等&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;跟踪会话&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;安全性&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;不安全&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;安全&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;session技术是要使用到cookie的，之所以出现session技术，主要是为了安全。&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>如何理解操作系统中的同步和异步、阻塞和非阻塞</title>
    <link href="http://yoursite.com/2018/03/07/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E3%80%81%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E/"/>
    <id>http://yoursite.com/2018/03/07/如何理解操作系统中的同步和异步、阻塞和非阻塞/</id>
    <published>2018-03-06T17:29:38.000Z</published>
    <updated>2018-03-06T17:59:01.007Z</updated>
    
    <content type="html"><![CDATA[<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。按照这个定义，其实绝大多数函数都是同步调用（例如sin, isdigit等）。但是一般而言，我们在说同步、异步的时候，特指那些需要其他部件协作或者需要一定时间完成的任务。</p><p>同步，可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是出于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。</p><p>最常见的例子就是 SendMessage。该函数发送一个消息给某个窗口，在对方处理完消息之前，这个函数不返回。当对方处理完毕以后，该函数才把消息处理函数所返回的 LRESULT值返回给调用者。</p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。由另外的并行程序执行这段代码，处理完这个调用的部件在完成后，通过状态、通知和回调来通知调用者。以CAsycSocket类为例（注意，CSocket从CAsyncSocket派生，但是起功能已经由异步转化为同步），当一个客户端通过调用 Connect函数发出一个连接请求后，调用者线程立刻可以朝下运行。当连接真正建立起来以后，socket底层会发送一个消息通知该对象。</p><p>这里提到执行部件和调用者通过三种途径返回结果：<code>状态、通知和回调</code>。可以使用哪一种依赖于执行部件的实现，除非执行部件提供多种选择，否则不受调用者控制。如果执行部件用状态来通知，那么调用者就需要每隔一定时间检查一次，效率就很低（有些初学多线程编程的人，总喜欢用一个循环去检查某个变量的值，这其实是一种很严重的错误）。如果是使用<code>通知</code>的方式，效率则很高，因为执行部件几乎不需要做额外的操作。至于回调函数，其实和通知没太多区别。</p><p>异步，执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。</p><h2 id="同步和异步类比"><a href="#同步和异步类比" class="headerlink" title="同步和异步类比"></a>同步和异步类比</h2><p>同步，就是实时处理，比如服务器一接收客户端请求，马上响应，这样客户端可以在最短的时间内得到结果，但是如果多个客户端，或者一个客户端发出的请求很频繁，服务器无法同步处理，就会造成涌塞。同步如打电话，通信双方不能断（我们是同时进行，同步），你一句我一句，这样的好处是，对方想表达的信息我马上能收到，但是，我在打着电话，我无法做别的事情。</p><p>异步，就是分时处理，服务器接收到客户端请求后并不是立即处理，而是等待服务器比较空闲的时候加以处理，可以避免涌塞。异步如收发收短信，对比打电话，打电话我一定要在电话的旁边听着，保证双方都在线，而收发短信，对方不用保证此刻我一定在手机旁，同时，我也不用时刻留意手机有没有来短信。这样的话，我看着视频，然后来了短信，我就处理短信（也可以不处理），接着再看视频。</p><p>对于写程序，同步往往会阻塞，没有数据过来，我就等着，异步则不会阻塞，没数据来我干别的事，有数据来去处理这些数据。</p><p>同步在一定程度上可以看做是单线程，这个线程请求一个方法后就待这个方法给他回复，否则他不往下执行（死心眼）。<br>异步在一定程度上可以看做是多线程的（废话，一个线程怎么叫异步），请求一个方法后，就不管了，继续执行其他的方法。</p><h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p>阻塞调用是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后才会返回。</p><p>有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。例如，我们在CSocket中调用Receive函数，如果缓冲区中没有数据，这个函数就会一直等待，直到有数据才返回。而此时，当前线程还会继续处理各种各样的消息。如果主窗口和调用函数在同一个线程中，除非你在特殊的界面操作函数中调用，其实主界面还是应该可以刷新。</p><p>socket接收数据的另外一个函数recv则是一个阻塞调用的例子。当socket工作在阻塞模式的时候，如果没有数据的情况下调用该函数，则当前线程就会被挂起，直到有数据为止。</p><h2 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h2><p>非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</p><h3 id="对象的阻塞模式和阻塞函数调用"><a href="#对象的阻塞模式和阻塞函数调用" class="headerlink" title="对象的阻塞模式和阻塞函数调用"></a>对象的阻塞模式和阻塞函数调用</h3><p>对象是否处于阻塞模式和函数是不是阻塞调用有很强的相关性，但是并不是一一对应的。阻塞对象上可以有非阻塞的调用方式，我们可以通过一定的API去轮询状态，在适当的时候调用阻塞函数，就可以避免阻塞。而对于非阻塞对象，调用特殊的函数也可以进入阻塞调用。函数select就是这样的一个例子。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;同步&quot;&gt;&lt;a href=&quot;#同步&quot; class=&quot;headerlink&quot; title=&quot;同步&quot;&gt;&lt;/a&gt;同步&lt;/h2&gt;&lt;p&gt;所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。按照这个定义，其实绝大多数函数都是同步调用（例如sin, isdig
      
    
    </summary>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="多任务处理" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Python3 nonlocal声明</title>
    <link href="http://yoursite.com/2018/03/06/Python3-nonlocal%E5%A3%B0%E6%98%8E/"/>
    <id>http://yoursite.com/2018/03/06/Python3-nonlocal声明/</id>
    <published>2018-03-06T06:58:07.000Z</published>
    <updated>2018-03-06T07:23:38.494Z</updated>
    
    <content type="html"><![CDATA[<p>前一节讲闭包时用到以下代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line">    series = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        series.append(new_value)</span><br><span class="line">        total = sum(series)</span><br><span class="line">        <span class="keyword">return</span> total/len(series)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> averager</span><br></pre></td></tr></table></figure></p><p>以上实现make_averager函数的方法效率不高。在如下示例中,我们把所有值存储在历史数列中，然后在每次调用averager时使用sum求和。更好的实现方式是，只存储目前的总和以及元素个数，然后使用这两个值计算平均数。以下是实现方式，这种实现方式存在缺陷，只是为了引出<code>nonlocal声明</code>。<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        total += new_value</span><br><span class="line">        <span class="keyword">return</span> total/count</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> averager</span><br></pre></td></tr></table></figure></p><p>尝试使用以上定义的函数，得到如下结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg = make_averager()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">10</span>)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">UnboundLocalError                         Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="number">-42</span>-ace390caaa2e&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; 1 avg(10)</span><br><span class="line"></span><br><span class="line">&lt;ipython-input<span class="number">-38</span><span class="number">-371</span>a27b41829&gt; <span class="keyword">in</span> averager(new_value)</span><br><span class="line">      <span class="number">3</span>     total = <span class="number">0</span></span><br><span class="line">      <span class="number">4</span>     <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">----&gt; 5         count += 1</span><br><span class="line">      <span class="number">6</span>         total += new_value</span><br><span class="line">      <span class="number">7</span>         <span class="keyword">return</span> total/count</span><br><span class="line"></span><br><span class="line">UnboundLocalError: local variable <span class="string">'count'</span> referenced before assignment</span><br></pre></td></tr></table></figure></p><p>问题是，当count是数字或任何不可变类型时，<code>count += 1</code>语句的作用其实与<code>count = count + 1</code>一样，因此我们在averager的定义体中为count赋值了，这样会把count变量变为局部变量，而不是自由变量。total变量也会受到这样的影响。</p><p>示例2 中没有遇到这样的问题是因为我们没有给series赋值，我们只是调用<code>series.append</code>，并把它传给sum和len。也就是说，我们利用了列表是可变的对象这一事实。</p><p>但是对数字和字符串、元组等不可变类型来说，只能读取，不能更新。如果尝试重新绑定，例如count += 1,其实会隐式的创建局部变量count。<code>这样count就不是自由变量了，也就不会保存在闭包中</code>。</p><p>为了解决这个问题，python3引入了<code>nonlocal声明</code>。他的作用是把变量标记为自由变量，即使在函数中变量赋予新值，也会变成自由变量。如果为nonlocal声明的变量赋予新值，闭包中保存的绑定会更新。正确版的make_averager的正确实现如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> count, total</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        total += new_value</span><br><span class="line">        <span class="keyword">return</span> total/count</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> averager</span><br></pre></td></tr></table></figure></p><p>这样一来，上面的错误就没有了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前一节讲闭包时用到以下代码：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 示例2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;make_averager&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    series = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;averager&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(new_value)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        series.append(new_value)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        total = sum(series)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; total/len(series)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; averager&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;以上实现make_averager函数的方法效率不高。在如下示例中,我们把所有值存储在历史数列中，然后在每次调用averager时使用sum求和。更好的实现方式是，只存储目前的总和以及元素个数，然后使用这两个值计算平均数。以下是实现方式，这种实现方式存在缺陷，只是为了引出&lt;code&gt;nonlocal声明&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
      <category term="Python3 闭包" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/Python3-%E9%97%AD%E5%8C%85/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Python3 闭包</title>
    <link href="http://yoursite.com/2018/03/06/Python3-%E9%97%AD%E5%8C%85/"/>
    <id>http://yoursite.com/2018/03/06/Python3-闭包/</id>
    <published>2018-03-06T06:04:56.000Z</published>
    <updated>2018-03-06T06:56:44.733Z</updated>
    
    <content type="html"><![CDATA[<p>闭包是指延伸了作用域的函数，其中包含函数定义体中引用、但是不在定义体中定义的非全局变量。<br>闭包(closure)是函数式编程的重要的语法结构。闭包也是一种组织代码的结构，它同样提高了代码的可重复使用性。</p><p>当一个内嵌函数引用其外部作用域的变量,我们就会得到一个闭包. 总结一下,创建一个闭包必须满足以下几点:</p><ol><li>必须有一个内嵌函数</li><li>内嵌函数必须引用外部函数中的变量</li><li>外部函数的返回值必须是内嵌函数</li></ol><p>闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，这样调用函数时虽然定义作用域不可用了，但仍能使用那些绑定。<br><a id="more"></a></p><p>闭包的概念难以掌握，最好通过示例理解。</p><p>假如有个名为avg的函数，他的作用是计算不断增加的系列值得平均数。起初，avg是这样使用的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">10</span>)</span><br><span class="line"><span class="number">10.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">11</span>)</span><br><span class="line"><span class="number">10.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">12</span>)</span><br><span class="line"><span class="number">11.0</span></span><br></pre></td></tr></table></figure></p><p>初学者可能会用类来实现，如示例1<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Averager</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""docstring for Average."""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.series = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, new_value)</span>:</span></span><br><span class="line">        self.series.append(new_value)</span><br><span class="line">        total = sum(self.series)</span><br><span class="line">        <span class="keyword">return</span> total/len(self.series)</span><br></pre></td></tr></table></figure></p><p>Average的实例是可调用对象：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg = Averager()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">10</span>)</span><br><span class="line"><span class="number">10.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">11</span>)</span><br><span class="line"><span class="number">10.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">12</span>)</span><br><span class="line"><span class="number">11.0</span></span><br></pre></td></tr></table></figure></p><p>下面使用函数式实现，如示例2：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line">    series = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        series.append(new_value)</span><br><span class="line">        total = sum(series)</span><br><span class="line">        <span class="keyword">return</span> total/len(series)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> averager</span><br></pre></td></tr></table></figure></p><p>调用make_averager时，返回一个averager函数对象。每次调用averager时，他会把参数添加到系列值中，然后计算当前平均值，如下所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg = make_averager()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">10</span>)</span><br><span class="line"><span class="number">10.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">11</span>)</span><br><span class="line"><span class="number">10.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">12</span>)</span><br><span class="line"><span class="number">11.0</span></span><br></pre></td></tr></table></figure></p><p>注意，以上两个示例有共通之处：调用Averager()或make_averager()得到一个可调用对象avg，他会更新历史值，然后计算当前均值。示例1中，avg是Averager的实例；实例2中是内部函数averager。不管怎样，我们都只需要调用avg(n),把n放入系列值中，然后重新计算均值。</p><p>Averager()类的实例avg在哪里存储历史值很明显：self.series实例属性；但是第二个示例中的avg函数在哪里寻找series呢？</p><p>注意，series是make_averager函数的局部变量，因为那个函数的定义体中初始化了series：series = []。可是，调用avg(10)时，make_averager函数已经返回了，而他的本地作用域也一去不复返了。</p><p>在averager函数中，series是自由变量。这是一个技术术语，指未在本地作用域中绑定的变量，如图：</p><p><img src="http://upload-images.jianshu.io/upload_images/2952111-039ebc44d7803bbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="闭包"></p><p><strong>averager的闭包延伸到那个函数的作用域之外，包含自由变量series的绑定</strong></p><p>我们可以审查返回的averager对象，发现Python在<code>__code__</code>属性（表示编译后的函数定义体）中保存局部变量和自由变量的名称，如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 审查make_averager创建的函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.__code__.co_varnames</span><br><span class="line">(<span class="string">'new_value'</span>, <span class="string">'total'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.__code__.co_freevars</span><br><span class="line">(<span class="string">'series'</span>,)</span><br></pre></td></tr></table></figure><p>series绑定在返回的avg函数的<code>__closure__</code>属性中。<code>avg.__closure__</code>中各个元素对应于<code>avg.__code__.co_freevars</code>中的一个名称。这些元素是cell对象，有个<code>cell_content</code>属性，保存着真正的值。这些属性的值如示例所示：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.__code__.co_freevars</span><br><span class="line">(<span class="string">'series'</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.__closure__</span><br><span class="line">(&lt;cell at <span class="number">0x108b89828</span>: list object at <span class="number">0x108ae96c8</span>&gt;,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg.__closure__[<span class="number">0</span>].cell_contents</span><br><span class="line">[<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]</span><br></pre></td></tr></table></figure></p><p>综上，闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，这样调用函数时虽然定义作用域不可用了，但仍能使用那些绑定。</p><p>注意，只有嵌套在其他函数中的函数才可能需要处理不在全局作用域中的外部变量。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;闭包是指延伸了作用域的函数，其中包含函数定义体中引用、但是不在定义体中定义的非全局变量。&lt;br&gt;闭包(closure)是函数式编程的重要的语法结构。闭包也是一种组织代码的结构，它同样提高了代码的可重复使用性。&lt;/p&gt;
&lt;p&gt;当一个内嵌函数引用其外部作用域的变量,我们就会得到一个闭包. 总结一下,创建一个闭包必须满足以下几点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;必须有一个内嵌函数&lt;/li&gt;
&lt;li&gt;内嵌函数必须引用外部函数中的变量&lt;/li&gt;
&lt;li&gt;外部函数的返回值必须是内嵌函数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，这样调用函数时虽然定义作用域不可用了，但仍能使用那些绑定。&lt;br&gt;
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
      <category term="Python3 闭包" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/Python3-%E9%97%AD%E5%8C%85/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Python3 让字典保持有序</title>
    <link href="http://yoursite.com/2018/03/06/Python3-%E8%AE%A9%E5%AD%97%E5%85%B8%E4%BF%9D%E6%8C%81%E6%9C%89%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/03/06/Python3-让字典保持有序/</id>
    <published>2018-03-06T04:02:36.000Z</published>
    <updated>2018-03-06T04:55:57.785Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>想创建一个字典，同时当对字典做迭代或序列化操作时，也能控制其中元素的顺序。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>要控制字典中元素的顺序，可以使用<code>collections模块</code>中的<code>OrderDict类</code>。当对字典做迭代时，他会严格按照元素初始添加的顺序执行。例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line">d = OrderedDict()</span><br><span class="line">d[<span class="string">'foo'</span>] = <span class="number">1</span></span><br><span class="line">d[<span class="string">'bar'</span>] = <span class="number">2</span></span><br><span class="line">d[<span class="string">'spam'</span>] = <span class="number">3</span></span><br><span class="line">d[<span class="string">'qrok'</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d:</span><br><span class="line">    print(key, d[key])</span><br><span class="line"></span><br><span class="line"><span class="comment"># output:</span></span><br><span class="line"><span class="comment"># foo 1</span></span><br><span class="line"><span class="comment"># bar 2</span></span><br><span class="line"><span class="comment"># spam 3</span></span><br><span class="line"><span class="comment"># qrok 4</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>当想创建一个映射结构以便稍后对其做序列化或编码成另一种格式时，OrderedDict就显得特别有用。例如，如果想在进行json编码时精确控制各个字段的顺序，那么只要首先在OrderedDict中构建数据就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.dumps(d)</span><br><span class="line"><span class="string">'&#123;"foo":1,"bar":2,"spam":3,"qrok":4&#125;'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><p>OrderedDict内部维护了一个双向链表，他会根据元素加入的顺序来排列键的位置。第一个加入的元素被放置的链表的末尾。接下来对已存在的键做重新赋值不会改变键的顺序。</p><p>注意OrderedDict的大小是普通字典的两倍多，这是由于它额外创建的链表所致。因此，如果打算构建一个涉及大量OrderedDict实例的数据结构（例如从CSV文件中读取100000行内容到OrderedDict列表中），那么需要认真对应用做需求分析，从而判断使用OrderedDict所带来的好处是否能够超越额外的内存开销带来的缺点。</p><p>a</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;想创建一个字典，同时当对字典做迭代或序列化操作时，也能控制其中元素的顺序。&lt;/p&gt;
&lt;h2 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;解决方案&lt;/h2&gt;&lt;p&gt;要控制字典中元素的顺序，可以使用&lt;code&gt;collections模块&lt;/code&gt;中的&lt;code&gt;OrderDict类&lt;/code&gt;。当对字典做迭代时，他会严格按照元素初始添加的顺序执行。例如：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; collections &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; OrderedDict&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;d = OrderedDict()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;d[&lt;span class=&quot;string&quot;&gt;&#39;foo&#39;&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;d[&lt;span class=&quot;string&quot;&gt;&#39;bar&#39;&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;d[&lt;span class=&quot;string&quot;&gt;&#39;spam&#39;&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;d[&lt;span class=&quot;string&quot;&gt;&#39;qrok&#39;&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; key &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; d:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(key, d[key])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# output:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# foo 1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# bar 2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# spam 3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# qrok 4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
      <category term="Python3 字典" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/Python3-%E5%AD%97%E5%85%B8/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Python2.7.x与Python3.x差异</title>
    <link href="http://yoursite.com/2018/03/06/Python2-7-x%E4%B8%8EPython3-x%E5%B7%AE%E5%BC%82/"/>
    <id>http://yoursite.com/2018/03/06/Python2-7-x与Python3-x差异/</id>
    <published>2018-03-05T17:08:15.000Z</published>
    <updated>2018-03-06T17:20:06.242Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Contents</strong></p><ol><li><a href="http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#__future__%E6%A8%A1%E5%9D%97" target="_blank" rel="noopener"><code>__future__模块</code></a></li><li><a href="http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#print%E5%87%BD%E6%95%B0" target="_blank" rel="noopener"><code>print函数</code></a></li><li><a href="http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#%E6%95%B4%E9%99%A4" target="_blank" rel="noopener"><code>整除</code></a></li><li><a href="http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#Unicode" target="_blank" rel="noopener"><code>Unicode</code></a></li><li><a href="http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#xrange%E6%A8%A1%E5%9D%97" target="_blank" rel="noopener"><code>xrange模块</code></a></li><li><a href="http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#Python3%E4%B8%AD%E7%9A%84range%E5%AF%B9%E8%B1%A1%E7%9A%84__contains__%E6%96%B9%E6%B3%95" target="_blank" rel="noopener"><code>Python3中的range对象的__contains__方法</code></a></li><li><a href="http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#Raising_exceptions" target="_blank" rel="noopener"><code>Raising exceptions</code></a></li><li><a href="http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#Handling_exceptions" target="_blank" rel="noopener"><code>Handling exceptions</code></a></li><li><a href="http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#next(" target="_blank" rel="noopener"><code>next()函数 and .next()方法</code></a></li><li><a href="http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#For%E5%BE%AA%E7%8E%AF%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%B3%84%E6%BC%8F" target="_blank" rel="noopener"><code>For循环变量和全局命名空间泄漏</code></a></li><li><a href="http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#%E6%AF%94%E8%BE%83%E4%B8%8D%E5%8F%AF%E6%8E%92%E5%BA%8F%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener"><code>比较不可排序类型</code></a></li><li><a href="http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#%E9%80%9A%E8%BF%87input(" target="_blank" rel="noopener"><code>通过input()解析用户的输入</code></a></li><li><a href="http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#%E8%BF%94%E5%9B%9E%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E5%88%97%E8%A1%A8" target="_blank" rel="noopener"><code>返回可迭代对象，而不是列表</code></a></li><li><p><a href="http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#%E6%9B%B4%E5%A4%9A%E7%9A%84%E5%85%B3%E4%BA%8E_Python_2_%E5%92%8C_Python_3_%E7%9A%84%E6%96%87%E7%AB%A0" target="_blank" rel="noopener"><code>更多的关于 Python 2 和 Python 3 的文章</code></a></p><p><strong>参考：</strong></p><ol><li><p><a href="http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/" target="_blank" rel="noopener">Python2.x与Python3.x差异</a></p></li><li><p><a href="http://nbviewer.jupyter.org/github/rasbt/python_reference/blob/master/tutorials/key_differences_between_python_2_and_3.ipynb?create=1" target="_blank" rel="noopener">Key differences between Python 2.7.x and Python 3.x</a></p></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Contents&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/#_
      
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Python3 垃圾回收机制</title>
    <link href="http://yoursite.com/2018/03/05/Python3-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/03/05/Python3-垃圾回收机制/</id>
    <published>2018-03-05T13:38:25.000Z</published>
    <updated>2018-03-05T16:51:20.605Z</updated>
    
    <content type="html"><![CDATA[<p>Python中的垃圾回收GC(Garbage collection)是以引用计数为主，分代收集为辅。引用计数的缺陷是循环引用的问题。<br>分代收集在一定程度上解决了循环引用的问题（可能描述不准确）。</p><a id="more"></a><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>Python语言默认采用的垃圾收集机制是『引用计数法 Reference Counting』，该算法最早George E. Collins在1960的时候首次提出，50年后的今天，该算法依然被很多编程语言使用，『引用计数法』的原理是：每个对象维护一个<code>ob_ref</code>字段，用来记录该对象当前被引用的次数，每当新的引用指向该对象时，它的引用计数ob_ref加1，每当该对象的引用失效时计数ob_ref减1，一旦对象的引用计数为0，该对象立即被回收，对象占用的内存空间将被释放。它的缺点是需要额外的空间维护引用计数，这个问题是其次的，不过最主要的问题是它不能解决对象的“循环引用”，因此，有很多语言比如Java并没有采用该算法做来垃圾的收集机制。</p><p>导致引用计数+1的情况</p><ol><li>对象被创建，例如<code>a=23</code></li><li>对象被引用，例如<code>b=a</code></li><li>对象被作为参数，传入到一个函数中，例如<code>func(a)</code></li><li>对象作为一个元素，存储在容器中，例如<code>list1=[a,a]</code><br>导致引用计数-1的情况</li><li>对象的别名被显式销毁，例如<code>del a</code></li><li>对象的别名被赋予新的对象，例如<code>a=24</code></li><li>一个对象离开它的作用域，例如f函数执行完毕时，func函数中的局部变量（全局变量不会）</li><li>对象所在的容器被销毁，或从容器中删除对象</li></ol><h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><p>『标记清除（Mark—Sweep）』算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。它分为两个阶段：第一阶段是标记阶段，GC会把所有的『活动对象』打上标记，第二阶段是把那些没有标记的对象『非活动对象』进行回收。那么GC又是如何判断哪些是活动对象哪些是非活动对象的呢？</p><p>对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。</p><p><img src="https://foofish.net/images/mark-sweep.svg" alt="mark-sweepg"></p><p>在上图中，我们把小黑圈视为全局变量，也就是把它作为root object，从小黑圈出发，对象1可直达，那么它将被标记，对象2、3可间接到达也会被标记，而4和5不可达，那么1、2、3就是活动对象，4和5是非活动对象会被GC回收。</p><p>标记清除算法作为Python的辅助垃圾收集技术主要处理的是一些容器对象，比如list、dict、tuple，instance等，因为对于字符串、数值对象是不可能造成循环引用问题。Python使用一个双向链表将这些容器对象组织起来。不过，这种简单粗暴的标记清除算法也有明显的缺点：清除非活动的对象前它必须顺序扫描整个堆内存，哪怕只剩下小部分活动对象也要扫描所有对象。</p><h2 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h2><p>分代回收是一种以空间换时间的操作方式，Python将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代），他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发，把那些可以被回收的对象回收掉(包括循环引用的对象)，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。同时，<code>分代回收是建立在标记清除技术基础之上</code>。分代回收同样作为Python的辅助垃圾收集技术处理那些容器对象</p><h2 id="Python中的GC阈值"><a href="#Python中的GC阈值" class="headerlink" title="Python中的GC阈值"></a>Python中的GC阈值</h2><p>随着你的程序运行，Python解释器保持对新创建的对象，以及因为引用计数为零而被释放掉的对象的追踪。从理论上说，这两个值应该保持一致，因为程序新建的每个对象都应该最终被释放掉。</p><p>当然，事实并非如此。因为循环引用的原因，并且因为你的程序使用了一些比其他对象存在时间更长的对象，从而被分配对象的计数值与被释放对象的计数值之间的差异在逐渐增长。一旦这个差异累计超过某个阈值，则Python的收集机制就启动了，并且触发上边所说到的零代算法，释放“浮动的垃圾”，并且将剩下的对象移动到一代列表。</p><p>随着时间的推移，程序所使用的对象逐渐从零代列表移动到一代列表。而Python对于一代列表中对象的处理遵循同样的方法，一旦被分配计数值与被释放计数值累计到达一定阈值，Python会将剩下的活跃对象移动到二代列表。</p><p>通过这种方法，你的代码所长期使用的对象，那些你的代码持续访问的活跃对象，会从零代链表转移到一代再转移到二代。通过不同的阈值设置，Python可以在不同的时间间隔处理这些对象。Python处理零代最为频繁，其次是一代然后才是二代。</p><h2 id="gc模块"><a href="#gc模块" class="headerlink" title="gc模块"></a>gc模块</h2><p><a href="https://docs.python.org/2/library/gc.html" target="_blank" rel="noopener">Garbage Collector interface</a><br>gc模块提供一个接口给开发者设置垃圾回收的选项。上面说到，采用引用计数的方法管理内存的一个缺陷是循环引用，而gc模块的一个主要功能就是解决循环引用的问题。</p><h3 id="常用函数："><a href="#常用函数：" class="headerlink" title="常用函数："></a>常用函数：</h3><ol><li>gc.set_debug(flags)<br>设置gc的debug日志，一般设置为gc.DEBUG_LEAK</li><li>gc.collect([generation])<br>显式进行垃圾回收，可以输入参数，0代表只检查第一代的对象，1代表检查一，二代的对象，2代表检查一，二，三代的对象，如果不传参数，执行一个full collection，也就是等于传2。<br>返回不可达（unreachable objects）对象的数目</li><li>gc.set_threshold(threshold0[, threshold1[, threshold2])<br>设置自动执行垃圾回收的频率。</li><li>gc.get_count()<br>获取当前自动执行垃圾回收的计数器，返回一个长度为3的列表</li></ol><h3 id="gc模块的自动垃圾回收机制"><a href="#gc模块的自动垃圾回收机制" class="headerlink" title="gc模块的自动垃圾回收机制"></a>gc模块的自动垃圾回收机制</h3><p>必须要import gc模块，并且is_enable()=True才会启动自动垃圾回收。<br>这个机制的主要作用就是发现并处理不可达的垃圾对象。</p><p><code>垃圾回收=垃圾检查+垃圾回收</code>  </p><p>在Python中，采用分代收集的方法。把对象分为三代，一开始，对象在创建的时候，放在一代中，如果在一次一代的垃圾检查中，该对象存活下来，就会被放到二代中，同理在一次二代的垃圾检查中，该对象存活下来，就会被放到三代中。</p><p>gc模块里面会有一个长度为3的列表的计数器，可以通过<code>gc.get_count()</code>获取。<br>例如<code>(488,3,0)</code>，其中<code>488</code>是指距离上一次0代垃圾检查，Python分配内存的数目减去释放内存的数目，<strong>注意是内存分配，而不是引用计数的增加</strong>。例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> gc.get_count()  <span class="comment"># (590, 8, 0)</span></span><br><span class="line">a = ClassA()</span><br><span class="line"><span class="keyword">print</span> gc.get_count()  <span class="comment"># (591, 8, 0)</span></span><br><span class="line"><span class="keyword">del</span> a</span><br><span class="line"><span class="keyword">print</span> gc.get_count()  <span class="comment"># (590, 8, 0)</span></span><br></pre></td></tr></table></figure></p><p><code>3</code>是指距离上一次1代垃圾检查，0代垃圾检查的次数，同理，<code>0</code>是指距离上一次2代垃圾检查，1代垃圾检查的次数。</p><p>gc模快有一个自动垃圾回收的阀值，即通过<code>gc.get_threshold</code>函数获取到的长度为3的元组，例如<code>(700,10,10)</code><br>每一次计数器的增加，gc模块就会检查增加后的计数是否达到阀值的数目，如果是，就会执行对应的代数的垃圾检查，然后重置计数器<br>例如，假设阀值是<code>(700,10,10)</code>：</p><ul><li>当计数器从<code>(699,3,0)</code>增加到<code>(700,3,0)</code>，gc模块就会执行<code>gc.collect(0)</code>,即检查0代对象的垃圾，并重置计数器为<code>(0,4,0)</code></li><li>当计数器从<code>(699,9,0)</code>增加到<code>(700,9,0)</code>，gc模块就会执行<code>gc.collect(1)</code>,即检查1、2代对象的垃圾，并重置计数器为<code>(0,0,1)</code></li><li>当计数器从<code>(699,9,9)</code>增加到<code>(700,9,9)</code>，gc模块就会执行<code>gc.collect(2)</code>,即检查0、1、2代对象的垃圾，并重置计数器为<code>(0,0,0)</code></li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol><li>项目中避免循环引用</li><li>引入gc模块，启动gc模块的自动清理循环引用的对象机制</li><li>由于分代收集，所以把需要长期使用的变量集中管理，并尽快移到二代以后，减少GC检查时的消耗</li><li>gc模块唯一处理不了的是循环引用的类都有<code>__del__</code>方法，所以项目中要避免定义_<code>_del__</code>方法，如果一定要使用该方法，同时导致了循环引用，需要代码显式调用<code>gc.garbage</code>里面的对象的<code>__del__</code>来打破僵局</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://python.jobbole.com/87843/" target="_blank" rel="noopener">http://python.jobbole.com/87843/</a></li><li><a href="https://www.cnblogs.com/pinganzi/p/6646742.html" target="_blank" rel="noopener">https://www.cnblogs.com/pinganzi/p/6646742.html</a></li><li><a href="http://python.jobbole.com/87064/?utm_source=blog.jobbole.com&amp;utm_medium=relatedPosts" target="_blank" rel="noopener">http://python.jobbole.com/87064/?utm_source=blog.jobbole.com&amp;utm_medium=relatedPosts</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python中的垃圾回收GC(Garbage collection)是以引用计数为主，分代收集为辅。引用计数的缺陷是循环引用的问题。&lt;br&gt;分代收集在一定程度上解决了循环引用的问题（可能描述不准确）。&lt;/p&gt;
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>IO密集型任务、计算密集型任务，以及多线程、多进程</title>
    <link href="http://yoursite.com/2018/03/05/IO%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1%E3%80%81%E8%AE%A1%E7%AE%97%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%81%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/03/05/IO密集型任务、计算密集型任务，以及多线程、多进程/</id>
    <published>2018-03-05T02:41:27.000Z</published>
    <updated>2018-03-05T15:54:17.211Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IO密集型任务-vs-计算密集型任务"><a href="#IO密集型任务-vs-计算密集型任务" class="headerlink" title="IO密集型任务 vs 计算密集型任务"></a>IO密集型任务 vs 计算密集型任务</h2><ul><li><p>所谓IO密集型任务，是指磁盘IO、网络IO占主要的任务，计算量很小。比如请求网页、读写文件等。当然我们在Python中可以利用sleep达到IO密集型任务的目的。  </p></li><li><p>所谓计算密集型任务，是指CPU计算占主要的任务，CPU一直处于满负荷状态。比如在一个很大的列表中查找元素（当然这不合理），复杂的加减乘除等。</p></li></ul><a id="more"></a><p>计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。</p><p>计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。</p><p>第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。</p><p>IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。</p><h2 id="多线程-VS-多进程"><a href="#多线程-VS-多进程" class="headerlink" title="多线程 VS 多进程"></a>多线程 VS 多进程</h2><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>多线程即在一个进程中启动多个线程执行任务。一般来说使用多线程可以达到并行的目的，但由于Python中使用了全局解释锁GIL的概念，导致Python中的多线程并不是并行执行，而是“交替执行”。类似于下图：（图片转自网络，侵删）</p><p><img src="https://pic2.zhimg.com/80/v2-dfad6468a9ddd7edd2494971296a00d0_hd.jpg" alt=""></p><p>所以Python中的多线程适合IO密集型任务，而不适合计算密集型任务。</p><p>Python提供两组多线程接口，一是thread模块_thread，提供低等级接口。二是threading模块，提供更容易使用的基于对象的接口，可以继承Thread对象来实现线程，此外其还提供了其它线程相关的对象，例如Timer，Lock等。</p><p>多线程模式通常比多进程快一点，但是也快不到哪去，而且，多线程模式致命的缺点就是任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存。在Windows上，如果一个线程执行的代码出了问题，你经常可以看到这样的提示：“该程序执行了非法操作，即将关闭”，其实往往是某个线程出了问题，但是操作系统会强制结束整个进程。</p><p>在Windows下，多线程的效率比多进程要高，所以微软的IIS服务器默认采用多线程模式。由于多线程存在稳定性的问题，IIS的稳定性就不如Apache。为了缓解这个问题，IIS和Apache现在又有多进程+多线程的混合模式，真是把问题越搞越复杂。</p><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>由于Python中GIL的原因，对于计算密集型任务，Python下比较好的并行方式是使用多进程，这样可以非常有效的使用CPU资源。当然同一时间执行的进程数量取决你电脑的CPU核心数。</p><p><img src="https://pic3.zhimg.com/80/v2-f1cdf422f5aef9a23f714a399e8e7016_hd.jpg" alt=""></p><p>Python中的进程模块为mutliprocess模块，提供了很多容易使用的基于对象的接口。另外它提供了封装好的管道和队列，可以方便的在进程间传递消息。Python还提供了进程池Pool对象，可以方便的管理和控制线程。</p><p>多进程模式最大的<code>优点</code>就是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程。（当然主进程挂了所有进程就全挂了，但是Master进程只负责分配任务，挂掉的概率低）著名的Apache最早就是采用多进程模式。</p><p>多进程模式的<code>缺点</code>是创建进程的代价大，在Unix/Linux系统下，用fork调用还行，在Windows下创建进程开销巨大。另外，操作系统能同时运行的进程数也是有限的，在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都会成问题。</p><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p><strong>实例讲解Python中的多线程、多进程如何应对IO密集型任务、计算密集型任务</strong></p><p>这里通过一个实例，说明多线程适合IO密集型任务，多进程适合计算密集型任务。首先定义一个队列，并定义初始化队列的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义全局变量Queue</span></span><br><span class="line">g_queue = multiprocessing.Queue()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_queue</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"init g_queue start"</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> g_queue.empty():</span><br><span class="line">        print(g_queue.get())</span><br><span class="line">    <span class="keyword">for</span> _index <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        g_queue.put(_index)</span><br><span class="line">    print(<span class="string">"init g_queue end"</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>定义IO密集型任务和计算密集型任务，分别从队列中获取任务数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个IO密集型任务：利用time.sleep()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task_io</span><span class="params">(task_id)</span>:</span></span><br><span class="line">    print(<span class="string">"IOTask[%s] start"</span> % task_id)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> g_queue.empty():</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = g_queue.get(block=<span class="keyword">True</span>, timeout=<span class="number">1</span>)</span><br><span class="line">            print(<span class="string">"IOTask[%s] get data: %s"</span> % (task_id, data))</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> excep:</span><br><span class="line">            print(<span class="string">"IOTask[%s] error: %s"</span> % (task_id, str(excep)))</span><br><span class="line">    print(<span class="string">"IOTask[%s] end"</span> % task_id)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">g_search_list = list(range(<span class="number">10000</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个计算密集型任务：利用一些复杂加减乘除、列表查找等</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task_cpu</span><span class="params">(task_id)</span>:</span></span><br><span class="line">    print(<span class="string">"CPUTask[%s] start"</span> % task_id)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> g_queue.empty():</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000</span>):</span><br><span class="line">            count += pow(<span class="number">3</span>*<span class="number">2</span>, <span class="number">3</span>*<span class="number">2</span>) <span class="keyword">if</span> i <span class="keyword">in</span> g_search_list <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = g_queue.get(block=<span class="keyword">True</span>, timeout=<span class="number">1</span>)</span><br><span class="line">            print(<span class="string">"CPUTask[%s] get data: %s"</span> % (task_id, data))</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> excep:</span><br><span class="line">            print(<span class="string">"CPUTask[%s] error: %s"</span> % (task_id, str(excep)))</span><br><span class="line">    print(<span class="string">"CPUTask[%s] end"</span> % task_id)</span><br><span class="line">    <span class="keyword">return</span> task_id</span><br></pre></td></tr></table></figure><p>准备完上述代码之后，进行试验：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">"cpu count:"</span>, multiprocessing.cpu_count(), <span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"========== 直接执行IO密集型任务 =========="</span>)</span><br><span class="line">    init_queue()</span><br><span class="line">    time_0 = time.time()</span><br><span class="line">    task_io(<span class="number">0</span>)</span><br><span class="line">    print(<span class="string">"结束："</span>, time.time() - time_0, <span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"========== 多线程执行IO密集型任务 =========="</span>)</span><br><span class="line">    init_queue()</span><br><span class="line">    time_0 = time.time()</span><br><span class="line">    thread_list = [threading.Thread(target=task_io, args=(i,)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> thread_list:</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> thread_list:</span><br><span class="line">        <span class="keyword">if</span> t.is_alive():</span><br><span class="line">            t.join()</span><br><span class="line">    print(<span class="string">"结束："</span>, time.time() - time_0, <span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"========== 多进程执行IO密集型任务 =========="</span>)</span><br><span class="line">    init_queue()</span><br><span class="line">    time_0 = time.time()</span><br><span class="line">    process_list = [multiprocessing.Process(target=task_io, args=(i,)) <span class="keyword">for</span> i <span class="keyword">in</span> range(multiprocessing.cpu_count())]</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> process_list:</span><br><span class="line">        p.start()</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> process_list:</span><br><span class="line">        <span class="keyword">if</span> p.is_alive():</span><br><span class="line">            p.join()</span><br><span class="line">    print(<span class="string">"结束："</span>, time.time() - time_0, <span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"========== 直接执行CPU密集型任务 =========="</span>)</span><br><span class="line">    init_queue()</span><br><span class="line">    time_0 = time.time()</span><br><span class="line">    task_cpu(<span class="number">0</span>)</span><br><span class="line">    print(<span class="string">"结束："</span>, time.time() - time_0, <span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"========== 多线程执行CPU密集型任务 =========="</span>)</span><br><span class="line">    init_queue()</span><br><span class="line">    time_0 = time.time()</span><br><span class="line">    thread_list = [threading.Thread(target=task_cpu, args=(i,)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> thread_list:</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> thread_list:</span><br><span class="line">        <span class="keyword">if</span> t.is_alive():</span><br><span class="line">            t.join()</span><br><span class="line">    print(<span class="string">"结束："</span>, time.time() - time_0, <span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"========== 多进程执行cpu密集型任务 =========="</span>)</span><br><span class="line">    init_queue()</span><br><span class="line">    time_0 = time.time()</span><br><span class="line">    process_list = [multiprocessing.Process(target=task_cpu, args=(i,)) <span class="keyword">for</span> i <span class="keyword">in</span> range(multiprocessing.cpu_count())]</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> process_list:</span><br><span class="line">        p.start()</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> process_list:</span><br><span class="line">        <span class="keyword">if</span> p.is_alive():</span><br><span class="line">            p.join()</span><br><span class="line">    print(<span class="string">"结束："</span>, time.time() - time_0, <span class="string">"\n"</span>)</span><br></pre></td></tr></table></figure></p><p>结果说明：</p><p><strong>对于IO密集型任务：</strong></p><ul><li>直接执行用时：10.0333秒</li><li>多线程执行用时：4.0156秒</li><li>多进程执行用时：5.0182秒</li></ul><p>说明多线程适合IO密集型任务。</p><p><strong>对于计算密集型任务</strong>  </p><ul><li>直接执行用时：10.0273秒</li><li>多线程执行用时：13.247秒</li><li>多进程执行用时：6.8377秒</li></ul><p>说明多进程适合计算密集型任务</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/24283040" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24283040</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;IO密集型任务-vs-计算密集型任务&quot;&gt;&lt;a href=&quot;#IO密集型任务-vs-计算密集型任务&quot; class=&quot;headerlink&quot; title=&quot;IO密集型任务 vs 计算密集型任务&quot;&gt;&lt;/a&gt;IO密集型任务 vs 计算密集型任务&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;所谓IO密集型任务，是指磁盘IO、网络IO占主要的任务，计算量很小。比如请求网页、读写文件等。当然我们在Python中可以利用sleep达到IO密集型任务的目的。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;所谓计算密集型任务，是指CPU计算占主要的任务，CPU一直处于满负荷状态。比如在一个很大的列表中查找元素（当然这不合理），复杂的加减乘除等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="多任务处理" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>进程、线程、协程</title>
    <link href="http://yoursite.com/2018/03/04/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/03/04/进程、线程、协程/</id>
    <published>2018-03-03T17:20:18.000Z</published>
    <updated>2018-03-03T19:00:47.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>电脑里运行的应用程序，都是进程，假设我们用的电脑是单核的，CPU同时只能执行一个进程。当程序处于I/O阻塞的时候，CPU如果和程序一起等待，那就太浪费了，CPU会去执行其他的程序，此时就涉及到切换，切换前要保存上一个程序运行的状态，才能恢复，所以就需要有个东西来记录这个东西，就可以引出进程的概念了。</p><p>进程就是<code>一个程序在一个数据集上的一次动态执行过程</code>。进程是一个动态概念，是竟争计算机系统资源的基本单位。进程由<code>程序</code>，<code>数据集</code>，<code>进程控制块</code>三部分组成。<code>程序</code>用来描述进程哪些功能以及如何完成；<code>数据集</code>是程序执行过程中所使用的资源；<code>进程控制块</code>用来保存程序运行的状态.</p><p><code>进程是系统进行资源分配和调度的一个独立单位</code>。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。</p><a id="more"></a><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>在网络或多用户环境下，一个服务器通常需要接收大量且不确定数量用户的并发请求，为每一个请求都创建一个进程显然是行不通的，——无论是从系统资源开销方面或是响应用户请求的效率方面来看。因此，操作系统中<code>线程</code>的概念便被引进了。线程，是进程的一部分，<code>一个没有线程的进程可以被看作是单线程的</code>。线程有时又被称为<code>轻权进程</code>或<code>轻量级进程</code>，是一个基本的cpu执行单元，也是程序执行过程中的最小单元。一个进程最少也会有一个主线程，在主线程中通过threading模块，再开子线程。</p><p>线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。</p><p><strong>进程拥有一个完整的虚拟地址空间，不依赖于线程而独立存在；反之，线程是进程的一部分，没有自己的地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。</strong></p><p><strong>进程的状态有就绪，运行，等待三个状态；线程的状态有新建-就绪-（阻塞）-运行–死亡四个基本状态</strong></p><p>线程全局锁GIL(Global Interpreter Lock),即Python为了保证线程安全而采取的<code>独立线程运行的限制</code>,说白了就是一个核只能在同一时间运行一个线程.对于io密集型任务，python的多线程起到作用，但对于cpu密集型任务，python的多线程几乎占不到任何优势，还有可能因为争夺资源而变慢。</p><h2 id="进程、线程的关系"><a href="#进程、线程的关系" class="headerlink" title="进程、线程的关系"></a>进程、线程的关系</h2><ol><li>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程</li><li>资源分配给进程，进程是程序的主体，同一进程的所有线程共享该进程的所有资源</li><li>CPU分配给线程，即真正在CPU上运行的是线程</li><li>线程是最小的执行单元，进程是最小的资源管理单元</li></ol><h2 id="协程Coroutine"><a href="#协程Coroutine" class="headerlink" title="协程Coroutine"></a>协程Coroutine</h2><p>协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p><p><code>进程</code>拥有自己独立的堆和栈，既不共享堆，亦不共享栈，<code>进程由操作系统调度</code>。<br><code>线程</code>拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。<br>协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。<br>进程和其他两个的区别还是很明显的。<br><code>协程和线程的区别是</code>：协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，<code>协程也失去了标准线程使用多CPU的能力。</code></p><p>举个例子：<br>假设有一个操作系统，是单核的，系统上没有其他的程序需要运行，有两个线程 A 和 B ，A 和 B 在单独运行时都需要 10 秒来完成自己的任务，而且任务都是运算操作，A B 之间也没有竞争和共享数据的问题。现在 A B 两个线程并行，操作系统会不停的在 A B 两个线程之间切换，达到一种伪并行的效果，假设切换的频率是每秒一次，切换的成本是 0.1 秒(主要是栈切换)，总共需要 20 + 19 <em> 0.1 = 21.9 秒。如果使用协程的方式，可以先运行协程 A ，A 结束的时候让位给协程 B ，只发生一次切换，总时间是 20 + 1 </em> 0.1 = 20.1 秒。如果系统是双核的，而且线程是标准线程，那么 A B 两个线程就可以真并行，总时间只需要 10 秒，而协程的方案仍然需要 20.1 秒。</p><p>人们通常将协程和子程序（函数）比较着理解。<br>子程序调用总是一个入口，一次返回，一旦退出即完成了子程序的执行。<br>协程的起始处是第一个入口点，在协程里，返回点之后是接下来的入口点。在python中，协程可以通过yield来调用其它协程。通过yield方式转移执行权的协程之间不是调用者与被调用者的关系，而是彼此对称、平等的，通过相互协作共同完成任务。其运行的大致流程如下：</p><ol><li>第一步，协程A开始执行。</li><li>第二步，协程A执行到一半，进入暂停，通过yield命令将执行权转移到协程B。</li><li>第三步，（一段时间后）协程B交还执行权。</li><li>第四步，协程A恢复执行。</li></ol><p>协程的特点在于是一个线程执行，与多线程相比，其优势体现在：</p><p>协程的执行效率非常高。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。<br>协程不需要多线程的锁机制。在协程中控制共享资源不加锁，只需要判断状态就好了。<br>Tips:利用多核CPU最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="进程与线程比较"><a href="#进程与线程比较" class="headerlink" title="进程与线程比较"></a>进程与线程比较</h3><p>线程是指进程内的一个执行单元,也是进程内的可调度实体。线程与进程的区别:</p><ol><li>地址空间:线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间，而进程有自己独立的地址空间</li><li>资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源</li><li>线程是处理器调度的基本单位,但进程不是</li><li><p>二者均可并发执行</p></li><li><p>每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制</p></li></ol><h3 id="协程与线程进行比较"><a href="#协程与线程进行比较" class="headerlink" title="协程与线程进行比较"></a>协程与线程进行比较</h3><ol><li>一个线程可以多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核CPU。</li><li>线程进程都是同步机制，而协程则是异步</li><li>协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h2&gt;&lt;p&gt;电脑里运行的应用程序，都是进程，假设我们用的电脑是单核的，CPU同时只能执行一个进程。当程序处于I/O阻塞的时候，CPU如果和程序一起等待，那就太浪费了，CPU会去执行其他的程序，此时就涉及到切换，切换前要保存上一个程序运行的状态，才能恢复，所以就需要有个东西来记录这个东西，就可以引出进程的概念了。&lt;/p&gt;
&lt;p&gt;进程就是&lt;code&gt;一个程序在一个数据集上的一次动态执行过程&lt;/code&gt;。进程是一个动态概念，是竟争计算机系统资源的基本单位。进程由&lt;code&gt;程序&lt;/code&gt;，&lt;code&gt;数据集&lt;/code&gt;，&lt;code&gt;进程控制块&lt;/code&gt;三部分组成。&lt;code&gt;程序&lt;/code&gt;用来描述进程哪些功能以及如何完成；&lt;code&gt;数据集&lt;/code&gt;是程序执行过程中所使用的资源；&lt;code&gt;进程控制块&lt;/code&gt;用来保存程序运行的状态.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;进程是系统进行资源分配和调度的一个独立单位&lt;/code&gt;。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="多任务处理" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86/"/>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Mac OS 命令之文件(夹)删除</title>
    <link href="http://yoursite.com/2018/03/03/Mac-OS-%E5%91%BD%E4%BB%A4%E4%B9%8B%E6%96%87%E4%BB%B6-%E5%A4%B9-%E5%88%A0%E9%99%A4/"/>
    <id>http://yoursite.com/2018/03/03/Mac-OS-命令之文件-夹-删除/</id>
    <published>2018-03-03T05:40:34.000Z</published>
    <updated>2018-03-03T05:49:16.813Z</updated>
    
    <content type="html"><![CDATA[<p><code>rmdir</code>删除空目录，不过一旦目录非空会提示<br>Directiry not empty</p><p>使用<code>rm</code>既可以删除文件又可以删除文件夹<br>删除文件夹（无论文件夹是否为空），使用 <code>-rf</code> 命令即可。<br>即：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm -rf 目录名字</span><br></pre></td></tr></table></figure></p><p><code>-r</code> 就是向下递归，不管有多少级目录，一并删除<br><code>-f</code> 就是直接强行删除，不作任何提示的意思<br><a id="more"></a><br>删除<code>文件夹</code>实例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm -rf  /User/Dhyana/desktop</span><br></pre></td></tr></table></figure></p><p>将会删除 /User/Dhyana/desktop目录以及其下所有文件、文件夹</p><p>删除<code>文件</code>使用实例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm -f  /User/Dhyana/desktop/test.py</span><br></pre></td></tr></table></figure></p><p>将会<strong>强制删除</strong>/User/Dhyana/desktop/test.py这个文件</p><p>值得注意的是：<br>使用这个rm -rf的时候一定要格外小心，linux没有回收站的，删除之后再想找回就很难了。有一个非常好笑的笑话就是命令行中输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rm -rf /.*</span><br><span class="line"><span class="comment"># 千万不要输入此命令，否则清空整个操作系统，后果自负</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;rmdir&lt;/code&gt;删除空目录，不过一旦目录非空会提示&lt;br&gt;Directiry not empty&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;rm&lt;/code&gt;既可以删除文件又可以删除文件夹&lt;br&gt;删除文件夹（无论文件夹是否为空），使用 &lt;code&gt;-rf&lt;/code&gt; 命令即可。&lt;br&gt;即：&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ rm -rf 目录名字&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-r&lt;/code&gt; 就是向下递归，不管有多少级目录，一并删除&lt;br&gt;&lt;code&gt;-f&lt;/code&gt; 就是直接强行删除，不作任何提示的意思&lt;br&gt;
    
    </summary>
    
      <category term="Mac OS 命令行" scheme="http://yoursite.com/categories/Mac-OS-%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
    
      <category term="Mac OS 命令行" scheme="http://yoursite.com/tags/Mac-OS-%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>Python3 使用virtualenv搭建虚拟环境</title>
    <link href="http://yoursite.com/2018/03/03/Python3-%E4%BD%BF%E7%94%A8virtualenv%E6%90%AD%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2018/03/03/Python3-使用virtualenv搭建虚拟环境/</id>
    <published>2018-03-03T05:28:31.000Z</published>
    <updated>2018-03-03T05:32:43.613Z</updated>
    
    <content type="html"><![CDATA[<p>在使用Python进行多个项目开发时，每个项目可能会需要安装不同的组件。把这些组件安装在同一台计算机下可能会导致组件之间的相互冲突，比如项目A使用Django 1.10，而项目B使用Django 1.8，那么同时安装两个版本可能在具体使用时产生冲突。使用虚拟环境可以有效避免这样的问题。</p><p>Python虚拟环境是一套由Ian Bicking编写的管理独立Python运行环境的系统。这样，开发者可以让每个项目运行在独立的虚拟环境中，从而避免了不同项目之间组件配置的冲突。<br><a id="more"></a></p><h4 id="1-虚拟环境安装"><a href="#1-虚拟环境安装" class="headerlink" title="1.虚拟环境安装"></a>1.虚拟环境安装</h4><p>在终端中执行命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install virtualenv</span><br></pre></td></tr></table></figure></p><h4 id="2-虚拟环境使用"><a href="#2-虚拟环境使用" class="headerlink" title="2.虚拟环境使用"></a>2.虚拟环境使用</h4><p>假定我们要开发一个新的项目，需要一套独立的Python运行环境，或者为已有的项目建立虚拟环境，终端执行如下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span>   [项目所在目录]</span><br><span class="line">$ virtualenv venv</span><br></pre></td></tr></table></figure></p><p>该命令执行后，将在当前目录下建立一个venv目录，<strong>该目录拷贝一份完整的当前系统的Python环境</strong>；</p><p>我么也可以执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ virtualenv --no-site-packages venv</span><br></pre></td></tr></table></figure></p><p>这样，已经安装到系统Python环境中的所有第三方包都不会复制过来，这样，我们就得到了一个不带任何第三方包的“干净”的Python运行环境。新建的Python环境被放到当前目录下的venv目录。</p><p>有了venv这个Python环境，可以用source进入该环境（注意是在cd之后的目录）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">source</span> venv/bin/activate[.fish|.zsh]</span><br></pre></td></tr></table></figure></p><p>注意到命令提示符变了，有个(venv)前缀，表示当前环境是一个名为venv的Python环境。在venv环境下，用pip安装的包都被安装到venv/lib目录，而不会影响系统的Python环境。</p><p>退出当前的venv环境，使用deactivate命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ deactivate</span><br></pre></td></tr></table></figure></p><p>此时回到了正常的环境，现在pip或python均是在系统Python环境下执行。</p><h4 id="3-注意"><a href="#3-注意" class="headerlink" title="3.注意"></a>3.注意</h4><p>为保证项目之间的独立性，建议所有使用pip安装的组件都在项目虚拟环境中进行，避免不同版本的冲突。</p><p>最后附上<a href="https://virtualenv.pypa.io/en/stable/" target="_blank" rel="noopener">Virtualenv的官方文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在使用Python进行多个项目开发时，每个项目可能会需要安装不同的组件。把这些组件安装在同一台计算机下可能会导致组件之间的相互冲突，比如项目A使用Django 1.10，而项目B使用Django 1.8，那么同时安装两个版本可能在具体使用时产生冲突。使用虚拟环境可以有效避免这样的问题。&lt;/p&gt;
&lt;p&gt;Python虚拟环境是一套由Ian Bicking编写的管理独立Python运行环境的系统。这样，开发者可以让每个项目运行在独立的虚拟环境中，从而避免了不同项目之间组件配置的冲突。&lt;br&gt;
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
      <category term="Python3 virtualenv" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/Python3-virtualenv/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Python3 真假值对照表</title>
    <link href="http://yoursite.com/2018/03/03/Python3-%E7%9C%9F%E5%81%87%E5%80%BC%E5%AF%B9%E7%85%A7%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/03/03/Python3-真假值对照表/</id>
    <published>2018-03-03T05:14:45.000Z</published>
    <updated>2018-03-03T05:21:56.663Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">False</th><th style="text-align:center">True</th></tr></thead><tbody><tr><td style="text-align:center">布尔</td><td style="text-align:center">False(与0等价)</td><td style="text-align:center">True(与1等价)</td></tr><tr><td style="text-align:center">数值</td><td style="text-align:center">0, &nbsp;&nbsp;0.0</td><td style="text-align:center">非零的数值</td></tr><tr><td style="text-align:center">字符串</td><td style="text-align:center">‘’,&nbsp;&nbsp;””(空字符串)</td><td style="text-align:center">非空字符串</td></tr><tr><td style="text-align:center">容器</td><td style="text-align:center">[],&nbsp;&nbsp;(),&nbsp;&nbsp;{},&nbsp;&nbsp;set()</td><td style="text-align:center">至少有一个元素的容器对象</td></tr><tr><td style="text-align:center">None</td><td style="text-align:center">None</td><td style="text-align:center">非None对象</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;类型&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;False&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;True&lt;/th&gt;

      
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
      <category term="Python3 True or False" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/Python3-True-or-False/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Markdown小技巧之空格输入</title>
    <link href="http://yoursite.com/2018/03/03/Markdown%E5%B0%8F%E6%8A%80%E5%B7%A7%E4%B9%8B%E7%A9%BA%E6%A0%BC%E8%BE%93%E5%85%A5/"/>
    <id>http://yoursite.com/2018/03/03/Markdown小技巧之空格输入/</id>
    <published>2018-03-03T05:06:47.000Z</published>
    <updated>2018-03-03T05:07:54.804Z</updated>
    
    <content type="html"><![CDATA[<p>在使用Markdown的时候，有时候会与到这样的需求——为Markdown添加空格。跟word等其他编辑器不同，Markdown只能识别一个空格（在半角输入状态下）。通过搜寻资料找到了两个解决方案。</p><ol><li><p>手动输入空格 （<strong>&amp;nbsp；</strong>）。<strong>注意！此时的分号为英文分号</strong>，但是不推荐使用此方法，太麻烦！</p></li><li><p>使用<strong>全角空格</strong>。即：在<strong>全角</strong>输入状态下直接使用空格键就ok了</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在使用Markdown的时候，有时候会与到这样的需求——为Markdown添加空格。跟word等其他编辑器不同，Markdown只能识别一个空格（在半角输入状态下）。通过搜寻资料找到了两个解决方案。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;手动输入空格 （&lt;strong&gt;&amp;amp;
      
    
    </summary>
    
      <category term="Markdown" scheme="http://yoursite.com/categories/Markdown/"/>
    
    
      <category term="Markdown" scheme="http://yoursite.com/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Python3 is和==的区别</title>
    <link href="http://yoursite.com/2018/03/03/Python3-is%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/03/03/Python3-is和-的区别/</id>
    <published>2018-03-03T04:16:34.000Z</published>
    <updated>2018-03-03T05:12:14.031Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python-对象三要素"><a href="#Python-对象三要素" class="headerlink" title="Python 对象三要素"></a>Python 对象三要素</h2><p>要理解Python中is和==的区别，首先要理解Python对象的三个要素:</p><table><thead><tr><th style="text-align:center">要素</th><th style="text-align:center">说明</th><th style="text-align:center">获取方式</th></tr></thead><tbody><tr><td style="text-align:center">id</td><td style="text-align:center">身份标识，基本就是内存地址，用来唯一标识一个对象</td><td style="text-align:center">id(obj)</td></tr><tr><td style="text-align:center">type</td><td style="text-align:center">数据类型</td><td style="text-align:center">type(obj)</td></tr><tr><td style="text-align:center">value</td><td style="text-align:center">值</td><td style="text-align:center">:—–:</td></tr></tbody></table><a id="more"></a><h2 id="is和-区别"><a href="#is和-区别" class="headerlink" title="is和==区别"></a>is和==区别</h2><table><thead><tr><th style="text-align:center">标识</th><th style="text-align:center">名称</th><th style="text-align:center">判断方法</th></tr></thead><tbody><tr><td style="text-align:center">is</td><td style="text-align:center">同一性运算符</td><td style="text-align:center">id</td></tr><tr><td style="text-align:center">==</td><td style="text-align:center">比较运算符</td><td style="text-align:center">value</td></tr></tbody></table><hr><h2 id="程序举例"><a href="#程序举例" class="headerlink" title="程序举例"></a>程序举例</h2><h3 id="例1："><a href="#例1：" class="headerlink" title="例1："></a>例1：</h3><p><img src="http://upload-images.jianshu.io/upload_images/2952111-ec5fa82d12a42a34.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕截图2.jpg"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">"a"</span>:<span class="number">1</span>, <span class="string">"b"</span>:<span class="number">2</span>&#125;</span><br><span class="line">b = a.copy()</span><br><span class="line"></span><br><span class="line">a == b  <span class="comment"># True value一样</span></span><br><span class="line">a <span class="keyword">is</span> b  <span class="comment"># False id不一样</span></span><br></pre></td></tr></table></figure><hr><h3 id="例2："><a href="#例2：" class="headerlink" title="例2："></a>例2：</h3><p><img src="http://upload-images.jianshu.io/upload_images/2952111-21696bc9de2d0e56.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕截图.jpg"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = y = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x == y</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x == z</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x <span class="keyword">is</span> y</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x <span class="keyword">is</span> z</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> id(x)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> id(y)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> id(z)</span><br></pre></td></tr></table></figure><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span> <span class="comment">#a和b为数值类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'cheesezh'</span> <span class="comment">#a和b为字符串类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">'cheesezh'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="comment">#a和b为元组类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="comment">#a和b为list类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;<span class="string">'cheese'</span>:<span class="number">1</span>,<span class="string">'zh'</span>:<span class="number">2</span>&#125; <span class="comment">#a和b为dict类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = &#123;<span class="string">'cheese'</span>:<span class="number">1</span>,<span class="string">'zh'</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = set([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])<span class="comment">#a和b为set类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = set([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Python-对象三要素&quot;&gt;&lt;a href=&quot;#Python-对象三要素&quot; class=&quot;headerlink&quot; title=&quot;Python 对象三要素&quot;&gt;&lt;/a&gt;Python 对象三要素&lt;/h2&gt;&lt;p&gt;要理解Python中is和==的区别，首先要理解Python对象的三个要素:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;要素&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;说明&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;获取方式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;id&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;身份标识，基本就是内存地址，用来唯一标识一个对象&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;id(obj)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;type&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;数据类型&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;type(obj)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;value&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;值&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;:—–:&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Python3 拷贝对象(深拷贝deepcopy和浅拷贝copy)</title>
    <link href="http://yoursite.com/2018/03/03/Python3-%E6%8B%B7%E8%B4%9D%E5%AF%B9%E8%B1%A1-%E6%B7%B1%E6%8B%B7%E8%B4%9Ddeepcopy%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9Dcopy/"/>
    <id>http://yoursite.com/2018/03/03/Python3-拷贝对象-深拷贝deepcopy和浅拷贝copy/</id>
    <published>2018-03-03T04:10:54.000Z</published>
    <updated>2018-03-03T04:14:09.659Z</updated>
    
    <content type="html"><![CDATA[<ol><li>copy.copy 浅拷贝 <code>只拷贝父对象</code>，不会拷贝对象的内部的子对象。</li><li>copy.deepcopy 深拷贝 <code>拷贝对象及其子对象</code></li></ol><hr><p><img src="http://upload-images.jianshu.io/upload_images/2952111-17e1f4233f95285d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="屏幕截图3.jpg"></p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*-coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]] <span class="comment">#原始对象</span></span><br><span class="line"></span><br><span class="line">b = a <span class="comment">#赋值，传对象的引用</span></span><br><span class="line">c = copy.copy(a) <span class="comment">#对象拷贝，浅拷贝</span></span><br><span class="line">d = copy.deepcopy(a) <span class="comment">#对象拷贝，深拷贝</span></span><br><span class="line"></span><br><span class="line">a.append(<span class="number">5</span>) <span class="comment">#修改对象a</span></span><br><span class="line">a[<span class="number">4</span>].append(<span class="string">'c'</span>) <span class="comment">#修改对象a中的['a', 'b']数组对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'a = '</span>, a</span><br><span class="line"><span class="keyword">print</span> <span class="string">'b = '</span>, b</span><br><span class="line"><span class="keyword">print</span> <span class="string">'c = '</span>, c</span><br><span class="line"><span class="keyword">print</span> <span class="string">'d = '</span>, d</span><br><span class="line">输出结果：</span><br><span class="line">a =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], <span class="number">5</span>]</span><br><span class="line">b =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], <span class="number">5</span>]</span><br><span class="line">c =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]]</span><br><span class="line">d =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;copy.copy 浅拷贝 &lt;code&gt;只拷贝父对象&lt;/code&gt;，不会拷贝对象的内部的子对象。&lt;/li&gt;
&lt;li&gt;copy.deepcopy 深拷贝 &lt;code&gt;拷贝对象及其子对象&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2952111-17e1f4233f95285d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;屏幕截图3.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
      <category term="Python3 拷贝对象" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/Python3-%E6%8B%B7%E8%B4%9D%E5%AF%B9%E8%B1%A1/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Python3 作用域</title>
    <link href="http://yoursite.com/2018/03/03/Python3-%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2018/03/03/Python3-作用域/</id>
    <published>2018-03-03T03:48:30.000Z</published>
    <updated>2018-03-03T03:56:30.508Z</updated>
    
    <content type="html"><![CDATA[<p>Python 中，一个变量的作用域总是由在代码中被赋值的地方所决定的。</p><p>Python 获取变量中的值的搜索顺序为：</p><p>本地作用域（Local）→ 当前作用域被嵌入的本地作用域（Enclosing locals）→ 全局/模块作用域（Global）→内置作用域（Built-in）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Python 中，一个变量的作用域总是由在代码中被赋值的地方所决定的。&lt;/p&gt;
&lt;p&gt;Python 获取变量中的值的搜索顺序为：&lt;/p&gt;
&lt;p&gt;本地作用域（Local）→ 当前作用域被嵌入的本地作用域（Enclosing locals）→ 全局/模块作用域（Global）→
      
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
      <category term="Python3 作用域" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/Python3-%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Python3 函数重载</title>
    <link href="http://yoursite.com/2018/03/03/Python3-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/"/>
    <id>http://yoursite.com/2018/03/03/Python3-函数重载/</id>
    <published>2018-03-03T02:54:44.000Z</published>
    <updated>2018-03-03T03:46:12.845Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数重载的目的"><a href="#函数重载的目的" class="headerlink" title="函数重载的目的"></a>函数重载的目的</h2><p>动态语言中，有鸭子类型，如果走起路来像鸭子，叫起来也像鸭子，那么它就是鸭子。一个对象的特征不是由它的类型决定，而是通过对象中的方法决定，所以函数重载在动态语言中就显得没有意义了，因为函数可以通过鸭子类型来处理不同类型的对象，鸭子类型也是多态性的一种表现。</p><p>在Python中实现函数重载：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Writer</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(output, content)</span>:</span></span><br><span class="line">        <span class="comment"># output对象只要实现了write方法就行</span></span><br><span class="line">        output.write(content)</span><br><span class="line"></span><br><span class="line"><span class="comment"># stringIO类型</span></span><br><span class="line">output = StringIO()</span><br><span class="line">Writer.write(output, <span class="string">'hello world'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># file 类型</span></span><br><span class="line">output = open(<span class="string">'out.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line">Writer.write(output, <span class="string">'hello world'</span>)</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>在静态语言中，方法重载是希望类可以以统一的方式处理不同类型的数据提供了可能。多个同名函数同时存在，具有不同的参数个数/类型，重载是一个类中多态性的一种表现。</p><p>在Java中实现函数重载：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Writer&#123;</span><br><span class="line">    public static void write(StringIO output, String content)&#123;</span><br><span class="line">        output.write(content);</span><br><span class="line">        <span class="keyword">return</span> null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void write(File output, String content)&#123;</span><br><span class="line">        output.write(content);</span><br><span class="line">        <span class="keyword">return</span> null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>参考自知乎用户刘志军：<a href="https://www.zhihu.com/question/20053359" target="_blank" rel="noopener">https://www.zhihu.com/question/20053359</a></p><hr><h2 id="函数重载主要是为了解决两个问题"><a href="#函数重载主要是为了解决两个问题" class="headerlink" title="函数重载主要是为了解决两个问题"></a>函数重载主要是为了解决两个问题</h2><ol><li>可变参数类型。</li><li>可变参数个数。</li></ol><blockquote><p>另外，一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载，如果两个函数的功能其实不同，那么不应当使用重载，而应当使用一个名字不同的函数。</p></blockquote><p>那么对于情况 1 ，函数功能相同，但是参数类型不同，python 如何处理？答案是根本不需要处理，因为 python 可以接受任何类型的参数，如果函数的功能相同，那么不同的参数类型在 python 中很可能是相同的代码，没有必要做成两个不同函数。</p><p>那么对于情况 2 ，函数功能相同，但参数个数不同，python 如何处理？大家知道，答案就是<code>缺省参数</code>。对那些缺少的参数设定为缺省参数即可解决问题。因为你假设函数功能相同，那么那些缺少的参数终归是需要用的。好了，鉴于情况 1 跟 情况 2 都有了解决方案，python 自然就不需要函数重载了。</p><p>参考自知乎用户<code>pansz</code>：<a href="https://www.zhihu.com/question/20053359" target="_blank" rel="noopener">https://www.zhihu.com/question/20053359</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;函数重载的目的&quot;&gt;&lt;a href=&quot;#函数重载的目的&quot; class=&quot;headerlink&quot; title=&quot;函数重载的目的&quot;&gt;&lt;/a&gt;函数重载的目的&lt;/h2&gt;&lt;p&gt;动态语言中，有鸭子类型，如果走起路来像鸭子，叫起来也像鸭子，那么它就是鸭子。一个对象的特征不是由它的类型决定，而是通过对象中的方法决定，所以函数重载在动态语言中就显得没有意义了，因为函数可以通过鸭子类型来处理不同类型的对象，鸭子类型也是多态性的一种表现。&lt;/p&gt;
&lt;p&gt;在Python中实现函数重载：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; io &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; StringIO&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Writer&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;    @staticmethod&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(output, content)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;# output对象只要实现了write方法就行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        output.write(content)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# stringIO类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;output = StringIO()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Writer.write(output, &lt;span class=&quot;string&quot;&gt;&#39;hello world&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# file 类型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;output = open(&lt;span class=&quot;string&quot;&gt;&#39;out.txt&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;w&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Writer.write(output, &lt;span class=&quot;string&quot;&gt;&#39;hello world&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
      <category term="Python3 重载" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/Python3-%E9%87%8D%E8%BD%BD/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Python3 子类的查看与类的对象判断</title>
    <link href="http://yoursite.com/2018/03/03/Python3-%E5%AD%90%E7%B1%BB%E7%9A%84%E6%9F%A5%E7%9C%8B%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%88%A4%E6%96%AD/"/>
    <id>http://yoursite.com/2018/03/03/Python3-子类的查看与类的对象判断/</id>
    <published>2018-03-02T18:24:21.000Z</published>
    <updated>2018-03-03T02:39:26.058Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>如果想要查看一个类是不是另一个类的子类，可以使用內建的 <code>issubclass</code> 函数或者使用它的特殊特性<code>__base__</code>；</p></li><li><p>如果想要检查一个对象是不是一个类的实例，可以使用內建的 <code>isinstance</code> 函数或者使用它的特殊特性<code>__class__</code>;</p><a id="more"></a></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-  </span></span><br><span class="line">__metaclass__ = type <span class="comment">#确定使新式类  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">father</span><span class="params">()</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        print(<span class="string">"father()已经创建"</span>)  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">son</span><span class="params">(father)</span>:</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        print(<span class="string">"son()已经创建"</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment">#下面测试issubclass()函数  </span></span><br><span class="line">print(issubclass(father,son))  <span class="comment"># output: False</span></span><br><span class="line">print(issubclass(son,father))  <span class="comment"># output: True</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#下面使用__bases__  </span></span><br><span class="line">print(<span class="string">"father.__bases__:"</span>,father.__bases__)  <span class="comment"># output: father.__bases__: (&lt;class 'object'&gt;,)  </span></span><br><span class="line">print(<span class="string">"son.__bases__:"</span>,son.__bases__)        <span class="comment"># output: son.__bases__: (&lt;class '__main__.father'&gt;,)  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#下面测试isinstance()函数  </span></span><br><span class="line">s = son()  </span><br><span class="line">print(isinstance(s,son))    <span class="comment"># output: True</span></span><br><span class="line">print(isinstance(s,father)) <span class="comment"># output: True</span></span><br><span class="line">print(isinstance(s,str))    <span class="comment"># output: False</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#下面使用__class__  </span></span><br><span class="line">print(<span class="string">"s.__class__:"</span>,s.__class__) <span class="comment"># output: s.__class__: &lt;class '__main__.son'&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果想要查看一个类是不是另一个类的子类，可以使用內建的 &lt;code&gt;issubclass&lt;/code&gt; 函数或者使用它的特殊特性&lt;code&gt;__base__&lt;/code&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果想要检查一个对象是不是一个类的实例，可以使用內建的 &lt;code&gt;isinstance&lt;/code&gt; 函数或者使用它的特殊特性&lt;code&gt;__class__&lt;/code&gt;;&lt;/p&gt;
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Python3 鸭子类型</title>
    <link href="http://yoursite.com/2018/03/03/Python3-%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/03/03/Python3-鸭子类型/</id>
    <published>2018-03-02T17:52:21.000Z</published>
    <updated>2018-03-03T05:40:54.624Z</updated>
    
    <content type="html"><![CDATA[<h2 id="来源和解释"><a href="#来源和解释" class="headerlink" title="来源和解释"></a>来源和解释</h2><p>Duck typing 这个概念来源于美国印第安纳州的诗人詹姆斯·惠特科姆·莱利（James Whitcomb Riley,1849-1916）的诗句：</p><blockquote><p>“ When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.”</p></blockquote><p>中文：</p><blockquote><p>“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”</p></blockquote><p>“鸭子类型”的语言是这么推断的：一只鸟走起来像鸭子、游起泳来像鸭子、叫起来也像鸭子，那它就可以被当做鸭子。也就是说，它不关注对象的类型，而是关注对象具有的行为(方法)。<br><a id="more"></a></p><p>鸭子类型是程序设计中的一种类型推断风格，这种风格适用于动态语言(比如PHP、Python、Ruby、Typescript、Perl、Objective-C、Lua、Julia、JavaScript、Java、Groovy、C#等)和某些静态语言(比如Golang,一般来说，静态类型语言在编译时便已确定了变量的类型，但是Golang的实现是：在编译时推断变量的类型)，支持”鸭子类型”的语言的解释器/编译器将会在解析(Parse)或编译时，推断对象的类型。</p><p><code>在鸭子类型中，关注的不是对象的类型本身，而是它是如何使用的。</code> 例如，在不使用鸭子类型的语言中，我们可以编写一个函数，它接受一个类型为鸭的对象，并调用它的走和叫方法。在使用鸭子类型的语言中，这样的一个函数可以接受一个任意类型的对象，并调用它的走和叫方法。如果这些需要被调用的方法不存在，那么将引发一个运行时错误。任何拥有这样的正确的走和叫方法的对象都可被函数接受的这种行为引出了以上表述，这种决定类型的方式因此得名。</p><p><code>鸭子类型通常得益于不测试方法和函数中参数的类型，而是依赖文档、清晰的代码和测试来确保正确使用。</code>从静态类型语言转向动态类型语言的用户通常试图添加一些静态的（在运行之前的）类型检查，从而影响了鸭子类型的益处和可伸缩性，并约束了语言的动态特性。</p><h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><p>“鸭子类型”没有任何静态检查，如类型检查、属性检查、方法签名检查等。</p><p>“鸭子类型”语言的程序可能会在运行时因为不具备某种特定的方法而抛出异常：如果一只小狗(对象)想加入合唱团(以对象会不会嘎嘎嘎叫的方法为检验标准)，也学鸭子那么嘎嘎嘎叫，好吧，它加入了，可是加入之后，却不会像鸭子那样走路，那么，迟早要出问题的。</p><p>再举个例子：一只小老鼠被猫盯上了，情急之下，它学了狗叫，猫撤了之后，小老鼠的妈妈不无感叹的对它说：看吧，我让你学的这门儿外语多么重要啊。这虽然是个段子，但是，由于猫在思考时，使用了 “鸭子测试”，它以为会叫的就是狗，会对自己产生威胁，所以撤退了，也正是因为这个错误的判断，它误失了一次进食机会。</p><h2 id="静态类型语言和动态类型语言的区别"><a href="#静态类型语言和动态类型语言的区别" class="headerlink" title="静态类型语言和动态类型语言的区别"></a>静态类型语言和动态类型语言的区别</h2><p>静态类型语言在编译时便已确定变量的类型，而动态类型语言的变量类型要到程序运行的时候，待变量被赋予某个值之后，才会具有某种类型。  </p><p><code>静态类型语言的优点</code>首先是在编译时就能发现类型不匹配的错误，编辑器可以帮助我们提前避免程序在运行期间有可能发生的一些错误。其次，如果在程序中明确地规定了数据类型，编译器还可以针对这些信息对程序进行一些优化工作，提高程序执行速度。  </p><p><code>静态类型语言的缺点</code>首先是迫使程序员依照强契约来编写程序，为每个变量规定数据类型，归根结底只是辅助我们编写可靠性高程序的一种手段，而不是编写程序的目的，毕竟大部分人编写程序的目的是为了完成需求交付生产。其次，类型的声明也会增加更多的代码，在程序编写过程中，这些细节会让程序员的精力从思考业务逻辑上分散开来。  </p><p><code>动态类型语言的优点</code>是编写的代码数量更少，看起来也更加简洁，程序员可以把精力更多地放在业务逻辑上面。虽然不区分类型在某些情况下会让程序变得难以理解，但整体而言，代码量越少，越专注于逻辑表达，对阅读程序是越有帮助的。<br><code>动态类型语言的缺点</code>是无法保证变量的类型，从而在程序的运行期有可能发生跟类型相关的错误。</p><p><strong>动态类型语言对变量类型的宽容给实际编码带来了很大的灵活性。由于无需进行类型检测，我们可以尝试调用任何对象的任意方法，而无需去考虑它原本是否被设计为拥有该方法。</strong></p><h2 id="面向接口编程"><a href="#面向接口编程" class="headerlink" title="面向接口编程"></a>面向接口编程</h2><p>动态类型语言的面向对象设计中，鸭子类型的概念至关重要。利用鸭子类型的思想，我们不必借助<code>超类型</code>的帮助，就能轻松地在动态类型语言中实现一个原则：“面向接口编程，而不是面向实现编程”。<br>例如,</p><ol><li>一个对象若有push和pop方法，并且这些方法提供了正确的实现，它就可以被当作栈来使用。</li><li>一个对象如果有length属性，也可以依照下标来存取属性（最好还要拥有slice和splice等方法），这个对象就可以被当作数组来使用。</li><li>比如在python中，有很多file-like的东西，比如StringIO,GzipFile,socket。它们有很多相同的方法，我们把它们当作文件使用。</li><li>又比如list.extend()方法中,我们并不关心它的参数是不是list,只要它是可迭代的,所以它的参数可以是list/tuple/dict/字符串/生成器等.</li></ol><p>鸭子类型在动态语言中经常使用，非常灵活，使得python不想java那样专门去弄一大堆的设计模式。</p><p>在静态类型语言中，要实现“面向接口编程”并不是一件容易的事情，往往要通过抽象类或者接口等将对象进行<code>向上转型</code>。当对象的真正类型被隐藏在它的超类型身后，这些对象才能在<code>类型检查系统</code>的“监视”之下互相被替换使用。只有当对象能够被互相替换使用，才能体现出对象多态性的价值。</p><h2 id="Python中的多态"><a href="#Python中的多态" class="headerlink" title="Python中的多态"></a>Python中的多态</h2><p><strong>Python中的鸭子类型允许我们使用任何提供所需方法的对象，而不需要迫使它成为一个子类。</strong><br>由于python属于动态语言，当你定义了一个基类和基类中的方法，并编写几个继承该基类的子类时，由于python在定义变量时不指定变量的类型，而是由解释器根据变量内容推断变量类型的（也就是说变量的类型取决于所关联的对象），这就使得python的多态不像是c++或java中那样—定义一个基类类型变量而隐藏了具体子类的细节。</p><p>请看下面的例子和说明：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AudioFile</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filename)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> filename.endswith(self.ext):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Invalid file format"</span>)</span><br><span class="line">        self.filename = filename</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MP3File</span><span class="params">(AudioFile)</span>:</span></span><br><span class="line">    ext = <span class="string">"mp3"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">play</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Playing &#123;&#125; as mp3"</span>.format(self.filename))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WavFile</span><span class="params">(AudioFile)</span>:</span></span><br><span class="line">    ext = <span class="string">"wav"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">play</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Playing &#123;&#125; as wav"</span>.format(self.filename))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OggFile</span><span class="params">(AudioFile)</span>:</span></span><br><span class="line">    ext = <span class="string">"ogg"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">play</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Playing &#123;&#125; as ogg"</span>.format(self.filename))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlacFile</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Though FlacFile class doesn't inherit AudioFile class,</span></span><br><span class="line"><span class="string">    it also has the same interface as three subclass of AudioFile.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    It is called duck typing.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filename)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> filename.endswith(<span class="string">".flac"</span>):</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Invalid file format"</span>)</span><br><span class="line">        self.filename = filename</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">play</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Playing &#123;&#125; as flac"</span>.format(self.filename))</span><br></pre></td></tr></table></figure></p><blockquote><p>Though FlacFile class doesn’t inherit AudioFile class,<br>it also has the same interface as three subclass of AudioFile.<br>It is called duck typing.</p></blockquote><p>上面的代码中，<code>MP3File</code>、<code>WavFile</code>、<code>OggFile</code>三个类型继承了<code>AudioFile</code>这一积累，而<code>FlacFile</code>没有扩展<code>AudioFile</code>，但是可以在python中使用完全相同的接口与之交互。  </p><p>因为任何提供正确接口的对象都可以在python中交替使用，它减少了多态的一般<code>超类</code>的需求。继承仍然可以用来共享代码，但是如果所有被共享的都是公共接口，鸭子类型就是所有所需的。这减少了继承的需要，同时也减少了多重继承的需要；通常，当多重继承似乎是一个有效方案的时候，我们只需要使用鸭子类型去模拟多个超类之一（定义和那个超类一样的接口和实现）就可以了。</p><blockquote><p>作者：JasonDing<br>链接：<a href="https://www.jianshu.com/p/650485b78d11" target="_blank" rel="noopener">https://www.jianshu.com/p/650485b78d11</a><br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://baike.baidu.com/item/鸭子类型/10845665?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/鸭子类型/10845665?fr=aladdin</a></li><li><a href="https://www.jianshu.com/p/650485b78d11" target="_blank" rel="noopener">https://www.jianshu.com/p/650485b78d11</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;来源和解释&quot;&gt;&lt;a href=&quot;#来源和解释&quot; class=&quot;headerlink&quot; title=&quot;来源和解释&quot;&gt;&lt;/a&gt;来源和解释&lt;/h2&gt;&lt;p&gt;Duck typing 这个概念来源于美国印第安纳州的诗人詹姆斯·惠特科姆·莱利（James Whitcomb Riley,1849-1916）的诗句：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“ When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;中文：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;“鸭子类型”的语言是这么推断的：一只鸟走起来像鸭子、游起泳来像鸭子、叫起来也像鸭子，那它就可以被当做鸭子。也就是说，它不关注对象的类型，而是关注对象具有的行为(方法)。&lt;br&gt;
    
    </summary>
    
      <category term="Python3 进阶" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/"/>
    
      <category term="Python3 鸭子类型" scheme="http://yoursite.com/categories/Python3-%E8%BF%9B%E9%98%B6/Python3-%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
  </entry>
  
</feed>
